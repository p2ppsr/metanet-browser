<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<script defer>/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["$"] = factory();
	else
		root["$"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../node_modules/idb/build/index.js":
/*!******************************************!*\
  !*** ../node_modules/idb/build/index.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteDB: () => (/* binding */ deleteDB),\n/* harmony export */   openDB: () => (/* binding */ openDB),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   wrap: () => (/* binding */ wrap)\n/* harmony export */ });\nconst instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\n\n\n\n//# sourceURL=webpack://$/../node_modules/idb/build/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/mod.js":
/*!***********************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/mod.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./src/primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/script/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/script/templates/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/transaction/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/transaction/fee-models/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/transaction/broadcasters/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/transaction/chaintrackers/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/transaction/http/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/messages/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/messages/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/compat/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/totp/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/totp/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/wallet/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/wallet/substrates/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/auth/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/storage/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/identity/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/identity/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/registry/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/registry/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./src/kvstore/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/kvstore/index.js\"), exports);\n//# sourceMappingURL=mod.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/mod.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/Peer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/Peer.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Peer = void 0;\nconst SessionManager_js_1 = __webpack_require__(/*! ./SessionManager.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js\");\nconst index_js_1 = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js\");\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst AUTH_VERSION = '0.1';\n/**\n * Represents a peer capable of performing mutual authentication.\n * Manages sessions, handles authentication handshakes, certificate requests and responses,\n * and sending and receiving general messages over a transport layer.\n *\n * This version supports multiple concurrent sessions per peer identityKey.\n */\nclass Peer {\n    /**\n     * Creates a new Peer instance\n     *\n     * @param {WalletInterface} wallet - The wallet instance used for cryptographic operations.\n     * @param {Transport} transport - The transport mechanism used for sending and receiving messages.\n     * @param {RequestedCertificateSet} [certificatesToRequest] - Optional set of certificates to request from a peer during the initial handshake.\n     * @param {SessionManager} [sessionManager] - Optional SessionManager to be used for managing peer sessions.\n     * @param {boolean} [autoPersistLastSession] - Whether to auto-persist the session with the last-interacted-with peer. Defaults to true.\n     */\n    constructor(wallet, transport, certificatesToRequest, sessionManager, autoPersistLastSession) {\n        this.onGeneralMessageReceivedCallbacks = new Map();\n        this.onCertificatesReceivedCallbacks = new Map();\n        this.onCertificateRequestReceivedCallbacks = new Map();\n        this.onInitialResponseReceivedCallbacks = new Map();\n        // Single shared counter for all callback types\n        this.callbackIdCounter = 0;\n        // Whether to auto-persist the session with the last-interacted-with peer\n        this.autoPersistLastSession = true;\n        this.wallet = wallet;\n        this.transport = transport;\n        this.certificatesToRequest = certificatesToRequest ?? {\n            certifiers: [],\n            types: {}\n        };\n        this.transport.onData(this.handleIncomingMessage.bind(this)).catch(e => {\n            throw e;\n        });\n        this.sessionManager =\n            sessionManager != null ? sessionManager : new SessionManager_js_1.SessionManager();\n        if (autoPersistLastSession === false) {\n            this.autoPersistLastSession = false;\n        }\n        else {\n            this.autoPersistLastSession = true;\n        }\n    }\n    /**\n     * Sends a general message to a peer, and initiates a handshake if necessary.\n     *\n     * @param {number[]} message - The message payload to send.\n     * @param {string} [identityKey] - The identity public key of the peer. If not provided, uses lastInteractedWithPeer (if any).\n     * @param {number} [maxWaitTime] - optional max wait time in ms\n     * @returns {Promise<void>}\n     * @throws Will throw an error if the message fails to send.\n     */\n    async toPeer(message, identityKey, maxWaitTime) {\n        if (this.autoPersistLastSession &&\n            typeof this.lastInteractedWithPeer === 'string' &&\n            typeof identityKey !== 'string') {\n            identityKey = this.lastInteractedWithPeer;\n        }\n        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);\n        // Prepare the general message\n        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));\n        const { signature } = await this.wallet.createSignature({\n            data: message,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const generalMessage = {\n            version: AUTH_VERSION,\n            messageType: 'general',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            yourNonce: peerSession.peerNonce,\n            payload: message,\n            signature\n        };\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(generalMessage);\n        }\n        catch (error) {\n            const e = new Error(`Failed to send message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);\n            e.stack = error.stack;\n            throw e;\n        }\n    }\n    /**\n     * Sends a request for certificates to a peer.\n     * This method allows a peer to dynamically request specific certificates after\n     * an initial handshake or message has been exchanged.\n     *\n     * @param {RequestedCertificateSet} certificatesToRequest - Specifies the certifiers and types of certificates required from the peer.\n     * @param {string} [identityKey] - The identity public key of the peer. If not provided, the current or last session identity is used.\n     * @param {number} [maxWaitTime=10000] - Maximum time in milliseconds to wait for the peer session to be authenticated.\n     * @returns {Promise<void>} Resolves if the certificate request message is successfully sent.\n     * @throws Will throw an error if the peer session is not authenticated or if sending the request fails.\n     */\n    async requestCertificates(certificatesToRequest, identityKey, maxWaitTime = 10000) {\n        if (this.autoPersistLastSession &&\n            typeof this.lastInteractedWithPeer === 'string' &&\n            typeof identityKey !== 'string') {\n            identityKey = this.lastInteractedWithPeer;\n        }\n        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);\n        // Prepare the message\n        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));\n        const { signature } = await this.wallet.createSignature({\n            data: Utils.toArray(JSON.stringify(certificatesToRequest), 'utf8'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const certRequestMessage = {\n            version: AUTH_VERSION,\n            messageType: 'certificateRequest',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            initialNonce: peerSession.sessionNonce,\n            yourNonce: peerSession.peerNonce,\n            requestedCertificates: certificatesToRequest,\n            signature\n        };\n        // Update last-used timestamp\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(certRequestMessage);\n        }\n        catch (error) {\n            throw new Error(`Failed to send certificate request message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);\n        }\n    }\n    /**\n     * Retrieves an authenticated session for a given peer identity. If no session exists\n     * or the session is not authenticated, initiates a handshake to create or authenticate the session.\n     *\n     * - If `identityKey` is provided, we look up any existing session for that identity key.\n     * - If none is found or not authenticated, we do a new handshake.\n     * - If `identityKey` is not provided, but we have a `lastInteractedWithPeer`, we try that key.\n     *\n     * @param {string} [identityKey] - The identity public key of the peer.\n     * @param {number} [maxWaitTime] - The maximum time in milliseconds to wait for the handshake.\n     * @returns {Promise<PeerSession>} - A promise that resolves with an authenticated `PeerSession`.\n     */\n    async getAuthenticatedSession(identityKey, maxWaitTime) {\n        if (this.transport === undefined) {\n            throw new Error('Peer transport is not connected!');\n        }\n        let peerSession;\n        if (typeof identityKey === 'string') {\n            peerSession = this.sessionManager.getSession(identityKey);\n        }\n        // If that session doesn't exist or isn't authenticated, initiate handshake\n        if ((peerSession == null) || !peerSession.isAuthenticated) {\n            // This will create a brand-new session\n            const sessionNonce = await this.initiateHandshake(identityKey, maxWaitTime);\n            // Now retrieve it by the sessionNonce\n            peerSession = this.sessionManager.getSession(sessionNonce);\n            if ((peerSession == null) || !peerSession.isAuthenticated) {\n                throw new Error('Unable to establish mutual authentication with peer!');\n            }\n        }\n        return peerSession;\n    }\n    /**\n     * Registers a callback to listen for general messages from peers.\n     *\n     * @param {(senderPublicKey: string, payload: number[]) => void} callback - The function to call when a general message is received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForGeneralMessages(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onGeneralMessageReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Removes a general message listener.\n     *\n     * @param {number} callbackID - The ID of the callback to remove.\n     */\n    stopListeningForGeneralMessages(callbackID) {\n        this.onGeneralMessageReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Registers a callback to listen for certificates received from peers.\n     *\n     * @param {(senderPublicKey: string, certs: VerifiableCertificate[]) => void} callback - The function to call when certificates are received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForCertificatesReceived(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onCertificatesReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Cancels and unsubscribes a certificatesReceived listener.\n     *\n     * @param {number} callbackID - The ID of the certificates received callback to cancel.\n     */\n    stopListeningForCertificatesReceived(callbackID) {\n        this.onCertificatesReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Registers a callback to listen for certificates requested from peers.\n     *\n     * @param {(requestedCertificates: RequestedCertificateSet) => void} callback - The function to call when a certificate request is received\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForCertificatesRequested(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onCertificateRequestReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Cancels and unsubscribes a certificatesRequested listener.\n     *\n     * @param {number} callbackID - The ID of the requested certificates callback to cancel.\n     */\n    stopListeningForCertificatesRequested(callbackID) {\n        this.onCertificateRequestReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Initiates the mutual authentication handshake with a peer.\n     *\n     * @private\n     * @param {string} [identityKey] - The identity public key of the peer.\n     * @param {number} [maxWaitTime=10000] - how long to wait for handshake\n     * @returns {Promise<string>} A promise that resolves to the session nonce.\n     */\n    async initiateHandshake(identityKey, maxWaitTime = 10000) {\n        const sessionNonce = await (0, index_js_1.createNonce)(this.wallet); // Initial request nonce\n        // Create the preliminary session (not yet authenticated)\n        const now = Date.now();\n        this.sessionManager.addSession({\n            isAuthenticated: false,\n            sessionNonce,\n            peerIdentityKey: identityKey,\n            lastUpdate: now\n        });\n        const initialRequest = {\n            version: AUTH_VERSION,\n            messageType: 'initialRequest',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            initialNonce: sessionNonce,\n            requestedCertificates: this.certificatesToRequest\n        };\n        await this.transport.send(initialRequest);\n        return await this.waitForInitialResponse(sessionNonce, maxWaitTime);\n    }\n    /**\n     * Waits for the initial response from the peer after sending an initial handshake request message.\n     *\n     * @param {string} sessionNonce - The session nonce created in the initial request.\n     * @returns {Promise<string>} A promise that resolves with the session nonce when the initial response is received.\n     */\n    async waitForInitialResponse(sessionNonce, maxWaitTime = 10000) {\n        return await new Promise((resolve, reject) => {\n            const callbackID = this.listenForInitialResponse(sessionNonce, nonce => {\n                clearTimeout(timeoutHandle);\n                this.stopListeningForInitialResponses(callbackID);\n                resolve(nonce);\n            });\n            const timeoutHandle = setTimeout(() => {\n                this.stopListeningForInitialResponses(callbackID);\n                reject(new Error('Initial response timed out.'));\n            }, maxWaitTime);\n        });\n    }\n    /**\n     * Adds a listener for an initial response message matching a specific initial nonce.\n     *\n     * @private\n     * @param {string} sessionNonce - The session nonce to match.\n     * @param {(sessionNonce: string) => void} callback - The callback to invoke when the initial response is received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForInitialResponse(sessionNonce, callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onInitialResponseReceivedCallbacks.set(callbackID, {\n            callback,\n            sessionNonce\n        });\n        return callbackID;\n    }\n    /**\n     * Removes a listener for initial responses.\n     *\n     * @private\n     * @param {number} callbackID - The ID of the callback to remove.\n     */\n    stopListeningForInitialResponses(callbackID) {\n        this.onInitialResponseReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Handles incoming messages from the transport.\n     *\n     * @param {AuthMessage} message - The incoming message to process.\n     * @returns {Promise<void>}\n     */\n    async handleIncomingMessage(message) {\n        if (typeof message.version !== 'string' || message.version !== AUTH_VERSION) {\n            throw new Error(`Invalid or unsupported message auth version! Received: ${message.version}, expected: ${AUTH_VERSION}`);\n        }\n        switch (message.messageType) {\n            case 'initialRequest':\n                await this.processInitialRequest(message);\n                break;\n            case 'initialResponse':\n                await this.processInitialResponse(message);\n                break;\n            case 'certificateRequest':\n                await this.processCertificateRequest(message);\n                break;\n            case 'certificateResponse':\n                await this.processCertificateResponse(message);\n                break;\n            case 'general':\n                await this.processGeneralMessage(message);\n                break;\n            default:\n                throw new Error(`Unknown message type of ${String(message.messageType)} from ${String(message.identityKey)}`);\n        }\n    }\n    /**\n     * Processes an initial request message from a peer.\n     *\n     * @param {AuthMessage} message - The incoming initial request message.\n     */\n    async processInitialRequest(message) {\n        if (typeof message.identityKey !== 'string' ||\n            typeof message.initialNonce !== 'string' ||\n            message.initialNonce === '') {\n            throw new Error('Missing required fields in initialRequest message.');\n        }\n        // Create a new sessionNonce for our side\n        const sessionNonce = await (0, index_js_1.createNonce)(this.wallet);\n        const now = Date.now();\n        // We'll treat this as fully authenticated from *our* perspective (the responding side).\n        this.sessionManager.addSession({\n            isAuthenticated: true,\n            sessionNonce,\n            peerNonce: message.initialNonce,\n            peerIdentityKey: message.identityKey,\n            lastUpdate: now\n        });\n        // Possibly handle the peer's requested certs\n        let certificatesToInclude;\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt to find automatically\n                certificatesToInclude = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n            }\n        }\n        // Create signature\n        const { signature } = await this.wallet.createSignature({\n            data: Utils.toArray(message.initialNonce + sessionNonce, 'base64'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.initialNonce} ${sessionNonce}`,\n            counterparty: message.identityKey\n        });\n        const initialResponseMessage = {\n            version: AUTH_VERSION,\n            messageType: 'initialResponse',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            initialNonce: sessionNonce,\n            yourNonce: message.initialNonce,\n            certificates: certificatesToInclude,\n            requestedCertificates: this.certificatesToRequest,\n            signature\n        };\n        // If we haven't interacted with a peer yet, store this identity as \"lastInteracted\"\n        if (this.lastInteractedWithPeer === undefined) {\n            this.lastInteractedWithPeer = message.identityKey;\n        }\n        // Send the response\n        await this.transport.send(initialResponseMessage);\n    }\n    /**\n     * Processes an initial response message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming initial response message.\n     * @throws Will throw an error if nonce or signature verification fails.\n     */\n    async processInitialResponse(message) {\n        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Initial response nonce verification failed from peer: ${message.identityKey}`);\n        }\n        // This is the session we previously created by calling initiateHandshake\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Peer session not found for peer: ${message.identityKey}`);\n        }\n        // Validate message signature\n        const dataToVerify = Utils.toArray((peerSession.sessionNonce ?? '') + (message.initialNonce ?? ''), 'base64');\n        const { valid } = await this.wallet.verifySignature({\n            data: dataToVerify,\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${peerSession.sessionNonce ?? ''} ${message.initialNonce ?? ''}`,\n            counterparty: message.identityKey\n        });\n        if (!valid) {\n            throw new Error(`Unable to verify initial response signature for peer: ${message.identityKey}`);\n        }\n        // Now mark the session as authenticated\n        peerSession.peerNonce = message.initialNonce;\n        peerSession.peerIdentityKey = message.identityKey;\n        peerSession.isAuthenticated = true;\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        // If the handshake had requested certificates, validate them\n        if (this.certificatesToRequest?.certifiers?.length > 0 &&\n            message.certificates?.length > 0) {\n            await (0, index_js_1.validateCertificates)(this.wallet, message, this.certificatesToRequest);\n            // Notify listeners\n            this.onCertificatesReceivedCallbacks.forEach(cb => cb(message.identityKey, message.certificates));\n        }\n        // Update lastInteractedWithPeer\n        this.lastInteractedWithPeer = message.identityKey;\n        // Let the handshake wait-latch know we got our response\n        this.onInitialResponseReceivedCallbacks.forEach(entry => {\n            if (entry.sessionNonce === peerSession.sessionNonce) {\n                entry.callback(peerSession.sessionNonce);\n            }\n        });\n        // The peer might also request certificates from us\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt auto\n                const verifiableCertificates = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);\n            }\n        }\n    }\n    /**\n     * Processes an incoming certificate request message from a peer.\n     * Verifies nonce/signature and then possibly sends a certificateResponse.\n     *\n     * @param {AuthMessage} message - The certificate request message received from the peer.\n     * @throws {Error} if nonce or signature is invalid.\n     */\n    async processCertificateRequest(message) {\n        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for certificate request message from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        const { valid } = await this.wallet.verifySignature({\n            data: Utils.toArray(JSON.stringify(message.requestedCertificates), 'utf8'),\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        if (!valid) {\n            throw new Error(`Invalid signature in certificate request message from ${peerSession.peerIdentityKey}`);\n        }\n        // Update usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt auto\n                const verifiableCertificates = await (0, index_js_1.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);\n            }\n        }\n    }\n    /**\n     * Sends a certificate response message containing the specified certificates to a peer.\n     *\n     * @param {string} verifierIdentityKey - The identity key of the peer requesting the certificates.\n     * @param {VerifiableCertificate[]} certificates - The list of certificates to include in the response.\n     * @throws Will throw an error if the transport fails to send the message.\n     */\n    async sendCertificateResponse(verifierIdentityKey, certificates) {\n        const peerSession = await this.getAuthenticatedSession(verifierIdentityKey);\n        const requestNonce = Utils.toBase64((0, Random_js_1.default)(32));\n        const { signature } = await this.wallet.createSignature({\n            data: Utils.toArray(JSON.stringify(certificates), 'utf8'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const certificateResponse = {\n            version: AUTH_VERSION,\n            messageType: 'certificateResponse',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            initialNonce: peerSession.sessionNonce,\n            yourNonce: peerSession.peerNonce,\n            certificates,\n            signature\n        };\n        // Update usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(certificateResponse);\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            throw new Error(`Failed to send certificate response message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${errorMessage}`);\n        }\n    }\n    /**\n     * Processes a certificate response message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming certificate response message.\n     * @throws Will throw an error if nonce verification or signature verification fails.\n     */\n    async processCertificateResponse(message) {\n        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for certificate response from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        // Validate message signature\n        const { valid } = await this.wallet.verifySignature({\n            data: Utils.toArray(JSON.stringify(message.certificates), 'utf8'),\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: message.identityKey\n        });\n        if (!valid) {\n            throw new Error(`Unable to verify certificate response signature for peer: ${message.identityKey}`);\n        }\n        // We also handle optional validation if there's a requestedCertificates field\n        await (0, index_js_1.validateCertificates)(this.wallet, message, message.requestedCertificates);\n        // Notify any listeners\n        this.onCertificatesReceivedCallbacks.forEach(cb => {\n            cb(message.identityKey, message.certificates ?? []);\n        });\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n    }\n    /**\n     * Processes a general message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming general message.\n     * @throws Will throw an error if nonce or signature verification fails.\n     */\n    async processGeneralMessage(message) {\n        const validNonce = await (0, index_js_1.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for general message from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        const { valid } = await this.wallet.verifySignature({\n            data: message.payload,\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        if (!valid) {\n            throw new Error(`Invalid signature in generalMessage from ${peerSession.peerIdentityKey}`);\n        }\n        // Mark last usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        // Update lastInteractedWithPeer\n        this.lastInteractedWithPeer = message.identityKey;\n        // Dispatch callbacks\n        this.onGeneralMessageReceivedCallbacks.forEach(cb => {\n            cb(message.identityKey, message.payload ?? []);\n        });\n    }\n}\nexports.Peer = Peer;\n//# sourceMappingURL=Peer.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/Peer.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SessionManager = void 0;\n/**\n * Manages sessions for peers, allowing multiple concurrent sessions\n * per identity key. Primary lookup is always by `sessionNonce`.\n */\nclass SessionManager {\n    constructor() {\n        this.sessionNonceToSession = new Map();\n        this.identityKeyToNonces = new Map();\n    }\n    /**\n     * Adds a session to the manager, associating it with its sessionNonce,\n     * and also with its peerIdentityKey (if any).\n     *\n     * This does NOT overwrite existing sessions for the same peerIdentityKey,\n     * allowing multiple concurrent sessions for the same peer.\n     *\n     * @param {PeerSession} session - The peer session to add.\n     */\n    addSession(session) {\n        if (typeof session.sessionNonce !== 'string') {\n            throw new Error('Invalid session: sessionNonce is required to add a session.');\n        }\n        // Use the sessionNonce as the primary key\n        this.sessionNonceToSession.set(session.sessionNonce, session);\n        // Also track it by identity key if present\n        if (typeof session.peerIdentityKey === 'string') {\n            let nonces = this.identityKeyToNonces.get(session.peerIdentityKey);\n            if (nonces == null) {\n                nonces = new Set();\n                this.identityKeyToNonces.set(session.peerIdentityKey, nonces);\n            }\n            nonces.add(session.sessionNonce);\n        }\n    }\n    /**\n     * Updates a session in the manager (primarily by re-adding it),\n     * ensuring we record the latest data (e.g., isAuthenticated, lastUpdate, etc.).\n     *\n     * @param {PeerSession} session - The peer session to update.\n     */\n    updateSession(session) {\n        // Remove the old references (if any) and re-add\n        this.removeSession(session);\n        this.addSession(session);\n    }\n    /**\n     * Retrieves a session based on a given identifier, which can be:\n     *  - A sessionNonce, or\n     *  - A peerIdentityKey.\n     *\n     * If it is a `sessionNonce`, returns that exact session.\n     * If it is a `peerIdentityKey`, returns the \"best\" (e.g. most recently updated,\n     * authenticated) session associated with that peer, if any.\n     *\n     * @param {string} identifier - The identifier for the session (sessionNonce or peerIdentityKey).\n     * @returns {PeerSession | undefined} - The matching peer session, or undefined if not found.\n     */\n    getSession(identifier) {\n        // Check if this identifier is directly a sessionNonce\n        const direct = this.sessionNonceToSession.get(identifier);\n        if (direct != null) {\n            return direct;\n        }\n        // Otherwise, interpret the identifier as an identity key\n        const nonces = this.identityKeyToNonces.get(identifier);\n        if ((nonces == null) || nonces.size === 0) {\n            return undefined;\n        }\n        // Pick the \"best\" session. One sensible approach:\n        // - Choose an authenticated session if available\n        // - Among them, pick the most recently updated\n        let best;\n        for (const nonce of nonces) {\n            const s = this.sessionNonceToSession.get(nonce);\n            if (s == null)\n                continue;\n            // We can prefer authenticated sessions\n            if (best == null) {\n                best = s;\n            }\n            else {\n                // If we want the \"most recently updated\" AND isAuthenticated\n                if ((s.lastUpdate ?? 0) > (best.lastUpdate ?? 0)) {\n                    best = s;\n                }\n            }\n        }\n        // Optionally, you could also filter out isAuthenticated===false if you only want\n        // an authenticated session. But for our usage, let's return the latest any session.\n        return best;\n    }\n    /**\n     * Removes a session from the manager by clearing all associated identifiers.\n     *\n     * @param {PeerSession} session - The peer session to remove.\n     */\n    removeSession(session) {\n        if (typeof session.sessionNonce === 'string') {\n            this.sessionNonceToSession.delete(session.sessionNonce);\n        }\n        if (typeof session.peerIdentityKey === 'string') {\n            const nonces = this.identityKeyToNonces.get(session.peerIdentityKey);\n            if (nonces != null) {\n                nonces.delete(session.sessionNonce ?? '');\n                if (nonces.size === 0) {\n                    this.identityKeyToNonces.delete(session.peerIdentityKey);\n                }\n            }\n        }\n    }\n    /**\n     * Checks if a session exists for a given identifier (either sessionNonce or identityKey).\n     *\n     * @param {string} identifier - The identifier to check.\n     * @returns {boolean} - True if the session exists, false otherwise.\n     */\n    hasSession(identifier) {\n        const direct = this.sessionNonceToSession.has(identifier);\n        if (direct)\n            return true;\n        // if not directly a nonce, interpret as identityKey\n        const nonces = this.identityKeyToNonces.get(identifier);\n        return !(nonces == null) && nonces.size > 0;\n    }\n}\nexports.SessionManager = SessionManager;\n//# sourceMappingURL=SessionManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst ProtoWallet_js_1 = __importDefault(__webpack_require__(/*! ../../wallet/ProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/ProtoWallet.js\"));\nconst Signature_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\"));\n/**\n * Represents an Identity Certificate as per the Wallet interface specifications.\n *\n * This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.\n */\nclass Certificate {\n    /**\n     * Constructs a new Certificate.\n     *\n     * @param {Base64String} type - Type identifier for the certificate, base64 encoded string, 32 bytes.\n     * @param {Base64String} serialNumber - Unique serial number of the certificate, base64 encoded string, 32 bytes.\n     * @param {PubKeyHex} subject - The public key belonging to the certificate's subject, compressed public key hex string.\n     * @param {PubKeyHex} certifier - Public key of the certifier who issued the certificate, compressed public key hex string.\n     * @param {OutpointString} revocationOutpoint - The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - All the fields present in the certificate.\n     * @param {HexString} signature - Certificate signature by the certifier's private key, DER encoded hex string.\n     */\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature) {\n        this.type = type;\n        this.serialNumber = serialNumber;\n        this.subject = subject;\n        this.certifier = certifier;\n        this.revocationOutpoint = revocationOutpoint;\n        this.fields = fields;\n        this.signature = signature;\n    }\n    /**\n     * Serializes the certificate into binary format, with or without a signature.\n     *\n     * @param {boolean} [includeSignature=true] - Whether to include the signature in the serialization.\n     * @returns {number[]} - The serialized certificate in binary format.\n     */\n    toBinary(includeSignature = true) {\n        const writer = new Utils.Writer();\n        // Write type (Base64String, 32 bytes)\n        const typeBytes = Utils.toArray(this.type, 'base64');\n        writer.write(typeBytes);\n        // Write serialNumber (Base64String, 32 bytes)\n        const serialNumberBytes = Utils.toArray(this.serialNumber, 'base64');\n        writer.write(serialNumberBytes);\n        // Write subject (33 bytes compressed PubKeyHex)\n        const subjectBytes = Utils.toArray(this.subject, 'hex');\n        writer.write(subjectBytes);\n        // Write certifier (33 bytes compressed PubKeyHex)\n        const certifierBytes = Utils.toArray(this.certifier, 'hex');\n        writer.write(certifierBytes);\n        // Write revocationOutpoint (TXID + OutputIndex)\n        const [txid, outputIndex] = this.revocationOutpoint.split('.');\n        const txidBytes = Utils.toArray(txid, 'hex');\n        writer.write(txidBytes);\n        writer.writeVarIntNum(Number(outputIndex));\n        // Write fields\n        // Sort field names lexicographically\n        const fieldNames = Object.keys(this.fields).sort();\n        writer.writeVarIntNum(fieldNames.length);\n        for (const fieldName of fieldNames) {\n            const fieldValue = this.fields[fieldName];\n            // Field name\n            const fieldNameBytes = Utils.toArray(fieldName, 'utf8');\n            writer.writeVarIntNum(fieldNameBytes.length);\n            writer.write(fieldNameBytes);\n            // Field value\n            const fieldValueBytes = Utils.toArray(fieldValue, 'utf8');\n            writer.writeVarIntNum(fieldValueBytes.length);\n            writer.write(fieldValueBytes);\n        }\n        // Write signature if included\n        if (includeSignature && (this.signature ?? '').length > 0) { //  Explicitly handle nullish signature\n            const signatureBytes = Utils.toArray(this.signature, 'hex'); //  Type assertion ensures it's a string\n            writer.write(signatureBytes);\n        }\n        return writer.toArray();\n    }\n    /**\n     * Deserializes a certificate from binary format.\n     *\n     * @param {number[]} bin - The binary data representing the certificate.\n     * @returns {Certificate} - The deserialized Certificate object.\n     */\n    static fromBinary(bin) {\n        const reader = new Utils.Reader(bin);\n        // Read type\n        const typeBytes = reader.read(32);\n        const type = Utils.toBase64(typeBytes);\n        // Read serialNumber\n        const serialNumberBytes = reader.read(32);\n        const serialNumber = Utils.toBase64(serialNumberBytes);\n        // Read subject (33 bytes)\n        const subjectBytes = reader.read(33);\n        const subject = Utils.toHex(subjectBytes);\n        // Read certifier (33 bytes)\n        const certifierBytes = reader.read(33);\n        const certifier = Utils.toHex(certifierBytes);\n        // Read revocationOutpoint\n        const txidBytes = reader.read(32);\n        const txid = Utils.toHex(txidBytes);\n        const outputIndex = reader.readVarIntNum();\n        const revocationOutpoint = `${txid}.${outputIndex}`;\n        // Read fields\n        const numFields = reader.readVarIntNum();\n        const fields = {};\n        for (let i = 0; i < numFields; i++) {\n            // Field name\n            const fieldNameLength = reader.readVarIntNum();\n            const fieldNameBytes = reader.read(fieldNameLength);\n            const fieldName = Utils.toUTF8(fieldNameBytes);\n            // Field value\n            const fieldValueLength = reader.readVarIntNum();\n            const fieldValueBytes = reader.read(fieldValueLength);\n            const fieldValue = Utils.toUTF8(fieldValueBytes);\n            fields[fieldName] = fieldValue;\n        }\n        // Read signature if present\n        let signature;\n        if (!reader.eof()) {\n            const signatureBytes = reader.read();\n            const sig = Signature_js_1.default.fromDER(signatureBytes);\n            signature = sig.toString('hex');\n        }\n        return new Certificate(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n    }\n    /**\n     * Verifies the certificate's signature.\n     *\n     * @returns {Promise<boolean>} - A promise that resolves to true if the signature is valid.\n     */\n    async verify() {\n        // A verifier can be any wallet capable of verifying signatures\n        const verifier = new ProtoWallet_js_1.default('anyone');\n        const verificationData = this.toBinary(false); // Exclude the signature from the verification data\n        const signatureHex = this.signature ?? ''; // Provide a fallback value (empty string)\n        const { valid } = await verifier.verifySignature({\n            signature: Utils.toArray(signatureHex, 'hex'),\n            data: verificationData,\n            protocolID: [2, 'certificate signature'],\n            keyID: `${this.type} ${this.serialNumber}`,\n            counterparty: this.certifier // The certifier is the one who signed the certificate\n        });\n        return valid;\n    }\n    /**\n   * Signs the certificate using the provided certifier wallet.\n   *\n   * @param {Wallet} certifierWallet - The wallet representing the certifier.\n   * @returns {Promise<void>}\n   */\n    async sign(certifierWallet) {\n        if (this.signature != null && this.signature.length > 0) { //  Explicitly checking for null/undefined\n            throw new Error(`Certificate has already been signed! Signature present: ${this.signature}`);\n        }\n        // Ensure the certifier declared is the one actually signing\n        this.certifier = (await certifierWallet.getPublicKey({ identityKey: true })).publicKey;\n        const preimage = this.toBinary(false); // Exclude the signature when signing\n        const { signature } = await certifierWallet.createSignature({\n            data: preimage,\n            protocolID: [2, 'certificate signature'],\n            keyID: `${this.type} ${this.serialNumber}`\n        });\n        this.signature = Utils.toHex(signature);\n    }\n    /**\n     * Helper function which retrieves the protocol ID and key ID for certificate field encryption.\n     *\n     * For master certificate creation, no serial number is provided because entropy is required\n     * from both the client and the certifier. In this case, the `keyID` is simply the `fieldName`.\n     *\n     * For VerifiableCertificates verifier keyring creation, both the serial number and field name are available,\n     * so the `keyID` is formed by concatenating the `serialNumber` and `fieldName`.\n     *\n     * @param fieldName - The name of the field within the certificate to be encrypted.\n     * @param serialNumber - (Optional) The serial number of the certificate.\n     * @returns An object containing:\n     *   - `protocolID` (WalletProtocol): The protocol ID for certificate field encryption.\n     *   - `keyID` (string): A unique key identifier. It is the `fieldName` if `serialNumber` is undefined,\n     *     otherwise it is a combination of `serialNumber` and `fieldName`.\n     */\n    static getCertificateFieldEncryptionDetails(fieldName, serialNumber) {\n        return {\n            protocolID: [2, 'certificate field encryption'],\n            keyID: serialNumber ? `${serialNumber} ${fieldName}` : fieldName\n        };\n    }\n}\nexports[\"default\"] = Certificate;\n//# sourceMappingURL=Certificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/MasterCertificate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/MasterCertificate.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MasterCertificate = void 0;\nconst Certificate_js_1 = __importDefault(__webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst SymmetricKey_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\n/**\n * MasterCertificate extends the base Certificate class to manage a master keyring, enabling the creation of verifiable certificates.\n *\n * It allows for the selective disclosure of certificate fields by creating a `VerifiableCertificate` for a specific verifier.\n * The `MasterCertificate` can securely decrypt each master key and re-encrypt it for a verifier, creating a customized\n * keyring containing only the keys necessary for the verifier to access designated fields.\n *\n */\nclass MasterCertificate extends Certificate_js_1.default {\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, masterKeyring, signature) {\n        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n        // Ensure every field in `fields` is a string and has a corresponding key in `masterKeyring`\n        for (const fieldName of Object.keys(fields)) {\n            if (masterKeyring[fieldName] === undefined || masterKeyring[fieldName] === '') {\n                throw new Error(`Master keyring must contain a value for every field. Missing or empty key for field: \"${fieldName}\".`);\n            }\n        }\n        this.masterKeyring = masterKeyring;\n    }\n    /**\n     * Encrypts certificate fields for a subject and generates a master keyring.\n     * This method returns a master keyring tied to a specific certifier or subject who will validate\n     * and sign off on the fields, along with the encrypted certificate fields.\n     *\n     * @param {ProtoWallet} creatorWallet - The wallet of the creator responsible for encrypting the fields.\n     * @param {WalletCounterparty} certifierOrSubject - The certifier or subject who will validate the certificate fields.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - A record of certificate field names (under 50 bytes) mapped to their values.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *\n     * @returns {Promise<CreateCertificateFieldsResult>} A promise resolving to an object containing:\n     *   - `certificateFields` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:\n     *     The encrypted certificate fields.\n     *   - `masterKeyring` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:\n     *     The master keyring containing encrypted revelation keys for each field.\n     */\n    static async createCertificateFields(creatorWallet, certifierOrSubject, fields, privileged, privilegedReason) {\n        const certificateFields = {};\n        const masterKeyring = {};\n        for (const [fieldName, fieldValue] of Object.entries(fields)) {\n            const fieldSymmetricKey = SymmetricKey_js_1.default.fromRandom();\n            const encryptedFieldValue = fieldSymmetricKey.encrypt(Utils.toArray(fieldValue, 'utf8'));\n            certificateFields[fieldName] = Utils.toBase64(encryptedFieldValue);\n            const { ciphertext: encryptedFieldRevelationKey } = await creatorWallet.encrypt({\n                plaintext: fieldSymmetricKey.toArray(),\n                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName),\n                counterparty: certifierOrSubject,\n                privileged,\n                privilegedReason\n            });\n            masterKeyring[fieldName] = Utils.toBase64(encryptedFieldRevelationKey);\n        }\n        return {\n            certificateFields,\n            masterKeyring\n        };\n    }\n    /**\n     * Creates a keyring for a verifier, enabling them to decrypt specific certificate fields.\n     * This method decrypts the master field keys for the specified fields and re-encrypts them\n     * for the verifier's identity key. The result is a keyring containing the keys necessary\n     * for the verifier to access the designated fields.\n     *\n     * @param {ProtoWallet} subjectWallet - The wallet instance of the subject, used to decrypt and re-encrypt field keys.\n     * @param {WalletCounterparty} verifier - The verifier who will receive access to the selectively revealed fields. Can be an identity key as hex, 'anyone', or 'self'.\n     * @param {string[]} fieldsToReveal - An array of field names to be revealed to the verifier. Must be a subset of the certificate's fields.\n     * @param {string} [originator] - Optional originator identifier, used if additional context is needed for decryption and encryption operations.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A keyring mapping field names to encrypted field revelation keys, allowing the verifier to decrypt specified fields.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *\n     * @throws {Error} Throws an error if:\n     *   - fieldsToReveal is not an array of strings.\n     *   - A field in `fieldsToReveal` does not exist in the certificate.\n     *   - The decrypted master field key fails to decrypt the corresponding field (indicating an invalid key).\n     */\n    static async createKeyringForVerifier(subjectWallet, certifier, verifier, fields, fieldsToReveal, masterKeyring, serialNumber, privileged, privilegedReason) {\n        if (!Array.isArray(fieldsToReveal)) {\n            throw new Error('fieldsToReveal must be an array of strings');\n        }\n        const fieldRevelationKeyring = {};\n        for (const fieldName of fieldsToReveal) {\n            // Make sure that fields to reveal is a subset of the certificate fields\n            if (fields[fieldName] === undefined || fields[fieldName] === null || fields[fieldName] === '') {\n                throw new Error(`Fields to reveal must be a subset of the certificate fields. Missing the \"${fieldName}\" field.`);\n            }\n            // Decrypt the master field key and verify that derived key actually decrypts requested field\n            const masterFieldKey = (await this.decryptField(subjectWallet, masterKeyring, fieldName, fields[fieldName], certifier, privileged, privilegedReason)).fieldRevelationKey;\n            // Encrypt derived fieldRevelationKey for verifier\n            const { ciphertext: encryptedFieldRevelationKey } = await subjectWallet.encrypt({\n                plaintext: masterFieldKey,\n                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName, serialNumber),\n                counterparty: verifier,\n                privileged,\n                privilegedReason\n            });\n            // Add encryptedFieldRevelationKey to fieldRevelationKeyring\n            fieldRevelationKeyring[fieldName] = Utils.toBase64(encryptedFieldRevelationKey);\n        }\n        // Return the field revelation keyring which can be used to create a verifiable certificate for a verifier.\n        return fieldRevelationKeyring;\n    }\n    /**\n     * Issues a new MasterCertificate for a specified subject.\n     *\n     * This method generates a certificate containing encrypted fields and a keyring\n     * for the subject to decrypt all fields. Each field is encrypted with a randomly\n     * generated symmetric key, which is then encrypted for the subject. The certificate\n     * can also includes a revocation outpoint to manage potential revocation.\n     *\n     * @param {ProtoWallet} certifierWallet - The wallet of the certifier, used to sign the certificate and encrypt field keys.\n     * @param {WalletCounterparty} subject - The subject for whom the certificate is issued.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - Unencrypted certificate fields to include, with their names and values.\n     * @param {string} certificateType - The type of certificate being issued.\n     * @param {function(string, Record<CertificateFieldNameUnder50Bytes, string>?): Promise<string>} getRevocationOutpoint -\n     *   Optional function to obtain a revocation outpoint for the certificate. Defaults to a placeholder.\n     * @param {function(string): Promise<void>} updateProgress - Optional callback for reporting progress updates during the operation. Defaults to a no-op.\n     * @returns {Promise<MasterCertificate>} - A signed MasterCertificate instance containing the encrypted fields and subject specific keyring.\n     *\n     * @throws {Error} Throws an error if any operation (e.g., encryption, signing) fails during certificate issuance.\n     */\n    static async issueCertificateForSubject(certifierWallet, subject, fields, certificateType, getRevocationOutpoint = async (_serial) => {\n        void _serial; // Explicitly acknowledge unused parameter\n        return 'Certificate revocation not tracked.';\n    }, serialNumber) {\n        // 1. Generate a random serialNumber if not provided\n        const finalSerialNumber = serialNumber ?? Utils.toBase64((0, Random_js_1.default)(32));\n        // 2. Create encrypted certificate fields and associated master keyring\n        const { certificateFields, masterKeyring } = await this.createCertificateFields(certifierWallet, subject, fields);\n        // 3. Obtain a revocation outpoint\n        const revocationOutpoint = await getRevocationOutpoint(finalSerialNumber);\n        // 4. Create new MasterCertificate instance\n        const certificate = new MasterCertificate(certificateType, finalSerialNumber, subject, (await certifierWallet.getPublicKey({ identityKey: true })).publicKey, revocationOutpoint, certificateFields, masterKeyring);\n        // 5. Sign and return the new MasterCertificate certifying the subject.\n        await certificate.sign(certifierWallet);\n        return certificate;\n    }\n    /**\n     * Decrypts all fields in the MasterCertificate using the subject's or certifier's wallet.\n     *\n     * This method allows the subject or certifier to decrypt the `masterKeyring` and retrieve\n     * the encryption keys for each field, which are then used to decrypt the corresponding field values.\n     * The counterparty used for decryption depends on how the certificate fields were created:\n     * - If the certificate is self-signed, the counterparty should be set to 'self'.\n     * - Otherwise, the counterparty should always be the other party involved in the certificate issuance process (the subject or certifier).\n     *\n     * @param {ProtoWallet} subjectOrCertifierWallet - The wallet of the subject or certifier, used to decrypt the master keyring and field values.\n     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} masterKeyring - A record containing encrypted keys for each field.\n     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} fields - A record of encrypted field names and their values.\n     * @param {WalletCounterparty} counterparty - The counterparty responsible for creating or signing the certificate. For self-signed certificates, use 'self'.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} A promise resolving to a record of field names and their decrypted values in plaintext.\n     *\n     * @throws {Error} Throws an error if the `masterKeyring` is invalid or if decryption fails for any field.\n     */\n    static async decryptFields(subjectOrCertifierWallet, masterKeyring, fields, counterparty, privileged, privilegedReason) {\n        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {\n            throw new Error('A MasterCertificate must have a valid masterKeyring!');\n        }\n        try {\n            const decryptedFields = {};\n            // Note: we want to iterate through all fields, not just masterKeyring keys/value pairs.\n            for (const fieldName of Object.keys(fields)) {\n                decryptedFields[fieldName] = (await this.decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fields[fieldName], counterparty, privileged, privilegedReason)).decryptedFieldValue;\n            }\n            return decryptedFields;\n        }\n        catch {\n            throw new Error('Failed to decrypt all master certificate fields.');\n        }\n    }\n    static async decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fieldValue, counterparty, privileged, privilegedReason) {\n        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {\n            throw new Error('A MasterCertificate must have a valid masterKeyring!');\n        }\n        try {\n            const { plaintext: fieldRevelationKey } = await subjectOrCertifierWallet.decrypt({\n                ciphertext: Utils.toArray(masterKeyring[fieldName], 'base64'),\n                ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName),\n                counterparty,\n                privileged,\n                privilegedReason\n            });\n            const decryptedFieldValue = new SymmetricKey_js_1.default(fieldRevelationKey).decrypt(Utils.toArray(fieldValue, 'base64'));\n            return {\n                fieldRevelationKey,\n                decryptedFieldValue: Utils.toUTF8(decryptedFieldValue)\n            };\n        }\n        catch {\n            throw new Error('Failed to decrypt certificate field!');\n        }\n    }\n}\nexports.MasterCertificate = MasterCertificate;\n//# sourceMappingURL=MasterCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/MasterCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.VerifiableCertificate = void 0;\nconst SymmetricKey_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst Certificate_js_1 = __importDefault(__webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\"));\n/**\n * VerifiableCertificate extends the Certificate class, adding functionality to manage a verifier-specific keyring.\n * This keyring allows selective decryption of certificate fields for authorized verifiers.\n */\nclass VerifiableCertificate extends Certificate_js_1.default {\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, keyring, signature, decryptedFields) {\n        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n        this.keyring = keyring;\n        this.decryptedFields = decryptedFields;\n    }\n    /**\n     *\n     * @param {WalletCertificate} certificate  The source certificate that was issued and signed by the certifier.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} keyring  A allows the verifier to decrypt selected certificate fields.\n     * @returns {VerifiableCertificate}  A fully-formed instance containing the\n     *   original certificate data plus the supplied keyring.\n     */\n    static fromCertificate(certificate, keyring) {\n        return new VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyring, certificate.signature);\n    }\n    /**\n     * Decrypts selectively revealed certificate fields using the provided keyring and verifier wallet\n     * @param {ProtoWallet} verifierWallet - The wallet instance of the certificate's verifier, used to decrypt field keys.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A promise that resolves to an object where each key is a field name and each value is the decrypted field value as a string.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.\n     * @throws {Error} Throws an error if any of the decryption operations fail, with a message indicating the failure context.\n     */\n    async decryptFields(verifierWallet, privileged, privilegedReason) {\n        if (this.keyring == null || Object.keys(this.keyring).length === 0) { //  Explicitly check null and empty object\n            throw new Error('A keyring is required to decrypt certificate fields for the verifier.');\n        }\n        try {\n            const decryptedFields = {};\n            for (const fieldName in this.keyring) {\n                const { plaintext: fieldRevelationKey } = await verifierWallet.decrypt({\n                    ciphertext: Utils.toArray(this.keyring[fieldName], 'base64'),\n                    ...Certificate_js_1.default.getCertificateFieldEncryptionDetails(fieldName, this.serialNumber),\n                    counterparty: this.subject,\n                    privileged,\n                    privilegedReason\n                });\n                const fieldValue = new SymmetricKey_js_1.default(fieldRevelationKey).decrypt(Utils.toArray(this.fields[fieldName], 'base64'));\n                decryptedFields[fieldName] = Utils.toUTF8(fieldValue);\n            }\n            return decryptedFields;\n        }\n        catch (error) {\n            throw new Error(`Failed to decrypt selectively revealed certificate fields using keyring: ${String(error instanceof Error ? error.message : error)}`);\n        }\n    }\n}\nexports.VerifiableCertificate = VerifiableCertificate;\n//# sourceMappingURL=VerifiableCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/__tests/CompletedProtoWallet.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/__tests/CompletedProtoWallet.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CompletedProtoWallet = void 0;\n//@ts-nocheck\nconst PrivateKey_js_1 = __importDefault(__webpack_require__(/*! ../../../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\"));\nconst index_js_1 = __webpack_require__(/*! ../../../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js\");\n// Test Mock wallet which extends ProtoWallet but still implements Wallet interface\n// Unsupported methods throw\nclass CompletedProtoWallet extends index_js_1.ProtoWallet {\n    constructor(rootKeyOrKeyDeriver) {\n        super(rootKeyOrKeyDeriver);\n        if (rootKeyOrKeyDeriver instanceof index_js_1.KeyDeriver) {\n            this.keyDeriver = rootKeyOrKeyDeriver;\n        }\n        else if (typeof rootKeyOrKeyDeriver === 'string' ||\n            rootKeyOrKeyDeriver instanceof PrivateKey_js_1.default) {\n            this.keyDeriver = new index_js_1.CachedKeyDeriver(rootKeyOrKeyDeriver);\n        }\n        else {\n            throw new Error('Invalid key deriver provided');\n        }\n    }\n    async isAuthenticated() {\n        throw new Error('not implemented');\n    }\n    async waitForAuthentication() {\n        throw new Error('not implemented');\n    }\n    async getNetwork() {\n        throw new Error('not implemented');\n    }\n    async getVersion() {\n        throw new Error('not implemented');\n    }\n    async getPublicKey(args) {\n        if (args.privileged === true) {\n            throw new Error('no privilege support');\n        }\n        if (args.identityKey === true) {\n            if (this.keyDeriver === null || this.keyDeriver === undefined) {\n                throw new Error('keyDeriver is not initialized');\n            }\n            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };\n        }\n        else {\n            if (args.protocolID == null || typeof args.keyID !== 'string' || args.keyID.trim() === '') {\n                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');\n            }\n            if (this.keyDeriver === null || this.keyDeriver === undefined) {\n                throw new Error('keyDeriver is not initialized');\n            }\n            return {\n                publicKey: this.keyDeriver\n                    .derivePublicKey(args.protocolID, args.keyID, typeof args.counterparty === 'string' && args.counterparty.trim() !== ''\n                    ? args.counterparty\n                    : 'self', Boolean(args.forSelf))\n                    .toString()\n            };\n        }\n    }\n    async createAction() {\n        throw new Error('not implemented');\n    }\n    async signAction() {\n        throw new Error('not implemented');\n    }\n    async abortAction() {\n        throw new Error('not implemented');\n    }\n    async listActions() {\n        throw new Error('not implemented');\n    }\n    async internalizeAction() {\n        throw new Error('not implemented');\n    }\n    async listOutputs() {\n        throw new Error('not implemented');\n    }\n    async relinquishOutput() {\n        throw new Error('not implemented');\n    }\n    async acquireCertificate() {\n        throw new Error('not implemented');\n    }\n    async listCertificates() {\n        throw new Error('not implemented');\n    }\n    async proveCertificate() {\n        throw new Error('not implemented');\n    }\n    async relinquishCertificate() {\n        throw new Error('not implemented');\n    }\n    async discoverByIdentityKey() {\n        throw new Error('not implemented');\n    }\n    async discoverByAttributes() {\n        throw new Error('not implemented');\n    }\n    async getHeight() {\n        throw new Error('not implemented');\n    }\n    async getHeaderForHeight() {\n        throw new Error('not implemented');\n    }\n}\nexports.CompletedProtoWallet = CompletedProtoWallet;\n//# sourceMappingURL=CompletedProtoWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/__tests/CompletedProtoWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Certificate = void 0;\nvar Certificate_js_1 = __webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\");\nObject.defineProperty(exports, \"Certificate\", ({ enumerable: true, get: function () { return __importDefault(Certificate_js_1).default; } }));\n__exportStar(__webpack_require__(/*! ./MasterCertificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/MasterCertificate.js\"), exports);\n__exportStar(__webpack_require__(/*! ./VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js\"), exports);\n__exportStar(__webpack_require__(/*! ./__tests/CompletedProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/__tests/CompletedProtoWallet.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/AuthFetch.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/AuthFetch.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AuthFetch = void 0;\n// @ts-nocheck\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst P2PKH_js_1 = __importDefault(__webpack_require__(/*! ../../script/templates/P2PKH.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst createNonce_js_1 = __webpack_require__(/*! ../utils/createNonce.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/createNonce.js\");\nconst Peer_js_1 = __webpack_require__(/*! ../Peer.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/Peer.js\");\nconst SimplifiedFetchTransport_js_1 = __webpack_require__(/*! ../transports/SimplifiedFetchTransport.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/SimplifiedFetchTransport.js\");\nconst SessionManager_js_1 = __webpack_require__(/*! ../SessionManager.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js\");\nconst index_js_1 = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js\");\nconst PAYMENT_VERSION = '1.0';\n/**\n * AuthFetch provides a lightweight fetch client for interacting with servers\n * over a simplified HTTP transport mechanism. It integrates session management, peer communication,\n * and certificate handling to enable secure and mutually-authenticated requests.\n *\n * Additionally, it automatically handles 402 Payment Required responses by creating\n * and sending BSV payment transactions when necessary.\n */\nclass AuthFetch {\n    /**\n    * Constructs a new AuthFetch instance.\n    * @param wallet - The wallet instance for signing and authentication.\n    * @param requestedCertificates - Optional set of certificates to request from peers.\n    */\n    constructor(wallet, requestedCertificates, sessionManager) {\n        this.callbacks = {};\n        this.certificatesReceived = [];\n        this.peers = {};\n        this.wallet = wallet;\n        this.requestedCertificates = requestedCertificates;\n        this.sessionManager = sessionManager || new SessionManager_js_1.SessionManager();\n    }\n    /**\n     * Mutually authenticates and sends a HTTP request to a server.\n     *\n     * 1) Attempt the request.\n     * 2) If 402 Payment Required, automatically create and send payment.\n     * 3) Return the final response.\n     *\n     * @param url - The URL to send the request to.\n     * @param config - Configuration options for the request, including method, headers, and body.\n     * @returns A promise that resolves with the server's response, structured as a Response-like object.\n     *\n     * @throws Will throw an error if unsupported headers are used or other validation fails.\n     */\n    async fetch(url, config = {}) {\n        if (typeof config.retryCounter === 'number') {\n            if (config.retryCounter <= 0) {\n                throw new Error('Request failed after maximum number of retries.');\n            }\n            config.retryCounter--;\n        }\n        const response = await new Promise((async (resolve, reject) => {\n            try {\n                // Apply defaults\n                const { method = 'GET', headers = {}, body } = config;\n                // Extract a base url\n                const parsedUrl = new URL(url);\n                const baseURL = parsedUrl.origin;\n                // Create a new transport for this base url if needed\n                let peerToUse;\n                if (typeof this.peers[baseURL] === 'undefined') {\n                    // Create a peer for the request\n                    const newTransport = new SimplifiedFetchTransport_js_1.SimplifiedFetchTransport(baseURL);\n                    peerToUse = {\n                        peer: new Peer_js_1.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager),\n                        pendingCertificateRequests: []\n                    };\n                    this.peers[baseURL] = peerToUse;\n                    this.peers[baseURL].peer.listenForCertificatesReceived((senderPublicKey, certs) => {\n                        this.certificatesReceived.push(...certs);\n                    });\n                    this.peers[baseURL].peer.listenForCertificatesRequested((async (verifier, requestedCertificates) => {\n                        try {\n                            this.peers[baseURL].pendingCertificateRequests.push(true);\n                            const certificatesToInclude = await (0, index_js_1.getVerifiableCertificates)(this.wallet, requestedCertificates, verifier);\n                            await this.peers[baseURL].peer.sendCertificateResponse(verifier, certificatesToInclude);\n                        }\n                        finally {\n                            // Give the backend 500 ms to process the certificates we just sent, before releasing the queue entry\n                            await new Promise(resolve => setTimeout(resolve, 500));\n                            this.peers[baseURL].pendingCertificateRequests.shift();\n                        }\n                    }));\n                }\n                else {\n                    // Check if there's a session associated with this baseURL\n                    if (this.peers[baseURL].supportsMutualAuth === false) {\n                        // Use standard fetch if mutual authentication is not supported\n                        try {\n                            const response = await this.handleFetchAndValidate(url, config, this.peers[baseURL]);\n                            resolve(response);\n                        }\n                        catch (error) {\n                            reject(error);\n                        }\n                        return;\n                    }\n                    peerToUse = this.peers[baseURL];\n                }\n                // Serialize the simplified fetch request.\n                const requestNonce = (0, Random_js_1.default)(32);\n                const requestNonceAsBase64 = Utils.toBase64(requestNonce);\n                const writer = await this.serializeRequest(method, headers, body, parsedUrl, requestNonce);\n                // Setup general message listener to resolve requests once a response is received\n                this.callbacks[requestNonceAsBase64] = { resolve, reject };\n                const listenerId = peerToUse.peer.listenForGeneralMessages((senderPublicKey, payload) => {\n                    // Create a reader\n                    const responseReader = new Utils.Reader(payload);\n                    // Deserialize first 32 bytes of payload\n                    const responseNonceAsBase64 = Utils.toBase64(responseReader.read(32));\n                    if (responseNonceAsBase64 !== requestNonceAsBase64) {\n                        return;\n                    }\n                    peerToUse.peer.stopListeningForGeneralMessages(listenerId);\n                    // Save the identity key for the peer for future requests, since we have it here.\n                    this.peers[baseURL].identityKey = senderPublicKey;\n                    this.peers[baseURL].supportsMutualAuth = true;\n                    // Status code\n                    const statusCode = responseReader.readVarIntNum();\n                    // Headers\n                    const responseHeaders = {};\n                    const nHeaders = responseReader.readVarIntNum();\n                    if (nHeaders > 0) {\n                        for (let i = 0; i < nHeaders; i++) {\n                            const nHeaderKeyBytes = responseReader.readVarIntNum();\n                            const headerKeyBytes = responseReader.read(nHeaderKeyBytes);\n                            const headerKey = Utils.toUTF8(headerKeyBytes);\n                            const nHeaderValueBytes = responseReader.readVarIntNum();\n                            const headerValueBytes = responseReader.read(nHeaderValueBytes);\n                            const headerValue = Utils.toUTF8(headerValueBytes);\n                            responseHeaders[headerKey] = headerValue;\n                        }\n                    }\n                    // Add back the server identity key header\n                    responseHeaders['x-bsv-auth-identity-key'] = senderPublicKey;\n                    // Body\n                    let responseBody;\n                    const responseBodyBytes = responseReader.readVarIntNum();\n                    if (responseBodyBytes > 0) {\n                        responseBody = responseReader.read(responseBodyBytes);\n                    }\n                    // Create the Response object\n                    const responseValue = new Response(responseBody ? new Uint8Array(responseBody) : null, {\n                        status: statusCode,\n                        statusText: `${statusCode}`,\n                        headers: new Headers(responseHeaders)\n                    });\n                    // Resolve or reject the correct request with the response data\n                    this.callbacks[requestNonceAsBase64].resolve(responseValue);\n                    // Clean up\n                    delete this.callbacks[requestNonceAsBase64];\n                });\n                // Before sending general messages to the peer, ensure that no certificate requests are pending.\n                // This way, the user would need to choose to either allow or reject the certificate request first.\n                // If the server has a resource that requires certificates to be sent before access would be granted,\n                // this makes sure the user has a chance to send the certificates before the resource is requested.\n                if (peerToUse.pendingCertificateRequests.length > 0) {\n                    await new Promise(resolve => {\n                        setInterval(() => {\n                            if (peerToUse.pendingCertificateRequests.length === 0) {\n                                resolve();\n                            }\n                        }, 100); // Check every 100 ms for the user to finish responding\n                    });\n                }\n                // Send the request, now that all listeners are set up\n                await peerToUse.peer.toPeer(writer.toArray(), peerToUse.identityKey).catch(async (error) => {\n                    if (error.message.includes('Session not found for nonce')) {\n                        delete this.peers[baseURL];\n                        config.retryCounter ?? (config.retryCounter = 3);\n                        const response = await this.fetch(url, config);\n                        resolve(response);\n                        return;\n                    }\n                    if (error.message.includes('HTTP server failed to authenticate')) {\n                        try {\n                            const response = await this.handleFetchAndValidate(url, config, peerToUse);\n                            resolve(response);\n                            return;\n                        }\n                        catch (fetchError) {\n                            reject(fetchError);\n                        }\n                    }\n                    else {\n                        reject(error);\n                    }\n                });\n            }\n            catch (e) {\n                reject(e);\n            }\n        }));\n        // Check if server requires payment to access the requested route\n        if (response.status === 402) {\n            // Create and attach a payment, then retry\n            return await this.handlePaymentAndRetry(url, config, response);\n        }\n        return response;\n    }\n    /**\n     * Request Certificates from a Peer\n     * @param baseUrl\n     * @param certificatesToRequest\n     */\n    async sendCertificateRequest(baseUrl, certificatesToRequest) {\n        const parsedUrl = new URL(baseUrl);\n        const baseURL = parsedUrl.origin;\n        let peerToUse;\n        if (typeof this.peers[baseURL] !== 'undefined') {\n            peerToUse = { peer: this.peers[baseURL].peer };\n        }\n        else {\n            const newTransport = new SimplifiedFetchTransport_js_1.SimplifiedFetchTransport(baseURL);\n            peerToUse = {\n                peer: new Peer_js_1.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager)\n            };\n            this.peers[baseURL] = peerToUse;\n        }\n        // Return a promise that resolves when certificates are received\n        return await new Promise((async (resolve, reject) => {\n            // Set up the listener before making the request\n            const callbackId = peerToUse.peer.listenForCertificatesReceived((_senderPublicKey, certs) => {\n                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);\n                this.certificatesReceived.push(...certs);\n                resolve(certs);\n            });\n            try {\n                // Initiate the certificate request\n                await peerToUse.peer.requestCertificates(certificatesToRequest, peerToUse.identityKey);\n            }\n            catch (err) {\n                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);\n                reject(err);\n            }\n        }));\n    }\n    /**\n     * Return any certificates we've collected thus far, then clear them out.\n     */\n    consumeReceivedCertificates() {\n        return this.certificatesReceived.splice(0);\n    }\n    /**\n     * Serializes the HTTP request to be sent over the Transport.\n     *\n     * @param method - The HTTP method (e.g., 'GET', 'POST') for the request.\n     * @param headers - A record of HTTP headers to include in the request.\n     * @param body - The body of the request, if applicable (e.g., for POST/PUT requests).\n     * @param parsedUrl - The parsed URL object containing the full request URL.\n     * @param requestNonce - A unique random nonce to ensure request integrity.\n     * @returns A promise that resolves to a `Writer` containing the serialized request.\n     *\n     * @throws Will throw an error if unsupported headers are used or serialization fails.\n     */\n    async serializeRequest(method, headers, body, parsedUrl, requestNonce) {\n        const writer = new Utils.Writer();\n        // Write request nonce\n        writer.write(requestNonce);\n        // Method length\n        writer.writeVarIntNum(method.length);\n        // Method\n        writer.write(Utils.toArray(method));\n        // Handle pathname (e.g. /path/to/resource)\n        if (parsedUrl.pathname.length > 0) {\n            // Pathname length\n            const pathnameAsArray = Utils.toArray(parsedUrl.pathname);\n            writer.writeVarIntNum(pathnameAsArray.length);\n            // Pathname\n            writer.write(pathnameAsArray);\n        }\n        else {\n            writer.writeVarIntNum(-1);\n        }\n        // Handle search params (e.g. ?q=hello)\n        if (parsedUrl.search.length > 0) {\n            // search length\n            const searchAsArray = Utils.toArray(parsedUrl.search);\n            writer.writeVarIntNum(searchAsArray.length);\n            // search\n            writer.write(searchAsArray);\n        }\n        else {\n            writer.writeVarIntNum(-1);\n        }\n        // Construct headers to send / sign:\n        // Ensures clients only provided supported HTTP request headers\n        // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)\n        // - Include a normalized version of the content-type header\n        // - Include the authorization header\n        const includedHeaders = [];\n        for (let [k, v] of Object.entries(headers)) {\n            k = k.toLowerCase(); // We will always sign lower-case header keys\n            if (k.startsWith('x-bsv-') || k === 'authorization') {\n                if (k.startsWith('x-bsv-auth')) {\n                    throw new Error('No BSV auth headers allowed here!');\n                }\n                includedHeaders.push([k, v]);\n            }\n            else if (k.startsWith('content-type')) {\n                // Normalize the Content-Type header by removing any parameters (e.g., \"; charset=utf-8\")\n                v = v.split(';')[0].trim();\n                includedHeaders.push([k, v]);\n            }\n            else {\n                throw new Error('Unsupported header in the simplified fetch implementation. Only content-type, authorization, and x-bsv-* headers are supported.');\n            }\n        }\n        // Sort the headers by key to ensure a consistent order for signing and verification.\n        includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n        // nHeaders\n        writer.writeVarIntNum(includedHeaders.length);\n        for (let i = 0; i < includedHeaders.length; i++) {\n            // headerKeyLength\n            const headerKeyAsArray = Utils.toArray(includedHeaders[i][0], 'utf8');\n            writer.writeVarIntNum(headerKeyAsArray.length);\n            // headerKey\n            writer.write(headerKeyAsArray);\n            // headerValueLength\n            const headerValueAsArray = Utils.toArray(includedHeaders[i][1], 'utf8');\n            writer.writeVarIntNum(headerValueAsArray.length);\n            // headerValue\n            writer.write(headerValueAsArray);\n        }\n        // If method typically carries a body and body is undefined, default it\n        // This prevents signature verification errors due to mismatch default body types with express\n        const methodsThatTypicallyHaveBody = ['POST', 'PUT', 'PATCH', 'DELETE'];\n        if (methodsThatTypicallyHaveBody.includes(method.toUpperCase()) && body === undefined) {\n            // Check if content-type is application/json\n            const contentTypeHeader = includedHeaders.find(([k]) => k === 'content-type');\n            if (contentTypeHeader && contentTypeHeader[1].includes('application/json')) {\n                body = '{}';\n            }\n            else {\n                body = '';\n            }\n        }\n        // Handle body\n        if (body) {\n            const reqBody = await this.normalizeBodyToNumberArray(body); // Use the utility function\n            writer.writeVarIntNum(reqBody.length);\n            writer.write(reqBody);\n        }\n        else {\n            writer.writeVarIntNum(-1); // No body\n        }\n        return writer;\n    }\n    /**\n     * Handles a non-authenticated fetch requests and validates that the server is not claiming to be authenticated.\n     */\n    async handleFetchAndValidate(url, config, peerToUse) {\n        const response = await fetch(url, config);\n        response.headers.forEach(header => {\n            if (header.toLocaleLowerCase().startsWith('x-bsv')) {\n                throw new Error('The server is trying to claim it has been authenticated when it has not!');\n            }\n        });\n        if (response.ok) {\n            peerToUse.supportsMutualAuth = false;\n            return response;\n        }\n        else {\n            throw new Error(`Request failed with status: ${response.status}`);\n        }\n    }\n    /**\n     * If we get 402 Payment Required, we build a transaction via wallet.createAction()\n     * and re-attempt the request with an x-bsv-payment header.\n     */\n    async handlePaymentAndRetry(url, config = {}, originalResponse) {\n        // Make sure the server is using the correct payment version\n        const paymentVersion = originalResponse.headers.get('x-bsv-payment-version');\n        if (!paymentVersion || paymentVersion !== PAYMENT_VERSION) {\n            throw new Error(`Unsupported x-bsv-payment-version response header. Client version: ${PAYMENT_VERSION}, Server version: ${paymentVersion}`);\n        }\n        // Get required headers from the 402 response\n        const satoshisRequiredHeader = originalResponse.headers.get('x-bsv-payment-satoshis-required');\n        if (!satoshisRequiredHeader) {\n            throw new Error('Missing x-bsv-payment-satoshis-required response header.');\n        }\n        const satoshisRequired = parseInt(satoshisRequiredHeader);\n        if (isNaN(satoshisRequired) || satoshisRequired <= 0) {\n            throw new Error('Invalid x-bsv-payment-satoshis-required response header value.');\n        }\n        const serverIdentityKey = originalResponse.headers.get('x-bsv-auth-identity-key');\n        if (!serverIdentityKey) {\n            throw new Error('Missing x-bsv-auth-identity-key response header.');\n        }\n        const derivationPrefix = originalResponse.headers.get('x-bsv-payment-derivation-prefix');\n        if (typeof derivationPrefix !== 'string' || derivationPrefix.length < 1) {\n            throw new Error('Missing x-bsv-payment-derivation-prefix response header.');\n        }\n        // Create a random suffix for the derivation path\n        const derivationSuffix = await (0, createNonce_js_1.createNonce)(this.wallet);\n        // Derive the script hex from the server identity key\n        const { publicKey: derivedPublicKey } = await this.wallet.getPublicKey({\n            protocolID: [2, '3241645161d8'],\n            keyID: `${derivationPrefix} ${derivationSuffix}`,\n            counterparty: serverIdentityKey\n        });\n        const lockingScript = new P2PKH_js_1.default().lock(PublicKey_js_1.default.fromString(derivedPublicKey).toAddress()).toHex();\n        // Create the payment transaction using createAction\n        const { tx } = await this.wallet.createAction({\n            description: `Payment for request to ${new URL(url).origin}`,\n            outputs: [{\n                    satoshis: satoshisRequired,\n                    lockingScript,\n                    customInstructions: JSON.stringify({ derivationPrefix, derivationSuffix, payee: serverIdentityKey }),\n                    outputDescription: 'HTTP request payment'\n                }],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        // Attach the payment to the request headers\n        config.headers = config.headers || {};\n        config.headers['x-bsv-payment'] = JSON.stringify({\n            derivationPrefix,\n            derivationSuffix,\n            transaction: Utils.toBase64(tx)\n        });\n        config.retryCounter ?? (config.retryCounter = 3);\n        // Re-attempt request with payment attached\n        return this.fetch(url, config);\n    }\n    async normalizeBodyToNumberArray(body) {\n        // 0. Null / undefined\n        if (body == null) {\n            return [];\n        }\n        // 1. object\n        if (typeof body === 'object') {\n            return Utils.toArray(JSON.stringify(body, 'utf8'));\n        }\n        // 2. number[]\n        if (Array.isArray(body) && body.every((item) => typeof item === 'number')) {\n            return body; // Return the array as is\n        }\n        // 3. string\n        if (typeof body === 'string') {\n            return Utils.toArray(body, 'utf8');\n        }\n        // 4. ArrayBuffer / TypedArrays\n        if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n            const typedArray = body instanceof ArrayBuffer ? new Uint8Array(body) : new Uint8Array(body.buffer);\n            return Array.from(typedArray);\n        }\n        // 5. Blob\n        if (body instanceof Blob) {\n            const arrayBuffer = await body.arrayBuffer();\n            return Array.from(new Uint8Array(arrayBuffer));\n        }\n        // 6. FormData\n        if (body instanceof FormData) {\n            const entries = [];\n            body.forEach((value, key) => {\n                entries.push([key, value.toString()]);\n            });\n            const urlEncoded = new URLSearchParams(entries).toString();\n            return Utils.toArray(urlEncoded, 'utf8');\n        }\n        // 7. URLSearchParams\n        if (body instanceof URLSearchParams) {\n            return Utils.toArray(body.toString(), 'utf8');\n        }\n        // 8. ReadableStream\n        if (body instanceof ReadableStream) {\n            throw new Error('ReadableStream cannot be directly converted to number[].');\n        }\n        // 9. Fallback\n        throw new Error('Unsupported body type in this SimplifiedFetch implementation.');\n    }\n}\nexports.AuthFetch = AuthFetch;\n//# sourceMappingURL=AuthFetch.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/AuthFetch.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./AuthFetch.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/AuthFetch.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./certificates/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Peer.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/Peer.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SessionManager.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/SessionManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utils/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./clients/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./transports/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/SimplifiedFetchTransport.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/SimplifiedFetchTransport.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimplifiedFetchTransport = void 0;\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\n// Only bind window.fetch in the browser\nconst defaultFetch = typeof window !== 'undefined' ? fetch.bind(window) : fetch;\n/**\n * Implements an HTTP-specific transport for handling Peer mutual authentication messages.\n * This class integrates with fetch to send and receive authenticated messages between peers.\n */\nclass SimplifiedFetchTransport {\n    /**\n     * Constructs a new instance of SimplifiedFetchTransport.\n     * @param baseUrl - The base URL for all HTTP requests made by this transport.\n     * @param fetchClient - A fetch implementation to use for HTTP requests (default: global fetch).\n     */\n    constructor(baseUrl, fetchClient = defaultFetch) {\n        this.fetchClient = fetchClient;\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Sends a message to an HTTP server using the transport mechanism.\n     * Handles both general and authenticated message types. For general messages,\n     * the payload is deserialized and sent as an HTTP request. For other message types,\n     * the message is sent as a POST request to the `/auth` endpoint.\n     *\n     * @param message - The AuthMessage to send.\n     * @returns A promise that resolves when the message is successfully sent.\n     *\n     * @throws Will throw an error if no listener has been registered via `onData`.\n     */\n    async send(message) {\n        if (this.onDataCallback == null) {\n            throw new Error('Listen before you start speaking. God gave you two ears and one mouth for a reason.');\n        }\n        if (message.messageType !== 'general') {\n            return await new Promise((resolve, reject) => {\n                void (async () => {\n                    try {\n                        const responsePromise = this.fetchClient(`${this.baseUrl}/.well-known/auth`, {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify(message)\n                        });\n                        // For initialRequest message, mark connection as established and start pool.\n                        if (message.messageType !== 'initialRequest') {\n                            resolve();\n                        }\n                        const response = await responsePromise;\n                        // Handle the response if data is received and callback is set\n                        if (response.ok && (this.onDataCallback != null)) {\n                            const responseMessage = await response.json();\n                            this.onDataCallback(responseMessage);\n                        }\n                        else {\n                            // Server may be a non authenticated server\n                            throw new Error('HTTP server failed to authenticate');\n                        }\n                        if (message.messageType === 'initialRequest') {\n                            resolve();\n                        }\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                })();\n            });\n        }\n        else {\n            // Parse message payload\n            const httpRequest = this.deserializeRequestPayload(message.payload);\n            // Send the byte array as the HTTP payload\n            const url = `${this.baseUrl}${httpRequest.urlPostfix}`;\n            const httpRequestWithAuthHeaders = httpRequest;\n            if (typeof httpRequest.headers !== 'object') {\n                httpRequestWithAuthHeaders.headers = {};\n            }\n            // Append auth headers in request to server\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-version'] = message.version;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-identity-key'] = message.identityKey;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-nonce'] = message.nonce;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-your-nonce'] = message.yourNonce;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-signature'] = Utils.toHex(message.signature);\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-request-id'] = httpRequest.requestId;\n            // Ensure Content-Type is set for requests with a body\n            if (httpRequestWithAuthHeaders.body != null) {\n                const headers = httpRequestWithAuthHeaders.headers;\n                if (headers['content-type'] == null) {\n                    throw new Error('Content-Type header is required for requests with a body.');\n                }\n                const contentType = String(headers['content-type'] ?? '');\n                // Transform body based on Content-Type\n                if (contentType.includes('application/json')) {\n                    // Convert byte array to JSON string\n                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else if (contentType.includes('application/x-www-form-urlencoded')) {\n                    // Convert byte array to URL-encoded string\n                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else if (contentType.includes('text/plain')) {\n                    // Convert byte array to plain UTF-8 string\n                    httpRequestWithAuthHeaders.body = Utils.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else {\n                    // For all other content types, treat as binary data\n                    httpRequestWithAuthHeaders.body = new Uint8Array(httpRequestWithAuthHeaders.body);\n                }\n            }\n            // Send the actual fetch request to the server\n            const response = await this.fetchClient(url, {\n                method: httpRequestWithAuthHeaders.method,\n                headers: httpRequestWithAuthHeaders.headers,\n                body: httpRequestWithAuthHeaders.body\n            });\n            // Check for an acceptable status\n            if (response.status === 500 && (response.headers.get('x-bsv-auth-request-id') == null &&\n                response.headers.get('x-bsv-auth-requested-certificates') == null)) {\n                // Try parsing JSON error\n                const errorInfo = await response.json();\n                // Otherwise just throw whatever we got\n                throw new Error(`HTTP ${response.status} - ${JSON.stringify(errorInfo)}`);\n            }\n            const parsedBody = await response.arrayBuffer();\n            const payloadWriter = new Utils.Writer();\n            if (response.headers.get('x-bsv-auth-request-id') != null) {\n                payloadWriter.write(Utils.toArray(response.headers.get('x-bsv-auth-request-id'), 'base64'));\n            }\n            payloadWriter.writeVarIntNum(response.status);\n            // PARSE RESPONSE HEADERS FROM SERVER --------------------------------\n            // Parse response headers from the server and include only the signed headers:\n            // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)\n            // - Include the authorization header\n            const includedHeaders = [];\n            response.headers.forEach((value, key) => {\n                const lowerKey = key.toLowerCase();\n                if ((lowerKey.startsWith('x-bsv-') || lowerKey === 'authorization') && !lowerKey.startsWith('x-bsv-auth')) {\n                    includedHeaders.push([lowerKey, value]);\n                }\n            });\n            // Sort the headers by key to ensure a consistent order for signing and verification.\n            includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n            // nHeaders\n            payloadWriter.writeVarIntNum(includedHeaders.length);\n            for (let i = 0; i < includedHeaders.length; i++) {\n                // headerKeyLength\n                const headerKeyAsArray = Utils.toArray(includedHeaders[i][0], 'utf8');\n                payloadWriter.writeVarIntNum(headerKeyAsArray.length);\n                // headerKey\n                payloadWriter.write(headerKeyAsArray);\n                // headerValueLength\n                const headerValueAsArray = Utils.toArray(includedHeaders[i][1], 'utf8');\n                payloadWriter.writeVarIntNum(headerValueAsArray.length);\n                // headerValue\n                payloadWriter.write(headerValueAsArray);\n            }\n            // Handle body\n            if (parsedBody != null) {\n                const bodyAsArray = Array.from(new Uint8Array(parsedBody));\n                payloadWriter.writeVarIntNum(bodyAsArray.length);\n                payloadWriter.write(bodyAsArray);\n            }\n            else {\n                payloadWriter.writeVarIntNum(-1);\n            }\n            // Build the correct AuthMessage for the response\n            const responseMessage = {\n                version: response.headers.get('x-bsv-auth-version'),\n                messageType: response.headers.get('x-bsv-auth-message-type') === 'certificateRequest' ? 'certificateRequest' : 'general',\n                identityKey: response.headers.get('x-bsv-auth-identity-key'),\n                nonce: response.headers.get('x-bsv-auth-nonce'),\n                yourNonce: response.headers.get('x-bsv-auth-your-nonce'),\n                requestedCertificates: JSON.parse(response.headers.get('x-bsv-auth-requested-certificates')),\n                payload: payloadWriter.toArray(),\n                signature: Utils.toArray(response.headers.get('x-bsv-auth-signature'), 'hex')\n            };\n            // If the server didn't provide the correct authentication headers, throw an error\n            if (responseMessage.version == null) {\n                throw new Error('HTTP server failed to authenticate');\n            }\n            // Handle the response if data is received and callback is set\n            this.onDataCallback(responseMessage);\n        }\n    }\n    /**\n     * Registers a callback to handle incoming messages.\n     * This must be called before sending any messages to ensure responses can be processed.\n     *\n     * @param callback - A function to invoke when an incoming AuthMessage is received.\n     * @returns A promise that resolves once the callback is set.\n     */\n    async onData(callback) {\n        this.onDataCallback = (m) => {\n            void callback(m);\n        };\n    }\n    /**\n     * Deserializes a request payload from a byte array into an HTTP request-like structure.\n     *\n     * @param payload - The serialized payload to deserialize.\n     * @returns An object representing the deserialized request, including the method,\n     *          URL postfix (path and query string), headers, body, and request ID.\n     */\n    deserializeRequestPayload(payload) {\n        // Create a reader\n        const requestReader = new Utils.Reader(payload);\n        // The first 32 bytes is the requestId\n        const requestId = Utils.toBase64(requestReader.read(32));\n        // Method\n        const methodLength = requestReader.readVarIntNum();\n        let method = 'GET';\n        if (methodLength > 0) {\n            method = Utils.toUTF8(requestReader.read(methodLength));\n        }\n        // Path\n        const pathLength = requestReader.readVarIntNum();\n        let path = '';\n        if (pathLength > 0) {\n            path = Utils.toUTF8(requestReader.read(pathLength));\n        }\n        // Search\n        const searchLength = requestReader.readVarIntNum();\n        let search = '';\n        if (searchLength > 0) {\n            search = Utils.toUTF8(requestReader.read(searchLength));\n        }\n        // Read headers\n        const requestHeaders = {};\n        const nHeaders = requestReader.readVarIntNum();\n        if (nHeaders > 0) {\n            for (let i = 0; i < nHeaders; i++) {\n                const nHeaderKeyBytes = requestReader.readVarIntNum();\n                const headerKeyBytes = requestReader.read(nHeaderKeyBytes);\n                const headerKey = Utils.toUTF8(headerKeyBytes);\n                const nHeaderValueBytes = requestReader.readVarIntNum();\n                const headerValueBytes = requestReader.read(nHeaderValueBytes);\n                const headerValue = Utils.toUTF8(headerValueBytes);\n                requestHeaders[headerKey] = headerValue;\n            }\n        }\n        // Read body\n        let requestBody;\n        const requestBodyBytes = requestReader.readVarIntNum();\n        if (requestBodyBytes > 0) {\n            requestBody = requestReader.read(requestBodyBytes);\n        }\n        // Return the deserialized RequestInit\n        return {\n            urlPostfix: path + search,\n            method,\n            headers: requestHeaders,\n            body: requestBody,\n            requestId\n        };\n    }\n}\nexports.SimplifiedFetchTransport = SimplifiedFetchTransport;\n//# sourceMappingURL=SimplifiedFetchTransport.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/SimplifiedFetchTransport.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./SimplifiedFetchTransport.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/SimplifiedFetchTransport.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/transports/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/types.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/createNonce.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/createNonce.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createNonce = void 0;\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\n/**\n * Creates a nonce derived from a wallet\n * @param wallet\n * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.\n * @returns A random nonce derived with a wallet\n */\nasync function createNonce(wallet, counterparty = 'self') {\n    // Generate 16 random bytes for the first half of the data\n    const firstHalf = (0, Random_js_1.default)(16);\n    // Create an sha256 HMAC\n    const { hmac } = await wallet.createHmac({\n        protocolID: [2, 'server hmac'],\n        keyID: Utils.toUTF8(firstHalf),\n        data: firstHalf,\n        counterparty\n    });\n    // Concatenate firstHalf and secondHalf as the nonce bytes\n    const nonceBytes = [...firstHalf, ...hmac];\n    return Utils.toBase64(nonceBytes);\n}\nexports.createNonce = createNonce;\n//# sourceMappingURL=createNonce.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/createNonce.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/getVerifiableCertificates.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/getVerifiableCertificates.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getVerifiableCertificates = void 0;\nconst VerifiableCertificate_js_1 = __webpack_require__(/*! ../certificates/VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js\");\n/**\n * Retrieves an array of verifiable certificates based on the request.\n *\n * @private\n * @param {RequestedCertificateSet} requestedCertificates - The set of certificates requested by the peer.\n * @param {string} verifierIdentityKey - The public key of the verifier requesting the certificates.\n * @returns {Promise<VerifiableCertificate[]>} An array of verifiable certificates.\n */\nconst getVerifiableCertificates = async (wallet, requestedCertificates, verifierIdentityKey) => {\n    // Find matching certificates we have\n    // Note: This may return multiple certificates that match the correct type.\n    const matchingCertificates = await wallet.listCertificates({\n        certifiers: requestedCertificates.certifiers,\n        types: Object.keys(requestedCertificates.types)\n    });\n    // For each certificate requested, create a verifiable cert with selectively revealed fields\n    return await Promise.all(matchingCertificates.certificates.map(async (certificate) => {\n        const { keyringForVerifier } = await wallet.proveCertificate({\n            certificate,\n            fieldsToReveal: requestedCertificates.types[certificate.type],\n            verifier: verifierIdentityKey\n        });\n        return new VerifiableCertificate_js_1.VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);\n    }));\n};\nexports.getVerifiableCertificates = getVerifiableCertificates;\n//# sourceMappingURL=getVerifiableCertificates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/getVerifiableCertificates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./verifyNonce.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/verifyNonce.js\"), exports);\n__exportStar(__webpack_require__(/*! ./createNonce.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/createNonce.js\"), exports);\n__exportStar(__webpack_require__(/*! ./getVerifiableCertificates.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/getVerifiableCertificates.js\"), exports);\n__exportStar(__webpack_require__(/*! ./validateCertificates.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/validateCertificates.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/validateCertificates.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/validateCertificates.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateCertificates = void 0;\nconst VerifiableCertificate_js_1 = __webpack_require__(/*! ../certificates/VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/VerifiableCertificate.js\");\n/**\n * Validates and processes the certificates received from a peer.\n *\n * @private\n * @param {AuthMessage} message - The message containing the certificates to validate.\n * @returns {Promise<void>}\n * @throws Will throw an error if certificate validation or field decryption fails.\n */\nconst validateCertificates = async (verifierWallet, message, certificatesRequested) => {\n    if ((message.certificates == null) || message.certificates.length === 0) {\n        throw new Error('No certificates were provided in the AuthMessage.');\n    }\n    await Promise.all(message.certificates.map(async (incomingCert) => {\n        if (incomingCert.subject !== message.identityKey) {\n            throw new Error(`The subject of one of your certificates (\"${incomingCert.subject}\") is not the same as the request sender (\"${message.identityKey}\").`);\n        }\n        // Verify Certificate structure and signature\n        const certToVerify = new VerifiableCertificate_js_1.VerifiableCertificate(incomingCert.type, incomingCert.serialNumber, incomingCert.subject, incomingCert.certifier, incomingCert.revocationOutpoint, incomingCert.fields, incomingCert.keyring, incomingCert.signature);\n        const isValidCert = await certToVerify.verify();\n        if (!isValidCert) {\n            throw new Error(`The signature for the certificate with serial number ${certToVerify.serialNumber} is invalid!`);\n        }\n        // Check if the certificate matches requested certifiers, types, and fields\n        if (certificatesRequested != null) {\n            const { certifiers, types } = certificatesRequested;\n            // Check certifier matches\n            if (!certifiers.includes(certToVerify.certifier)) {\n                throw new Error(`Certificate with serial number ${certToVerify.serialNumber} has an unrequested certifier: ${certToVerify.certifier}`);\n            }\n            // Check type and fields match requested\n            const requestedFields = types[certToVerify.type];\n            if (requestedFields == null) { //  Explicitly check for null or undefined\n                throw new Error(`Certificate with type ${certToVerify.type} was not requested`);\n            }\n        }\n        // Attempt to decrypt fields\n        await certToVerify.decryptFields(verifierWallet);\n    }));\n};\nexports.validateCertificates = validateCertificates;\n//# sourceMappingURL=validateCertificates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/validateCertificates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/verifyNonce.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/verifyNonce.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verifyNonce = void 0;\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\n/**\n * Verifies a nonce derived from a wallet\n * @param nonce - A nonce to verify as a base64 string.\n * @param wallet\n * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.\n * @returns The status of the validation\n */\nasync function verifyNonce(nonce, wallet, counterparty = 'self') {\n    // Convert nonce from base64 string to Uint8Array\n    const buffer = Utils.toArray(nonce, 'base64');\n    // Split the nonce buffer\n    const data = buffer.slice(0, 16);\n    const hmac = buffer.slice(16);\n    // Calculate the HMAC\n    const { valid } = await wallet.verifyHmac({\n        data,\n        hmac,\n        protocolID: [2, 'server hmac'],\n        keyID: Utils.toUTF8(data),\n        counterparty\n    });\n    return valid;\n}\nexports.verifyNonce = verifyNonce;\n//# sourceMappingURL=verifyNonce.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/auth/utils/verifyNonce.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/BSM.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/BSM.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verify = exports.sign = exports.magicHash = void 0;\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst ECDSA = __importStar(__webpack_require__(/*! ../primitives/ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\"));\nconst Hash = __importStar(__webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst prefix = 'Bitcoin Signed Message:\\n';\n/**\n * Generates a SHA256 double-hash of the prefixed message.\n * @deprecated Replaced by BRC-77 which uses a more secure and private method for message signing.\n * @param messageBuf The message buffer to be hashed.\n * @returns The double-hash of the prefixed message as a number array.\n */\nconst magicHash = (messageBuf) => {\n    const bw = new utils_js_1.Writer();\n    bw.writeVarIntNum(prefix.length);\n    bw.write((0, utils_js_1.toArray)(prefix, 'utf8'));\n    bw.writeVarIntNum(messageBuf.length);\n    bw.write(messageBuf);\n    const buf = bw.toArray();\n    const hashBuf = Hash.hash256(buf);\n    return hashBuf;\n};\nexports.magicHash = magicHash;\n/**\n * Signs a BSM message using the given private key.\n * @deprecated Replaced by BRC-77 which employs BRC-42 key derivation and BRC-43 invoice numbers for enhanced security and privacy.\n * @param message The message to be signed as a number array.\n * @param privateKey The private key used for signing the message.\n * @param mode The mode of operation. When \"base64\", the BSM format signature is returned. When \"raw\", a Signature object is returned. Default: \"base64\".\n * @returns The signature object when in raw mode, or the BSM base64 string when in base64 mode.\n */\nconst sign = (message, privateKey, mode = 'base64') => {\n    const hashBuf = (0, exports.magicHash)(message);\n    const sig = ECDSA.sign(new BigNumber_js_1.default(hashBuf), privateKey, true);\n    if (mode === 'raw') {\n        return sig;\n    }\n    const h = new BigNumber_js_1.default(hashBuf);\n    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);\n    return sig.toCompact(r, true, 'base64');\n};\nexports.sign = sign;\n/**\n * Verifies a BSM signed message using the given public key.\n * @deprecated Replaced by BRC-77 which provides privately-verifiable signatures and avoids key reuse.\n * @param message The message to be verified as a number array.\n * @param sig The signature object.\n * @param pubKey The public key for verification.\n * @returns True if the signature is valid, false otherwise.\n */\nconst verify = (message, sig, pubKey) => {\n    const hashBuf = (0, exports.magicHash)(message);\n    return ECDSA.verify(new BigNumber_js_1.default(hashBuf), sig, pubKey);\n};\nexports.verify = verify;\n//# sourceMappingURL=BSM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/BSM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/ECIES.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/ECIES.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// import { AESWrappercbc } from './aescbc'\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst PrivateKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst Point_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\"));\nconst Hash = __importStar(__webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nfunction AES(key) {\n    if (this._tables[0][0][0] === 0)\n        this._precompute();\n    let tmp, encKey, decKey;\n    const sbox = this._tables[0][4];\n    const decTable = this._tables[1];\n    const keyLen = key.length;\n    let rcon = 1;\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n        throw new Error('invalid aes key size');\n    }\n    this._key = [(encKey = key.slice(0)), (decKey = [])];\n    // schedule encryption keys\n    let i;\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n        tmp = encKey[i - 1];\n        // apply sbox\n        if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {\n            tmp =\n                (sbox[tmp >>> 24] << 24) ^\n                    (sbox[(tmp >> 16) & 255] << 16) ^\n                    (sbox[(tmp >> 8) & 255] << 8) ^\n                    sbox[tmp & 255];\n            // shift rows and add rcon\n            if (i % keyLen === 0) {\n                tmp = (tmp << 8) ^ (tmp >>> 24) ^ (rcon << 24);\n                rcon = (rcon << 1) ^ ((rcon >> 7) * 283);\n            }\n        }\n        encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n    // schedule decryption keys\n    for (let j = 0; i > 0; j++, i--) {\n        tmp = encKey[(j & 3) !== 0 ? i : i - 4];\n        if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n        }\n        else {\n            decKey[j] =\n                decTable[0][sbox[tmp >>> 24]] ^\n                    decTable[1][sbox[(tmp >> 16) & 255]] ^\n                    decTable[2][sbox[(tmp >> 8) & 255]] ^\n                    decTable[3][sbox[tmp & 255]];\n        }\n    }\n}\nAES.prototype = {\n    /**\n     * Encrypt an array of 4 big-endian words.\n     * @param {Array} data The plaintext.\n     * @return {Array} The ciphertext.\n     */\n    encrypt: function (data) {\n        return this._crypt(data, 0);\n    },\n    /**\n     * Decrypt an array of 4 big-endian words.\n     * @param {Array} data The ciphertext.\n     * @return {Array} The plaintext.\n     */\n    decrypt: function (data) {\n        return this._crypt(data, 1);\n    },\n    /**\n     * The expanded S-box and inverse S-box tables.  These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    _tables: [\n        [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ],\n        [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ]\n    ],\n    // Expand the S-box tables.\n    _precompute: function () {\n        const encTable = this._tables[0];\n        const decTable = this._tables[1];\n        const sbox = encTable[4];\n        const sboxInv = decTable[4];\n        let i;\n        let x;\n        let xInv;\n        const d = new Uint8Array(256);\n        const th = new Uint8Array(256);\n        let x2;\n        let x4;\n        let x8;\n        let s;\n        let tEnc;\n        let tDec;\n        // Compute double and third tables\n        for (i = 0; i < 256; i++) {\n            th[(d[i] = (i << 1) ^ ((i >> 7) * 283)) ^ i] = i;\n        }\n        for (x = xInv = 0; sbox[x] === 0; x ^= (x2 !== 0 ? x2 : 1), xInv = th[xInv] !== 0 ? th[xInv] : 1) {\n            // Compute sbox\n            s = xInv ^ (xInv << 1) ^ (xInv << 2) ^ (xInv << 3) ^ (xInv << 4);\n            s = (s >> 8) ^ (s & 255) ^ 99;\n            sbox[x] = s;\n            sboxInv[s] = x;\n            // Compute MixColumns\n            x8 = d[(x4 = d[(x2 = d[x])])];\n            tDec = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n            tEnc = (d[s] * 0x101) ^ (s * 0x1010100);\n            for (i = 0; i < 4; i++) {\n                encTable[i][x] = tEnc = (tEnc << 24) ^ (tEnc >>> 8);\n                decTable[i][s] = tDec = (tDec << 24) ^ (tDec >>> 8);\n            }\n        }\n    },\n    /**\n     * Encryption and decryption core.\n     * @param {Array} input Four words to be encrypted or decrypted.\n     * @param dir The direction, 0 for encrypt and 1 for decrypt.\n     * @return {Array} The four encrypted or decrypted words.\n     * @private\n     */\n    _crypt: function (input, dir) {\n        if (input.length !== 4) {\n            throw new Error('invalid aes block size');\n        }\n        const key = this._key[dir];\n        // state variables a,b,c,d are loaded with pre-whitened data\n        let a = input[0] ^ key[0];\n        let b = input[dir === 1 ? 3 : 1] ^ key[1];\n        let c = input[2] ^ key[2];\n        let d = input[dir === 1 ? 1 : 3] ^ key[3];\n        let a2;\n        let b2;\n        let c2;\n        const nInnerRounds = key.length / 4 - 2;\n        let i;\n        let kIndex = 4;\n        const out = new Uint32Array(4);\n        const // <--- this is slower in Node, about the same in Chrome */\n        table = this._tables[dir];\n        // load up the tables\n        const t0 = table[0];\n        const t1 = table[1];\n        const t2 = table[2];\n        const t3 = table[3];\n        const sbox = table[4];\n        // Inner rounds.  Cribbed from OpenSSL.\n        for (i = 0; i < nInnerRounds; i++) {\n            a2 =\n                t0[a >>> 24] ^\n                    t1[(b >> 16) & 255] ^\n                    t2[(c >> 8) & 255] ^\n                    t3[d & 255] ^\n                    key[kIndex];\n            b2 =\n                t0[b >>> 24] ^\n                    t1[(c >> 16) & 255] ^\n                    t2[(d >> 8) & 255] ^\n                    t3[a & 255] ^\n                    key[kIndex + 1];\n            c2 =\n                t0[c >>> 24] ^\n                    t1[(d >> 16) & 255] ^\n                    t2[(a >> 8) & 255] ^\n                    t3[b & 255] ^\n                    key[kIndex + 2];\n            d =\n                t0[d >>> 24] ^\n                    t1[(a >> 16) & 255] ^\n                    t2[(b >> 8) & 255] ^\n                    t3[c & 255] ^\n                    key[kIndex + 3];\n            kIndex += 4;\n            a = a2;\n            b = b2;\n            c = c2;\n        }\n        // Last round.\n        for (i = 0; i < 4; i++) {\n            out[dir === 1 ? 3 & -i : i] =\n                (sbox[a >>> 24] << 24) ^\n                    (sbox[(b >> 16) & 255] << 16) ^\n                    (sbox[(c >> 8) & 255] << 8) ^\n                    sbox[d & 255] ^\n                    key[kIndex++];\n            a2 = a;\n            a = b;\n            b = c;\n            c = d;\n            d = a2;\n        }\n        return out;\n    }\n};\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass AESWrapper {\n    static encrypt(messageBuf, keyBuf) {\n        const key = AESWrapper.buf2Words(keyBuf);\n        const message = AESWrapper.buf2Words(messageBuf);\n        const a = new AES(key);\n        const enc = a.encrypt(message);\n        const encBuf = AESWrapper.words2Buf(enc);\n        return encBuf;\n    }\n    static decrypt(encBuf, keyBuf) {\n        const enc = AESWrapper.buf2Words(encBuf);\n        const key = AESWrapper.buf2Words(keyBuf);\n        const a = new AES(key);\n        const message = a.decrypt(enc);\n        const messageBuf = AESWrapper.words2Buf(message);\n        return messageBuf;\n    }\n    static buf2Words(buf) {\n        if (buf.length % 4 !== 0) {\n            throw new Error('buf length must be a multiple of 4');\n        }\n        const words = [];\n        for (let i = 0; i < buf.length / 4; i++) {\n            const val = buf[i * 4] * 0x1000000 + // Shift the first byte by 24 bits\n                ((buf[i * 4 + 1] << 16) | // Shift the second byte by 16 bits\n                    (buf[i * 4 + 2] << 8) | // Shift the third byte by 8 bits\n                    buf[i * 4 + 3]); // The fourth byte\n            words.push(val);\n        }\n        return words;\n    }\n    static words2Buf(words) {\n        const buf = new Array(words.length * 4);\n        for (let i = 0; i < words.length; i++) {\n            const word = words[i];\n            buf[i * 4] = (word >>> 24) & 0xff;\n            buf[i * 4 + 1] = (word >>> 16) & 0xff;\n            buf[i * 4 + 2] = (word >>> 8) & 0xff;\n            buf[i * 4 + 3] = word & 0xff;\n        }\n        return buf;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass CBC {\n    static buf2BlocksBuf(buf, blockSize) {\n        const bytesize = blockSize / 8;\n        const blockBufs = [];\n        for (let i = 0; i <= buf.length / bytesize; i++) {\n            let blockBuf = buf.slice(i * bytesize, i * bytesize + bytesize);\n            if (blockBuf.length < blockSize) {\n                blockBuf = CBC.pkcs7Pad(blockBuf, blockSize);\n            }\n            blockBufs.push(blockBuf);\n        }\n        return blockBufs;\n    }\n    static blockBufs2Buf(blockBufs) {\n        let last = blockBufs[blockBufs.length - 1];\n        last = CBC.pkcs7Unpad(last);\n        blockBufs[blockBufs.length - 1] = last;\n        const buf = blockBufs.flat();\n        return buf;\n    }\n    static encrypt(messageBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const blockSize = ivBuf.length * 8;\n        const blockBufs = CBC.buf2BlocksBuf(messageBuf, blockSize);\n        const encBufs = CBC.encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf);\n        const encBuf = encBufs.flat();\n        return encBuf;\n    }\n    static decrypt(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const bytesize = ivBuf.length;\n        const encBufs = [];\n        for (let i = 0; i < encBuf.length / bytesize; i++) {\n            encBufs.push(encBuf.slice(i * bytesize, i * bytesize + bytesize));\n        }\n        const blockBufs = CBC.decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf);\n        const buf = CBC.blockBufs2Buf(blockBufs);\n        return buf;\n    }\n    static encryptBlock(blockBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const xorbuf = CBC.xorBufs(blockBuf, ivBuf);\n        const encBuf = blockCipher.encrypt(xorbuf, cipherKeyBuf);\n        return encBuf;\n    }\n    static decryptBlock(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const xorbuf = blockCipher.decrypt(encBuf, cipherKeyBuf);\n        const blockBuf = CBC.xorBufs(xorbuf, ivBuf);\n        return blockBuf;\n    }\n    static encryptBlocks(blockBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const encBufs = [];\n        for (let i = 0; i < blockBufs.length; i++) {\n            const blockBuf = blockBufs[i];\n            const encBuf = CBC.encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf);\n            encBufs.push(encBuf);\n            ivBuf = encBuf;\n        }\n        return encBufs;\n    }\n    static decryptBlocks(encBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const blockBufs = [];\n        for (let i = 0; i < encBufs.length; i++) {\n            const encBuf = encBufs[i];\n            const blockBuf = CBC.decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf);\n            blockBufs.push(blockBuf);\n            ivBuf = encBuf;\n        }\n        return blockBufs;\n    }\n    static pkcs7Pad(buf, blockSize) {\n        const bytesize = blockSize / 8;\n        const padbytesize = bytesize - buf.length;\n        const pad = new Array(padbytesize);\n        pad.fill(padbytesize);\n        const paddedbuf = [...buf, ...pad];\n        return paddedbuf;\n    }\n    static pkcs7Unpad(paddedbuf) {\n        const padlength = paddedbuf[paddedbuf.length - 1];\n        const padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);\n        const padbuf2 = new Array(padlength);\n        padbuf2.fill(padlength);\n        if ((0, utils_js_1.toHex)(padbuf) !== (0, utils_js_1.toHex)(padbuf2)) {\n            throw new Error('invalid padding');\n        }\n        return paddedbuf.slice(0, paddedbuf.length - padlength);\n    }\n    static xorBufs(buf1, buf2) {\n        if (buf1.length !== buf2.length) {\n            throw new Error('bufs must have the same length');\n        }\n        const buf = new Array(buf1.length);\n        for (let i = 0; i < buf1.length; i++) {\n            buf[i] = buf1[i] ^ buf2[i];\n        }\n        return buf;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass AESCBC {\n    static encrypt(messageBuf, cipherKeyBuf, ivBuf, concatIvBuf = true) {\n        ivBuf = ivBuf ?? (0, Random_js_1.default)(128 / 8);\n        const ctBuf = CBC.encrypt(messageBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        if (concatIvBuf) {\n            return [...ivBuf, ...ctBuf];\n        }\n        else {\n            return [...ctBuf];\n        }\n    }\n    static decrypt(encBuf, cipherKeyBuf, ivBuf) {\n        if (ivBuf == null) {\n            ivBuf = encBuf.slice(0, 128 / 8);\n            const ctBuf = encBuf.slice(128 / 8);\n            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        }\n        else {\n            const ctBuf = encBuf;\n            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        }\n    }\n}\n/**\n * @class ECIES\n * Implements the Electrum ECIES protocol for encrypted communication.\n *\n * @prprecated This class is deprecated in favor of the BRC-78 standard for portable encrypted messages,\n * which provides a more comprehensive and secure solution by integrating with BRC-42 and BRC-43 standards.\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass ECIES {\n    /**\n     * Generates the initialization vector (iv), encryption key (kE), and MAC key (kM)\n     * using the sender's private key and receiver's public key.\n     *\n     * @param {PrivateKey} privKey - The sender's private key.\n     * @param {PublicKey} pubKey - The receiver's public key.\n     * @returns {Object} An object containing the iv, kE, and kM as number arrays.\n     */\n    static ivkEkM(privKey, pubKey) {\n        const r = privKey;\n        const KB = pubKey;\n        const P = KB.mul(r);\n        const S = new PublicKey_js_1.default(P.x, P.y);\n        const Sbuf = S.encode(true);\n        const hash = Hash.sha512(Sbuf);\n        return {\n            iv: hash.slice(0, 16),\n            kE: hash.slice(16, 32),\n            kM: hash.slice(32, 64)\n        };\n    }\n    /**\n     * Encrypts a given message using the Electrum ECIES method.\n     *\n     * @param {number[]} messageBuf - The message to be encrypted, in number array format.\n     * @param {PublicKey} toPublicKey - The public key of the recipient.\n     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.\n     * @param {boolean} [noKey=false] - If true, does not include the sender's public key in the encrypted message.\n     * @returns {number[]} The encrypted message as a number array.\n     */\n    static electrumEncrypt(messageBuf, toPublicKey, fromPrivateKey, noKey = false) {\n        let Rbuf = null;\n        if (fromPrivateKey == null) {\n            fromPrivateKey = PrivateKey_js_1.default.fromRandom();\n        }\n        if (!noKey) {\n            Rbuf = fromPrivateKey.toPublicKey().encode(true);\n        }\n        const { iv, kE, kM } = ECIES.ivkEkM(fromPrivateKey, toPublicKey);\n        const ciphertext = AESCBC.encrypt(messageBuf, kE, iv, false);\n        const BIE1 = (0, utils_js_1.toArray)('BIE1', 'utf8');\n        let encBuf;\n        if (Rbuf !== undefined && Rbuf !== null && Rbuf.length > 0) {\n            encBuf = [...BIE1, ...Rbuf, ...ciphertext];\n        }\n        else {\n            encBuf = [...BIE1, ...ciphertext];\n        }\n        const hmac = Hash.sha256hmac(kM, encBuf);\n        return [...encBuf, ...hmac];\n    }\n    /**\n     * Decrypts a message encrypted using the Electrum ECIES method.\n     *\n     * @param {number[]} encBuf - The encrypted message buffer.\n     * @param {PrivateKey} toPrivateKey - The private key of the recipient.\n     * @param {PublicKey} [fromPublicKey=null] - The public key of the sender. If not provided, it is extracted from the message.\n     * @returns {number[]} The decrypted message as a number array.\n     */\n    static electrumDecrypt(encBuf, toPrivateKey, fromPublicKey) {\n        const tagLength = 32;\n        const magic = encBuf.slice(0, 4);\n        if ((0, utils_js_1.encode)(magic, 'utf8') !== 'BIE1') {\n            throw new Error('Invalid Magic');\n        }\n        let offset = 4;\n        // Determine if the sender's public key is included in encBuf\n        let Rbuf = null;\n        if (encBuf.length - offset - tagLength >= 33) {\n            const firstByte = encBuf[offset];\n            if (firstByte === 0x02 || firstByte === 0x03) {\n                // Compressed public key\n                Rbuf = encBuf.slice(offset, offset + 33);\n                offset += 33;\n            }\n            else if (firstByte === 0x04) {\n                // Uncompressed public key\n                Rbuf = encBuf.slice(offset, offset + 65);\n                offset += 65;\n            }\n        }\n        if (Rbuf !== null) {\n            if (fromPublicKey == null) {\n                fromPublicKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(Rbuf));\n            }\n        }\n        else {\n            if (fromPublicKey == null) {\n                throw new Error('Sender public key is required');\n            }\n        }\n        const { iv, kE, kM } = ECIES.ivkEkM(toPrivateKey, fromPublicKey);\n        const ciphertext = encBuf.slice(offset, encBuf.length - tagLength);\n        const hmac = encBuf.slice(encBuf.length - tagLength, encBuf.length);\n        const hmac2 = Hash.sha256hmac(kM, encBuf.slice(0, encBuf.length - tagLength));\n        if ((0, utils_js_1.toHex)(hmac) !== (0, utils_js_1.toHex)(hmac2)) {\n            throw new Error('Invalid checksum');\n        }\n        return AESCBC.decrypt(ciphertext, kE, iv);\n    }\n    /**\n     * Encrypts a given message using the Bitcore variant of ECIES.\n     *\n     * @param {number[]} messageBuf - The message to be encrypted, in number array format.\n     * @param {PublicKey} toPublicKey - The public key of the recipient.\n     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.\n     * @param {number[]} [ivBuf] - The initialization vector for encryption. If not provided, a random IV is used.\n     * @returns {number[]} The encrypted message as a number array.\n     */\n    static bitcoreEncrypt(messageBuf, toPublicKey, fromPrivateKey, ivBuf) {\n        if (fromPrivateKey == null) {\n            fromPrivateKey = PrivateKey_js_1.default.fromRandom();\n        }\n        if (ivBuf == null) {\n            ivBuf = (0, Random_js_1.default)(16);\n        }\n        const r = fromPrivateKey;\n        const RPublicKey = fromPrivateKey.toPublicKey();\n        const RBuf = RPublicKey.encode(true);\n        const KB = toPublicKey;\n        const P = KB.mul(r);\n        const S = P.getX();\n        const Sbuf = S.toArray('be', 32);\n        const kEkM = Hash.sha512(Sbuf);\n        const kE = kEkM.slice(0, 32);\n        const kM = kEkM.slice(32, 64);\n        const c = AESCBC.encrypt(messageBuf, kE, ivBuf);\n        const d = Hash.sha256hmac(kM, [...c]);\n        const encBuf = [...RBuf, ...c, ...d];\n        return encBuf;\n    }\n    /**\n     * Decrypts a message encrypted using the Bitcore variant of ECIES.\n     *\n     * @param {number[]} encBuf - The encrypted message buffer.\n     * @param {PrivateKey} toPrivateKey - The private key of the recipient.\n     * @returns {number[]} The decrypted message as a number array.\n     */\n    static bitcoreDecrypt(encBuf, toPrivateKey) {\n        const kB = toPrivateKey;\n        const fromPublicKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(encBuf.slice(0, 33)));\n        const R = fromPublicKey;\n        const P = R.mul(kB);\n        if (P.eq(new Point_js_1.default(0, 0))) {\n            throw new Error('P equals 0');\n        }\n        const S = P.getX();\n        const Sbuf = S.toArray('be', 32);\n        const kEkM = Hash.sha512(Sbuf);\n        const kE = kEkM.slice(0, 32);\n        const kM = kEkM.slice(32, 64);\n        const c = encBuf.slice(33, encBuf.length - 32);\n        const d = encBuf.slice(encBuf.length - 32, encBuf.length);\n        const d2 = Hash.sha256hmac(kM, c);\n        if ((0, utils_js_1.toHex)(d) !== (0, utils_js_1.toHex)(d2)) {\n            throw new Error('Invalid checksum');\n        }\n        const messageBuf = AESCBC.decrypt(c, kE);\n        return [...messageBuf];\n    }\n}\nexports[\"default\"] = ECIES;\n//# sourceMappingURL=ECIES.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/ECIES.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/HD.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/HD.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// @ts-nocheck\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Hash = __importStar(__webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst PrivateKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\n/**\n * @deprecated\n * The HD class implements the Bitcoin Improvement Proposal 32 (BIP32) hierarchical deterministic wallets.\n * It allows the generation of child keys from a master key, ensuring a tree-like structure of keys and addresses.\n * This class is deprecated due to the introduction of BRC-42, which offers an enhanced key derivation scheme.\n * BRC-42 uses invoice numbers for key derivation, improving privacy and scalability compared to BIP32.\n *\n * @class HD\n * @deprecated Replaced by BRC-42 which uses invoice numbers and supports private derivation.\n */\nclass HD {\n    /**\n     * Constructor for the BIP32 HD wallet.\n     * Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.\n     * @param versionBytesNum - Version bytes number for the wallet.\n     * @param depth - Depth of the key in the hierarchy.\n     * @param parentFingerPrint - Fingerprint of the parent key.\n     * @param childIndex - Index of the child key.\n     * @param chainCode - Chain code for key derivation.\n     * @param privKey - Private key of the wallet.\n     * @param pubKey - Public key of the wallet.\n     */\n    constructor(versionBytesNum, depth, parentFingerPrint, childIndex, chainCode, privKey, pubKey) {\n        this.constants = {\n            pubKey: 0x0488b21e,\n            privKey: 0x0488ade4\n        };\n        this.versionBytesNum = versionBytesNum;\n        this.depth = depth;\n        this.parentFingerPrint = parentFingerPrint;\n        this.childIndex = childIndex;\n        this.chainCode = chainCode;\n        this.privKey = privKey;\n        this.pubKey = pubKey;\n    }\n    /**\n     * Generates a new HD wallet with random keys.\n     * This method creates a root HD wallet with randomly generated private and public keys.\n     * @returns {HD} The current HD instance with generated keys.\n     */\n    fromRandom() {\n        this.versionBytesNum = this.constants.privKey;\n        this.depth = 0x00;\n        this.parentFingerPrint = [0, 0, 0, 0];\n        this.childIndex = 0;\n        this.chainCode = (0, Random_js_1.default)(32);\n        this.privKey = PrivateKey_js_1.default.fromRandom();\n        this.pubKey = this.privKey.toPublicKey();\n        return this;\n    }\n    /**\n     * Generates a new HD wallet with random keys.\n     * This method creates a root HD wallet with randomly generated private and public keys.\n     * @returns {HD} A new HD instance with generated keys.\n     * @static\n     */\n    static fromRandom() {\n        return new this().fromRandom();\n    }\n    /**\n     * Initializes the HD wallet from a given base58 encoded string.\n     * This method decodes a provided string to set up the HD wallet's properties.\n     * @param str - A base58 encoded string representing the wallet.\n     * @returns {HD} The new instance with properties set from the string.\n     */\n    static fromString(str) {\n        return new this().fromString(str);\n    }\n    /**\n     * Initializes the HD wallet from a given base58 encoded string.\n     * This method decodes a provided string to set up the HD wallet's properties.\n     * @param str - A base58 encoded string representing the wallet.\n     * @returns {HD} The current instance with properties set from the string.\n     */\n    fromString(str) {\n        const decoded = (0, utils_js_1.fromBase58Check)(str);\n        return this.fromBinary([...decoded.prefix, ...decoded.data]);\n    }\n    /**\n     * Initializes the HD wallet from a seed.\n     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.\n     * @param bytes - An array of bytes representing the seed.\n     * @returns {HD} The current instance with properties set from the seed.\n     */\n    static fromSeed(bytes) {\n        return new this().fromSeed(bytes);\n    }\n    /**\n     * Initializes the HD wallet from a seed.\n     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.\n     * @param bytes - An array of bytes representing the seed.\n     * @returns {HD} The current instance with properties set from the seed.\n     */\n    fromSeed(bytes) {\n        if (bytes.length < 128 / 8) {\n            throw new Error('Need more than 128 bits of entropy');\n        }\n        if (bytes.length > 512 / 8) {\n            throw new Error('More than 512 bits of entropy is nonstandard');\n        }\n        const hash = Hash.sha512hmac((0, utils_js_1.toArray)('Bitcoin seed', 'utf8'), bytes);\n        this.depth = 0x00;\n        this.parentFingerPrint = [0, 0, 0, 0];\n        this.childIndex = 0;\n        this.chainCode = hash.slice(32, 64);\n        this.versionBytesNum = this.constants.privKey;\n        this.privKey = new PrivateKey_js_1.default(hash.slice(0, 32));\n        this.pubKey = this.privKey.toPublicKey();\n        return this;\n    }\n    /**\n     * Initializes the HD wallet from a binary buffer.\n     * Parses a binary buffer to set up the wallet's properties.\n     * @param buf - A buffer containing the wallet data.\n     * @returns {HD} The new instance with properties set from the buffer.\n     */\n    static fromBinary(buf) {\n        return new this().fromBinary(buf);\n    }\n    /**\n     * Initializes the HD wallet from a binary buffer.\n     * Parses a binary buffer to set up the wallet's properties.\n     * @param buf - A buffer containing the wallet data.\n     * @returns {HD} The current instance with properties set from the buffer.\n     */\n    fromBinary(buf) {\n        // Both pub and private extended keys are 78 buf\n        if (buf.length !== 78) {\n            throw new Error('incorrect bip32 data length');\n        }\n        const reader = new utils_js_1.Reader(buf);\n        this.versionBytesNum = reader.readUInt32BE();\n        this.depth = reader.readUInt8();\n        this.parentFingerPrint = reader.read(4);\n        this.childIndex = reader.readUInt32BE();\n        this.chainCode = reader.read(32);\n        const keyBytes = reader.read(33);\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        const isPublic = this.versionBytesNum === this.constants.pubKey;\n        if (isPrivate && keyBytes[0] === 0) {\n            this.privKey = new PrivateKey_js_1.default(keyBytes.slice(1, 33));\n            this.pubKey = this.privKey.toPublicKey();\n        }\n        else if (isPublic && (keyBytes[0] === 0x02 || keyBytes[0] === 0x03)) {\n            this.pubKey = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(keyBytes));\n        }\n        else {\n            throw new Error('Invalid key');\n        }\n        return this;\n    }\n    /**\n     * Converts the HD wallet to a base58 encoded string.\n     * This method provides a string representation of the HD wallet's current state.\n     * @returns {string} A base58 encoded string of the HD wallet.\n     */\n    toString() {\n        const bin = this.toBinary();\n        return (0, utils_js_1.toBase58Check)(bin, []);\n    }\n    /**\n     * Derives a child HD wallet based on a given path.\n     * The path specifies the hierarchy of the child key to be derived.\n     * @param path - A string representing the derivation path (e.g., 'm/0'/1).\n     * @returns {HD} A new HD instance representing the derived child wallet.\n     */\n    derive(path) {\n        if (path === 'm') {\n            return this;\n        }\n        const e = path.split('/');\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let bip32 = this;\n        for (const [i, c] of e.entries()) {\n            if (i === 0) { // Since `i` is now a number, compare it to 0\n                if (c !== 'm') {\n                    throw new Error('invalid path');\n                }\n                continue;\n            }\n            if (parseInt(c.replace(\"'\", ''), 10).toString() !== c.replace(\"'\", '')) {\n                throw new Error('invalid path');\n            }\n            const usePrivate = c.length > 1 && c[c.length - 1] === \"'\";\n            let childIndex = parseInt(usePrivate ? c.slice(0, c.length - 1) : c, 10) & 0x7fffffff;\n            if (usePrivate) {\n                childIndex += 0x80000000;\n            }\n            bip32 = bip32.deriveChild(childIndex);\n        }\n        return bip32;\n    }\n    /**\n     * Derives a child HD wallet from the current wallet based on an index.\n     * This method generates either a private or public child key depending on the current wallet's state.\n     * @param i - The index of the child key to derive.\n     * @returns {HD} A new HD instance representing the derived child wallet.\n     */\n    deriveChild(i) {\n        if (typeof i !== 'number') {\n            throw new Error('i must be a number');\n        }\n        const ibc = [];\n        ibc.push((i >> 24) & 0xff);\n        ibc.push((i >> 16) & 0xff);\n        ibc.push((i >> 8) & 0xff);\n        ibc.push(i & 0xff);\n        const ib = [...ibc];\n        const usePrivate = (i & 0x80000000) !== 0;\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        if (usePrivate && (this.privKey === null || this.privKey === undefined || !isPrivate)) {\n            throw new Error('Cannot do private key derivation without private key');\n        }\n        let ret = null;\n        if (this.privKey !== null && this.privKey !== undefined) {\n            let data = null;\n            if (usePrivate) {\n                data = [0, ...this.privKey.toArray('be', 32), ...ib];\n            }\n            else {\n                data = [...this.pubKey.encode(true), ...ib];\n            }\n            const hash = Hash.sha512hmac(this.chainCode, data);\n            const il = new BigNumber_js_1.default(hash.slice(0, 32));\n            const ir = hash.slice(32, 64);\n            // ki = IL + kpar (mod n).\n            const k = il.add(this.privKey).mod(new Curve_js_1.default().n);\n            ret = new HD();\n            ret.chainCode = ir;\n            ret.privKey = new PrivateKey_js_1.default(k.toArray());\n            ret.pubKey = ret.privKey.toPublicKey();\n        }\n        else {\n            const data = [...this.pubKey.encode(true), ...ib];\n            const hash = Hash.sha512hmac(this.chainCode, data);\n            const il = new BigNumber_js_1.default(hash.slice(0, 32));\n            const ir = hash.slice(32, 64);\n            // Ki = (IL + kpar)*G = IL*G + Kpar\n            const ilG = new Curve_js_1.default().g.mul(il);\n            const Kpar = this.pubKey;\n            const Ki = ilG.add(Kpar);\n            const newpub = new PublicKey_js_1.default(Ki.x, Ki.y);\n            ret = new HD();\n            ret.chainCode = ir;\n            ret.pubKey = newpub;\n        }\n        ret.childIndex = i;\n        const pubKeyhash = Hash.hash160(this.pubKey.encode(true));\n        ret.parentFingerPrint = pubKeyhash.slice(0, 4);\n        ret.versionBytesNum = this.versionBytesNum;\n        ret.depth = this.depth + 1;\n        return ret;\n    }\n    /**\n     * Converts the current HD wallet to a public-only wallet.\n     * This method strips away the private key information, leaving only the public part.\n     * @returns {HD} A new HD instance representing the public-only wallet.\n     */\n    toPublic() {\n        const bip32 = new HD(this.versionBytesNum, this.depth, this.parentFingerPrint, this.childIndex, this.chainCode, this.privKey, this.pubKey);\n        bip32.versionBytesNum = this.constants.pubKey;\n        bip32.privKey = undefined;\n        return bip32;\n    }\n    /**\n     * Converts the HD wallet into a binary representation.\n     * This method serializes the wallet's properties into a binary format.\n     * @returns {number[]} An array of numbers representing the binary data of the wallet.\n     */\n    toBinary() {\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        const isPublic = this.versionBytesNum === this.constants.pubKey;\n        if (isPrivate) {\n            return new utils_js_1.Writer()\n                .writeUInt32BE(this.versionBytesNum)\n                .writeUInt8(this.depth)\n                .write(this.parentFingerPrint)\n                .writeUInt32BE(this.childIndex)\n                .write(this.chainCode)\n                .writeUInt8(0)\n                .write(this.privKey.toArray('be', 32))\n                .toArray();\n        }\n        else if (isPublic) {\n            return new utils_js_1.Writer()\n                .writeUInt32BE(this.versionBytesNum)\n                .writeUInt8(this.depth)\n                .write(this.parentFingerPrint)\n                .writeUInt32BE(this.childIndex)\n                .write(this.chainCode)\n                .write(this.pubKey.encode(true))\n                .toArray();\n        }\n        else {\n            throw new Error('bip32: invalid versionBytesNum byte');\n        }\n    }\n    /**\n     * Checks if the HD wallet contains a private key.\n     * This method determines whether the wallet is a private key wallet or a public key only wallet.\n     * @returns {boolean} A boolean value indicating whether the wallet has a private key (true) or not (false).\n     */\n    isPrivate() {\n        return this.versionBytesNum === this.constants.privKey;\n    }\n}\nexports[\"default\"] = HD;\n//# sourceMappingURL=HD.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/HD.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/Mnemonic.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/Mnemonic.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst bip_39_wordlist_en_js_1 = __webpack_require__(/*! ./bip-39-wordlist-en.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/bip-39-wordlist-en.js\");\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Hash = __importStar(__webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\n/**\n * @class Mnemonic\n *\n * @description\n * Class representing Mnemonic functionality.\n * This class provides methods for generating, converting, and validating mnemonic phrases\n * according to the BIP39 standard. It supports creating mnemonics from random entropy,\n * converting mnemonics to seeds, and validating mnemonic phrases.\n */\nclass Mnemonic {\n    /**\n     * Constructs a Mnemonic object.\n     * @param {string} [mnemonic] - An optional mnemonic phrase.\n     * @param {number[]} [seed] - An optional seed derived from the mnemonic.\n     * @param {object} [wordlist=wordList] - An object containing a list of words and space character used in the mnemonic.\n     */\n    constructor(mnemonic, seed, wordlist = bip_39_wordlist_en_js_1.wordList) {\n        this.mnemonic = mnemonic ?? ''; // Default to empty string if undefined\n        this.seed = seed ?? []; // Default to empty array if undefined\n        this.Wordlist = wordlist;\n    }\n    /**\n     * Converts the mnemonic and seed into a binary representation.\n     * @returns {number[]} The binary representation of the mnemonic and seed.\n     */\n    toBinary() {\n        const bw = new utils_js_1.Writer();\n        if (this.mnemonic !== '') {\n            const buf = (0, utils_js_1.toArray)(this.mnemonic, 'utf8');\n            bw.writeVarIntNum(buf.length);\n            bw.write(buf);\n        }\n        else {\n            bw.writeVarIntNum(0);\n        }\n        if (this.seed.length > 0) {\n            bw.writeVarIntNum(this.seed.length);\n            bw.write(this.seed);\n        }\n        else {\n            bw.writeVarIntNum(0);\n        }\n        return bw.toArray();\n    }\n    /**\n     * Loads a mnemonic and seed from a binary representation.\n     * @param {number[]} bin - The binary representation of a mnemonic and seed.\n     * @returns {this} The Mnemonic instance with loaded mnemonic and seed.\n     */\n    fromBinary(bin) {\n        const br = new utils_js_1.Reader(bin);\n        const mnemoniclen = br.readVarIntNum();\n        if (mnemoniclen > 0) {\n            this.mnemonic = (0, utils_js_1.encode)(br.read(mnemoniclen), 'utf8');\n        }\n        const seedlen = br.readVarIntNum();\n        if (seedlen > 0) {\n            this.seed = br.read(seedlen);\n        }\n        return this;\n    }\n    /**\n     * Generates a random mnemonic from a given bit length.\n     * @param {number} [bits=128] - The bit length for the random mnemonic (must be a multiple of 32 and at least 128).\n     * @returns {this} The Mnemonic instance with the new random mnemonic.\n     * @throws {Error} If the bit length is not a multiple of 32 or is less than 128.\n     */\n    fromRandom(bits) {\n        if (bits === undefined || bits === null || isNaN(bits) || bits === 0) {\n            bits = 128;\n        }\n        if (bits % 32 !== 0) {\n            throw new Error('bits must be multiple of 32');\n        }\n        if (bits < 128) {\n            throw new Error('bits must be at least 128');\n        }\n        const buf = (0, Random_js_1.default)(bits / 8);\n        this.entropy2Mnemonic(buf);\n        this.mnemonic2Seed();\n        return this;\n    }\n    /**\n     * Static method to generate a Mnemonic instance with a random mnemonic.\n     * @param {number} [bits=128] - The bit length for the random mnemonic.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromRandom(bits) {\n        return new this().fromRandom(bits);\n    }\n    /**\n     * Converts given entropy into a mnemonic phrase.\n     * This method is used to generate a mnemonic from a specific entropy source.\n     * @param {number[]} buf - The entropy buffer, must be at least 128 bits.\n     * @returns {this} The Mnemonic instance with the mnemonic set from the given entropy.\n     * @throws {Error} If the entropy is less than 128 bits.\n     */\n    fromEntropy(buf) {\n        this.entropy2Mnemonic(buf);\n        return this;\n    }\n    /**\n     * Static method to create a Mnemonic instance from a given entropy.\n     * @param {number[]} buf - The entropy buffer.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromEntropy(buf) {\n        return new this().fromEntropy(buf);\n    }\n    /**\n     * Sets the mnemonic for the instance from a string.\n     * @param {string} mnemonic - The mnemonic phrase as a string.\n     * @returns {this} The Mnemonic instance with the set mnemonic.\n     */\n    fromString(mnemonic) {\n        this.mnemonic = mnemonic;\n        return this;\n    }\n    /**\n     * Static method to create a Mnemonic instance from a mnemonic string.\n     * @param {string} str - The mnemonic phrase.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromString(str) {\n        return new this().fromString(str);\n    }\n    /**\n     * Converts the instance's mnemonic to a string representation.\n     * @returns {string} The mnemonic phrase as a string.\n     */\n    toString() {\n        return this.mnemonic;\n    }\n    /**\n     * Converts the mnemonic to a seed.\n     * The mnemonic must pass the validity check before conversion.\n     * @param {string} [passphrase=''] - An optional passphrase for additional security.\n     * @returns {number[]} The generated seed.\n     * @throws {Error} If the mnemonic is invalid.\n     */\n    toSeed(passphrase) {\n        this.mnemonic2Seed(passphrase);\n        return this.seed;\n    }\n    /**\n     * Converts entropy to a mnemonic phrase.\n     * This method takes a buffer of entropy and converts it into a corresponding\n     * mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits.\n     * The method applies a checksum and maps the entropy to words in the wordlist.\n     * @param {number[]} buf - The entropy buffer to convert. Must be at least 128 bits.\n     * @returns {this} The Mnemonic instance with the mnemonic set from the entropy.\n     * @throws {Error} If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.\n     */\n    entropy2Mnemonic(buf) {\n        if (buf.length < 128 / 8) {\n            throw new Error('Entropy is less than 128 bits. It must be 128 bits or more.');\n        }\n        const hash = Hash.sha256(buf);\n        let bin = '';\n        const bits = buf.length * 8;\n        for (let i = 0; i < buf.length; i++) {\n            bin = bin + ('00000000' + buf[i].toString(2)).slice(-8);\n        }\n        let hashbits = hash[0].toString(2);\n        hashbits = ('00000000' + hashbits).slice(-8).slice(0, bits / 32);\n        bin = bin + hashbits;\n        if (bin.length % 11 !== 0) {\n            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +\n                bin.length.toString());\n        }\n        let mnemonic = '';\n        for (let i = 0; i < bin.length / 11; i++) {\n            if (mnemonic !== '') {\n                mnemonic = mnemonic + this.Wordlist.space;\n            }\n            const wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n            mnemonic = mnemonic + this.Wordlist.value[wi];\n        }\n        this.mnemonic = mnemonic;\n        return this;\n    }\n    /**\n     * Validates the mnemonic phrase.\n     * Checks for correct length, absence of invalid words, and proper checksum.\n     * @returns {boolean} True if the mnemonic is valid, false otherwise.\n     * @throws {Error} If the mnemonic is not an even multiple of 11 bits.\n     */\n    check() {\n        const mnemonic = this.mnemonic;\n        // confirm no invalid words\n        const words = mnemonic.split(this.Wordlist.space);\n        let bin = '';\n        for (let i = 0; i < words.length; i++) {\n            const ind = this.Wordlist.value.indexOf(words[i]);\n            if (ind < 0) {\n                return false;\n            }\n            bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n        }\n        if (bin.length % 11 !== 0) {\n            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +\n                bin.length.toString());\n        }\n        // confirm checksum\n        const cs = bin.length / 33;\n        const hashBits = bin.slice(-cs);\n        const nonhashBits = bin.slice(0, bin.length - cs);\n        const buf = [];\n        for (let i = 0; i < nonhashBits.length / 8; i++) {\n            buf.push(parseInt(bin.slice(i * 8, (i + 1) * 8), 2));\n        }\n        const hash = Hash.sha256(buf.slice(0, nonhashBits.length / 8));\n        let expectedHashBits = hash[0].toString(2);\n        expectedHashBits = ('00000000' + expectedHashBits).slice(-8).slice(0, cs);\n        return expectedHashBits === hashBits;\n    }\n    /**\n     * Converts a mnemonic to a seed.\n     * This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided),\n     * and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion.\n     * This seed can then be used for generating deterministic keys.\n     * @param {string} [passphrase=''] - An optional passphrase for added security.\n     * @returns {this} The Mnemonic instance with the seed generated from the mnemonic.\n     * @throws {Error} If the mnemonic does not pass validation or if the passphrase is not a string.\n     */\n    mnemonic2Seed(passphrase = '') {\n        let mnemonic = this.mnemonic;\n        if (!this.check()) {\n            throw new Error('Mnemonic does not pass the check - was the mnemonic typed incorrectly? Are there extra spaces?');\n        }\n        if (typeof passphrase !== 'string') {\n            throw new Error('passphrase must be a string or undefined');\n        }\n        mnemonic = mnemonic.normalize('NFKD');\n        passphrase = passphrase.normalize('NFKD');\n        const mbuf = (0, utils_js_1.toArray)(mnemonic, 'utf8');\n        const pbuf = [\n            ...(0, utils_js_1.toArray)('mnemonic', 'utf8'),\n            ...(0, utils_js_1.toArray)(passphrase, 'utf8')\n        ];\n        this.seed = Hash.pbkdf2(mbuf, pbuf, 2048, 64, 'sha512');\n        return this;\n    }\n    /**\n     * Determines the validity of a given passphrase with the mnemonic.\n     * This method is useful for checking if a passphrase matches with the mnemonic.\n     * @param {string} [passphrase=''] - The passphrase to validate.\n     * @returns {boolean} True if the mnemonic and passphrase combination is valid, false otherwise.\n     */\n    isValid(passphrase = '') {\n        let isValid;\n        try {\n            this.mnemonic2Seed(passphrase);\n            isValid = true;\n        }\n        catch {\n            isValid = false;\n        }\n        return isValid;\n    }\n    /**\n     * Static method to check the validity of a given mnemonic and passphrase combination.\n     * @param {string} mnemonic - The mnemonic phrase.\n     * @param {string} [passphrase=''] - The passphrase to validate.\n     * @returns {boolean} True if the combination is valid, false otherwise.\n     */\n    static isValid(mnemonic, passphrase = '') {\n        return new Mnemonic(mnemonic).isValid(passphrase);\n    }\n}\nexports[\"default\"] = Mnemonic;\n//# sourceMappingURL=Mnemonic.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/Mnemonic.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/Utxo.js":
/*!***********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/Utxo.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Transaction_js_1 = __importDefault(__webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js\"));\nconst LockingScript_js_1 = __importDefault(__webpack_require__(/*! ../script/LockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js\"));\n/**\n * @method fromUtxo\n *\n * @description\n * This function creates a transaction input from a utxo json object\n * The idea being old code that uses utxos rather than sourceTranactions can convert using this.\n *\n * @deprecated\n * This approach is made available for compatibility only. It is deprecated in favor of using sourceTransactions\n * directly. It's recommended that wallets general keep transactions which store unspent outputs in their entirety,\n * along with corresonding Merkle paths. The reason you would keep the whole transaction is such that you can prove\n * the txid, and therefore its inclusion within a specific block.\n *\n * @example\n * const i = fromUtxo({\n *   txid: '434555433eaca96dff6e71a4d02febd0dd3832e5ca4e5734623ca914522e17d5',\n *   vout: 0,\n *   script: '51',\n *   satoshis: 1234\n * }, new P2PKH().unlock(p))\n *\n * tx.addInput(i)\n *\n * @param utxo: jsonUtxo\n * @param unlockingScriptTemplate: { sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>, estimateLength: (tx: Transaction, inputIndex: number) => Promise<number> }\n * @returns\n */\nfunction fromUtxo(utxo, unlockingScriptTemplate) {\n    const sourceTransaction = new Transaction_js_1.default(0, [], [], 0);\n    sourceTransaction.outputs = Array(utxo.vout + 1).fill(null);\n    sourceTransaction.outputs[utxo.vout] = {\n        satoshis: utxo.satoshis,\n        lockingScript: LockingScript_js_1.default.fromHex(utxo.script)\n    };\n    return {\n        sourceTransaction,\n        sourceTXID: utxo.txid,\n        sourceOutputIndex: utxo.vout,\n        unlockingScriptTemplate,\n        sequence: 0xffffffff\n    };\n}\nexports[\"default\"] = fromUtxo;\n//# sourceMappingURL=Utxo.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/Utxo.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/bip-39-wordlist-en.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/bip-39-wordlist-en.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wordList = void 0;\nexports.wordList = {\n    value: [\n        'abandon',\n        'ability',\n        'able',\n        'about',\n        'above',\n        'absent',\n        'absorb',\n        'abstract',\n        'absurd',\n        'abuse',\n        'access',\n        'accident',\n        'account',\n        'accuse',\n        'achieve',\n        'acid',\n        'acoustic',\n        'acquire',\n        'across',\n        'act',\n        'action',\n        'actor',\n        'actress',\n        'actual',\n        'adapt',\n        'add',\n        'addict',\n        'address',\n        'adjust',\n        'admit',\n        'adult',\n        'advance',\n        'advice',\n        'aerobic',\n        'affair',\n        'afford',\n        'afraid',\n        'again',\n        'age',\n        'agent',\n        'agree',\n        'ahead',\n        'aim',\n        'air',\n        'airport',\n        'aisle',\n        'alarm',\n        'album',\n        'alcohol',\n        'alert',\n        'alien',\n        'all',\n        'alley',\n        'allow',\n        'almost',\n        'alone',\n        'alpha',\n        'already',\n        'also',\n        'alter',\n        'always',\n        'amateur',\n        'amazing',\n        'among',\n        'amount',\n        'amused',\n        'analyst',\n        'anchor',\n        'ancient',\n        'anger',\n        'angle',\n        'angry',\n        'animal',\n        'ankle',\n        'announce',\n        'annual',\n        'another',\n        'answer',\n        'antenna',\n        'antique',\n        'anxiety',\n        'any',\n        'apart',\n        'apology',\n        'appear',\n        'apple',\n        'approve',\n        'april',\n        'arch',\n        'arctic',\n        'area',\n        'arena',\n        'argue',\n        'arm',\n        'armed',\n        'armor',\n        'army',\n        'around',\n        'arrange',\n        'arrest',\n        'arrive',\n        'arrow',\n        'art',\n        'artefact',\n        'artist',\n        'artwork',\n        'ask',\n        'aspect',\n        'assault',\n        'asset',\n        'assist',\n        'assume',\n        'asthma',\n        'athlete',\n        'atom',\n        'attack',\n        'attend',\n        'attitude',\n        'attract',\n        'auction',\n        'audit',\n        'august',\n        'aunt',\n        'author',\n        'auto',\n        'autumn',\n        'average',\n        'avocado',\n        'avoid',\n        'awake',\n        'aware',\n        'away',\n        'awesome',\n        'awful',\n        'awkward',\n        'axis',\n        'baby',\n        'bachelor',\n        'bacon',\n        'badge',\n        'bag',\n        'balance',\n        'balcony',\n        'ball',\n        'bamboo',\n        'banana',\n        'banner',\n        'bar',\n        'barely',\n        'bargain',\n        'barrel',\n        'base',\n        'basic',\n        'basket',\n        'battle',\n        'beach',\n        'bean',\n        'beauty',\n        'because',\n        'become',\n        'beef',\n        'before',\n        'begin',\n        'behave',\n        'behind',\n        'believe',\n        'below',\n        'belt',\n        'bench',\n        'benefit',\n        'best',\n        'betray',\n        'better',\n        'between',\n        'beyond',\n        'bicycle',\n        'bid',\n        'bike',\n        'bind',\n        'biology',\n        'bird',\n        'birth',\n        'bitter',\n        'black',\n        'blade',\n        'blame',\n        'blanket',\n        'blast',\n        'bleak',\n        'bless',\n        'blind',\n        'blood',\n        'blossom',\n        'blouse',\n        'blue',\n        'blur',\n        'blush',\n        'board',\n        'boat',\n        'body',\n        'boil',\n        'bomb',\n        'bone',\n        'bonus',\n        'book',\n        'boost',\n        'border',\n        'boring',\n        'borrow',\n        'boss',\n        'bottom',\n        'bounce',\n        'box',\n        'boy',\n        'bracket',\n        'brain',\n        'brand',\n        'brass',\n        'brave',\n        'bread',\n        'breeze',\n        'brick',\n        'bridge',\n        'brief',\n        'bright',\n        'bring',\n        'brisk',\n        'broccoli',\n        'broken',\n        'bronze',\n        'broom',\n        'brother',\n        'brown',\n        'brush',\n        'bubble',\n        'buddy',\n        'budget',\n        'buffalo',\n        'build',\n        'bulb',\n        'bulk',\n        'bullet',\n        'bundle',\n        'bunker',\n        'burden',\n        'burger',\n        'burst',\n        'bus',\n        'business',\n        'busy',\n        'butter',\n        'buyer',\n        'buzz',\n        'cabbage',\n        'cabin',\n        'cable',\n        'cactus',\n        'cage',\n        'cake',\n        'call',\n        'calm',\n        'camera',\n        'camp',\n        'can',\n        'canal',\n        'cancel',\n        'candy',\n        'cannon',\n        'canoe',\n        'canvas',\n        'canyon',\n        'capable',\n        'capital',\n        'captain',\n        'car',\n        'carbon',\n        'card',\n        'cargo',\n        'carpet',\n        'carry',\n        'cart',\n        'case',\n        'cash',\n        'casino',\n        'castle',\n        'casual',\n        'cat',\n        'catalog',\n        'catch',\n        'category',\n        'cattle',\n        'caught',\n        'cause',\n        'caution',\n        'cave',\n        'ceiling',\n        'celery',\n        'cement',\n        'census',\n        'century',\n        'cereal',\n        'certain',\n        'chair',\n        'chalk',\n        'champion',\n        'change',\n        'chaos',\n        'chapter',\n        'charge',\n        'chase',\n        'chat',\n        'cheap',\n        'check',\n        'cheese',\n        'chef',\n        'cherry',\n        'chest',\n        'chicken',\n        'chief',\n        'child',\n        'chimney',\n        'choice',\n        'choose',\n        'chronic',\n        'chuckle',\n        'chunk',\n        'churn',\n        'cigar',\n        'cinnamon',\n        'circle',\n        'citizen',\n        'city',\n        'civil',\n        'claim',\n        'clap',\n        'clarify',\n        'claw',\n        'clay',\n        'clean',\n        'clerk',\n        'clever',\n        'click',\n        'client',\n        'cliff',\n        'climb',\n        'clinic',\n        'clip',\n        'clock',\n        'clog',\n        'close',\n        'cloth',\n        'cloud',\n        'clown',\n        'club',\n        'clump',\n        'cluster',\n        'clutch',\n        'coach',\n        'coast',\n        'coconut',\n        'code',\n        'coffee',\n        'coil',\n        'coin',\n        'collect',\n        'color',\n        'column',\n        'combine',\n        'come',\n        'comfort',\n        'comic',\n        'common',\n        'company',\n        'concert',\n        'conduct',\n        'confirm',\n        'congress',\n        'connect',\n        'consider',\n        'control',\n        'convince',\n        'cook',\n        'cool',\n        'copper',\n        'copy',\n        'coral',\n        'core',\n        'corn',\n        'correct',\n        'cost',\n        'cotton',\n        'couch',\n        'country',\n        'couple',\n        'course',\n        'cousin',\n        'cover',\n        'coyote',\n        'crack',\n        'cradle',\n        'craft',\n        'cram',\n        'crane',\n        'crash',\n        'crater',\n        'crawl',\n        'crazy',\n        'cream',\n        'credit',\n        'creek',\n        'crew',\n        'cricket',\n        'crime',\n        'crisp',\n        'critic',\n        'crop',\n        'cross',\n        'crouch',\n        'crowd',\n        'crucial',\n        'cruel',\n        'cruise',\n        'crumble',\n        'crunch',\n        'crush',\n        'cry',\n        'crystal',\n        'cube',\n        'culture',\n        'cup',\n        'cupboard',\n        'curious',\n        'current',\n        'curtain',\n        'curve',\n        'cushion',\n        'custom',\n        'cute',\n        'cycle',\n        'dad',\n        'damage',\n        'damp',\n        'dance',\n        'danger',\n        'daring',\n        'dash',\n        'daughter',\n        'dawn',\n        'day',\n        'deal',\n        'debate',\n        'debris',\n        'decade',\n        'december',\n        'decide',\n        'decline',\n        'decorate',\n        'decrease',\n        'deer',\n        'defense',\n        'define',\n        'defy',\n        'degree',\n        'delay',\n        'deliver',\n        'demand',\n        'demise',\n        'denial',\n        'dentist',\n        'deny',\n        'depart',\n        'depend',\n        'deposit',\n        'depth',\n        'deputy',\n        'derive',\n        'describe',\n        'desert',\n        'design',\n        'desk',\n        'despair',\n        'destroy',\n        'detail',\n        'detect',\n        'develop',\n        'device',\n        'devote',\n        'diagram',\n        'dial',\n        'diamond',\n        'diary',\n        'dice',\n        'diesel',\n        'diet',\n        'differ',\n        'digital',\n        'dignity',\n        'dilemma',\n        'dinner',\n        'dinosaur',\n        'direct',\n        'dirt',\n        'disagree',\n        'discover',\n        'disease',\n        'dish',\n        'dismiss',\n        'disorder',\n        'display',\n        'distance',\n        'divert',\n        'divide',\n        'divorce',\n        'dizzy',\n        'doctor',\n        'document',\n        'dog',\n        'doll',\n        'dolphin',\n        'domain',\n        'donate',\n        'donkey',\n        'donor',\n        'door',\n        'dose',\n        'double',\n        'dove',\n        'draft',\n        'dragon',\n        'drama',\n        'drastic',\n        'draw',\n        'dream',\n        'dress',\n        'drift',\n        'drill',\n        'drink',\n        'drip',\n        'drive',\n        'drop',\n        'drum',\n        'dry',\n        'duck',\n        'dumb',\n        'dune',\n        'during',\n        'dust',\n        'dutch',\n        'duty',\n        'dwarf',\n        'dynamic',\n        'eager',\n        'eagle',\n        'early',\n        'earn',\n        'earth',\n        'easily',\n        'east',\n        'easy',\n        'echo',\n        'ecology',\n        'economy',\n        'edge',\n        'edit',\n        'educate',\n        'effort',\n        'egg',\n        'eight',\n        'either',\n        'elbow',\n        'elder',\n        'electric',\n        'elegant',\n        'element',\n        'elephant',\n        'elevator',\n        'elite',\n        'else',\n        'embark',\n        'embody',\n        'embrace',\n        'emerge',\n        'emotion',\n        'employ',\n        'empower',\n        'empty',\n        'enable',\n        'enact',\n        'end',\n        'endless',\n        'endorse',\n        'enemy',\n        'energy',\n        'enforce',\n        'engage',\n        'engine',\n        'enhance',\n        'enjoy',\n        'enlist',\n        'enough',\n        'enrich',\n        'enroll',\n        'ensure',\n        'enter',\n        'entire',\n        'entry',\n        'envelope',\n        'episode',\n        'equal',\n        'equip',\n        'era',\n        'erase',\n        'erode',\n        'erosion',\n        'error',\n        'erupt',\n        'escape',\n        'essay',\n        'essence',\n        'estate',\n        'eternal',\n        'ethics',\n        'evidence',\n        'evil',\n        'evoke',\n        'evolve',\n        'exact',\n        'example',\n        'excess',\n        'exchange',\n        'excite',\n        'exclude',\n        'excuse',\n        'execute',\n        'exercise',\n        'exhaust',\n        'exhibit',\n        'exile',\n        'exist',\n        'exit',\n        'exotic',\n        'expand',\n        'expect',\n        'expire',\n        'explain',\n        'expose',\n        'express',\n        'extend',\n        'extra',\n        'eye',\n        'eyebrow',\n        'fabric',\n        'face',\n        'faculty',\n        'fade',\n        'faint',\n        'faith',\n        'fall',\n        'false',\n        'fame',\n        'family',\n        'famous',\n        'fan',\n        'fancy',\n        'fantasy',\n        'farm',\n        'fashion',\n        'fat',\n        'fatal',\n        'father',\n        'fatigue',\n        'fault',\n        'favorite',\n        'feature',\n        'february',\n        'federal',\n        'fee',\n        'feed',\n        'feel',\n        'female',\n        'fence',\n        'festival',\n        'fetch',\n        'fever',\n        'few',\n        'fiber',\n        'fiction',\n        'field',\n        'figure',\n        'file',\n        'film',\n        'filter',\n        'final',\n        'find',\n        'fine',\n        'finger',\n        'finish',\n        'fire',\n        'firm',\n        'first',\n        'fiscal',\n        'fish',\n        'fit',\n        'fitness',\n        'fix',\n        'flag',\n        'flame',\n        'flash',\n        'flat',\n        'flavor',\n        'flee',\n        'flight',\n        'flip',\n        'float',\n        'flock',\n        'floor',\n        'flower',\n        'fluid',\n        'flush',\n        'fly',\n        'foam',\n        'focus',\n        'fog',\n        'foil',\n        'fold',\n        'follow',\n        'food',\n        'foot',\n        'force',\n        'forest',\n        'forget',\n        'fork',\n        'fortune',\n        'forum',\n        'forward',\n        'fossil',\n        'foster',\n        'found',\n        'fox',\n        'fragile',\n        'frame',\n        'frequent',\n        'fresh',\n        'friend',\n        'fringe',\n        'frog',\n        'front',\n        'frost',\n        'frown',\n        'frozen',\n        'fruit',\n        'fuel',\n        'fun',\n        'funny',\n        'furnace',\n        'fury',\n        'future',\n        'gadget',\n        'gain',\n        'galaxy',\n        'gallery',\n        'game',\n        'gap',\n        'garage',\n        'garbage',\n        'garden',\n        'garlic',\n        'garment',\n        'gas',\n        'gasp',\n        'gate',\n        'gather',\n        'gauge',\n        'gaze',\n        'general',\n        'genius',\n        'genre',\n        'gentle',\n        'genuine',\n        'gesture',\n        'ghost',\n        'giant',\n        'gift',\n        'giggle',\n        'ginger',\n        'giraffe',\n        'girl',\n        'give',\n        'glad',\n        'glance',\n        'glare',\n        'glass',\n        'glide',\n        'glimpse',\n        'globe',\n        'gloom',\n        'glory',\n        'glove',\n        'glow',\n        'glue',\n        'goat',\n        'goddess',\n        'gold',\n        'good',\n        'goose',\n        'gorilla',\n        'gospel',\n        'gossip',\n        'govern',\n        'gown',\n        'grab',\n        'grace',\n        'grain',\n        'grant',\n        'grape',\n        'grass',\n        'gravity',\n        'great',\n        'green',\n        'grid',\n        'grief',\n        'grit',\n        'grocery',\n        'group',\n        'grow',\n        'grunt',\n        'guard',\n        'guess',\n        'guide',\n        'guilt',\n        'guitar',\n        'gun',\n        'gym',\n        'habit',\n        'hair',\n        'half',\n        'hammer',\n        'hamster',\n        'hand',\n        'happy',\n        'harbor',\n        'hard',\n        'harsh',\n        'harvest',\n        'hat',\n        'have',\n        'hawk',\n        'hazard',\n        'head',\n        'health',\n        'heart',\n        'heavy',\n        'hedgehog',\n        'height',\n        'hello',\n        'helmet',\n        'help',\n        'hen',\n        'hero',\n        'hidden',\n        'high',\n        'hill',\n        'hint',\n        'hip',\n        'hire',\n        'history',\n        'hobby',\n        'hockey',\n        'hold',\n        'hole',\n        'holiday',\n        'hollow',\n        'home',\n        'honey',\n        'hood',\n        'hope',\n        'horn',\n        'horror',\n        'horse',\n        'hospital',\n        'host',\n        'hotel',\n        'hour',\n        'hover',\n        'hub',\n        'huge',\n        'human',\n        'humble',\n        'humor',\n        'hundred',\n        'hungry',\n        'hunt',\n        'hurdle',\n        'hurry',\n        'hurt',\n        'husband',\n        'hybrid',\n        'ice',\n        'icon',\n        'idea',\n        'identify',\n        'idle',\n        'ignore',\n        'ill',\n        'illegal',\n        'illness',\n        'image',\n        'imitate',\n        'immense',\n        'immune',\n        'impact',\n        'impose',\n        'improve',\n        'impulse',\n        'inch',\n        'include',\n        'income',\n        'increase',\n        'index',\n        'indicate',\n        'indoor',\n        'industry',\n        'infant',\n        'inflict',\n        'inform',\n        'inhale',\n        'inherit',\n        'initial',\n        'inject',\n        'injury',\n        'inmate',\n        'inner',\n        'innocent',\n        'input',\n        'inquiry',\n        'insane',\n        'insect',\n        'inside',\n        'inspire',\n        'install',\n        'intact',\n        'interest',\n        'into',\n        'invest',\n        'invite',\n        'involve',\n        'iron',\n        'island',\n        'isolate',\n        'issue',\n        'item',\n        'ivory',\n        'jacket',\n        'jaguar',\n        'jar',\n        'jazz',\n        'jealous',\n        'jeans',\n        'jelly',\n        'jewel',\n        'job',\n        'join',\n        'joke',\n        'journey',\n        'joy',\n        'judge',\n        'juice',\n        'jump',\n        'jungle',\n        'junior',\n        'junk',\n        'just',\n        'kangaroo',\n        'keen',\n        'keep',\n        'ketchup',\n        'key',\n        'kick',\n        'kid',\n        'kidney',\n        'kind',\n        'kingdom',\n        'kiss',\n        'kit',\n        'kitchen',\n        'kite',\n        'kitten',\n        'kiwi',\n        'knee',\n        'knife',\n        'knock',\n        'know',\n        'lab',\n        'label',\n        'labor',\n        'ladder',\n        'lady',\n        'lake',\n        'lamp',\n        'language',\n        'laptop',\n        'large',\n        'later',\n        'latin',\n        'laugh',\n        'laundry',\n        'lava',\n        'law',\n        'lawn',\n        'lawsuit',\n        'layer',\n        'lazy',\n        'leader',\n        'leaf',\n        'learn',\n        'leave',\n        'lecture',\n        'left',\n        'leg',\n        'legal',\n        'legend',\n        'leisure',\n        'lemon',\n        'lend',\n        'length',\n        'lens',\n        'leopard',\n        'lesson',\n        'letter',\n        'level',\n        'liar',\n        'liberty',\n        'library',\n        'license',\n        'life',\n        'lift',\n        'light',\n        'like',\n        'limb',\n        'limit',\n        'link',\n        'lion',\n        'liquid',\n        'list',\n        'little',\n        'live',\n        'lizard',\n        'load',\n        'loan',\n        'lobster',\n        'local',\n        'lock',\n        'logic',\n        'lonely',\n        'long',\n        'loop',\n        'lottery',\n        'loud',\n        'lounge',\n        'love',\n        'loyal',\n        'lucky',\n        'luggage',\n        'lumber',\n        'lunar',\n        'lunch',\n        'luxury',\n        'lyrics',\n        'machine',\n        'mad',\n        'magic',\n        'magnet',\n        'maid',\n        'mail',\n        'main',\n        'major',\n        'make',\n        'mammal',\n        'man',\n        'manage',\n        'mandate',\n        'mango',\n        'mansion',\n        'manual',\n        'maple',\n        'marble',\n        'march',\n        'margin',\n        'marine',\n        'market',\n        'marriage',\n        'mask',\n        'mass',\n        'master',\n        'match',\n        'material',\n        'math',\n        'matrix',\n        'matter',\n        'maximum',\n        'maze',\n        'meadow',\n        'mean',\n        'measure',\n        'meat',\n        'mechanic',\n        'medal',\n        'media',\n        'melody',\n        'melt',\n        'member',\n        'memory',\n        'mention',\n        'menu',\n        'mercy',\n        'merge',\n        'merit',\n        'merry',\n        'mesh',\n        'message',\n        'metal',\n        'method',\n        'middle',\n        'midnight',\n        'milk',\n        'million',\n        'mimic',\n        'mind',\n        'minimum',\n        'minor',\n        'minute',\n        'miracle',\n        'mirror',\n        'misery',\n        'miss',\n        'mistake',\n        'mix',\n        'mixed',\n        'mixture',\n        'mobile',\n        'model',\n        'modify',\n        'mom',\n        'moment',\n        'monitor',\n        'monkey',\n        'monster',\n        'month',\n        'moon',\n        'moral',\n        'more',\n        'morning',\n        'mosquito',\n        'mother',\n        'motion',\n        'motor',\n        'mountain',\n        'mouse',\n        'move',\n        'movie',\n        'much',\n        'muffin',\n        'mule',\n        'multiply',\n        'muscle',\n        'museum',\n        'mushroom',\n        'music',\n        'must',\n        'mutual',\n        'myself',\n        'mystery',\n        'myth',\n        'naive',\n        'name',\n        'napkin',\n        'narrow',\n        'nasty',\n        'nation',\n        'nature',\n        'near',\n        'neck',\n        'need',\n        'negative',\n        'neglect',\n        'neither',\n        'nephew',\n        'nerve',\n        'nest',\n        'net',\n        'network',\n        'neutral',\n        'never',\n        'news',\n        'next',\n        'nice',\n        'night',\n        'noble',\n        'noise',\n        'nominee',\n        'noodle',\n        'normal',\n        'north',\n        'nose',\n        'notable',\n        'note',\n        'nothing',\n        'notice',\n        'novel',\n        'now',\n        'nuclear',\n        'number',\n        'nurse',\n        'nut',\n        'oak',\n        'obey',\n        'object',\n        'oblige',\n        'obscure',\n        'observe',\n        'obtain',\n        'obvious',\n        'occur',\n        'ocean',\n        'october',\n        'odor',\n        'off',\n        'offer',\n        'office',\n        'often',\n        'oil',\n        'okay',\n        'old',\n        'olive',\n        'olympic',\n        'omit',\n        'once',\n        'one',\n        'onion',\n        'online',\n        'only',\n        'open',\n        'opera',\n        'opinion',\n        'oppose',\n        'option',\n        'orange',\n        'orbit',\n        'orchard',\n        'order',\n        'ordinary',\n        'organ',\n        'orient',\n        'original',\n        'orphan',\n        'ostrich',\n        'other',\n        'outdoor',\n        'outer',\n        'output',\n        'outside',\n        'oval',\n        'oven',\n        'over',\n        'own',\n        'owner',\n        'oxygen',\n        'oyster',\n        'ozone',\n        'pact',\n        'paddle',\n        'page',\n        'pair',\n        'palace',\n        'palm',\n        'panda',\n        'panel',\n        'panic',\n        'panther',\n        'paper',\n        'parade',\n        'parent',\n        'park',\n        'parrot',\n        'party',\n        'pass',\n        'patch',\n        'path',\n        'patient',\n        'patrol',\n        'pattern',\n        'pause',\n        'pave',\n        'payment',\n        'peace',\n        'peanut',\n        'pear',\n        'peasant',\n        'pelican',\n        'pen',\n        'penalty',\n        'pencil',\n        'people',\n        'pepper',\n        'perfect',\n        'permit',\n        'person',\n        'pet',\n        'phone',\n        'photo',\n        'phrase',\n        'physical',\n        'piano',\n        'picnic',\n        'picture',\n        'piece',\n        'pig',\n        'pigeon',\n        'pill',\n        'pilot',\n        'pink',\n        'pioneer',\n        'pipe',\n        'pistol',\n        'pitch',\n        'pizza',\n        'place',\n        'planet',\n        'plastic',\n        'plate',\n        'play',\n        'please',\n        'pledge',\n        'pluck',\n        'plug',\n        'plunge',\n        'poem',\n        'poet',\n        'point',\n        'polar',\n        'pole',\n        'police',\n        'pond',\n        'pony',\n        'pool',\n        'popular',\n        'portion',\n        'position',\n        'possible',\n        'post',\n        'potato',\n        'pottery',\n        'poverty',\n        'powder',\n        'power',\n        'practice',\n        'praise',\n        'predict',\n        'prefer',\n        'prepare',\n        'present',\n        'pretty',\n        'prevent',\n        'price',\n        'pride',\n        'primary',\n        'print',\n        'priority',\n        'prison',\n        'private',\n        'prize',\n        'problem',\n        'process',\n        'produce',\n        'profit',\n        'program',\n        'project',\n        'promote',\n        'proof',\n        'property',\n        'prosper',\n        'protect',\n        'proud',\n        'provide',\n        'public',\n        'pudding',\n        'pull',\n        'pulp',\n        'pulse',\n        'pumpkin',\n        'punch',\n        'pupil',\n        'puppy',\n        'purchase',\n        'purity',\n        'purpose',\n        'purse',\n        'push',\n        'put',\n        'puzzle',\n        'pyramid',\n        'quality',\n        'quantum',\n        'quarter',\n        'question',\n        'quick',\n        'quit',\n        'quiz',\n        'quote',\n        'rabbit',\n        'raccoon',\n        'race',\n        'rack',\n        'radar',\n        'radio',\n        'rail',\n        'rain',\n        'raise',\n        'rally',\n        'ramp',\n        'ranch',\n        'random',\n        'range',\n        'rapid',\n        'rare',\n        'rate',\n        'rather',\n        'raven',\n        'raw',\n        'razor',\n        'ready',\n        'real',\n        'reason',\n        'rebel',\n        'rebuild',\n        'recall',\n        'receive',\n        'recipe',\n        'record',\n        'recycle',\n        'reduce',\n        'reflect',\n        'reform',\n        'refuse',\n        'region',\n        'regret',\n        'regular',\n        'reject',\n        'relax',\n        'release',\n        'relief',\n        'rely',\n        'remain',\n        'remember',\n        'remind',\n        'remove',\n        'render',\n        'renew',\n        'rent',\n        'reopen',\n        'repair',\n        'repeat',\n        'replace',\n        'report',\n        'require',\n        'rescue',\n        'resemble',\n        'resist',\n        'resource',\n        'response',\n        'result',\n        'retire',\n        'retreat',\n        'return',\n        'reunion',\n        'reveal',\n        'review',\n        'reward',\n        'rhythm',\n        'rib',\n        'ribbon',\n        'rice',\n        'rich',\n        'ride',\n        'ridge',\n        'rifle',\n        'right',\n        'rigid',\n        'ring',\n        'riot',\n        'ripple',\n        'risk',\n        'ritual',\n        'rival',\n        'river',\n        'road',\n        'roast',\n        'robot',\n        'robust',\n        'rocket',\n        'romance',\n        'roof',\n        'rookie',\n        'room',\n        'rose',\n        'rotate',\n        'rough',\n        'round',\n        'route',\n        'royal',\n        'rubber',\n        'rude',\n        'rug',\n        'rule',\n        'run',\n        'runway',\n        'rural',\n        'sad',\n        'saddle',\n        'sadness',\n        'safe',\n        'sail',\n        'salad',\n        'salmon',\n        'salon',\n        'salt',\n        'salute',\n        'same',\n        'sample',\n        'sand',\n        'satisfy',\n        'satoshi',\n        'sauce',\n        'sausage',\n        'save',\n        'say',\n        'scale',\n        'scan',\n        'scare',\n        'scatter',\n        'scene',\n        'scheme',\n        'school',\n        'science',\n        'scissors',\n        'scorpion',\n        'scout',\n        'scrap',\n        'screen',\n        'script',\n        'scrub',\n        'sea',\n        'search',\n        'season',\n        'seat',\n        'second',\n        'secret',\n        'section',\n        'security',\n        'seed',\n        'seek',\n        'segment',\n        'select',\n        'sell',\n        'seminar',\n        'senior',\n        'sense',\n        'sentence',\n        'series',\n        'service',\n        'session',\n        'settle',\n        'setup',\n        'seven',\n        'shadow',\n        'shaft',\n        'shallow',\n        'share',\n        'shed',\n        'shell',\n        'sheriff',\n        'shield',\n        'shift',\n        'shine',\n        'ship',\n        'shiver',\n        'shock',\n        'shoe',\n        'shoot',\n        'shop',\n        'short',\n        'shoulder',\n        'shove',\n        'shrimp',\n        'shrug',\n        'shuffle',\n        'shy',\n        'sibling',\n        'sick',\n        'side',\n        'siege',\n        'sight',\n        'sign',\n        'silent',\n        'silk',\n        'silly',\n        'silver',\n        'similar',\n        'simple',\n        'since',\n        'sing',\n        'siren',\n        'sister',\n        'situate',\n        'six',\n        'size',\n        'skate',\n        'sketch',\n        'ski',\n        'skill',\n        'skin',\n        'skirt',\n        'skull',\n        'slab',\n        'slam',\n        'sleep',\n        'slender',\n        'slice',\n        'slide',\n        'slight',\n        'slim',\n        'slogan',\n        'slot',\n        'slow',\n        'slush',\n        'small',\n        'smart',\n        'smile',\n        'smoke',\n        'smooth',\n        'snack',\n        'snake',\n        'snap',\n        'sniff',\n        'snow',\n        'soap',\n        'soccer',\n        'social',\n        'sock',\n        'soda',\n        'soft',\n        'solar',\n        'soldier',\n        'solid',\n        'solution',\n        'solve',\n        'someone',\n        'song',\n        'soon',\n        'sorry',\n        'sort',\n        'soul',\n        'sound',\n        'soup',\n        'source',\n        'south',\n        'space',\n        'spare',\n        'spatial',\n        'spawn',\n        'speak',\n        'special',\n        'speed',\n        'spell',\n        'spend',\n        'sphere',\n        'spice',\n        'spider',\n        'spike',\n        'spin',\n        'spirit',\n        'split',\n        'spoil',\n        'sponsor',\n        'spoon',\n        'sport',\n        'spot',\n        'spray',\n        'spread',\n        'spring',\n        'spy',\n        'square',\n        'squeeze',\n        'squirrel',\n        'stable',\n        'stadium',\n        'staff',\n        'stage',\n        'stairs',\n        'stamp',\n        'stand',\n        'start',\n        'state',\n        'stay',\n        'steak',\n        'steel',\n        'stem',\n        'step',\n        'stereo',\n        'stick',\n        'still',\n        'sting',\n        'stock',\n        'stomach',\n        'stone',\n        'stool',\n        'story',\n        'stove',\n        'strategy',\n        'street',\n        'strike',\n        'strong',\n        'struggle',\n        'student',\n        'stuff',\n        'stumble',\n        'style',\n        'subject',\n        'submit',\n        'subway',\n        'success',\n        'such',\n        'sudden',\n        'suffer',\n        'sugar',\n        'suggest',\n        'suit',\n        'summer',\n        'sun',\n        'sunny',\n        'sunset',\n        'super',\n        'supply',\n        'supreme',\n        'sure',\n        'surface',\n        'surge',\n        'surprise',\n        'surround',\n        'survey',\n        'suspect',\n        'sustain',\n        'swallow',\n        'swamp',\n        'swap',\n        'swarm',\n        'swear',\n        'sweet',\n        'swift',\n        'swim',\n        'swing',\n        'switch',\n        'sword',\n        'symbol',\n        'symptom',\n        'syrup',\n        'system',\n        'table',\n        'tackle',\n        'tag',\n        'tail',\n        'talent',\n        'talk',\n        'tank',\n        'tape',\n        'target',\n        'task',\n        'taste',\n        'tattoo',\n        'taxi',\n        'teach',\n        'team',\n        'tell',\n        'ten',\n        'tenant',\n        'tennis',\n        'tent',\n        'term',\n        'test',\n        'text',\n        'thank',\n        'that',\n        'theme',\n        'then',\n        'theory',\n        'there',\n        'they',\n        'thing',\n        'this',\n        'thought',\n        'three',\n        'thrive',\n        'throw',\n        'thumb',\n        'thunder',\n        'ticket',\n        'tide',\n        'tiger',\n        'tilt',\n        'timber',\n        'time',\n        'tiny',\n        'tip',\n        'tired',\n        'tissue',\n        'title',\n        'toast',\n        'tobacco',\n        'today',\n        'toddler',\n        'toe',\n        'together',\n        'toilet',\n        'token',\n        'tomato',\n        'tomorrow',\n        'tone',\n        'tongue',\n        'tonight',\n        'tool',\n        'tooth',\n        'top',\n        'topic',\n        'topple',\n        'torch',\n        'tornado',\n        'tortoise',\n        'toss',\n        'total',\n        'tourist',\n        'toward',\n        'tower',\n        'town',\n        'toy',\n        'track',\n        'trade',\n        'traffic',\n        'tragic',\n        'train',\n        'transfer',\n        'trap',\n        'trash',\n        'travel',\n        'tray',\n        'treat',\n        'tree',\n        'trend',\n        'trial',\n        'tribe',\n        'trick',\n        'trigger',\n        'trim',\n        'trip',\n        'trophy',\n        'trouble',\n        'truck',\n        'true',\n        'truly',\n        'trumpet',\n        'trust',\n        'truth',\n        'try',\n        'tube',\n        'tuition',\n        'tumble',\n        'tuna',\n        'tunnel',\n        'turkey',\n        'turn',\n        'turtle',\n        'twelve',\n        'twenty',\n        'twice',\n        'twin',\n        'twist',\n        'two',\n        'type',\n        'typical',\n        'ugly',\n        'umbrella',\n        'unable',\n        'unaware',\n        'uncle',\n        'uncover',\n        'under',\n        'undo',\n        'unfair',\n        'unfold',\n        'unhappy',\n        'uniform',\n        'unique',\n        'unit',\n        'universe',\n        'unknown',\n        'unlock',\n        'until',\n        'unusual',\n        'unveil',\n        'update',\n        'upgrade',\n        'uphold',\n        'upon',\n        'upper',\n        'upset',\n        'urban',\n        'urge',\n        'usage',\n        'use',\n        'used',\n        'useful',\n        'useless',\n        'usual',\n        'utility',\n        'vacant',\n        'vacuum',\n        'vague',\n        'valid',\n        'valley',\n        'valve',\n        'van',\n        'vanish',\n        'vapor',\n        'various',\n        'vast',\n        'vault',\n        'vehicle',\n        'velvet',\n        'vendor',\n        'venture',\n        'venue',\n        'verb',\n        'verify',\n        'version',\n        'very',\n        'vessel',\n        'veteran',\n        'viable',\n        'vibrant',\n        'vicious',\n        'victory',\n        'video',\n        'view',\n        'village',\n        'vintage',\n        'violin',\n        'virtual',\n        'virus',\n        'visa',\n        'visit',\n        'visual',\n        'vital',\n        'vivid',\n        'vocal',\n        'voice',\n        'void',\n        'volcano',\n        'volume',\n        'vote',\n        'voyage',\n        'wage',\n        'wagon',\n        'wait',\n        'walk',\n        'wall',\n        'walnut',\n        'want',\n        'warfare',\n        'warm',\n        'warrior',\n        'wash',\n        'wasp',\n        'waste',\n        'water',\n        'wave',\n        'way',\n        'wealth',\n        'weapon',\n        'wear',\n        'weasel',\n        'weather',\n        'web',\n        'wedding',\n        'weekend',\n        'weird',\n        'welcome',\n        'west',\n        'wet',\n        'whale',\n        'what',\n        'wheat',\n        'wheel',\n        'when',\n        'where',\n        'whip',\n        'whisper',\n        'wide',\n        'width',\n        'wife',\n        'wild',\n        'will',\n        'win',\n        'window',\n        'wine',\n        'wing',\n        'wink',\n        'winner',\n        'winter',\n        'wire',\n        'wisdom',\n        'wise',\n        'wish',\n        'witness',\n        'wolf',\n        'woman',\n        'wonder',\n        'wood',\n        'wool',\n        'word',\n        'work',\n        'world',\n        'worry',\n        'worth',\n        'wrap',\n        'wreck',\n        'wrestle',\n        'wrist',\n        'write',\n        'wrong',\n        'yard',\n        'year',\n        'yellow',\n        'you',\n        'young',\n        'youth',\n        'zebra',\n        'zero',\n        'zone',\n        'zoo'\n    ],\n    space: ' '\n};\n//# sourceMappingURL=bip-39-wordlist-en.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/bip-39-wordlist-en.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/compat/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/compat/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromUtxo = exports.ECIES = exports.Mnemonic = exports.HD = exports.BSM = void 0;\nexports.BSM = __importStar(__webpack_require__(/*! ./BSM.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/BSM.js\"));\nvar HD_js_1 = __webpack_require__(/*! ./HD.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/HD.js\");\nObject.defineProperty(exports, \"HD\", ({ enumerable: true, get: function () { return __importDefault(HD_js_1).default; } }));\nvar Mnemonic_js_1 = __webpack_require__(/*! ./Mnemonic.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/Mnemonic.js\");\nObject.defineProperty(exports, \"Mnemonic\", ({ enumerable: true, get: function () { return __importDefault(Mnemonic_js_1).default; } }));\nvar ECIES_js_1 = __webpack_require__(/*! ./ECIES.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/ECIES.js\");\nObject.defineProperty(exports, \"ECIES\", ({ enumerable: true, get: function () { return __importDefault(ECIES_js_1).default; } }));\nvar Utxo_js_1 = __webpack_require__(/*! ./Utxo.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/compat/Utxo.js\");\nObject.defineProperty(exports, \"fromUtxo\", ({ enumerable: true, get: function () { return __importDefault(Utxo_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/compat/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/identity/IdentityClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/identity/IdentityClient.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdentityClient = void 0;\nconst index_js_1 = __webpack_require__(/*! ../auth/clients/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/index.js\");\nconst index_js_2 = __webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/identity/types/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js\");\nconst Certificate_js_1 = __importDefault(__webpack_require__(/*! ../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\"));\nconst index_js_5 = __webpack_require__(/*! ../script/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/index.js\");\nconst index_js_6 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\nconst index_js_7 = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js\");\n/**\n * IdentityClient lets you discover who others are, and let the world know who you are.\n */\nclass IdentityClient {\n    constructor(wallet, options = index_js_2.DEFAULT_IDENTITY_CLIENT_OPTIONS, originator) {\n        this.options = options;\n        this.originator = originator;\n        this.wallet = wallet ?? new index_js_3.WalletClient();\n        this.authClient = new index_js_1.AuthFetch(this.wallet);\n    }\n    /**\n     * Publicly reveals selected fields from a given certificate by creating a publicly verifiable certificate.\n     * The publicly revealed certificate is included in a blockchain transaction and broadcast to a federated overlay node.\n     *\n     * @param {Certificate} certificate - The master certificate to selectively reveal.\n     * @param {CertificateFieldNameUnder50Bytes[]} fieldsToReveal - An array of certificate field names to reveal. Only these fields will be included in the public certificate.\n     *\n     * @returns {Promise<object>} A promise that resolves with the broadcast result from the overlay network.\n     * @throws {Error} Throws an error if the certificate is invalid, the fields cannot be revealed, or if the broadcast fails.\n     */\n    async publiclyRevealAttributes(certificate, fieldsToReveal) {\n        if (Object.keys(certificate.fields).length === 0) {\n            throw new Error('Public reveal failed: Certificate has no fields to reveal!');\n        }\n        if (fieldsToReveal.length === 0) {\n            throw new Error('Public reveal failed: You must reveal at least one field!');\n        }\n        try {\n            const masterCert = new Certificate_js_1.default(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.signature);\n            await masterCert.verify();\n        }\n        catch (error) {\n            throw new Error('Public reveal failed: Certificate verification failed!');\n        }\n        // Given we already have a master certificate from a certifier,\n        // create an anyone verifiable certificate with selectively revealed fields\n        const { keyringForVerifier } = await this.wallet.proveCertificate({\n            certificate,\n            fieldsToReveal,\n            verifier: new index_js_6.PrivateKey(1).toPublicKey().toString()\n        });\n        // Build the lockingScript with pushdrop.create() and the transaction with createAction()\n        const lockingScript = await new index_js_5.PushDrop(this.wallet).lock([index_js_6.Utils.toArray(JSON.stringify({ ...certificate, keyring: keyringForVerifier }))], this.options.protocolID, this.options.keyID, 'anyone', true, true);\n        // TODO: Consider verification and if this is necessary\n        // counterpartyCanVerifyMyOwnership: true\n        const { tx } = await this.wallet.createAction({\n            description: 'Create a new Identity Token',\n            outputs: [{\n                    satoshis: this.options.tokenAmount,\n                    lockingScript: lockingScript.toHex(),\n                    outputDescription: 'Identity Token'\n                }],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        if (tx !== undefined) {\n            // Submit the transaction to an overlay\n            const broadcaster = new index_js_7.TopicBroadcaster(['tm_identity'], {\n                networkPreset: (await (this.wallet.getNetwork({}))).network\n            });\n            return await broadcaster.broadcast(index_js_4.Transaction.fromAtomicBEEF(tx));\n        }\n        throw new Error('Public reveal failed: failed to create action!');\n    }\n    /**\n    * Resolves displayable identity certificates, issued to a given identity key by a trusted certifier.\n    *\n    * @param {DiscoverByIdentityKeyArgs} args - Arguments for requesting the discovery based on the identity key.\n    * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.\n    */\n    async resolveByIdentityKey(args) {\n        const { certificates } = await this.wallet.discoverByIdentityKey(args, this.originator);\n        return certificates.map(cert => {\n            return IdentityClient.parseIdentity(cert);\n        });\n    }\n    /**\n     * Resolves displayable identity certificates by specific identity attributes, issued by a trusted entity.\n     *\n     * @param {DiscoverByAttributesArgs} args - Attributes and optional parameters used to discover certificates.\n     * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.\n     */\n    async resolveByAttributes(args) {\n        const { certificates } = await this.wallet.discoverByAttributes(args, this.originator);\n        return certificates.map(cert => {\n            return IdentityClient.parseIdentity(cert);\n        });\n    }\n    /**\n     * TODO: Implement once revocation overlay is created\n     * Remove public certificate revelation from overlay services by spending the identity token\n     * @param serialNumber - Unique serial number of the certificate to revoke revelation\n     */\n    // async revokeCertificateRevelation(\n    //   serialNumber: Base64String\n    // ): Promise<BroadcastResponse | BroadcastFailure> {\n    //   // 1. Find existing UTXO\n    //   const lookupResolver = new LookupResolver()\n    //   const result = await lookupResolver.query({\n    //     service: 'ls_identity',\n    //     query: {\n    //       serialNumber\n    //     }\n    //   })\n    //   let outpoint: string\n    //   let lockingScript: LockingScript | undefined\n    //   if (result.type === 'output-list') {\n    //     const tx = Transaction.fromAtomicBEEF(result.outputs[this.options.outputIndex].beef)\n    //     outpoint = `${tx.id('hex')}.${this.options.outputIndex}` // Consider better way\n    //     lockingScript = tx.outputs[this.options.outputIndex].lockingScript\n    //   }\n    //   if (lockingScript === undefined) {\n    //     throw new Error('Failed to get locking script for revelation output!')\n    //   }\n    //   // 2. Parse results\n    //   const { signableTransaction } = await this.wallet.createAction({\n    //     description: '',\n    //     inputs: [{\n    //       inputDescription: 'Spend certificate revelation token',\n    //       outpoint,\n    //       unlockingScriptLength: 73\n    //     }],\n    //     options: {\n    //       randomizeOutputs: false\n    //     }\n    //   })\n    //   if (signableTransaction === undefined) {\n    //     throw new Error('Failed to create signable transaction')\n    //   }\n    //   const partialTx = Transaction.fromBEEF(signableTransaction.tx)\n    //   const unlocker = new PushDrop(this.wallet).unlock(\n    //     this.options.protocolID,\n    //     this.options.keyID,\n    //     'self',\n    //     'all',\n    //     false,\n    //     1,\n    //     lockingScript\n    //   )\n    //   const unlockingScript = await unlocker.sign(partialTx, this.options.outputIndex)\n    //   const { tx: signedTx } = await this.wallet.signAction({\n    //     reference: signableTransaction.reference,\n    //     spends: {\n    //       [this.options.outputIndex]: {\n    //         unlockingScript: unlockingScript.toHex()\n    //       }\n    //     }\n    //   })\n    //   // 4. Return broadcast status\n    //   // Submit the transaction to an overlay\n    //   const broadcaster = new SHIPBroadcaster(['tm_identity'])\n    //   return await broadcaster.broadcast(Transaction.fromAtomicBEEF(signedTx as number[]))\n    // }\n    /**\n     * Parse out identity and certifier attributes to display from an IdentityCertificate\n     * @param identityToParse - The Identity Certificate to parse\n     * @returns - IdentityToDisplay\n     */\n    static parseIdentity(identityToParse) {\n        const { type, decryptedFields, certifierInfo } = identityToParse;\n        let name, avatarURL, badgeLabel, badgeIconURL, badgeClickURL;\n        // Parse out the name to display based on the specific certificate type which has clearly defined fields.\n        switch (type) {\n            case index_js_2.KNOWN_IDENTITY_TYPES.xCert:\n                name = decryptedFields.userName;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `X account certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.discordCert:\n                name = decryptedFields.userName;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `Discord account certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.emailCert:\n                name = decryptedFields.email;\n                avatarURL = 'XUTZxep7BBghAJbSBwTjNfmcsDdRFs5EaGEgkESGSgjJVYgMEizu';\n                badgeLabel = `Email certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.phoneCert:\n                name = decryptedFields.phoneNumber;\n                avatarURL = 'XUTLxtX3ELNUwRhLwL7kWNGbdnFM8WG2eSLv84J7654oH8HaJWrU';\n                badgeLabel = `Phone certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.identiCert:\n                name = `${decryptedFields.firstName} ${decryptedFields.lastName}`;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `Government ID certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://identicert.me'; // TODO Make a specific page for this.\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.registrant:\n                name = decryptedFields.name;\n                avatarURL = decryptedFields.icon;\n                badgeLabel = `Entity certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://projectbabbage.com/docs/registrant'; // TODO: Make this doc page exist\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.coolCert:\n                name = decryptedFields.cool === 'true' ? 'Cool Person!' : 'Not cool!';\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.anyone:\n                name = 'Anyone';\n                avatarURL = 'XUT4bpQ6cpBaXi1oMzZsXfpkWGbtp2JTUYAoN7PzhStFJ6wLfoeR';\n                badgeLabel = 'Represents the ability for anyone to access this information.';\n                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';\n                badgeClickURL = 'https://projectbabbage.com/docs/anyone-identity'; // TODO: Make this doc page exist\n                break;\n            case index_js_2.KNOWN_IDENTITY_TYPES.self:\n                name = 'You';\n                avatarURL = 'XUT9jHGk2qace148jeCX5rDsMftkSGYKmigLwU2PLLBc7Hm63VYR';\n                badgeLabel = 'Represents your ability to access this information.';\n                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';\n                badgeClickURL = 'https://projectbabbage.com/docs/self-identity'; // TODO: Make this doc page exist\n                break;\n            default:\n                name = index_js_2.defaultIdentity.name;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = index_js_2.defaultIdentity.badgeLabel;\n                badgeIconURL = index_js_2.defaultIdentity.badgeIconURL;\n                badgeClickURL = index_js_2.defaultIdentity.badgeClickURL; // TODO: Make this doc page exist\n                break;\n        }\n        return {\n            name,\n            avatarURL,\n            abbreviatedKey: identityToParse.subject.length > 0 ? `${identityToParse.subject.substring(0, 10)}...` : '',\n            identityKey: identityToParse.subject,\n            badgeIconURL,\n            badgeLabel,\n            badgeClickURL\n        };\n    }\n}\nexports.IdentityClient = IdentityClient;\n//# sourceMappingURL=IdentityClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/identity/IdentityClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/identity/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/identity/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./IdentityClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/identity/IdentityClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/identity/types/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/identity/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/identity/types/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/identity/types/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KNOWN_IDENTITY_TYPES = exports.DEFAULT_IDENTITY_CLIENT_OPTIONS = exports.defaultIdentity = void 0;\nexports.defaultIdentity = {\n    name: 'Unknown Identity',\n    avatarURL: 'XUUB8bbn9fEthk15Ge3zTQXypUShfC94vFjp65v7u5CQ8qkpxzst',\n    identityKey: '',\n    abbreviatedKey: '',\n    badgeIconURL: 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG',\n    badgeLabel: 'Not verified by anyone you trust.',\n    badgeClickURL: 'https://projectbabbage.com/docs/unknown-identity'\n};\nexports.DEFAULT_IDENTITY_CLIENT_OPTIONS = {\n    protocolID: [1, 'identity'],\n    keyID: '1',\n    tokenAmount: 1,\n    outputIndex: 0\n};\nexports.KNOWN_IDENTITY_TYPES = {\n    identiCert: 'z40BOInXkI8m7f/wBrv4MJ09bZfzZbTj2fJqCtONqCY=',\n    discordCert: '2TgqRC35B1zehGmB21xveZNc7i5iqHc0uxMb+1NMPW4=',\n    phoneCert: 'mffUklUzxbHr65xLohn0hRL0Tq2GjW1GYF/OPfzqJ6A=',\n    xCert: 'vdDWvftf1H+5+ZprUw123kjHlywH+v20aPQTuXgMpNc=',\n    registrant: 'YoPsbfR6YQczjzPdHCoGC7nJsOdPQR50+SYqcWpJ0y0=',\n    emailCert: 'exOl3KM0dIJ04EW5pZgbZmPag6MdJXd3/a1enmUU/BA=',\n    anyone: 'mfkOMfLDQmrr3SBxBQ5WeE+6Hy3VJRFq6w4A5Ljtlis=',\n    self: 'Hkge6X5JRxt1cWXtHLCrSTg6dCVTxjQJJ48iOYd7n3g=',\n    coolCert: 'AGfk/WrT1eBDXpz3mcw386Zww2HmqcIn3uY6x4Af1eo='\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/identity/types/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/kvstore/LocalKVStore.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/kvstore/LocalKVStore.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PushDrop_js_1 = __importDefault(__webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst WalletClient_js_1 = __importDefault(__webpack_require__(/*! ../wallet/WalletClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletClient.js\"));\nconst Transaction_js_1 = __importDefault(__webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js\"));\nconst Beef_js_1 = __webpack_require__(/*! ../transaction/Beef.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js\");\n/**\n * Implements a key-value storage system backed by transaction outputs managed by a wallet.\n * Each key-value pair is represented by a PushDrop token output in a specific context (basket).\n * Allows setting, getting, and removing key-value pairs, with optional encryption.\n */\nclass LocalKVStore {\n    /**\n     * Creates an instance of the localKVStore.\n     *\n     * @param {WalletInterface} [wallet=new WalletClient()] - The wallet interface to use. Defaults to a new WalletClient instance.\n     * @param {string} [context='kvstoredefault'] - The context (basket) for namespacing keys. Defaults to 'kvstore default'.\n     * @param {boolean} [encrypt=true] - Whether to encrypt values. Defaults to true.\n     * @param {string} [originator]  An originator to use with PushDrop and the wallet, if provided.\n     * @throws {Error} If the context is missing or empty.\n     */\n    constructor(wallet = new WalletClient_js_1.default(), context = 'kvstore default', encrypt = true, originator, acceptDelayedBroadcast = false) {\n        this.acceptDelayedBroadcast = false;\n        /**\n         * A map to store locks for each key to ensure atomic updates.\n         * @private\n         */\n        this.keyLocks = new Map();\n        if (typeof context !== 'string' || context.length < 1) {\n            throw new Error('A context in which to operate is required.');\n        }\n        this.wallet = wallet;\n        this.context = context;\n        this.encrypt = encrypt;\n        this.originator = originator;\n        this.acceptDelayedBroadcast = acceptDelayedBroadcast;\n    }\n    async queueOperationOnKey(key) {\n        // Check if a lock exists for this key and wait for it to resolve\n        let lockQueue = this.keyLocks.get(key);\n        if (lockQueue == null) {\n            lockQueue = [];\n            this.keyLocks.set(key, lockQueue);\n        }\n        let resolveNewLock = () => { };\n        const newLock = new Promise((resolve) => {\n            resolveNewLock = resolve;\n            if (lockQueue != null) {\n                lockQueue.push(resolve);\n            }\n        });\n        // If we are the only request, resolve the lock immediately, queue remains at 1 item until request ends.\n        if (lockQueue.length === 1) {\n            resolveNewLock();\n        }\n        await newLock;\n        return lockQueue;\n    }\n    finishOperationOnKey(key, lockQueue) {\n        lockQueue.shift(); // Remove the current lock from the queue\n        if (lockQueue.length > 0) {\n            // If there are more locks waiting, resolve the next one\n            lockQueue[0]();\n        }\n    }\n    getProtocol(key) {\n        return { protocolID: [2, this.context], keyID: key };\n    }\n    async getOutputs(key, limit) {\n        const results = await this.wallet.listOutputs({\n            basket: this.context,\n            tags: [key],\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit\n        });\n        return results;\n    }\n    /**\n     * Retrieves the value associated with a given key.\n     *\n     * @param {string} key - The key to retrieve the value for.\n     * @param {string | undefined} [defaultValue=undefined] - The value to return if the key is not found.\n     * @returns {Promise<string | undefined>} A promise that resolves to the value as a string,\n     *   the defaultValue if the key is not found, or undefined if no defaultValue is provided.\n     * @throws {Error} If too many outputs are found for the key (ambiguous state).\n     * @throws {Error} If the found output's locking script cannot be decoded or represents an invalid token format.\n     */\n    async get(key, defaultValue = undefined) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const r = await this.lookupValue(key, defaultValue, 5);\n            return r.value;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n    getLockingScript(output, beef) {\n        const [txid, vout] = output.outpoint.split('.');\n        const tx = beef.findTxid(txid)?.tx;\n        if (tx == null) {\n            throw new Error(`beef must contain txid ${txid}`);\n        }\n        const lockingScript = tx.outputs[Number(vout)].lockingScript;\n        return lockingScript;\n    }\n    async lookupValue(key, defaultValue, limit) {\n        const lor = await this.getOutputs(key, limit);\n        const r = { value: defaultValue, outpoint: undefined, lor };\n        const { outputs } = lor;\n        if (outputs.length === 0) {\n            return r;\n        }\n        const output = outputs.slice(-1)[0];\n        r.outpoint = output.outpoint;\n        let field;\n        try {\n            if (lor.BEEF === undefined) {\n                throw new Error('entire transactions listOutputs option must return valid BEEF');\n            }\n            const lockingScript = this.getLockingScript(output, Beef_js_1.Beef.fromBinary(lor.BEEF));\n            const decoded = PushDrop_js_1.default.decode(lockingScript);\n            if (decoded.fields.length < 1 || decoded.fields.length > 2) {\n                throw new Error('Invalid token.');\n            }\n            field = decoded.fields[0];\n        }\n        catch (_) {\n            throw new Error(`Invalid value found. You need to call set to collapse the corrupted state (or relinquish the corrupted ${outputs[0].outpoint} output from the ${this.context} basket) before you can get this value again.`);\n        }\n        if (!this.encrypt) {\n            r.value = Utils.toUTF8(field);\n        }\n        else {\n            const { plaintext } = await this.wallet.decrypt({\n                ...this.getProtocol(key),\n                ciphertext: field\n            });\n            r.value = Utils.toUTF8(plaintext);\n        }\n        return r;\n    }\n    getInputs(outputs) {\n        const inputs = [];\n        for (let i = 0; i < outputs.length; i++) {\n            inputs.push({\n                outpoint: outputs[i].outpoint,\n                unlockingScriptLength: 74,\n                inputDescription: 'Previous key-value token'\n            });\n        }\n        return inputs;\n    }\n    async getSpends(key, outputs, pushdrop, atomicBEEF) {\n        const p = this.getProtocol(key);\n        const tx = Transaction_js_1.default.fromAtomicBEEF(atomicBEEF);\n        const spends = {};\n        for (let i = 0; i < outputs.length; i++) {\n            const unlocker = pushdrop.unlock(p.protocolID, p.keyID, 'self');\n            const unlockingScript = await unlocker.sign(tx, i);\n            spends[i] = {\n                unlockingScript: unlockingScript.toHex()\n            };\n        }\n        return spends;\n    }\n    /**\n     * Sets or updates the value associated with a given key atomically.\n     * If the key already exists (one or more outputs found), it spends the existing output(s)\n     * and creates a new one with the updated value. If multiple outputs exist for the key,\n     * they are collapsed into a single new output.\n     * If the key does not exist, it creates a new output.\n     * Handles encryption if enabled.\n     * If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain.\n     * Ensures atomicity by locking the key during the operation, preventing concurrent updates\n     * to the same key from missing earlier changes.\n     *\n     * @param {string} key - The key to set or update.\n     * @param {string} value - The value to associate with the key.\n     * @returns {Promise<OutpointString>} A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.\n     */\n    async set(key, value) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const current = await this.lookupValue(key, undefined, 10);\n            if (current.value === value) {\n                if (current.outpoint === undefined) {\n                    throw new Error('outpoint must be valid when value is valid and unchanged');\n                }\n                // Don't create a new transaction if the value doesn't need to change\n                return current.outpoint;\n            }\n            const protocol = this.getProtocol(key);\n            let valueAsArray = Utils.toArray(value, 'utf8');\n            if (this.encrypt) {\n                const { ciphertext } = await this.wallet.encrypt({\n                    ...protocol,\n                    plaintext: valueAsArray\n                });\n                valueAsArray = ciphertext;\n            }\n            const pushdrop = new PushDrop_js_1.default(this.wallet, this.originator);\n            const lockingScript = await pushdrop.lock([valueAsArray], protocol.protocolID, protocol.keyID, 'self');\n            const { outputs, BEEF: inputBEEF } = current.lor;\n            let outpoint;\n            try {\n                const inputs = this.getInputs(outputs);\n                const { txid, signableTransaction } = await this.wallet.createAction({\n                    description: `Update ${key} in ${this.context}`,\n                    inputBEEF,\n                    inputs,\n                    outputs: [{\n                            basket: this.context,\n                            tags: [key],\n                            lockingScript: lockingScript.toHex(),\n                            satoshis: 1,\n                            outputDescription: 'Key-value token'\n                        }],\n                    options: {\n                        acceptDelayedBroadcast: this.acceptDelayedBroadcast,\n                        randomizeOutputs: false\n                    }\n                });\n                if (outputs.length > 0 && typeof signableTransaction !== 'object') {\n                    throw new Error('Wallet did not return a signable transaction when expected.');\n                }\n                if (signableTransaction == null) {\n                    outpoint = `${txid}.0`;\n                }\n                else {\n                    const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);\n                    const { txid } = await this.wallet.signAction({\n                        reference: signableTransaction.reference,\n                        spends\n                    });\n                    outpoint = `${txid}.0`;\n                }\n            }\n            catch (_) {\n                throw new Error(`There are ${outputs.length} outputs with tag ${key} that cannot be unlocked.`);\n            }\n            return outpoint;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n    /**\n     * Removes the key-value pair associated with the given key.\n     * It finds the existing output(s) for the key and spends them without creating a new output.\n     * If multiple outputs exist, they are all spent in the same transaction.\n     * If the key does not exist, it does nothing.\n     * If signing the removal transaction fails, it relinquishes the original outputs instead of spending.\n     *\n     * @param {string} key - The key to remove.\n     * @returns {Promise<string[]>} A promise that resolves to the txids of the removal transactions if successful.\n     */\n    async remove(key) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const txids = [];\n            for (;;) {\n                const { outputs, BEEF: inputBEEF, totalOutputs } = await this.getOutputs(key);\n                if (outputs.length > 0) {\n                    const pushdrop = new PushDrop_js_1.default(this.wallet, this.originator);\n                    try {\n                        const inputs = this.getInputs(outputs);\n                        const { signableTransaction } = await this.wallet.createAction({\n                            description: `Remove ${key} in ${this.context}`,\n                            inputBEEF,\n                            inputs,\n                            options: {\n                                acceptDelayedBroadcast: this.acceptDelayedBroadcast\n                            }\n                        });\n                        if (typeof signableTransaction !== 'object') {\n                            throw new Error('Wallet did not return a signable transaction when expected.');\n                        }\n                        const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);\n                        const { txid } = await this.wallet.signAction({\n                            reference: signableTransaction.reference,\n                            spends\n                        });\n                        if (txid === undefined) {\n                            throw new Error('signAction must return a valid txid');\n                        }\n                        txids.push(txid);\n                    }\n                    catch (_) {\n                        throw new Error(`There are ${totalOutputs} outputs with tag ${key} that cannot be unlocked.`);\n                    }\n                }\n                if (outputs.length === totalOutputs) {\n                    break;\n                }\n            }\n            return txids;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n}\nexports[\"default\"] = LocalKVStore;\n//# sourceMappingURL=LocalKVStore.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/kvstore/LocalKVStore.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/kvstore/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/kvstore/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalKVStore = void 0;\nvar LocalKVStore_js_1 = __webpack_require__(/*! ./LocalKVStore.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/kvstore/LocalKVStore.js\");\nObject.defineProperty(exports, \"LocalKVStore\", ({ enumerable: true, get: function () { return __importDefault(LocalKVStore_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/kvstore/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/messages/EncryptedMessage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/messages/EncryptedMessage.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decrypt = exports.encrypt = void 0;\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst SymmetricKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst VERSION = '42421033';\n/**\n * Encrypts a message from one party to another using the BRC-78 message encryption protocol.\n * @param message The message to encrypt\n * @param sender The private key of the sender\n * @param recipient The public key of the recipient\n *\n * @returns The encrypted message\n */\nconst encrypt = (message, sender, recipient) => {\n    const keyID = (0, Random_js_1.default)(32);\n    const keyIDBase64 = (0, utils_js_1.toBase64)(keyID);\n    const invoiceNumber = `2-message encryption-${keyIDBase64}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey_js_1.default(sharedSecret.encode(true).slice(1));\n    const encrypted = symmetricKey.encrypt(message);\n    const senderPublicKey = sender.toPublicKey().encode(true);\n    const version = (0, utils_js_1.toArray)(VERSION, 'hex');\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...recipient.encode(true),\n        ...keyID,\n        ...encrypted\n    ];\n};\nexports.encrypt = encrypt;\n/**\n * Decrypts a message from one party to another using the BRC-78 message encryption protocol.\n * @param message The message to decrypt\n * @param sender The private key of the recipient\n *\n * @returns The decrypted message\n */\nconst decrypt = (message, recipient) => {\n    const reader = new utils_js_1.Reader(message);\n    const messageVersion = (0, utils_js_1.toHex)(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const sender = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(reader.read(33)));\n    const expectedRecipientDER = (0, utils_js_1.toHex)(reader.read(33));\n    const actualRecipientDER = recipient\n        .toPublicKey()\n        .encode(true, 'hex');\n    if (expectedRecipientDER !== actualRecipientDER) {\n        throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);\n    }\n    const keyID = (0, utils_js_1.toBase64)(reader.read(32));\n    const encrypted = reader.read(reader.bin.length - reader.pos);\n    const invoiceNumber = `2-message encryption-${keyID}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new SymmetricKey_js_1.default(sharedSecret.encode(true).slice(1));\n    return symmetricKey.decrypt(encrypted);\n};\nexports.decrypt = decrypt;\n//# sourceMappingURL=EncryptedMessage.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/messages/EncryptedMessage.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/messages/SignedMessage.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/messages/SignedMessage.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verify = exports.sign = void 0;\n// @ts-nocheck\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst PrivateKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\"));\nconst Signature_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst VERSION = '42423301';\n/**\n * Signs a message from one party to be verified by another, or for verification by anyone, using the BRC-77 message signing protocol.\n * @param message The message to sign\n * @param signer The private key of the message signer\n * @param [verifier] The public key of the person who can verify the message. If not provided, anyone will be able to verify the message signature.\n *\n * @returns The message signature.\n */\nconst sign = (message, signer, verifier) => {\n    const recipientAnyone = typeof verifier !== 'object';\n    if (recipientAnyone) {\n        const curve = new Curve_js_1.default();\n        const anyone = new PrivateKey_js_1.default(1);\n        const anyonePoint = curve.g.mul(anyone);\n        verifier = new PublicKey_js_1.default(anyonePoint.x, anyonePoint.y);\n    }\n    const keyID = (0, Random_js_1.default)(32);\n    const keyIDBase64 = (0, utils_js_1.toBase64)(keyID);\n    const invoiceNumber = `2-message signing-${keyIDBase64}`;\n    const signingKey = signer.deriveChild(verifier, invoiceNumber);\n    const signature = signingKey.sign(message).toDER();\n    const senderPublicKey = signer.toPublicKey().encode(true);\n    const version = (0, utils_js_1.toArray)(VERSION, 'hex');\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...(recipientAnyone ? [0] : verifier.encode(true)),\n        ...keyID,\n        ...signature\n    ];\n};\nexports.sign = sign;\n/**\n * Verifies a message using the BRC-77 message signing protocol.\n * @param message The message to verify.\n * @param sig The message signature to be verified.\n * @param [recipient] The private key of the message verifier. This can be omitted if the message is verifiable by anyone.\n *\n * @returns True if the message is verified.\n */\nconst verify = (message, sig, recipient) => {\n    const reader = new utils_js_1.Reader(sig);\n    const messageVersion = (0, utils_js_1.toHex)(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const signer = PublicKey_js_1.default.fromString((0, utils_js_1.toHex)(reader.read(33)));\n    const [verifierFirst] = reader.read(1);\n    if (verifierFirst === 0) {\n        recipient = new PrivateKey_js_1.default(1);\n    }\n    else {\n        const verifierRest = reader.read(32);\n        const verifierDER = (0, utils_js_1.toHex)([verifierFirst, ...verifierRest]);\n        if (typeof recipient !== 'object') {\n            throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);\n        }\n        const recipientDER = recipient.toPublicKey().encode(true, 'hex');\n        if (verifierDER !== recipientDER) {\n            throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);\n        }\n    }\n    const keyID = (0, utils_js_1.toBase64)(reader.read(32));\n    const signatureDER = (0, utils_js_1.toHex)(reader.read(reader.bin.length - reader.pos));\n    const signature = Signature_js_1.default.fromDER(signatureDER, 'hex');\n    const invoiceNumber = `2-message signing-${keyID}`;\n    const signingKey = signer.deriveChild(recipient, invoiceNumber);\n    const verified = signingKey.verify(message, signature);\n    return verified;\n};\nexports.verify = verify;\n//# sourceMappingURL=SignedMessage.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/messages/SignedMessage.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/messages/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/messages/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EncryptedMessage = exports.SignedMessage = void 0;\nexports.SignedMessage = __importStar(__webpack_require__(/*! ./SignedMessage.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/messages/SignedMessage.js\"));\nexports.EncryptedMessage = __importStar(__webpack_require__(/*! ./EncryptedMessage.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/messages/EncryptedMessage.js\"));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/messages/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HTTPSOverlayLookupFacilitator = exports.DEFAULT_TESTNET_SLAP_TRACKERS = exports.DEFAULT_SLAP_TRACKERS = void 0;\nconst index_js_1 = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js\");\nconst OverlayAdminTokenTemplate_js_1 = __importDefault(__webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js\"));\n/** Default SLAP trackers */\nexports.DEFAULT_SLAP_TRACKERS = [\n    // BSVA clusters\n    'https://overlay-us-1.bsvb.tech',\n    'https://overlay-eu-1.bsvb.tech',\n    'https://overlay-ap-1.bsvb.tech',\n    // Babbage primary overlay service\n    'https://users.bapp.dev'\n    // NOTE: Other entities may submit pull requests to the library if they maintain SLAP overlay services.\n    // Additional trackers run by different entities contribute to greater network resiliency.\n    // It also generally doesn't hurt to have more trackers in this list.\n    // DISCLAIMER:\n    // Trackers known to host invalid or illegal records will be removed at the discretion of the BSV Association.\n];\n/** Default testnet SLAP trackers */\nexports.DEFAULT_TESTNET_SLAP_TRACKERS = [\n    // Babbage primary testnet overlay service\n    'https://testnet-users.bapp.dev'\n];\nconst MAX_TRACKER_WAIT_TIME = 5000;\nclass HTTPSOverlayLookupFacilitator {\n    constructor(httpClient = fetch, allowHTTP = false) {\n        this.fetchClient = httpClient;\n        this.allowHTTP = allowHTTP;\n    }\n    async lookup(url, question, timeout = 5000) {\n        if (!url.startsWith('https:') && !this.allowHTTP) {\n            throw new Error('HTTPS facilitator can only use URLs that start with \"https:\"');\n        }\n        const timeoutPromise = new Promise((resolve, reject) => setTimeout(() => reject(new Error('Request timed out')), timeout));\n        const fetchPromise = fetch(`${url}/lookup`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                service: question.service,\n                query: question.query\n            })\n        });\n        const response = (await Promise.race([\n            fetchPromise,\n            timeoutPromise\n        ]));\n        if (response.ok) {\n            return await response.json();\n        }\n        else {\n            throw new Error('Failed to facilitate lookup');\n        }\n    }\n}\nexports.HTTPSOverlayLookupFacilitator = HTTPSOverlayLookupFacilitator;\n/**\n * Represents an SHIP transaction broadcaster.\n */\nclass LookupResolver {\n    constructor(config = {}) {\n        this.networkPreset = config.networkPreset ?? 'mainnet';\n        this.facilitator = config.facilitator ?? new HTTPSOverlayLookupFacilitator(undefined, this.networkPreset === 'local');\n        this.slapTrackers = config.slapTrackers ?? (this.networkPreset === 'mainnet' ? exports.DEFAULT_SLAP_TRACKERS : exports.DEFAULT_TESTNET_SLAP_TRACKERS);\n        this.hostOverrides = config.hostOverrides ?? {};\n        this.additionalHosts = config.additionalHosts ?? {};\n    }\n    /**\n     * Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.\n     */\n    async query(question, timeout) {\n        let competentHosts = [];\n        if (question.service === 'ls_slap') {\n            competentHosts = this.networkPreset === 'local' ? ['http://localhost:8080'] : this.slapTrackers;\n        }\n        else if (this.hostOverrides[question.service] != null) {\n            competentHosts = this.hostOverrides[question.service];\n        }\n        else if (this.networkPreset === 'local') {\n            competentHosts = ['http://localhost:8080'];\n        }\n        else {\n            competentHosts = await this.findCompetentHosts(question.service);\n        }\n        if (this.additionalHosts[question.service]?.length > 0) {\n            competentHosts = [\n                ...competentHosts,\n                ...this.additionalHosts[question.service]\n            ];\n        }\n        if (competentHosts.length < 1) {\n            throw new Error(`No competent ${this.networkPreset} hosts found by the SLAP trackers for lookup service: ${question.service}`);\n        }\n        // Use Promise.allSettled to handle individual host failures\n        const hostResponses = await Promise.allSettled(competentHosts.map(async (host) => await this.facilitator.lookup(host, question, timeout)));\n        const successfulResponses = hostResponses\n            .filter((result) => result.status === 'fulfilled')\n            .map((result) => result.value);\n        if (successfulResponses.length === 0) {\n            throw new Error('No successful responses from any hosts');\n        }\n        // Process the successful responses\n        // Aggregate outputs from all successful responses\n        const outputs = new Map();\n        for (const response of successfulResponses) {\n            if (response.type !== 'output-list') {\n                continue;\n            }\n            try {\n                for (const output of response.outputs) {\n                    try {\n                        const txId = index_js_1.Transaction.fromBEEF(output.beef).id('hex'); // !! This is STUPIDLY inefficient.\n                        const key = `${txId}.${output.outputIndex}`;\n                        outputs.set(key, output);\n                    }\n                    catch {\n                        continue;\n                    }\n                }\n            }\n            catch (_) {\n                // Error processing output, proceed.\n            }\n        }\n        return {\n            type: 'output-list',\n            outputs: Array.from(outputs.values())\n        };\n    }\n    /**\n     * Returns a list of competent hosts for a given lookup service.\n     * @param service Service for which competent hosts are to be returned\n     * @returns Array of hosts competent for resolving queries\n     */\n    async findCompetentHosts(service) {\n        const query = {\n            service: 'ls_slap',\n            query: {\n                service\n            }\n        };\n        // Use Promise.allSettled to handle individual SLAP tracker failures\n        const trackerResponses = await Promise.allSettled(this.slapTrackers.map(async (tracker) => await this.facilitator.lookup(tracker, query, MAX_TRACKER_WAIT_TIME)));\n        const hosts = new Set();\n        for (const result of trackerResponses) {\n            if (result.status === 'fulfilled') {\n                const answer = result.value;\n                if (answer.type !== 'output-list') {\n                    // Log invalid response and continue\n                    continue;\n                }\n                for (const output of answer.outputs) {\n                    try {\n                        const tx = index_js_1.Transaction.fromBEEF(output.beef);\n                        const script = tx.outputs[output.outputIndex].lockingScript;\n                        const parsed = OverlayAdminTokenTemplate_js_1.default.decode(script);\n                        if (parsed.topicOrService !== service ||\n                            parsed.protocol !== 'SLAP') {\n                            // Invalid advertisement, skip\n                            continue;\n                        }\n                        hosts.add(parsed.domain);\n                    }\n                    catch {\n                        // Invalid output, skip\n                        continue;\n                    }\n                }\n            }\n            else {\n                // Log tracker failure and continue\n                continue;\n            }\n        }\n        return [...hosts];\n    }\n}\nexports[\"default\"] = LookupResolver;\n//# sourceMappingURL=LookupResolver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst PushDrop_js_1 = __importDefault(__webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js\"));\nconst index_js_1 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\n/**\n * Script template enabling the creation, unlocking, and decoding of SHIP and SLAP advertisements.\n */\nclass OverlayAdminTokenTemplate {\n    /**\n     * Decodes a SHIP or SLAP advertisement from a given locking script.\n     * @param script Locking script comprising a SHIP or SLAP token to decode\n     * @returns Decoded SHIP or SLAP advertisement\n     */\n    static decode(script) {\n        const result = PushDrop_js_1.default.decode(script);\n        if (result.fields.length < 4) {\n            throw new Error('Invalid SHIP/SLAP advertisement!');\n        }\n        const protocol = index_js_1.Utils.toUTF8(result.fields[0]);\n        if (protocol !== 'SHIP' && protocol !== 'SLAP') {\n            throw new Error('Invalid protocol type!');\n        }\n        const identityKey = index_js_1.Utils.toHex(result.fields[1]);\n        const domain = index_js_1.Utils.toUTF8(result.fields[2]);\n        const topicOrService = index_js_1.Utils.toUTF8(result.fields[3]);\n        return {\n            protocol,\n            identityKey,\n            domain,\n            topicOrService\n        };\n    }\n    /**\n     * Constructs a new Overlay Admin template instance\n     * @param wallet Wallet to use for locking and unlocking\n     */\n    constructor(wallet) {\n        this.pushDrop = new PushDrop_js_1.default(wallet);\n    }\n    /**\n     * Creates a new advertisement locking script\n     * @param protocol SHIP or SLAP\n     * @param domain Domain where the topic or service is available\n     * @param topicOrService Topic or service to advertise\n     * @returns Locking script comprising the advertisement token\n     */\n    async lock(protocol, domain, topicOrService) {\n        const { publicKey: identityKey } = await this.pushDrop.wallet.getPublicKey({\n            identityKey: true\n        });\n        return await this.pushDrop.lock([\n            index_js_1.Utils.toArray(protocol, 'utf8'),\n            index_js_1.Utils.toArray(identityKey, 'hex'),\n            index_js_1.Utils.toArray(domain, 'utf8'),\n            index_js_1.Utils.toArray(topicOrService, 'utf8')\n        ], [\n            2,\n            protocol === 'SHIP'\n                ? 'Service Host Interconnect'\n                : 'Service Lookup Availability'\n        ], '1', 'self');\n    }\n    /**\n     * Unlocks an advertisement token as part of a transaction.\n     * @param protocol SHIP or SLAP, depending on the token to unlock\n     * @returns Script unlocker capable of unlocking the advertisement token\n     */\n    unlock(protocol) {\n        return this.pushDrop.unlock([\n            2,\n            protocol === 'SHIP'\n                ? 'Service Host Interconnect'\n                : 'Service Lookup Availability'\n        ], '1', 'self');\n    }\n}\nexports[\"default\"] = OverlayAdminTokenTemplate;\n//# sourceMappingURL=OverlayAdminTokenTemplate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HTTPSOverlayBroadcastFacilitator = void 0;\nconst index_js_1 = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js\");\nconst Utils = __importStar(__webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst LookupResolver_js_1 = __importDefault(__webpack_require__(/*! ./LookupResolver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js\"));\nconst OverlayAdminTokenTemplate_js_1 = __importDefault(__webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js\"));\nconst MAX_SHIP_QUERY_TIMEOUT = 5000;\nclass HTTPSOverlayBroadcastFacilitator {\n    constructor(httpClient = fetch, allowHTTP = false) {\n        this.httpClient = httpClient;\n        this.allowHTTP = allowHTTP;\n    }\n    async send(url, taggedBEEF) {\n        if (!url.startsWith('https:') && !this.allowHTTP) {\n            throw new Error('HTTPS facilitator can only use URLs that start with \"https:\"');\n        }\n        const headers = {\n            'Content-Type': 'application/octet-stream',\n            'X-Topics': JSON.stringify(taggedBEEF.topics)\n        };\n        let body;\n        if (Array.isArray(taggedBEEF.offChainValues)) {\n            headers['x-includes-off-chain-values'] = 'true';\n            const w = new Utils.Writer();\n            w.writeVarIntNum(taggedBEEF.beef.length);\n            w.write(taggedBEEF.beef);\n            w.write(taggedBEEF.offChainValues);\n            body = new Uint8Array(w.toArray());\n        }\n        else {\n            body = new Uint8Array(taggedBEEF.beef);\n        }\n        const response = await fetch(`${url}/submit`, {\n            method: 'POST',\n            headers,\n            body\n        });\n        if (response.ok) {\n            return await response.json();\n        }\n        else {\n            throw new Error('Failed to facilitate broadcast');\n        }\n    }\n}\nexports.HTTPSOverlayBroadcastFacilitator = HTTPSOverlayBroadcastFacilitator;\n/**\n * Broadcasts transactions to one or more overlay topics.\n */\nclass TopicBroadcaster {\n    /**\n     * Constructs an instance of the SHIP broadcaster.\n     *\n     * @param {string[]} topics - The list of SHIP topic names where transactions are to be sent.\n     * @param {SHIPBroadcasterConfig} config - Configuration options for the SHIP broadcaster.\n     */\n    constructor(topics, config = {}) {\n        if (topics.length === 0) {\n            throw new Error('At least one topic is required for broadcast.');\n        }\n        if (topics.some((x) => !x.startsWith('tm_'))) {\n            throw new Error('Every topic must start with \"tm_\".');\n        }\n        this.topics = topics;\n        this.networkPreset = config.networkPreset ?? 'mainnet';\n        this.facilitator = config.facilitator ?? new HTTPSOverlayBroadcastFacilitator(undefined, this.networkPreset === 'local');\n        this.resolver = config.resolver ?? new LookupResolver_js_1.default({ networkPreset: this.networkPreset });\n        this.requireAcknowledgmentFromAllHostsForTopics =\n            config.requireAcknowledgmentFromAllHostsForTopics ?? [];\n        this.requireAcknowledgmentFromAnyHostForTopics =\n            config.requireAcknowledgmentFromAnyHostForTopics ?? 'all';\n        this.requireAcknowledgmentFromSpecificHostsForTopics =\n            config.requireAcknowledgmentFromSpecificHostsForTopics ?? {};\n    }\n    /**\n     * Broadcasts a transaction to Overlay Services via SHIP.\n     *\n     * @param {Transaction} tx - The transaction to be sent.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        let beef;\n        const offChainValues = tx.metadata.get('OffChainValues');\n        try {\n            beef = tx.toBEEF();\n        }\n        catch (error) {\n            throw new Error('Transactions sent via SHIP to Overlay Services must be serializable to BEEF format.');\n        }\n        const interestedHosts = await this.findInterestedHosts();\n        if (Object.keys(interestedHosts).length === 0) {\n            return {\n                status: 'error',\n                code: 'ERR_NO_HOSTS_INTERESTED',\n                description: `No ${this.networkPreset} hosts are interested in receiving this transaction.`\n            };\n        }\n        const hostPromises = Object.entries(interestedHosts).map(async ([host, topics]) => {\n            try {\n                const steak = await this.facilitator.send(host, {\n                    beef,\n                    offChainValues,\n                    topics: [...topics]\n                });\n                if (steak == null || Object.keys(steak).length === 0) {\n                    throw new Error('Steak has no topics.');\n                }\n                return { host, success: true, steak };\n            }\n            catch (error) {\n                console.error(error);\n                // Log error if needed\n                return { host, success: false, error };\n            }\n        });\n        const results = await Promise.all(hostPromises);\n        const successfulHosts = results.filter((result) => result.success);\n        if (successfulHosts.length === 0) {\n            return {\n                status: 'error',\n                code: 'ERR_ALL_HOSTS_REJECTED',\n                description: `All ${this.networkPreset} topical hosts have rejected the transaction.`\n            };\n        }\n        // Collect host acknowledgments\n        const hostAcknowledgments = {};\n        for (const result of successfulHosts) {\n            const host = result.host;\n            const steak = result.steak;\n            const acknowledgedTopics = new Set();\n            for (const [topic, instructions] of Object.entries(steak)) {\n                const outputsToAdmit = instructions.outputsToAdmit;\n                const coinsToRetain = instructions.coinsToRetain;\n                const coinsRemoved = instructions.coinsRemoved;\n                if (outputsToAdmit?.length > 0 ||\n                    coinsToRetain?.length > 0 ||\n                    coinsRemoved?.length > 0) {\n                    acknowledgedTopics.add(topic);\n                }\n            }\n            hostAcknowledgments[host] = acknowledgedTopics;\n        }\n        // Now, perform the checks\n        // Check requireAcknowledgmentFromAllHostsForTopics\n        let requiredTopicsAllHosts;\n        let requireAllHosts;\n        if (this.requireAcknowledgmentFromAllHostsForTopics === 'all') {\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'all';\n        }\n        else if (this.requireAcknowledgmentFromAllHostsForTopics === 'any') {\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'any';\n        }\n        else if (Array.isArray(this.requireAcknowledgmentFromAllHostsForTopics)) {\n            requiredTopicsAllHosts = this.requireAcknowledgmentFromAllHostsForTopics;\n            requireAllHosts = 'all';\n        }\n        else {\n            // Default to 'all' and 'all'\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'all';\n        }\n        if (requiredTopicsAllHosts.length > 0) {\n            const allHostsAcknowledged = this.checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopicsAllHosts, requireAllHosts);\n            if (!allHostsAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_ALL_HOSTS_FAILED',\n                    description: 'Not all hosts acknowledged the required topics.'\n                };\n            }\n        }\n        // Check requireAcknowledgmentFromAnyHostForTopics\n        let requiredTopicsAnyHost;\n        let requireAnyHost;\n        if (this.requireAcknowledgmentFromAnyHostForTopics === 'all') {\n            requiredTopicsAnyHost = this.topics;\n            requireAnyHost = 'all';\n        }\n        else if (this.requireAcknowledgmentFromAnyHostForTopics === 'any') {\n            requiredTopicsAnyHost = this.topics;\n            requireAnyHost = 'any';\n        }\n        else if (Array.isArray(this.requireAcknowledgmentFromAnyHostForTopics)) {\n            requiredTopicsAnyHost = this.requireAcknowledgmentFromAnyHostForTopics;\n            requireAnyHost = 'all';\n        }\n        else {\n            // No requirement\n            requiredTopicsAnyHost = [];\n            requireAnyHost = 'all';\n        }\n        if (requiredTopicsAnyHost.length > 0) {\n            const anyHostAcknowledged = this.checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopicsAnyHost, requireAnyHost);\n            if (!anyHostAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_ANY_HOST_FAILED',\n                    description: 'No host acknowledged the required topics.'\n                };\n            }\n        }\n        // Check requireAcknowledgmentFromSpecificHostsForTopics\n        if (Object.keys(this.requireAcknowledgmentFromSpecificHostsForTopics).length >\n            0) {\n            const specificHostsAcknowledged = this.checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, this.requireAcknowledgmentFromSpecificHostsForTopics);\n            if (!specificHostsAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_SPECIFIC_HOSTS_FAILED',\n                    description: 'Specific hosts did not acknowledge the required topics.'\n                };\n            }\n        }\n        // If all checks pass, return success\n        return {\n            status: 'success',\n            txid: tx.id('hex'),\n            message: `Sent to ${successfulHosts.length} Overlay Services ${successfulHosts.length === 1 ? 'host' : 'hosts'}.`\n        };\n    }\n    checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopics, require) {\n        for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n            if (require === 'all') {\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        return false;\n                    }\n                }\n            }\n            else if (require === 'any') {\n                let anyAcknowledged = false;\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        anyAcknowledged = true;\n                        break;\n                    }\n                }\n                if (!anyAcknowledged) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopics, require) {\n        if (require === 'all') {\n            // All required topics must be acknowledged by at least one host\n            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n                let acknowledgesAllRequiredTopics = true;\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        acknowledgesAllRequiredTopics = false;\n                        break;\n                    }\n                }\n                if (acknowledgesAllRequiredTopics) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            // At least one required topic must be acknowledged by at least one host\n            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, requirements) {\n        for (const [host, requiredTopicsOrAllAny] of Object.entries(requirements)) {\n            const acknowledgedTopics = hostAcknowledgments[host];\n            if (acknowledgedTopics == null) {\n                // Host did not respond successfully\n                return false;\n            }\n            let requiredTopics;\n            let require;\n            if (requiredTopicsOrAllAny === 'all' ||\n                requiredTopicsOrAllAny === 'any') {\n                require = requiredTopicsOrAllAny;\n                requiredTopics = this.topics;\n            }\n            else if (Array.isArray(requiredTopicsOrAllAny)) {\n                requiredTopics = requiredTopicsOrAllAny;\n                require = 'all';\n            }\n            else {\n                // Invalid configuration\n                continue;\n            }\n            if (require === 'all') {\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        return false;\n                    }\n                }\n            }\n            else if (require === 'any') {\n                let anyAcknowledged = false;\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        anyAcknowledged = true;\n                        break;\n                    }\n                }\n                if (!anyAcknowledged) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Finds which hosts are interested in transactions tagged with the given set of topics.\n     *\n     * @returns A mapping of URLs for hosts interested in this transaction. Keys are URLs, values are which of our topics the specific host cares about.\n     */\n    async findInterestedHosts() {\n        // Handle the local network preset\n        if (this.networkPreset === 'local') {\n            const resultSet = new Set();\n            for (let i = 0; i < this.topics.length; i++) {\n                resultSet.add(this.topics[i]);\n            }\n            return { 'http://localhost:8080': resultSet };\n        }\n        // TODO: cache the list of interested hosts to avoid spamming SHIP trackers.\n        // TODO: Monetize the operation of the SHIP tracker system.\n        // TODO: Cache ship/slap lookup with expiry (every 5min)\n        // Find all SHIP advertisements for the topics we care about\n        const results = {};\n        const answer = await this.resolver.query({\n            service: 'ls_ship',\n            query: {\n                topics: this.topics\n            }\n        }, MAX_SHIP_QUERY_TIMEOUT);\n        if (answer.type !== 'output-list') {\n            throw new Error('SHIP answer is not an output list.');\n        }\n        for (const output of answer.outputs) {\n            try {\n                const tx = index_js_1.Transaction.fromBEEF(output.beef);\n                const script = tx.outputs[output.outputIndex].lockingScript;\n                const parsed = OverlayAdminTokenTemplate_js_1.default.decode(script);\n                if (!this.topics.includes(parsed.topicOrService) ||\n                    parsed.protocol !== 'SHIP') {\n                    // This should make us think a LOT less highly of this SHIP tracker if it ever happens...\n                    continue;\n                }\n                if (results[parsed.domain] === undefined) {\n                    results[parsed.domain] = new Set();\n                }\n                results[parsed.domain].add(parsed.topicOrService);\n            }\n            catch (e) {\n                continue;\n            }\n        }\n        return results;\n    }\n}\nexports[\"default\"] = TopicBroadcaster;\n//# sourceMappingURL=SHIPBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHIPCast = exports.SHIPBroadcaster = exports.TopicBroadcaster = exports.LookupResolver = exports.OverlayAdminTokenTemplate = void 0;\n__exportStar(__webpack_require__(/*! ./LookupResolver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SHIPBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js\"), exports);\nvar OverlayAdminTokenTemplate_js_1 = __webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/OverlayAdminTokenTemplate.js\");\nObject.defineProperty(exports, \"OverlayAdminTokenTemplate\", ({ enumerable: true, get: function () { return __importDefault(OverlayAdminTokenTemplate_js_1).default; } }));\nvar LookupResolver_js_1 = __webpack_require__(/*! ./LookupResolver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/LookupResolver.js\");\nObject.defineProperty(exports, \"LookupResolver\", ({ enumerable: true, get: function () { return __importDefault(LookupResolver_js_1).default; } }));\n// For intuitive clarity, we name this the Topic Broadcaster.\nvar SHIPBroadcaster_js_1 = __webpack_require__(/*! ./SHIPBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js\");\nObject.defineProperty(exports, \"TopicBroadcaster\", ({ enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_1).default; } }));\n// Historically, it was also known by two other names:\nvar SHIPBroadcaster_js_2 = __webpack_require__(/*! ./SHIPBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js\");\nObject.defineProperty(exports, \"SHIPBroadcaster\", ({ enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_2).default; } }));\nvar SHIPBroadcaster_js_3 = __webpack_require__(/*! ./SHIPBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/SHIPBroadcaster.js\");\nObject.defineProperty(exports, \"SHIPCast\", ({ enumerable: true, get: function () { return __importDefault(SHIPBroadcaster_js_3).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/AESGCM.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/AESGCM.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AESGCMDecrypt = exports.AESGCM = exports.ghash = exports.incrementLeastSignificantThirtyTwoBits = exports.multiply = exports.rightShift = exports.exclusiveOR = exports.getBytes = exports.checkBit = exports.AES = void 0;\n// @ts-nocheck\nconst SBox = new Uint8Array([\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n]);\nconst Rcon = [\n    [0x00, 0x00, 0x00, 0x00], [0x01, 0x00, 0x00, 0x00], [0x02, 0x00, 0x00, 0x00], [0x04, 0x00, 0x00, 0x00],\n    [0x08, 0x00, 0x00, 0x00], [0x10, 0x00, 0x00, 0x00], [0x20, 0x00, 0x00, 0x00], [0x40, 0x00, 0x00, 0x00],\n    [0x80, 0x00, 0x00, 0x00], [0x1b, 0x00, 0x00, 0x00], [0x36, 0x00, 0x00, 0x00]\n].map(v => new Uint8Array(v));\nconst mul2 = new Uint8Array(256);\nconst mul3 = new Uint8Array(256);\nfor (let i = 0; i < 256; i++) {\n    const m2 = ((i << 1) ^ ((i & 0x80) !== 0 ? 0x1b : 0)) & 0xff;\n    mul2[i] = m2;\n    mul3[i] = m2 ^ i;\n}\nfunction addRoundKey(state, roundKeyArray, offset) {\n    for (let c = 0; c < 4; c++) {\n        const keyCol = roundKeyArray[offset + c];\n        for (let r = 0; r < 4; r++) {\n            state[r][c] ^= keyCol[r];\n        }\n    }\n}\nfunction subBytes(state) {\n    for (let r = 0; r < 4; r++) {\n        for (let c = 0; c < 4; c++) {\n            state[r][c] = SBox[state[r][c]];\n        }\n    }\n}\nfunction subWord(value) {\n    for (let i = 0; i < 4; i++) {\n        value[i] = SBox[value[i]];\n    }\n}\nfunction rotWord(value) {\n    const temp = value[0];\n    value[0] = value[1];\n    value[1] = value[2];\n    value[2] = value[3];\n    value[3] = temp;\n}\nfunction shiftRows(state) {\n    let tmp = state[1][0];\n    state[1][0] = state[1][1];\n    state[1][1] = state[1][2];\n    state[1][2] = state[1][3];\n    state[1][3] = tmp;\n    tmp = state[2][0];\n    const tmp2 = state[2][1];\n    state[2][0] = state[2][2];\n    state[2][1] = state[2][3];\n    state[2][2] = tmp;\n    state[2][3] = tmp2;\n    tmp = state[3][3];\n    state[3][3] = state[3][2];\n    state[3][2] = state[3][1];\n    state[3][1] = state[3][0];\n    state[3][0] = tmp;\n}\nfunction mixColumns(state) {\n    for (let c = 0; c < 4; c++) {\n        const s0 = state[0][c];\n        const s1 = state[1][c];\n        const s2 = state[2][c];\n        const s3 = state[3][c];\n        state[0][c] = mul2[s0] ^ mul3[s1] ^ s2 ^ s3;\n        state[1][c] = s0 ^ mul2[s1] ^ mul3[s2] ^ s3;\n        state[2][c] = s0 ^ s1 ^ mul2[s2] ^ mul3[s3];\n        state[3][c] = mul3[s0] ^ s1 ^ s2 ^ mul2[s3];\n    }\n}\nfunction keyExpansion(roundLimit, key) {\n    const nK = key.length / 4;\n    const result = [];\n    for (let i = 0; i < key.length; i++) {\n        if (i % 4 === 0)\n            result.push([]);\n        result[i >> 2].push(key[i]);\n    }\n    for (let i = nK; i < 4 * roundLimit; i++) {\n        result[i] = [];\n        const temp = result[i - 1].slice();\n        if (i % nK === 0) {\n            rotWord(temp);\n            subWord(temp);\n            const r = Rcon[i / nK];\n            for (let j = 0; j < 4; j++) {\n                temp[j] ^= r[j];\n            }\n        }\n        else if (nK > 6 && (i % nK) === 4) {\n            subWord(temp);\n        }\n        for (let j = 0; j < 4; j++) {\n            result[i][j] = result[i - nK][j] ^ temp[j];\n        }\n    }\n    return result;\n}\nfunction AES(input, key) {\n    let i;\n    let j;\n    let round;\n    let roundLimit;\n    const state = [[], [], [], []];\n    const output = [];\n    // Since the BigNumber representation of keys ignores big endian zeroes,\n    // extend incoming key arrays with zeros to the smallest standard key size.\n    const ekey = Array.from(key);\n    if (ekey.length <= 16) {\n        while (ekey.length < 16)\n            ekey.unshift(0);\n        roundLimit = 11;\n    }\n    else if (ekey.length <= 24) {\n        while (ekey.length < 24)\n            ekey.unshift(0);\n        roundLimit = 13;\n    }\n    else if (key.length <= 32) {\n        while (ekey.length < 32)\n            ekey.unshift(0);\n        roundLimit = 15;\n    }\n    else {\n        throw new Error('Illegal key length: ' + String(key.length));\n    }\n    const w = keyExpansion(roundLimit, ekey);\n    for (let c = 0; c < 4; c++) {\n        state[0][c] = input[c * 4];\n        state[1][c] = input[c * 4 + 1];\n        state[2][c] = input[c * 4 + 2];\n        state[3][c] = input[c * 4 + 3];\n    }\n    addRoundKey(state, w, 0);\n    for (round = 1; round < roundLimit; round++) {\n        subBytes(state);\n        shiftRows(state);\n        if (round + 1 < roundLimit) {\n            mixColumns(state);\n        }\n        addRoundKey(state, w, round * 4);\n    }\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            output.push(state[j][i]);\n        }\n    }\n    return output;\n}\nexports.AES = AES;\nconst checkBit = function (byteArray, byteIndex, bitIndex) {\n    return (byteArray[byteIndex] & (0x01 << bitIndex)) !== 0 ? 1 : 0;\n};\nexports.checkBit = checkBit;\nconst getBytes = function (numericValue) {\n    return [\n        (numericValue & 0xFF000000) >>> 24,\n        (numericValue & 0x00FF0000) >> 16,\n        (numericValue & 0x0000FF00) >> 8,\n        numericValue & 0x000000FF\n    ];\n};\nexports.getBytes = getBytes;\nconst createZeroBlock = function (length) {\n    return new Array(length).fill(0);\n};\nconst R = [0xe1].concat(createZeroBlock(15));\nconst exclusiveOR = function (block0, block1) {\n    const len = block0.length;\n    const result = new Array(len);\n    for (let i = 0; i < len; i++) {\n        result[i] = block0[i] ^ block1[i];\n    }\n    return result;\n};\nexports.exclusiveOR = exclusiveOR;\nconst xorInto = function (target, block) {\n    for (let i = 0; i < target.length; i++) {\n        target[i] ^= block[i];\n    }\n};\nconst rightShift = function (block) {\n    let i;\n    let carry = 0;\n    let oldCarry = 0;\n    for (i = 0; i < block.length; i++) {\n        oldCarry = carry;\n        carry = block[i] & 0x01;\n        block[i] = block[i] >> 1;\n        if (oldCarry !== 0) {\n            block[i] = block[i] | 0x80;\n        }\n    }\n    return block;\n};\nexports.rightShift = rightShift;\nconst multiply = function (block0, block1) {\n    const v = block1.slice();\n    const z = createZeroBlock(16);\n    for (let i = 0; i < 16; i++) {\n        for (let j = 7; j >= 0; j--) {\n            if ((block0[i] & (1 << j)) !== 0) {\n                xorInto(z, v);\n            }\n            if ((v[15] & 1) !== 0) {\n                (0, exports.rightShift)(v);\n                xorInto(v, R);\n            }\n            else {\n                (0, exports.rightShift)(v);\n            }\n        }\n    }\n    return z;\n};\nexports.multiply = multiply;\nconst incrementLeastSignificantThirtyTwoBits = function (block) {\n    let i;\n    const result = block.slice();\n    for (i = 15; i !== 11; i--) {\n        result[i] = result[i] + 1;\n        if (result[i] === 256) {\n            result[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n};\nexports.incrementLeastSignificantThirtyTwoBits = incrementLeastSignificantThirtyTwoBits;\nfunction ghash(input, hashSubKey) {\n    let result = createZeroBlock(16);\n    for (let i = 0; i < input.length; i += 16) {\n        const block = result.slice();\n        for (let j = 0; j < 16; j++) {\n            block[j] ^= input[i + j] ?? 0;\n        }\n        result = (0, exports.multiply)(block, hashSubKey);\n    }\n    return result;\n}\nexports.ghash = ghash;\nfunction gctr(input, initialCounterBlock, key) {\n    if (input.length === 0)\n        return [];\n    const output = new Array(input.length);\n    let counterBlock = initialCounterBlock;\n    let pos = 0;\n    const n = Math.ceil(input.length / 16);\n    for (let i = 0; i < n; i++) {\n        const counter = AES(counterBlock, key);\n        const chunk = Math.min(16, input.length - pos);\n        for (let j = 0; j < chunk; j++) {\n            output[pos] = input[pos] ^ counter[j];\n            pos++;\n        }\n        if (i + 1 < n) {\n            counterBlock = (0, exports.incrementLeastSignificantThirtyTwoBits)(counterBlock);\n        }\n    }\n    return output;\n}\nfunction AESGCM(plainText, additionalAuthenticatedData, initializationVector, key) {\n    let preCounterBlock;\n    let plainTag;\n    const hashSubKey = AES(createZeroBlock(16), key);\n    preCounterBlock = [...initializationVector];\n    if (initializationVector.length === 12) {\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);\n    }\n    else {\n        if (initializationVector.length % 16 !== 0) {\n            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));\n        }\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));\n        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4))\n            .concat((0, exports.getBytes)(initializationVector.length * 8)), hashSubKey);\n    }\n    const cipherText = gctr(plainText, (0, exports.incrementLeastSignificantThirtyTwoBits)(preCounterBlock), key);\n    plainTag = additionalAuthenticatedData.slice();\n    if (additionalAuthenticatedData.length === 0) {\n        plainTag = plainTag.concat(createZeroBlock(16));\n    }\n    else if (additionalAuthenticatedData.length % 16 !== 0) {\n        plainTag = plainTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));\n    }\n    plainTag = plainTag.concat(cipherText);\n    if (cipherText.length === 0) {\n        plainTag = plainTag.concat(createZeroBlock(16));\n    }\n    else if (cipherText.length % 16 !== 0) {\n        plainTag = plainTag.concat(createZeroBlock(16 - (cipherText.length % 16)));\n    }\n    plainTag = plainTag.concat(createZeroBlock(4))\n        .concat((0, exports.getBytes)(additionalAuthenticatedData.length * 8))\n        .concat(createZeroBlock(4)).concat((0, exports.getBytes)(cipherText.length * 8));\n    return {\n        result: cipherText,\n        authenticationTag: gctr(ghash(plainTag, hashSubKey), preCounterBlock, key)\n    };\n}\nexports.AESGCM = AESGCM;\nfunction AESGCMDecrypt(cipherText, additionalAuthenticatedData, initializationVector, authenticationTag, key) {\n    let preCounterBlock;\n    let compareTag;\n    // Generate the hash subkey\n    const hashSubKey = AES(createZeroBlock(16), key);\n    preCounterBlock = [...initializationVector];\n    if (initializationVector.length === 12) {\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);\n    }\n    else {\n        if (initializationVector.length % 16 !== 0) {\n            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));\n        }\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));\n        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4)).concat((0, exports.getBytes)(initializationVector.length * 8)), hashSubKey);\n    }\n    // Decrypt to obtain the plain text\n    const plainText = gctr(cipherText, (0, exports.incrementLeastSignificantThirtyTwoBits)(preCounterBlock), key);\n    compareTag = additionalAuthenticatedData.slice();\n    if (additionalAuthenticatedData.length === 0) {\n        compareTag = compareTag.concat(createZeroBlock(16));\n    }\n    else if (additionalAuthenticatedData.length % 16 !== 0) {\n        compareTag = compareTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));\n    }\n    compareTag = compareTag.concat(cipherText);\n    if (cipherText.length === 0) {\n        compareTag = compareTag.concat(createZeroBlock(16));\n    }\n    else if (cipherText.length % 16 !== 0) {\n        compareTag = compareTag.concat(createZeroBlock(16 - (cipherText.length % 16)));\n    }\n    compareTag = compareTag.concat(createZeroBlock(4))\n        .concat((0, exports.getBytes)(additionalAuthenticatedData.length * 8))\n        .concat(createZeroBlock(4)).concat((0, exports.getBytes)(cipherText.length * 8));\n    // Generate the authentication tag\n    const calculatedTag = gctr(ghash(compareTag, hashSubKey), preCounterBlock, key);\n    // If the calculated tag does not match the provided tag, return null - the decryption failed.\n    if (calculatedTag.join() !== authenticationTag.join()) {\n        return null;\n    }\n    return plainText;\n}\nexports.AESGCMDecrypt = AESGCMDecrypt;\n//# sourceMappingURL=AESGCM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/AESGCM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/BasePoint.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/BasePoint.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\n/**\n * Base class for Point (affine coordinates) and JacobianPoint classes,\n * defining their curve and type.\n */\nclass BasePoint {\n    constructor(type) {\n        this.curve = new Curve_js_1.default(); // Always initialized, so never null\n        this.type = type;\n        this.precomputed = null;\n    }\n}\nexports[\"default\"] = BasePoint;\n//# sourceMappingURL=BasePoint.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/BasePoint.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on\n * 256-bit cryptography, this BigNumber class enables operations on larger\n * numbers.\n *\n * @class BigNumber\n */\nclass BigNumber {\n    /**\n     * Negative flag. Indicates whether the big number is a negative number.\n     * - If 0, the number is positive.\n     * - If 1, the number is negative.\n     *\n     * @property negative\n     */\n    get negative() {\n        return this._sign;\n    }\n    /**\n     * Sets the negative flag. Only 0 (positive) or 1 (negative) are allowed.\n     */\n    set negative(val) {\n        this.assert(val === 0 || val === 1, 'Negative property must be 0 or 1');\n        const newSign = val === 1 ? 1 : 0;\n        if (this._magnitude === 0n) {\n            this._sign = 0;\n        }\n        else {\n            this._sign = newSign;\n        }\n    }\n    get _computedWordsArray() {\n        if (this._magnitude === 0n)\n            return [0];\n        const arr = [];\n        let temp = this._magnitude;\n        while (temp > 0n) {\n            arr.push(Number(temp & BigNumber.WORD_MASK));\n            temp >>= BigNumber.WORD_SIZE_BIGINT;\n        }\n        return arr.length > 0 ? arr : [0];\n    }\n    /**\n     * Array of numbers, where each number represents a part of the value of the big number.\n     *\n     * @property words\n     */\n    get words() {\n        const computed = this._computedWordsArray;\n        if (this._nominalWordLength <= computed.length) {\n            return computed;\n        }\n        const paddedWords = new Array(this._nominalWordLength).fill(0);\n        for (let i = 0; i < computed.length; i++) {\n            paddedWords[i] = computed[i];\n        }\n        return paddedWords;\n    }\n    /**\n     * Sets the words array representing the value of the big number.\n     */\n    set words(newWords) {\n        const oldSign = this._sign;\n        let newMagnitude = 0n;\n        const len = newWords.length > 0 ? newWords.length : 1;\n        for (let i = len - 1; i >= 0; i--) {\n            const wordVal = newWords[i] === undefined ? 0 : newWords[i];\n            newMagnitude = (newMagnitude << BigNumber.WORD_SIZE_BIGINT) | BigInt(wordVal & Number(BigNumber.WORD_MASK));\n        }\n        this._magnitude = newMagnitude;\n        this._sign = oldSign;\n        this._nominalWordLength = len;\n        this.normSign();\n    }\n    /**\n     * Length of the words array.\n     *\n     * @property length\n     */\n    get length() {\n        return Math.max(1, this._nominalWordLength);\n    }\n    /**\n     * Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.\n     *\n     * @method isBN\n     * @param num - The value to be checked.\n     * @returns - Returns a boolean value determining whether or not the checked num parameter is a BigNumber.\n     */\n    static isBN(num) {\n        if (num instanceof BigNumber)\n            return true;\n        return (num !== null &&\n            typeof num === 'object' &&\n            num.constructor?.wordSize === BigNumber.wordSize &&\n            Array.isArray(num.words));\n    }\n    /**\n     * Returns the bigger value between two BigNumbers\n     *\n     * @method max\n     * @param left - The first BigNumber to be compared.\n     * @param right - The second BigNumber to be compared.\n     * @returns - Returns the bigger BigNumber between left and right.\n     */\n    static max(left, right) { return left.cmp(right) > 0 ? left : right; }\n    /**\n     * Returns the smaller value between two BigNumbers\n     *\n     * @method min\n     * @param left - The first BigNumber to be compared.\n     * @param right - The second BigNumber to be compared.\n     * @returns - Returns the smaller value between left and right.\n     */\n    static min(left, right) { return left.cmp(right) < 0 ? left : right; }\n    /**\n     * @constructor\n     *\n     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.\n     * @param base - The base of number provided. By default is 10.\n     * @param endian - The endianness provided. By default is 'big endian'.\n     */\n    constructor(number = 0, base = 10, endian = 'be') {\n        this._magnitude = 0n;\n        this._sign = 0;\n        this._nominalWordLength = 1;\n        this.red = null;\n        if (number === undefined)\n            number = 0;\n        if (number === null) {\n            this._initializeState(0n, 0);\n            return;\n        }\n        if (typeof number === 'bigint') {\n            this._initializeState(number < 0n ? -number : number, number < 0n ? 1 : 0);\n            this.normSign();\n            return;\n        }\n        let effectiveBase = base;\n        let effectiveEndian = endian;\n        if (base === 'le' || base === 'be') {\n            effectiveEndian = base;\n            effectiveBase = 10;\n        }\n        if (typeof number === 'number') {\n            this.initNumber(number, effectiveEndian);\n            return;\n        }\n        if (Array.isArray(number)) {\n            this.initArray(number, effectiveEndian);\n            return;\n        }\n        if (typeof number === 'string') {\n            if (effectiveBase === 'hex')\n                effectiveBase = 16;\n            this.assert(typeof effectiveBase === 'number' && effectiveBase === (effectiveBase | 0) && effectiveBase >= 2 && effectiveBase <= 36, 'Base must be an integer between 2 and 36');\n            const originalNumberStr = number.toString().replace(/\\s+/g, '');\n            let start = 0;\n            let sign = 0;\n            if (originalNumberStr.startsWith('-')) {\n                start++;\n                sign = 1;\n            }\n            else if (originalNumberStr.startsWith('+')) {\n                start++;\n            }\n            const numStr = originalNumberStr.substring(start);\n            if (numStr.length === 0) {\n                this._initializeState(0n, (sign === 1 && originalNumberStr.startsWith('-')) ? 1 : 0);\n                this.normSign();\n                return;\n            }\n            if (effectiveBase === 16) {\n                let tempMagnitude;\n                if (effectiveEndian === 'le') {\n                    const bytes = [];\n                    let hexStr = numStr;\n                    if (hexStr.length % 2 !== 0)\n                        hexStr = '0' + hexStr;\n                    for (let i = 0; i < hexStr.length; i += 2) {\n                        const byteHex = hexStr.substring(i, i + 2);\n                        const byteVal = parseInt(byteHex, 16);\n                        if (isNaN(byteVal))\n                            throw new Error('Invalid character in ' + hexStr);\n                        bytes.push(byteVal);\n                    }\n                    this.initArray(bytes, 'le');\n                    this._sign = sign;\n                    this.normSign();\n                    return;\n                }\n                else {\n                    try {\n                        tempMagnitude = BigInt('0x' + numStr);\n                    }\n                    catch (e) {\n                        throw new Error('Invalid character in ' + numStr);\n                    }\n                }\n                this._initializeState(tempMagnitude, sign);\n                this.normSign();\n            }\n            else {\n                try {\n                    this._parseBaseString(numStr, effectiveBase);\n                    this._sign = sign;\n                    this.normSign();\n                    if (effectiveEndian === 'le') {\n                        const currentSign = this._sign;\n                        this.initArray(this.toArray('be'), 'le');\n                        this._sign = currentSign;\n                        this.normSign();\n                    }\n                }\n                catch (err) {\n                    const error = err;\n                    if (error.message.includes('Invalid character in string') ||\n                        error.message.includes('Invalid digit for base') ||\n                        error.message.startsWith('Invalid character:')) {\n                        throw new Error('Invalid character');\n                    }\n                    throw error;\n                }\n            }\n        }\n        else if (number !== 0) {\n            this.assert(false, 'Unsupported input type for BigNumber constructor');\n        }\n        else {\n            this._initializeState(0n, 0);\n        }\n    }\n    _bigIntToStringInBase(num, base) {\n        if (num === 0n)\n            return '0';\n        if (base < 2 || base > 36)\n            throw new Error('Base must be between 2 and 36');\n        const digits = '0123456789abcdefghijklmnopqrstuvwxyz';\n        let result = '';\n        let currentNum = num > 0n ? num : -num;\n        const bigBase = BigInt(base);\n        while (currentNum > 0n) {\n            result = digits[Number(currentNum % bigBase)] + result;\n            currentNum /= bigBase;\n        }\n        return result;\n    }\n    _parseBaseString(numberStr, base) {\n        if (numberStr.length === 0) {\n            this._magnitude = 0n;\n            this._finishInitialization();\n            return;\n        }\n        this._magnitude = 0n;\n        const bigBase = BigInt(base);\n        let groupSize = BigNumber.groupSizes[base];\n        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);\n        if (groupSize === 0 || groupBaseBigInt === 0n) {\n            groupSize = Math.floor(Math.log(0x3ffffff) / Math.log(base));\n            if (groupSize === 0)\n                groupSize = 1;\n            groupBaseBigInt = bigBase ** BigInt(groupSize);\n        }\n        let currentPos = 0;\n        const totalLen = numberStr.length;\n        let firstChunkLen = totalLen % groupSize;\n        if (firstChunkLen === 0 && totalLen > 0)\n            firstChunkLen = groupSize;\n        if (firstChunkLen > 0) {\n            const chunkStr = numberStr.substring(currentPos, currentPos + firstChunkLen);\n            this._magnitude = BigInt(this._parseBaseWord(chunkStr, base));\n            currentPos += firstChunkLen;\n        }\n        while (currentPos < totalLen) {\n            const chunkStr = numberStr.substring(currentPos, currentPos + groupSize);\n            const wordVal = BigInt(this._parseBaseWord(chunkStr, base));\n            this._magnitude = this._magnitude * groupBaseBigInt + wordVal;\n            currentPos += groupSize;\n        }\n        this._finishInitialization();\n    }\n    _parseBaseWord(str, base) {\n        let r = 0;\n        for (let i = 0; i < str.length; i++) {\n            const charCode = str.charCodeAt(i);\n            let digitVal;\n            if (charCode >= 48 && charCode <= 57)\n                digitVal = charCode - 48;\n            else if (charCode >= 65 && charCode <= 90)\n                digitVal = charCode - 65 + 10;\n            else if (charCode >= 97 && charCode <= 122)\n                digitVal = charCode - 97 + 10;\n            else\n                throw new Error('Invalid character: ' + str[i]);\n            if (digitVal >= base)\n                throw new Error('Invalid character');\n            r = r * base + digitVal;\n        }\n        return r;\n    }\n    _initializeState(magnitude, sign) {\n        this._magnitude = magnitude;\n        this._sign = (magnitude === 0n) ? 0 : sign;\n        this._finishInitialization();\n    }\n    _finishInitialization() {\n        if (this._magnitude === 0n) {\n            this._nominalWordLength = 1;\n            this._sign = 0;\n        }\n        else {\n            const bitLen = this._magnitude.toString(2).length;\n            this._nominalWordLength = Math.max(1, Math.ceil(bitLen / BigNumber.wordSize));\n        }\n    }\n    assert(val, msg = 'Assertion failed') { if (!val)\n        throw new Error(msg); }\n    initNumber(number, endian = 'be') {\n        this.assert(BigInt(Math.abs(number)) <= BigNumber.MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT, 'The number is larger than 2 ^ 53 (unsafe)');\n        this.assert(number % 1 === 0, 'Number must be an integer for BigNumber conversion');\n        this._initializeState(BigInt(Math.abs(number)), number < 0 ? 1 : 0);\n        if (endian === 'le') {\n            const currentSign = this._sign;\n            const beBytes = this.toArray('be');\n            this.initArray(beBytes, 'le');\n            this._sign = currentSign;\n            this.normSign();\n        }\n        return this;\n    }\n    initArray(bytes, endian) {\n        if (bytes.length === 0) {\n            this._initializeState(0n, 0);\n            return this;\n        }\n        let magnitude = 0n;\n        if (endian === 'be') {\n            for (let i = 0; i < bytes.length; i++)\n                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);\n        }\n        else {\n            for (let i = bytes.length - 1; i >= 0; i--)\n                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);\n        }\n        this._initializeState(magnitude, 0);\n        return this;\n    }\n    copy(dest) { dest._magnitude = this._magnitude; dest._sign = this._sign; dest._nominalWordLength = this._nominalWordLength; dest.red = this.red; }\n    static move(dest, src) { dest._magnitude = src._magnitude; dest._sign = src._sign; dest._nominalWordLength = src._nominalWordLength; dest.red = src.red; }\n    clone() { const r = new BigNumber(0n); this.copy(r); return r; }\n    expand(size) {\n        this.assert(size >= 0, 'Expand size must be non-negative');\n        this._nominalWordLength = Math.max(this._nominalWordLength, size, 1);\n        return this;\n    }\n    strip() { this._finishInitialization(); return this.normSign(); }\n    normSign() { if (this._magnitude === 0n)\n        this._sign = 0; return this; }\n    inspect() { return (this.red !== null ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'; }\n    _getMinimalHex() {\n        if (this._magnitude === 0n)\n            return '0';\n        return this._magnitude.toString(16);\n    }\n    /**\n     * Converts the BigNumber instance to a string representation.\n     *\n     * @method toString\n     * @param base - The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.\n     * @param padding - Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.\n     * @returns The string representation of the BigNumber instance\n     */\n    toString(base = 10, padding = 1) {\n        if (base === 16 || base === 'hex') {\n            // For toString('hex', N), N is the 'multiple-of-N characters' rule from bn.js tests\n            // For toString(16, P) where P=1 (default) or P=0, it means minimal hex.\n            let hexStr = this._getMinimalHex(); // e.g., \"f\", \"123\", \"0\"\n            if (padding > 1) { // N-multiple rule for characters\n                // Ensure hexStr is even length if not \"0\" to represent full bytes before applying multiple rule\n                if (hexStr !== '0' && hexStr.length % 2 !== 0) {\n                    hexStr = '0' + hexStr;\n                }\n                while (hexStr.length % padding !== 0) {\n                    hexStr = '0' + hexStr;\n                }\n            }\n            // If padding is 0 or 1, hexStr (minimal) is used as is.\n            // \"0\" is always \"0\" unless toHex(\"\") specific case.\n            // Single digit hex like \"f\" is not \"0f\" by default from toString(16).\n            return (this.isNeg() ? '-' : '') + hexStr;\n        }\n        if (typeof base !== 'number' || base < 2 || base > 36 || base % 1 !== 0)\n            throw new Error('Base should be an integer between 2 and 36');\n        return this.toBaseString(base, padding);\n    }\n    toBaseString(base, padding) {\n        if (this._magnitude === 0n) {\n            let out = '0';\n            if (padding > 1) {\n                while (out.length < padding)\n                    out = '0' + out;\n            }\n            return out;\n        }\n        let groupSize = BigNumber.groupSizes[base];\n        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);\n        if (groupSize === 0 || groupBaseBigInt === 0n) {\n            groupSize = Math.floor(Math.log(Number.MAX_SAFE_INTEGER) / Math.log(base));\n            if (groupSize === 0)\n                groupSize = 1;\n            groupBaseBigInt = BigInt(base) ** BigInt(groupSize);\n        }\n        let out = '';\n        let tempMag = this._magnitude;\n        while (tempMag > 0n) {\n            const remainder = tempMag % groupBaseBigInt;\n            tempMag /= groupBaseBigInt;\n            const chunkStr = this._bigIntToStringInBase(remainder, base);\n            if (tempMag > 0n) {\n                const zerosToPrepend = groupSize - chunkStr.length;\n                if (zerosToPrepend > 0 && zerosToPrepend < BigNumber.zeros.length) {\n                    out = BigNumber.zeros[zerosToPrepend] + chunkStr + out;\n                }\n                else if (zerosToPrepend > 0) {\n                    out = '0'.repeat(zerosToPrepend) + chunkStr + out;\n                }\n                else {\n                    out = chunkStr + out;\n                }\n            }\n            else {\n                out = chunkStr + out;\n            }\n        }\n        if (padding > 0) {\n            while (out.length < padding)\n                out = '0' + out;\n        }\n        return (this._sign === 1 ? '-' : '') + out;\n    }\n    /**\n     * Converts the BigNumber instance to a JavaScript number.\n     * Please note that JavaScript numbers are only precise up to 53 bits.\n     *\n     * @method toNumber\n     * @throws If the BigNumber instance cannot be safely stored in a JavaScript number\n     * @returns The JavaScript number representation of the BigNumber instance.\n     */\n    toNumber() {\n        const val = this._getSignedValue();\n        if (val > BigNumber.MAX_SAFE_INTEGER_BIGINT || val < BigNumber.MIN_SAFE_INTEGER_BIGINT)\n            throw new Error('Number can only safely store up to 53 bits');\n        return Number(val);\n    }\n    /**\n     * Converts the BigNumber instance to a JSON-formatted string.\n     *\n     * @method toJSON\n     * @returns The JSON string representation of the BigNumber instance.\n     */\n    toJSON() {\n        const hex = this._getMinimalHex();\n        return (this.isNeg() ? '-' : '') + hex;\n    }\n    toArrayLikeGeneric(res, isLE) {\n        let tempMag = this._magnitude;\n        let position = isLE ? 0 : res.length - 1;\n        const increment = isLE ? 1 : -1;\n        for (let k = 0; k < res.length; ++k) {\n            if (tempMag === 0n && position >= 0 && position < res.length) {\n                res[position] = 0;\n            }\n            else if (position >= 0 && position < res.length) {\n                res[position] = Number(tempMag & 0xffn);\n            }\n            else {\n                break;\n            }\n            tempMag >>= 8n;\n            position += increment;\n        }\n    }\n    /**\n     * Converts the BigNumber instance to an array of bytes.\n     *\n     * @method toArray\n     * @param endian - Endianness of the output array, defaults to 'be'.\n     * @param length - Optional length of the output array.\n     * @returns Array of bytes representing the BigNumber.\n     */\n    toArray(endian = 'be', length) {\n        this.strip();\n        const actualByteLength = this.byteLength();\n        const reqLength = length ?? Math.max(1, actualByteLength);\n        this.assert(actualByteLength <= reqLength, 'byte array longer than desired length');\n        this.assert(reqLength > 0, 'Requested array length <= 0');\n        const res = new Array(reqLength).fill(0);\n        if (this._magnitude === 0n && reqLength > 0)\n            return res;\n        if (this._magnitude === 0n && reqLength === 0)\n            return [];\n        this.toArrayLikeGeneric(res, endian === 'le');\n        return res;\n    }\n    /**\n     * Calculates the number of bits required to represent the BigNumber.\n     *\n     * @method bitLength\n     * @returns The bit length of the BigNumber.\n     */\n    bitLength() { if (this._magnitude === 0n)\n        return 0; return this._magnitude.toString(2).length; }\n    /**\n     * Converts a BigNumber to an array of bits.\n     *\n     * @method toBitArray\n     * @param num - The BigNumber to convert.\n     * @returns An array of bits.\n     */\n    static toBitArray(num) {\n        const len = num.bitLength();\n        if (len === 0)\n            return [];\n        const w = new Array(len);\n        const mag = num._magnitude;\n        for (let bit = 0; bit < len; bit++) {\n            w[bit] = ((mag >> BigInt(bit)) & 1n) !== 0n ? 1 : 0;\n        }\n        return w;\n    }\n    /**\n     * Instance version of {@link toBitArray}.\n     */\n    toBitArray() { return BigNumber.toBitArray(this); }\n    /**\n     * Returns the number of trailing zero bits in the big number.\n     *\n     * @method zeroBits\n     * @returns Returns the number of trailing zero bits\n     * in the binary representation of the big number.\n     *\n     * @example\n     * const bn = new BigNumber('8'); // binary: 1000\n     * const zeroBits = bn.zeroBits(); // 3\n     */\n    zeroBits() {\n        if (this._magnitude === 0n)\n            return 0;\n        let c = 0;\n        let t = this._magnitude;\n        while ((t & 1n) === 0n && t !== 0n) {\n            c++;\n            t >>= 1n;\n        }\n        return c;\n    }\n    /**\n     * Calculates the number of bytes required to represent the BigNumber.\n     *\n     * @method byteLength\n     * @returns The byte length of the BigNumber.\n     */\n    byteLength() { if (this._magnitude === 0n)\n        return 0; return Math.ceil(this.bitLength() / 8); }\n    _getSignedValue() { return this._sign === 1 ? -this._magnitude : this._magnitude; }\n    _setValueFromSigned(sVal) {\n        if (sVal < 0n) {\n            this._magnitude = -sVal;\n            this._sign = 1;\n        }\n        else {\n            this._magnitude = sVal;\n            this._sign = 0;\n        }\n        this._finishInitialization();\n        this.normSign();\n    }\n    toTwos(width) {\n        this.assert(width >= 0);\n        const Bw = BigInt(width);\n        let v = this._getSignedValue();\n        if (this._sign === 1 && this._magnitude !== 0n)\n            v = (1n << Bw) + v;\n        const m = (1n << Bw) - 1n;\n        v &= m;\n        const r = new BigNumber(0n);\n        r._initializeState(v, 0);\n        return r;\n    }\n    fromTwos(width) {\n        this.assert(width >= 0);\n        const Bw = BigInt(width);\n        const m = this._magnitude;\n        if (width > 0 && ((m >> (Bw - 1n)) & 1n) !== 0n && this._sign === 0) {\n            const sVal = m - (1n << Bw);\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(sVal);\n            return r;\n        }\n        return this.clone();\n    }\n    isNeg() { return this._sign === 1 && this._magnitude !== 0n; }\n    neg() { return this.clone().ineg(); }\n    ineg() { if (this._magnitude !== 0n)\n        this._sign = this._sign === 1 ? 0 : 1; return this; }\n    _iuop(num, op) {\n        const newMag = op(this._magnitude, num._magnitude);\n        const isXor = op === ((a, b) => a ^ b);\n        let targetNominalLength = this._nominalWordLength;\n        if (isXor)\n            targetNominalLength = Math.max(this.length, num.length);\n        this._magnitude = newMag;\n        this._finishInitialization();\n        if (isXor)\n            this._nominalWordLength = Math.max(this._nominalWordLength, targetNominalLength);\n        return this.strip();\n    }\n    iuor(num) { return this._iuop(num, (a, b) => a | b); }\n    iuand(num) { return this._iuop(num, (a, b) => a & b); }\n    iuxor(num) { return this._iuop(num, (a, b) => a ^ b); }\n    _iop(num, op) { this.assert(this._sign === 0 && num._sign === 0); return this._iuop(num, op); }\n    ior(num) { return this._iop(num, (a, b) => a | b); }\n    iand(num) { return this._iop(num, (a, b) => a & b); }\n    ixor(num) { return this._iop(num, (a, b) => a ^ b); }\n    _uop_new(num, opName) { if (this.length >= num.length)\n        return this.clone()[opName](num); return num.clone()[opName](this); }\n    or(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuor'); }\n    uor(num) { return this._uop_new(num, 'iuor'); }\n    and(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuand'); }\n    uand(num) { return this._uop_new(num, 'iuand'); }\n    xor(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuxor'); }\n    uxor(num) { return this._uop_new(num, 'iuxor'); }\n    inotn(width) {\n        this.assert(typeof width === 'number' && width >= 0);\n        const Bw = BigInt(width);\n        const m = (1n << Bw) - 1n;\n        this._magnitude = (~this._magnitude) & m;\n        const wfw = width === 0 ? 1 : Math.ceil(width / BigNumber.wordSize);\n        this._nominalWordLength = Math.max(1, wfw);\n        this.strip();\n        this._nominalWordLength = Math.max(this._nominalWordLength, Math.max(1, wfw));\n        return this;\n    }\n    notn(width) { return this.clone().inotn(width); }\n    setn(bit, val) { this.assert(typeof bit === 'number' && bit >= 0); const Bb = BigInt(bit); if (val === 1 || val === true)\n        this._magnitude |= (1n << Bb);\n    else\n        this._magnitude &= ~(1n << Bb); const wnb = Math.floor(bit / BigNumber.wordSize) + 1; this._nominalWordLength = Math.max(this._nominalWordLength, wnb); this._finishInitialization(); return this.strip(); }\n    iadd(num) { this._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return this; }\n    add(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return r; }\n    isub(num) { this._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return this; }\n    sub(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return r; }\n    mul(num) {\n        const r = new BigNumber(0n);\n        r._magnitude = this._magnitude * num._magnitude;\n        r._sign = r._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        r._nominalWordLength = this.length + num.length;\n        r.red = null;\n        return r.normSign();\n    }\n    imul(num) {\n        this._magnitude *= num._magnitude;\n        this._sign = this._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        this._nominalWordLength = this.length + num.length;\n        this.red = null;\n        return this.normSign();\n    }\n    imuln(num) { this.assert(typeof num === 'number', 'Assertion failed'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() * BigInt(num)); return this; }\n    muln(num) { return this.clone().imuln(num); }\n    sqr() {\n        const r = new BigNumber(0n);\n        r._magnitude = this._magnitude * this._magnitude;\n        r._sign = 0;\n        r._nominalWordLength = this.length * 2;\n        r.red = null;\n        return r;\n    }\n    isqr() {\n        this._magnitude *= this._magnitude;\n        this._sign = 0;\n        this._nominalWordLength = this.length * 2;\n        this.red = null;\n        return this;\n    }\n    pow(num) {\n        this.assert(num._sign === 0, 'Exponent for pow must be non-negative');\n        if (num.isZero())\n            return new BigNumber(1n);\n        const res = new BigNumber(1n);\n        const currentBase = this.clone();\n        const exp = num.clone();\n        const baseIsNegative = currentBase.isNeg();\n        const expIsOdd = exp.isOdd();\n        if (baseIsNegative)\n            currentBase.ineg();\n        while (!exp.isZero()) {\n            if (exp.isOdd()) {\n                res.imul(currentBase);\n            }\n            currentBase.isqr();\n            exp.iushrn(1);\n        }\n        if (baseIsNegative && expIsOdd) {\n            res.ineg();\n        }\n        return res;\n    }\n    iushln(bits) { this.assert(typeof bits === 'number' && bits >= 0); if (bits === 0)\n        return this; this._magnitude <<= BigInt(bits); this._finishInitialization(); return this.strip(); }\n    ishln(bits) { this.assert(this._sign === 0, 'ishln requires positive number'); return this.iushln(bits); }\n    iushrn(bits, hint, extended) {\n        this.assert(typeof bits === 'number' && bits >= 0);\n        if (bits === 0) {\n            if (extended != null)\n                extended._initializeState(0n, 0);\n            return this;\n        }\n        if (extended != null) {\n            const m = (1n << BigInt(bits)) - 1n;\n            const sOut = this._magnitude & m;\n            extended._initializeState(sOut, 0);\n        }\n        this._magnitude >>= BigInt(bits);\n        this._finishInitialization();\n        return this.strip();\n    }\n    ishrn(bits, hint, extended) {\n        this.assert(this._sign === 0, 'ishrn requires positive number');\n        return this.iushrn(bits, hint, extended);\n    }\n    shln(bits) { return this.clone().ishln(bits); }\n    ushln(bits) { return this.clone().iushln(bits); }\n    shrn(bits) { return this.clone().ishrn(bits); }\n    ushrn(bits) { return this.clone().iushrn(bits); }\n    testn(bit) {\n        this.assert(typeof bit === 'number' && bit >= 0);\n        return ((this._magnitude >> BigInt(bit)) & 1n) !== 0n;\n    }\n    imaskn(bits) {\n        this.assert(typeof bits === 'number' && bits >= 0);\n        this.assert(this._sign === 0, 'imaskn works only with positive numbers');\n        const Bb = BigInt(bits);\n        const m = Bb === 0n ? 0n : (1n << Bb) - 1n;\n        this._magnitude &= m;\n        const wfm = bits === 0 ? 1 : Math.max(1, Math.ceil(bits / BigNumber.wordSize));\n        this._nominalWordLength = wfm;\n        this._finishInitialization();\n        this._nominalWordLength = Math.max(this._nominalWordLength, wfm);\n        return this.strip();\n    }\n    maskn(bits) { return this.clone().imaskn(bits); }\n    iaddn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large'); this._setValueFromSigned(this._getSignedValue() + BigInt(num)); return this; }\n    _iaddn(num) { return this.iaddn(num); }\n    isubn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() - BigInt(num)); return this; }\n    addn(num) { return this.clone().iaddn(num); }\n    subn(num) { return this.clone().isubn(num); }\n    iabs() { this._sign = 0; return this; }\n    abs() { return this.clone().iabs(); }\n    divmod(num, mode, positive) {\n        this.assert(!num.isZero(), 'Division by zero');\n        if (this.isZero()) {\n            const z = new BigNumber(0n);\n            return { div: mode !== 'mod' ? z : null, mod: mode !== 'div' ? z : null };\n        }\n        const tV = this._getSignedValue();\n        const nV = num._getSignedValue();\n        let dV = null;\n        let mV = null;\n        if (mode !== 'mod')\n            dV = tV / nV;\n        if (mode !== 'div') {\n            mV = tV % nV;\n            if (positive === true && mV < 0n)\n                mV += nV < 0n ? -nV : nV;\n        }\n        const rd = dV !== null ? new BigNumber(0n) : null;\n        if (rd !== null && dV !== null)\n            rd._setValueFromSigned(dV);\n        const rm = mV !== null ? new BigNumber(0n) : null;\n        if (rm !== null && mV !== null)\n            rm._setValueFromSigned(mV);\n        return { div: rd, mod: rm };\n    }\n    div(num) {\n        return this.divmod(num, 'div', false).div;\n    }\n    mod(num) {\n        return this.divmod(num, 'mod', false).mod;\n    }\n    umod(num) {\n        return this.divmod(num, 'mod', true).mod;\n    }\n    divRound(num) {\n        this.assert(!num.isZero());\n        const tV = this._getSignedValue();\n        const nV = num._getSignedValue();\n        let d = tV / nV;\n        const m = tV % nV;\n        if (m === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(d);\n            return r;\n        }\n        const absM = m < 0n ? -m : m;\n        const absNV = nV < 0n ? -nV : nV;\n        if (absM * 2n >= absNV) {\n            if ((tV > 0n && nV > 0n) || (tV < 0n && nV < 0n)) {\n                d += 1n;\n            }\n            else {\n                d -= 1n;\n            }\n        }\n        const r = new BigNumber(0n);\n        r._setValueFromSigned(d);\n        return r;\n    }\n    modrn(numArg) {\n        this.assert(numArg !== 0, 'Division by zero in modrn');\n        const absDivisor = BigInt(Math.abs(numArg));\n        if (absDivisor === 0n)\n            throw new Error('Division by zero in modrn');\n        const remainderMag = this._magnitude % absDivisor;\n        return numArg < 0 ? Number(-remainderMag) : Number(remainderMag);\n    }\n    idivn(num) {\n        this.assert(num !== 0);\n        this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large');\n        this._setValueFromSigned(this._getSignedValue() / BigInt(num));\n        return this;\n    }\n    divn(num) { return this.clone().idivn(num); }\n    egcd(p) {\n        this.assert(p._sign === 0, 'p must not be negative');\n        this.assert(!p.isZero(), 'p must not be zero');\n        let uV = this._getSignedValue();\n        let vV = p._magnitude;\n        let a = 1n;\n        let pa = 0n;\n        let b = 0n;\n        let pb = 1n;\n        while (vV !== 0n) {\n            const q = uV / vV;\n            let t = vV;\n            vV = uV % vV;\n            uV = t;\n            t = pa;\n            pa = a - q * pa;\n            a = t;\n            t = pb;\n            pb = b - q * pb;\n            b = t;\n        }\n        const ra = new BigNumber(0n);\n        ra._setValueFromSigned(a);\n        const rb = new BigNumber(0n);\n        rb._setValueFromSigned(b);\n        const rg = new BigNumber(0n);\n        rg._initializeState(uV < 0n ? -uV : uV, 0);\n        return { a: ra, b: rb, gcd: rg };\n    }\n    gcd(num) {\n        let u = this._magnitude;\n        let v = num._magnitude;\n        if (u === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(v);\n            return r.iabs();\n        }\n        if (v === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(u);\n            return r.iabs();\n        }\n        while (v !== 0n) {\n            const t = u % v;\n            u = v;\n            v = t;\n        }\n        const res = new BigNumber(0n);\n        res._initializeState(u, 0);\n        return res;\n    }\n    invm(num) {\n        this.assert(!num.isZero() && num._sign === 0, 'Modulus for invm must be positive and non-zero');\n        const eg = this.egcd(num);\n        if (!eg.gcd.eqn(1)) {\n            throw new Error('Inverse does not exist (numbers are not coprime).');\n        }\n        return eg.a.umod(num);\n    }\n    isEven() { return this._magnitude % 2n === 0n; }\n    isOdd() { return this._magnitude % 2n === 1n; }\n    andln(num) { this.assert(num >= 0); return Number(this._magnitude & BigInt(num)); }\n    bincn(bit) { this.assert(typeof bit === 'number' && bit >= 0); const BVal = 1n << BigInt(bit); this._setValueFromSigned(this._getSignedValue() + BVal); return this; }\n    isZero() { return this._magnitude === 0n; }\n    cmpn(num) { this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Number is too big'); const tV = this._getSignedValue(); const nV = BigInt(num); if (tV < nV)\n        return -1; if (tV > nV)\n        return 1; return 0; }\n    cmp(num) { const tV = this._getSignedValue(); const nV = num._getSignedValue(); if (tV < nV)\n        return -1; if (tV > nV)\n        return 1; return 0; }\n    ucmp(num) { if (this._magnitude < num._magnitude)\n        return -1; if (this._magnitude > num._magnitude)\n        return 1; return 0; }\n    gtn(num) { return this.cmpn(num) === 1; }\n    gt(num) { return this.cmp(num) === 1; }\n    gten(num) { return this.cmpn(num) >= 0; }\n    gte(num) { return this.cmp(num) >= 0; }\n    ltn(num) { return this.cmpn(num) === -1; }\n    lt(num) { return this.cmp(num) === -1; }\n    lten(num) { return this.cmpn(num) <= 0; }\n    lte(num) { return this.cmp(num) <= 0; }\n    eqn(num) { return this.cmpn(num) === 0; }\n    eq(num) { return this.cmp(num) === 0; }\n    toRed(ctx) { this.assert(this.red == null, 'Already a number in reduction context'); this.assert(this._sign === 0, 'toRed works only with positives'); return ctx.convertTo(this).forceRed(ctx); }\n    fromRed() { this.assert(this.red, 'fromRed works only with numbers in reduction context'); return this.red.convertFrom(this); }\n    forceRed(ctx) { this.red = ctx; return this; }\n    redAdd(num) { this.assert(this.red, 'redAdd works only with red numbers'); return this.red.add(this, num); }\n    redIAdd(num) { this.assert(this.red, 'redIAdd works only with red numbers'); return this.red.iadd(this, num); }\n    redSub(num) { this.assert(this.red, 'redSub works only with red numbers'); return this.red.sub(this, num); }\n    redISub(num) { this.assert(this.red, 'redISub works only with red numbers'); return this.red.isub(this, num); }\n    redShl(num) { this.assert(this.red, 'redShl works only with red numbers'); return this.red.shl(this, num); }\n    redMul(num) { this.assert(this.red, 'redMul works only with red numbers'); this.red.verify2(this, num); return this.red.mul(this, num); }\n    redIMul(num) { this.assert(this.red, 'redIMul works only with red numbers'); this.red.verify2(this, num); return this.red.imul(this, num); }\n    redSqr() { this.assert(this.red, 'redSqr works only with red numbers'); this.red.verify1(this); return this.red.sqr(this); }\n    redISqr() { this.assert(this.red, 'redISqr works only with red numbers'); this.red.verify1(this); return this.red.isqr(this); }\n    redSqrt() { this.assert(this.red, 'redSqrt works only with red numbers'); this.red.verify1(this); return this.red.sqrt(this); }\n    redInvm() { this.assert(this.red, 'redInvm works only with red numbers'); this.red.verify1(this); return this.red.invm(this); }\n    redNeg() { this.assert(this.red, 'redNeg works only with red numbers'); this.red.verify1(this); return this.red.neg(this); }\n    redPow(num) { this.assert(this.red != null && num.red == null, 'redPow(normalNum)'); this.red.verify1(this); return this.red.pow(this, num); }\n    /**\n     * Creates a BigNumber from a hexadecimal string.\n     *\n     * @static\n     * @method fromHex\n     * @param hex - The hexadecimal string to create a BigNumber from.\n     * @param endian - Optional endianness for parsing the hex string.\n     * @returns Returns a BigNumber created from the hexadecimal input string.\n     *\n     * @example\n     * const exampleHex = 'a1b2c3';\n     * const bigNumber = BigNumber.fromHex(exampleHex);\n     */\n    static fromHex(hex, endian) {\n        let eE = 'be';\n        if (endian === 'little' || endian === 'le')\n            eE = 'le';\n        return new BigNumber(hex, 16, eE);\n    }\n    /**\n     * Converts this BigNumber to a hexadecimal string.\n     *\n     * @method toHex\n     * @param length - The minimum length of the hex string\n     * @returns Returns a string representing the hexadecimal value of this BigNumber.\n     *\n     * @example\n     * const bigNumber = new BigNumber(255)\n     * const hex = bigNumber.toHex()\n     */\n    toHex(byteLength = 0) {\n        if (this.isZero() && byteLength === 0)\n            return '';\n        let hexStr = this._getMinimalHex(); // Raw hex: \"0\", \"f\", \"10\", \"123\"\n        // Ensure even length for non-zero values (byte alignment)\n        if (hexStr !== '0' && hexStr.length % 2 !== 0) {\n            hexStr = '0' + hexStr;\n        }\n        // Pad to minimum character length (byteLength * 2)\n        const minChars = byteLength * 2;\n        while (hexStr.length < minChars) {\n            hexStr = '0' + hexStr;\n        }\n        return (this.isNeg() ? '-' : '') + hexStr;\n    }\n    /**\n     * Creates a BigNumber from a JSON-serialized string.\n     *\n     * @static\n     * @method fromJSON\n     * @param str - The JSON-serialized string to create a BigNumber from.\n     * @returns Returns a BigNumber created from the JSON input string.\n     */\n    static fromJSON(str) { return new BigNumber(str, 16); }\n    /**\n     * Creates a BigNumber from a number.\n     *\n     * @static\n     * @method fromNumber\n     * @param n - The number to create a BigNumber from.\n     * @returns Returns a BigNumber equivalent to the input number.\n     */\n    static fromNumber(n) { return new BigNumber(n); }\n    /**\n     * Creates a BigNumber from a string, considering an optional base.\n     *\n     * @static\n     * @method fromString\n     * @param str - The string to create a BigNumber from.\n     * @param base - The base used for conversion. If not provided, base 10 is assumed.\n     * @returns Returns a BigNumber equivalent to the string after conversion from the specified base.\n     */\n    static fromString(str, base) { return new BigNumber(str, base); }\n    /**\n     * Creates a BigNumber from a signed magnitude number.\n     *\n     * @static\n     * @method fromSm\n     * @param bytes - The signed magnitude number to convert to a BigNumber.\n     * @param endian - Defines endianess. If not provided, big endian is assumed.\n     * @returns Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.\n     */\n    static fromSm(bytes, endian = 'big') {\n        if (bytes.length === 0)\n            return new BigNumber(0n);\n        let sign = 0;\n        let hex = '';\n        if (endian === 'little') {\n            const last = bytes.length - 1;\n            let firstByte = bytes[last];\n            if ((firstByte & 0x80) !== 0) {\n                sign = 1;\n                firstByte &= 0x7f;\n            }\n            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);\n            for (let i = last - 1; i >= 0; i--) {\n                const b = bytes[i];\n                hex += (b < 16 ? '0' : '') + b.toString(16);\n            }\n        }\n        else {\n            let firstByte = bytes[0];\n            if ((firstByte & 0x80) !== 0) {\n                sign = 1;\n                firstByte &= 0x7f;\n            }\n            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);\n            for (let i = 1; i < bytes.length; i++) {\n                const b = bytes[i];\n                hex += (b < 16 ? '0' : '') + b.toString(16);\n            }\n        }\n        const mag = hex === '' ? 0n : BigInt('0x' + hex);\n        const r = new BigNumber(0n);\n        r._initializeState(mag, sign);\n        return r;\n    }\n    /**\n     * Converts this BigNumber to a signed magnitude number.\n     *\n     * @method toSm\n     * @param endian - Defines endianess. If not provided, big endian is assumed.\n     * @returns Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.\n     */\n    toSm(endian = 'big') {\n        if (this._magnitude === 0n) {\n            return this._sign === 1 ? [0x80] : [];\n        }\n        let hex = this._getMinimalHex();\n        if (hex.length % 2 !== 0)\n            hex = '0' + hex;\n        const byteLen = hex.length / 2;\n        const bytes = new Array(byteLen);\n        for (let i = 0, j = 0; i < hex.length; i += 2) {\n            bytes[j++] = parseInt(hex.slice(i, i + 2), 16);\n        }\n        if (this._sign === 1) {\n            if ((bytes[0] & 0x80) !== 0)\n                bytes.unshift(0x80);\n            else\n                bytes[0] |= 0x80;\n        }\n        else if ((bytes[0] & 0x80) !== 0) {\n            bytes.unshift(0x00);\n        }\n        return endian === 'little' ? bytes.reverse() : bytes;\n    }\n    /**\n     * Creates a BigNumber from a number representing the \"bits\" value in a block header.\n     *\n     * @static\n     * @method fromBits\n     * @param bits - The number representing the bits value in a block header.\n     * @param strict - If true, an error is thrown if the number has negative bit set.\n     * @returns Returns a BigNumber equivalent to the \"bits\" value in a block header.\n     * @throws Will throw an error if `strict` is `true` and the number has negative bit set.\n     */\n    static fromBits(bits, strict = false) {\n        const nSize = bits >>> 24;\n        const nWordCompact = bits & 0x007fffff;\n        const isNegativeFromBit = (bits & 0x00800000) !== 0;\n        if (strict && isNegativeFromBit) {\n            throw new Error('negative bit set');\n        }\n        if (nSize === 0 && nWordCompact === 0) {\n            if (isNegativeFromBit && strict)\n                throw new Error('negative bit set for zero value');\n            return new BigNumber(0n);\n        }\n        const bn = new BigNumber(nWordCompact);\n        // This logic comes from original bn.js `fromCompact`\n        if (nSize <= 3) {\n            bn.iushrn((3 - nSize) * 8);\n        }\n        else {\n            bn.iushln((nSize - 3) * 8);\n        }\n        if (isNegativeFromBit) {\n            bn.ineg();\n        }\n        return bn;\n    }\n    /**\n     * Converts this BigNumber to a number representing the \"bits\" value in a block header.\n     *\n     * @method toBits\n     * @returns Returns a number equivalent to the \"bits\" value in a block header.\n     */\n    toBits() {\n        this.strip();\n        if (this.isZero() && !this.isNeg())\n            return 0;\n        const isActualNegative = this.isNeg();\n        const bnAbs = this.abs(); // Work with absolute value for magnitude\n        // Get byte array of absolute value\n        let mB = bnAbs.toArray('be'); // Minimal byte array\n        // Remove leading zeros from byte array, if any (toArray('be') might already do this if no length specified)\n        let firstNonZeroIdx = 0;\n        while (firstNonZeroIdx < mB.length - 1 && mB[firstNonZeroIdx] === 0) { // Keep last byte if it's [0]\n            firstNonZeroIdx++;\n        }\n        mB = mB.slice(firstNonZeroIdx);\n        let nSize = mB.length;\n        if (nSize === 0 && !bnAbs.isZero()) { // Should not happen if bnAbs is truly non-zero and toArray is correct\n            mB = [0]; // Should not be needed if toArray works for small numbers\n            nSize = 1;\n        }\n        if (bnAbs.isZero()) { // if original was, e.g., -0, bnAbs is 0.\n            nSize = 0; // Size for 0 is 0, unless it's negative 0 to be encoded\n            mB = [];\n        }\n        let nWordNum;\n        if (nSize === 0) {\n            nWordNum = 0;\n        }\n        else if (nSize <= 3) {\n            nWordNum = 0;\n            for (let i = 0; i < nSize; i++) {\n                nWordNum = (nWordNum << 8) | mB[i];\n            }\n        }\n        else { // nSize > 3\n            nWordNum = (mB[0] << 16) | (mB[1] << 8) | mB[2];\n        }\n        if ((nWordNum & 0x00800000) !== 0 && nSize <= 0xff) { // MSB of 3-byte mantissa is set\n            nWordNum >>>= 8; // Shift mantissa over by one byte\n            nSize++; // Increase size component by one\n        }\n        let b = (nSize << 24) | nWordNum;\n        if (isActualNegative)\n            b |= 0x00800000;\n        return b >>> 0;\n    }\n    /**\n     * Creates a BigNumber from the format used in Bitcoin scripts.\n     *\n     * @static\n     * @method fromScriptNum\n     * @param num - The number in the format used in Bitcoin scripts.\n     * @param requireMinimal - If true, non-minimally encoded values will throw an error.\n     * @param maxNumSize - The maximum allowed size for the number.\n     * @returns Returns a BigNumber equivalent to the number used in a Bitcoin script.\n     */\n    static fromScriptNum(num, requireMinimal = false, maxNumSize) {\n        if (maxNumSize !== undefined && num.length > maxNumSize)\n            throw new Error('script number overflow');\n        if (num.length === 0)\n            return new BigNumber(0n);\n        if (requireMinimal) {\n            if ((num[num.length - 1] & 0x7f) === 0) {\n                if (num.length <= 1 || (num[num.length - 2] & 0x80) === 0) {\n                    throw new Error('non-minimally encoded script number');\n                }\n            }\n        }\n        return BigNumber.fromSm(num, 'little');\n    }\n    /**\n     * Converts this BigNumber to a number in the format used in Bitcoin scripts.\n     *\n     * @method toScriptNum\n     * @returns Returns the equivalent to this BigNumber as a Bitcoin script number.\n     */\n    toScriptNum() { return this.toSm('little'); }\n    /**\n     * Compute the multiplicative inverse of the current BigNumber in the modulus field specified by `p`.\n     * The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.\n     *\n     * @method _invmp\n     * @param p - The `BigNumber` specifying the modulus field.\n     * @returns The multiplicative inverse `BigNumber` in the modulus field specified by `p`.\n     */\n    _invmp(p) {\n        this.assert(p._sign === 0, 'p must not be negative for _invmp');\n        this.assert(!p.isZero(), 'p must not be zero for _invmp');\n        const aBN = this.umod(p);\n        let aVal = aBN._magnitude;\n        let bVal = p._magnitude;\n        let x1Val = 1n;\n        let x2Val = 0n;\n        const modulus = p._magnitude;\n        while (aVal > 1n && bVal > 1n) {\n            let i = 0;\n            while (((aVal >> BigInt(i)) & 1n) === 0n)\n                i++;\n            if (i > 0) {\n                aVal >>= BigInt(i);\n                for (let k = 0; k < i; ++k) {\n                    if ((x1Val & 1n) !== 0n)\n                        x1Val += modulus;\n                    x1Val >>= 1n;\n                }\n            }\n            let j = 0;\n            while (((bVal >> BigInt(j)) & 1n) === 0n)\n                j++;\n            if (j > 0) {\n                bVal >>= BigInt(j);\n                for (let k = 0; k < j; ++k) {\n                    if ((x2Val & 1n) !== 0n)\n                        x2Val += modulus;\n                    x2Val >>= 1n;\n                }\n            }\n            if (aVal >= bVal) {\n                aVal -= bVal;\n                x1Val -= x2Val;\n            }\n            else {\n                bVal -= aVal;\n                x2Val -= x1Val;\n            }\n        }\n        let resultVal;\n        if (aVal === 1n)\n            resultVal = x1Val;\n        else if (bVal === 1n)\n            resultVal = x2Val;\n        else if (aVal === 0n && bVal === 1n)\n            resultVal = x2Val;\n        else if (bVal === 0n && aVal === 1n)\n            resultVal = x1Val;\n        else\n            throw new Error('_invmp: GCD is not 1, inverse does not exist. aVal=' + aVal + ', bVal=' + bVal);\n        resultVal %= modulus;\n        if (resultVal < 0n)\n            resultVal += modulus;\n        const resultBN = new BigNumber(0n);\n        resultBN._initializeState(resultVal, 0);\n        return resultBN;\n    }\n    /**\n     * Performs multiplication between the BigNumber instance and a given BigNumber.\n     * It chooses the multiplication method based on the lengths of the numbers to optimize execution time.\n     *\n     * @method mulTo\n     * @param num - The BigNumber multiply with.\n     * @param out - The BigNumber where to store the result.\n     * @returns The BigNumber resulting from the multiplication operation.\n     */\n    mulTo(num, out) {\n        out._magnitude = this._magnitude * num._magnitude;\n        out._sign = out._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        out._nominalWordLength = this.length + num.length;\n        out.red = null;\n        out.normSign();\n        return out;\n    }\n}\n/**\n * @privateinitializer\n */\nBigNumber.zeros = [\n    '', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000',\n    '000000000', '0000000000', '00000000000', '000000000000', '0000000000000',\n    '00000000000000', '000000000000000', '0000000000000000', '00000000000000000',\n    '000000000000000000', '0000000000000000000', '00000000000000000000',\n    '000000000000000000000', '0000000000000000000000', '00000000000000000000000',\n    '000000000000000000000000', '0000000000000000000000000'\n];\n/**\n * @privateinitializer\n */\nBigNumber.groupSizes = [\n    0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n];\n/**\n * @privateinitializer\n */\nBigNumber.groupBases = [\n    0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343,\n    7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000,\n    28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n];\n/**\n * The word size of big number chunks.\n *\n * @property wordSize\n *\n * @example\n * console.log(BigNumber.wordSize);  // output: 26\n */\nBigNumber.wordSize = 26;\nBigNumber.WORD_SIZE_BIGINT = BigInt(BigNumber.wordSize);\nBigNumber.WORD_MASK = (1n << BigNumber.WORD_SIZE_BIGINT) - 1n;\nBigNumber.MAX_SAFE_INTEGER_BIGINT = BigInt(Number.MAX_SAFE_INTEGER);\nBigNumber.MIN_SAFE_INTEGER_BIGINT = BigInt(Number.MIN_SAFE_INTEGER);\nBigNumber.MAX_IMULN_ARG = 0x4000000 - 1;\nBigNumber.MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT = (1n << 53n) - 1n;\nexports[\"default\"] = BigNumber;\n//# sourceMappingURL=BigNumber.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst ReductionContext_js_1 = __importDefault(__webpack_require__(/*! ./ReductionContext.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ReductionContext.js\"));\nconst MontgomoryMethod_js_1 = __importDefault(__webpack_require__(/*! ./MontgomoryMethod.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/MontgomoryMethod.js\"));\nconst Point_js_1 = __importDefault(__webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n// This ensures that only one curve is ever created, enhancing performance.\n// This assumes there is never a need to have multiple distinct Curve instances.\n// So far, this assumption has proven to be valid.\nlet globalCurve;\nclass Curve {\n    // Represent num in a w-NAF form\n    static assert(expression, message = 'Elliptic curve assertion failed') {\n        if (!expression) {\n            throw new Error(message);\n        }\n    }\n    getNAF(num, w, bits) {\n        const naf = new Array(Math.max(num.bitLength(), bits) + 1);\n        naf.fill(0);\n        const ws = 1 << (w + 1);\n        const k = num.clone();\n        for (let i = 0; i < naf.length; i++) {\n            let z;\n            const mod = k.andln(ws - 1);\n            if (k.isOdd()) {\n                if (mod > (ws >> 1) - 1) {\n                    z = (ws >> 1) - mod;\n                }\n                else {\n                    z = mod;\n                }\n                k.isubn(z);\n            }\n            else {\n                z = 0;\n            }\n            naf[i] = z;\n            k.iushrn(1);\n        }\n        return naf;\n    }\n    // Represent k1, k2 in a Joint Sparse Form\n    getJSF(k1, k2) {\n        const jsf = [[], []];\n        k1 = k1.clone();\n        k2 = k2.clone();\n        let d1 = 0;\n        let d2 = 0;\n        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n            // First phase\n            let m14 = (k1.andln(3) + d1) & 3;\n            let m24 = (k2.andln(3) + d2) & 3;\n            if (m14 === 3) {\n                m14 = -1;\n            }\n            if (m24 === 3) {\n                m24 = -1;\n            }\n            let u1;\n            if ((m14 & 1) === 0) {\n                u1 = 0;\n            }\n            else {\n                const m8 = (k1.andln(7) + d1) & 7;\n                if ((m8 === 3 || m8 === 5) && m24 === 2) {\n                    u1 = -m14;\n                }\n                else {\n                    u1 = m14;\n                }\n            }\n            jsf[0].push(u1);\n            let u2;\n            if ((m24 & 1) === 0) {\n                u2 = 0;\n            }\n            else {\n                const m8 = (k2.andln(7) + d2) & 7;\n                if ((m8 === 3 || m8 === 5) && m14 === 2) {\n                    u2 = -m24;\n                }\n                else {\n                    u2 = m24;\n                }\n            }\n            jsf[1].push(u2);\n            // Second phase\n            if (2 * d1 === u1 + 1) {\n                d1 = 1 - d1;\n            }\n            if (2 * d2 === u2 + 1) {\n                d2 = 1 - d2;\n            }\n            k1.iushrn(1);\n            k2.iushrn(1);\n        }\n        return jsf;\n    }\n    static cachedProperty(obj, name, computer) {\n        const key = '_' + name;\n        obj.prototype[name] = function cachedProperty() {\n            const r = this[key] !== undefined ? this[key] : (this[key] = computer.call(this));\n            return r;\n        };\n    }\n    static parseBytes(bytes) {\n        return typeof bytes === 'string' ? (0, utils_js_1.toArray)(bytes, 'hex') : bytes;\n    }\n    static intFromLE(bytes) {\n        return new BigNumber_js_1.default(bytes, 'hex', 'le');\n    }\n    constructor() {\n        if (typeof globalCurve !== 'undefined') {\n            return globalCurve;\n        }\n        else {\n            /* eslint-disable @typescript-eslint/no-this-alias */\n            globalCurve = this;\n        }\n        const precomputed = {\n            doubles: {\n                step: 4,\n                points: [\n                    [\n                        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n                        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\n                    ],\n                    [\n                        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n                        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\n                    ],\n                    [\n                        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n                        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\n                    ],\n                    [\n                        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n                        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\n                    ],\n                    [\n                        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n                        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\n                    ],\n                    [\n                        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n                        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\n                    ],\n                    [\n                        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n                        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\n                    ],\n                    [\n                        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n                        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\n                    ],\n                    [\n                        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n                        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\n                    ],\n                    [\n                        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n                        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\n                    ],\n                    [\n                        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n                        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\n                    ],\n                    [\n                        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n                        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\n                    ],\n                    [\n                        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n                        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\n                    ],\n                    [\n                        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n                        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\n                    ],\n                    [\n                        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n                        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\n                    ],\n                    [\n                        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n                        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\n                    ],\n                    [\n                        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n                        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\n                    ],\n                    [\n                        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n                        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\n                    ],\n                    [\n                        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n                        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\n                    ],\n                    [\n                        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n                        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\n                    ],\n                    [\n                        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n                        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\n                    ],\n                    [\n                        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n                        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\n                    ],\n                    [\n                        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n                        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\n                    ],\n                    [\n                        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n                        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\n                    ],\n                    [\n                        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n                        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\n                    ],\n                    [\n                        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n                        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\n                    ],\n                    [\n                        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n                        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\n                    ],\n                    [\n                        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n                        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\n                    ],\n                    [\n                        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n                        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\n                    ],\n                    [\n                        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n                        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\n                    ],\n                    [\n                        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n                        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\n                    ],\n                    [\n                        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n                        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\n                    ],\n                    [\n                        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n                        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\n                    ],\n                    [\n                        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n                        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\n                    ],\n                    [\n                        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n                        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\n                    ],\n                    [\n                        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n                        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\n                    ],\n                    [\n                        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n                        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\n                    ],\n                    [\n                        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n                        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\n                    ],\n                    [\n                        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n                        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\n                    ],\n                    [\n                        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n                        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\n                    ],\n                    [\n                        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n                        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\n                    ],\n                    [\n                        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n                        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\n                    ],\n                    [\n                        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n                        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\n                    ],\n                    [\n                        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n                        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\n                    ],\n                    [\n                        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n                        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\n                    ],\n                    [\n                        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n                        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\n                    ],\n                    [\n                        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n                        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\n                    ],\n                    [\n                        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n                        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\n                    ],\n                    [\n                        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n                        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\n                    ],\n                    [\n                        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n                        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\n                    ],\n                    [\n                        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n                        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\n                    ],\n                    [\n                        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n                        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\n                    ],\n                    [\n                        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n                        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\n                    ],\n                    [\n                        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n                        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\n                    ],\n                    [\n                        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n                        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\n                    ],\n                    [\n                        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n                        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\n                    ],\n                    [\n                        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n                        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\n                    ],\n                    [\n                        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n                        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\n                    ],\n                    [\n                        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n                        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\n                    ],\n                    [\n                        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n                        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\n                    ],\n                    [\n                        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n                        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\n                    ],\n                    [\n                        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n                        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\n                    ],\n                    [\n                        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n                        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\n                    ],\n                    [\n                        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n                        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\n                    ],\n                    [\n                        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n                        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\n                    ]\n                ]\n            },\n            naf: {\n                wnd: 7,\n                points: [\n                    [\n                        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n                        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\n                    ],\n                    [\n                        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n                        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\n                    ],\n                    [\n                        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n                        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\n                    ],\n                    [\n                        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n                        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\n                    ],\n                    [\n                        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n                        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\n                    ],\n                    [\n                        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n                        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\n                    ],\n                    [\n                        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n                        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\n                    ],\n                    [\n                        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n                        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\n                    ],\n                    [\n                        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n                        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\n                    ],\n                    [\n                        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n                        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\n                    ],\n                    [\n                        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n                        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\n                    ],\n                    [\n                        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n                        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\n                    ],\n                    [\n                        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n                        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\n                    ],\n                    [\n                        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n                        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\n                    ],\n                    [\n                        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n                        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\n                    ],\n                    [\n                        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n                        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\n                    ],\n                    [\n                        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n                        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\n                    ],\n                    [\n                        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n                        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\n                    ],\n                    [\n                        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n                        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\n                    ],\n                    [\n                        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n                        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\n                    ],\n                    [\n                        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n                        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\n                    ],\n                    [\n                        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n                        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\n                    ],\n                    [\n                        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n                        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\n                    ],\n                    [\n                        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n                        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\n                    ],\n                    [\n                        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n                        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\n                    ],\n                    [\n                        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n                        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\n                    ],\n                    [\n                        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n                        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\n                    ],\n                    [\n                        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n                        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\n                    ],\n                    [\n                        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n                        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\n                    ],\n                    [\n                        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n                        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\n                    ],\n                    [\n                        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n                        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\n                    ],\n                    [\n                        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n                        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\n                    ],\n                    [\n                        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n                        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\n                    ],\n                    [\n                        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n                        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\n                    ],\n                    [\n                        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n                        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\n                    ],\n                    [\n                        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n                        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\n                    ],\n                    [\n                        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n                        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\n                    ],\n                    [\n                        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n                        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\n                    ],\n                    [\n                        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n                        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\n                    ],\n                    [\n                        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n                        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\n                    ],\n                    [\n                        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n                        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\n                    ],\n                    [\n                        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n                        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\n                    ],\n                    [\n                        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n                        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\n                    ],\n                    [\n                        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n                        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\n                    ],\n                    [\n                        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n                        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\n                    ],\n                    [\n                        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n                        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\n                    ],\n                    [\n                        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n                        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\n                    ],\n                    [\n                        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n                        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\n                    ],\n                    [\n                        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n                        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\n                    ],\n                    [\n                        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n                        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\n                    ],\n                    [\n                        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n                        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\n                    ],\n                    [\n                        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n                        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\n                    ],\n                    [\n                        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n                        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\n                    ],\n                    [\n                        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n                        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\n                    ],\n                    [\n                        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n                        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\n                    ],\n                    [\n                        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n                        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\n                    ],\n                    [\n                        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n                        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\n                    ],\n                    [\n                        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n                        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\n                    ],\n                    [\n                        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n                        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\n                    ],\n                    [\n                        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n                        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\n                    ],\n                    [\n                        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n                        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\n                    ],\n                    [\n                        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n                        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\n                    ],\n                    [\n                        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n                        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\n                    ],\n                    [\n                        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n                        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\n                    ],\n                    [\n                        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n                        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\n                    ],\n                    [\n                        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n                        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\n                    ],\n                    [\n                        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n                        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\n                    ],\n                    [\n                        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n                        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\n                    ],\n                    [\n                        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n                        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\n                    ],\n                    [\n                        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n                        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\n                    ],\n                    [\n                        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n                        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\n                    ],\n                    [\n                        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n                        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\n                    ],\n                    [\n                        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n                        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\n                    ],\n                    [\n                        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n                        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\n                    ],\n                    [\n                        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n                        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\n                    ],\n                    [\n                        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n                        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\n                    ],\n                    [\n                        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n                        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\n                    ],\n                    [\n                        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n                        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\n                    ],\n                    [\n                        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n                        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\n                    ],\n                    [\n                        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n                        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\n                    ],\n                    [\n                        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n                        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\n                    ],\n                    [\n                        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n                        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\n                    ],\n                    [\n                        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n                        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\n                    ],\n                    [\n                        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n                        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\n                    ],\n                    [\n                        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n                        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\n                    ],\n                    [\n                        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n                        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\n                    ],\n                    [\n                        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n                        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\n                    ],\n                    [\n                        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n                        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\n                    ],\n                    [\n                        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n                        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\n                    ],\n                    [\n                        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n                        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\n                    ],\n                    [\n                        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n                        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\n                    ],\n                    [\n                        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n                        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\n                    ],\n                    [\n                        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n                        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\n                    ],\n                    [\n                        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n                        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\n                    ],\n                    [\n                        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n                        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\n                    ],\n                    [\n                        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n                        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\n                    ],\n                    [\n                        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n                        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\n                    ],\n                    [\n                        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n                        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\n                    ],\n                    [\n                        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n                        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\n                    ],\n                    [\n                        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n                        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\n                    ],\n                    [\n                        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n                        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\n                    ],\n                    [\n                        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n                        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\n                    ],\n                    [\n                        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n                        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\n                    ],\n                    [\n                        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n                        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\n                    ],\n                    [\n                        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n                        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\n                    ],\n                    [\n                        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n                        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\n                    ],\n                    [\n                        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n                        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\n                    ],\n                    [\n                        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n                        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\n                    ],\n                    [\n                        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n                        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\n                    ],\n                    [\n                        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n                        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\n                    ],\n                    [\n                        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n                        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\n                    ],\n                    [\n                        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n                        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\n                    ],\n                    [\n                        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n                        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\n                    ],\n                    [\n                        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n                        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\n                    ],\n                    [\n                        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n                        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\n                    ],\n                    [\n                        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n                        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\n                    ],\n                    [\n                        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n                        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\n                    ],\n                    [\n                        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n                        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\n                    ],\n                    [\n                        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n                        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\n                    ],\n                    [\n                        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n                        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\n                    ],\n                    [\n                        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n                        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\n                    ],\n                    [\n                        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n                        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\n                    ],\n                    [\n                        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n                        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\n                    ],\n                    [\n                        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n                        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\n                    ],\n                    [\n                        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n                        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\n                    ],\n                    [\n                        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n                        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\n                    ],\n                    [\n                        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n                        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\n                    ]\n                ]\n            }\n        };\n        const conf = {\n            prime: 'k256',\n            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n            a: '0',\n            b: '7',\n            n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n            h: '1',\n            // Precomputed endomorphism\n            beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n            lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n            basis: [\n                {\n                    a: '3086d221a7d46bcde86c90e49284eb15',\n                    b: '-e4437ed6010e88286f547fa90abfe4c3'\n                },\n                {\n                    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n                    b: '3086d221a7d46bcde86c90e49284eb15'\n                }\n            ],\n            gRed: false,\n            g: [\n                '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n                '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n                precomputed\n            ]\n        };\n        this.p = new BigNumber_js_1.default(conf.p, 16);\n        // Use Montgomery, when there is no fast reduction for the prime\n        this.red = new ReductionContext_js_1.default(conf.prime);\n        // Useful for many curves\n        this.zero = new BigNumber_js_1.default(0).toRed(this.red);\n        this.one = new BigNumber_js_1.default(1).toRed(this.red);\n        this.two = new BigNumber_js_1.default(2).toRed(this.red);\n        // Curve configuration, optional\n        this.n = new BigNumber_js_1.default(conf.n, 16);\n        this.g = Point_js_1.default.fromJSON(conf.g, conf.gRed);\n        // Temporary arrays\n        this._wnafT1 = new Array(4);\n        this._wnafT2 = new Array(4);\n        this._wnafT3 = new Array(4);\n        this._wnafT4 = new Array(4);\n        this._bitLength = this.n.bitLength();\n        this.redN = this.n.toRed(this.red);\n        this.a = new BigNumber_js_1.default(conf.a, 16).toRed(this.red);\n        this.b = new BigNumber_js_1.default(conf.b, 16).toRed(this.red);\n        this.tinv = this.two.redInvm();\n        this.zeroA = this.a.fromRed().cmpn(0) === 0;\n        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n        // If the curve is endomorphic, precalculate beta and lambda\n        this.endo = this._getEndomorphism(conf);\n        this._endoWnafT1 = new Array(4);\n        this._endoWnafT2 = new Array(4);\n    }\n    _getEndomorphism(conf) {\n        // No efficient endomorphism\n        if (!this.zeroA || this.p.modrn(3) !== 1) {\n            return;\n        }\n        // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n        let beta;\n        let lambda;\n        if (conf.beta !== undefined) {\n            beta = new BigNumber_js_1.default(conf.beta, 16).toRed(this.red);\n        }\n        else {\n            const betas = this._getEndoRoots(this.p);\n            if (betas === null) {\n                throw new Error('Failed to get endomorphism roots for beta.');\n            }\n            // Choose the smallest beta\n            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n            beta = beta.toRed(this.red);\n        }\n        if (conf.lambda !== undefined) {\n            lambda = new BigNumber_js_1.default(conf.lambda, 16);\n        }\n        else {\n            // Choose the lambda that matches selected beta\n            const lambdas = this._getEndoRoots(this.n);\n            if (lambdas === null) {\n                throw new Error('Failed to get endomorphism roots for lambda.');\n            }\n            if (this.g == null) {\n                throw new Error('Curve generator point (g) is not defined.');\n            }\n            const gMulX = this.g.mul(lambdas[0])?.x;\n            const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;\n            if ((gMulX != null) && (gXRedMulBeta != null) && gMulX.cmp(gXRedMulBeta) === 0) {\n                lambda = lambdas[0];\n            }\n            else {\n                lambda = lambdas[1];\n                if (this.g == null) {\n                    throw new Error('Curve generator point (g) is not defined.');\n                }\n                const gMulX = this.g.mul(lambda)?.x;\n                const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;\n                if ((gMulX == null) || (gXRedMulBeta == null)) {\n                    throw new Error('Lambda computation failed: g.mul(lambda).x or g.x.redMul(beta) is undefined.');\n                }\n                Curve.assert(gMulX.cmp(gXRedMulBeta) === 0, 'Lambda selection does not match computed beta.');\n            }\n        }\n        // Get basis vectors, used for balanced length-two representation\n        let basis;\n        if (typeof conf.basis === 'object' && conf.basis !== null) {\n            basis = conf.basis.map(function (vec) {\n                return {\n                    a: new BigNumber_js_1.default(vec.a, 16),\n                    b: new BigNumber_js_1.default(vec.b, 16)\n                };\n            });\n        }\n        else {\n            basis = this._getEndoBasis(lambda);\n        }\n        return {\n            beta,\n            lambda,\n            basis\n        };\n    }\n    _getEndoRoots(num) {\n        // Find roots of for x^2 + x + 1 in F\n        // Root = (-1 +- Sqrt(-3)) / 2\n        //\n        const red = num === this.p ? this.red : new MontgomoryMethod_js_1.default(num);\n        const tinv = new BigNumber_js_1.default(2).toRed(red).redInvm();\n        const ntinv = tinv.redNeg();\n        const s = new BigNumber_js_1.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n        const l1 = ntinv.redAdd(s).fromRed();\n        const l2 = ntinv.redSub(s).fromRed();\n        return [l1, l2];\n    }\n    _getEndoBasis(lambda) {\n        // aprxSqrt >= sqrt(this.n)\n        const aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n        // 3.74\n        // Run EGCD, until r(L + 1) < aprxSqrt\n        let u = lambda;\n        let v = this.n.clone();\n        let x1 = new BigNumber_js_1.default(1);\n        let y1 = new BigNumber_js_1.default(0);\n        let x2 = new BigNumber_js_1.default(0);\n        let y2 = new BigNumber_js_1.default(1);\n        // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n        let a0;\n        let b0;\n        // First vector\n        let a1;\n        let b1;\n        // Second vector\n        let a2;\n        let b2;\n        let prevR = new BigNumber_js_1.default(0);\n        let i = 0;\n        let r = new BigNumber_js_1.default(0);\n        let x = new BigNumber_js_1.default(0); // Ensure x is initialized\n        while (u.cmpn(0) !== 0) {\n            const q = v.div(u);\n            r = v.sub(q.mul(u));\n            x = x2.sub(q.mul(x1)); // Now TypeScript knows x is always assigned\n            const y = y2.sub(q.mul(y1));\n            if (a1 === undefined && r.cmp(aprxSqrt) < 0) {\n                a0 = prevR.neg();\n                b0 = x1;\n                a1 = r.neg();\n                b1 = x;\n            }\n            else if (a1 !== undefined && ++i === 2) {\n                break;\n            }\n            prevR = r;\n            v = u;\n            u = r;\n            x2 = x1;\n            x1 = x;\n            y2 = y1;\n            y1 = y;\n        }\n        // Ensure a0 and b0 have been assigned\n        if (a0 === undefined ||\n            b0 === undefined ||\n            a1 === undefined ||\n            b1 === undefined) {\n            throw new Error('Failed to compute Endo Basis values');\n        }\n        a2 = r.neg();\n        b2 = x;\n        const len1 = a1.sqr().add(b1.sqr());\n        const len2 = a2.sqr().add(b2.sqr());\n        if (len2.cmp(len1) >= 0) {\n            a2 = a0;\n            b2 = b0;\n        }\n        // Normalize signs\n        if (a1.negative !== 0) {\n            a1 = a1.neg();\n            b1 = b1.neg();\n        }\n        if (a2.negative !== 0) {\n            a2 = a2.neg();\n            b2 = b2.neg();\n        }\n        return [\n            { a: a1, b: b1 },\n            { a: a2, b: b2 }\n        ];\n    }\n    _endoSplit(k) {\n        if (this.endo == null) {\n            throw new Error('Endomorphism is not defined.');\n        }\n        const basis = this.endo.basis;\n        const v1 = basis[0];\n        const v2 = basis[1];\n        const c1 = v2.b.mul(k).divRound(this.n);\n        const c2 = v1.b.neg().mul(k).divRound(this.n);\n        const p1 = c1.mul(v1.a);\n        const p2 = c2.mul(v2.a);\n        const q1 = c1.mul(v1.b);\n        const q2 = c2.mul(v2.b);\n        // Calculate answer\n        const k1 = k.sub(p1).sub(p2);\n        const k2 = q1.add(q2).neg();\n        return { k1, k2 };\n    }\n    validate(point) {\n        if (point.inf) {\n            return true;\n        }\n        const x = point.x;\n        const y = point.y;\n        // Ensure x and y are not null before proceeding\n        if (x === null || y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        const ax = this.a.redMul(x);\n        const rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n        return y.redSqr().redISub(rhs).cmpn(0) === 0;\n    }\n}\nexports[\"default\"] = Curve;\n//# sourceMappingURL=Curve.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/DRBG.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/DRBG.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n/**\n * This class behaves as a HMAC-based deterministic random bit generator (DRBG). It implements a deterministic random number generator using SHA256HMAC HASH function. It takes an initial entropy and nonce when instantiated for seeding purpose.\n * @class DRBG\n *\n * @constructor\n * @param entropy - Initial entropy either in number array or hexadecimal string.\n * @param nonce - Initial nonce either in number array or hexadecimal string.\n *\n * @throws Throws an error message 'Not enough entropy. Minimum is 256 bits' when entropy's length is less than 32.\n *\n * @example\n * const drbg = new DRBG('af12de...', '123ef...');\n */\nclass DRBG {\n    constructor(entropy, nonce) {\n        entropy = (0, utils_js_1.toArray)(entropy, 'hex');\n        nonce = (0, utils_js_1.toArray)(nonce, 'hex');\n        if (entropy.length < 32) {\n            throw new Error('Not enough entropy. Minimum is 256 bits');\n        }\n        const seed = entropy.concat(nonce);\n        this.K = new Array(32);\n        this.V = new Array(32);\n        for (let i = 0; i < 32; i++) {\n            this.K[i] = 0x00;\n            this.V[i] = 0x01;\n        }\n        this.update(seed);\n    }\n    /**\n     * Generates HMAC using the K value of the instance. This method is used internally for operations.\n     *\n     * @method hmac\n     * @returns The SHA256HMAC object created with K value.\n     *\n     * @example\n     * const hmac = drbg.hmac();\n     */\n    hmac() {\n        return new Hash_js_1.SHA256HMAC(this.K);\n    }\n    /**\n     * Updates the `K` and `V` values of the instance based on the seed.\n     * The seed if not provided uses `V` as seed.\n     *\n     * @method update\n     * @param seed - an optional value that used to update `K` and `V`. Default is `undefined`.\n     * @returns Nothing, but updates the internal state `K` and `V` value.\n     *\n     * @example\n     * drbg.update('e13af...');\n     */\n    update(seed) {\n        let kmac = this.hmac().update(this.V).update([0x00]);\n        if (seed !== undefined) {\n            kmac = kmac.update(seed);\n        }\n        this.K = kmac.digest();\n        this.V = this.hmac().update(this.V).digest();\n        if (seed === undefined) {\n            return;\n        }\n        this.K = this.hmac().update(this.V).update([0x01]).update(seed).digest();\n        this.V = this.hmac().update(this.V).digest();\n    }\n    /**\n     * Generates deterministic random hexadecimal string of given length.\n     * In every generation process, it also updates the internal state `K` and `V`.\n     *\n     * @method generate\n     * @param len - The length of required random number.\n     * @returns The required deterministic random hexadecimal string.\n     *\n     * @example\n     * const randomHex = drbg.generate(256);\n     */\n    generate(len) {\n        let temp = [];\n        while (temp.length < len) {\n            this.V = this.hmac().update(this.V).digest();\n            temp = temp.concat(this.V);\n        }\n        const res = temp.slice(0, len);\n        this.update();\n        return (0, utils_js_1.toHex)(res);\n    }\n}\nexports[\"default\"] = DRBG;\n//# sourceMappingURL=DRBG.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/DRBG.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.verify = exports.sign = void 0;\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Signature_js_1 = __importDefault(__webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst Point_js_1 = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\");\nconst DRBG_js_1 = __importDefault(__webpack_require__(/*! ./DRBG.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/DRBG.js\"));\n/**\n * Truncates a BigNumber message to the length of the curve order n, in the context of the Elliptic Curve Digital Signature Algorithm (ECDSA).\n * This method is used as part of ECDSA signing and verification.\n *\n * The method calculates `delta`, which is a difference obtained by subtracting the bit length of the curve order `n` from the byte length of the message in bits.\n * If `delta` is greater than zero, logical shifts msg to the right by `delta`, retaining the sign.\n *\n * Another condition is tested, but only if `truncOnly` is false. This condition compares the value of msg to curve order `n`.\n * If msg is greater or equal to `n`, it is decreased by `n` and returned.\n *\n * @method truncateToN\n * @param msg - The BigNumber message to be truncated.\n * @param truncOnly - An optional boolean parameter that if set to true, the method will only perform truncation of the BigNumber without doing the additional subtraction from the curve order.\n * @returns Returns the truncated BigNumber value, potentially subtracted by the curve order n.\n *\n * @example\n * let msg = new BigNumber('1234567890abcdef', 16);\n * let truncatedMsg = truncateToN(msg);\n */\nfunction truncateToN(msg, truncOnly, curve = new Curve_js_1.default()) {\n    const delta = msg.byteLength() * 8 - curve.n.bitLength();\n    if (delta > 0) {\n        msg.iushrn(delta);\n    }\n    if (truncOnly === null && msg.cmp(curve.n) >= 0) {\n        return msg.sub(curve.n);\n    }\n    else {\n        return msg;\n    }\n}\nconst curve = new Curve_js_1.default();\nconst bytes = curve.n.byteLength();\nconst ns1 = curve.n.subn(1);\nconst halfN = Point_js_1.N_BIGINT >> 1n;\n/**\n * Generates a digital signature for a given message.\n *\n * @function sign\n * @param msg - The BigNumber message for which the signature has to be computed.\n * @param key - Private key in BigNumber.\n * @param forceLowS - Optional boolean flag if True forces \"s\" to be the lower of two possible values.\n * @param customK - Optional specification for k value, which can be a function or BigNumber.\n * @returns Returns the elliptic curve digital signature of the message.\n *\n * @example\n * const msg = new BigNumber('2664878')\n * const key = new BigNumber('123456')\n * const signature = sign(msg, key)\n */\nconst sign = (msg, key, forceLowS = false, customK) => {\n    //  prepare inputs \n    msg = truncateToN(msg);\n    const msgBig = BigInt('0x' + msg.toString(16));\n    const keyBig = BigInt('0x' + key.toString(16));\n    // DRBG seeding identical to previous implementation\n    const bkey = key.toArray('be', bytes);\n    const nonce = msg.toArray('be', bytes);\n    const drbg = new DRBG_js_1.default(bkey, nonce);\n    for (let iter = 0;; iter++) {\n        //  k generation & basic validity checks \n        let kBN = typeof customK === 'function'\n            ? customK(iter)\n            : BigNumber_js_1.default.isBN(customK)\n                ? customK\n                : new BigNumber_js_1.default(drbg.generate(bytes), 16);\n        if (kBN == null)\n            throw new Error('k is undefined');\n        kBN = truncateToN(kBN, true);\n        if (kBN.cmpn(1) <= 0 || kBN.cmp(ns1) >= 0) {\n            if (BigNumber_js_1.default.isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (must be >1 and <N1)');\n            }\n            continue;\n        }\n        const kBig = BigInt('0x' + kBN.toString(16));\n        //  R = kG (Jacobian, windowNAF) \n        const R = (0, Point_js_1.scalarMultiplyWNAF)(kBig, { x: Point_js_1.GX_BIGINT, y: Point_js_1.GY_BIGINT });\n        if (R.Z === 0n) { // point at infinity  should never happen for valid k\n            if (BigNumber_js_1.default.isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (kG at infinity)');\n            }\n            continue;\n        }\n        // affine X coordinate of R\n        const zInv = (0, Point_js_1.biModInv)(R.Z);\n        const zInv2 = (0, Point_js_1.biModMul)(zInv, zInv);\n        const xAff = (0, Point_js_1.biModMul)(R.X, zInv2);\n        const rBig = (0, Point_js_1.modN)(xAff);\n        if (rBig === 0n) {\n            if (BigNumber_js_1.default.isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (r == 0)');\n            }\n            continue;\n        }\n        //  s = k  (msg + rkey)  mod n \n        const kInv = (0, Point_js_1.modInvN)(kBig);\n        const rTimesKey = (0, Point_js_1.modMulN)(rBig, keyBig);\n        const sum = (0, Point_js_1.modN)(msgBig + rTimesKey);\n        let sBig = (0, Point_js_1.modMulN)(kInv, sum);\n        if (sBig === 0n) {\n            if (BigNumber_js_1.default.isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (s == 0)');\n            }\n            continue;\n        }\n        // lowS mitigation (BIP62/BIP340 style)\n        if (forceLowS && sBig > halfN) {\n            sBig = Point_js_1.N_BIGINT - sBig;\n        }\n        //  convert back to BigNumber & return \n        const r = new BigNumber_js_1.default(rBig.toString(16), 16);\n        const s = new BigNumber_js_1.default(sBig.toString(16), 16);\n        return new Signature_js_1.default(r, s);\n    }\n};\nexports.sign = sign;\n/**\n * Verifies a digital signature of a given message.\n *\n * Message and key used during the signature generation process, and the previously computed signature\n * are used to validate the authenticity of the digital signature.\n *\n * @function verify\n * @param msg - The BigNumber message for which the signature has to be verified.\n * @param sig - Signature object consisting of parameters 'r' and 's'.\n * @param key - Public key in Point.\n * @returns Returns true if the signature is valid and false otherwise.\n *\n * @example\n * const msg = new BigNumber('2664878', 16)\n * const key = new Point(new BigNumber(10), new BigNumber(20)\n * const signature = sign(msg, new BigNumber('123456'))\n * const isVerified = verify(msg, sig, key)\n */\nconst verify = (msg, sig, key) => {\n    // Convert inputs to BigInt\n    const hash = BigInt('0x' + msg.toString(16));\n    if ((key.x == null) || (key.y == null)) {\n        throw new Error('Invalid public key: missing coordinates.');\n    }\n    const publicKey = {\n        x: BigInt('0x' + key.x.toString(16)),\n        y: BigInt('0x' + key.y.toString(16))\n    };\n    const signature = {\n        r: BigInt('0x' + sig.r.toString(16)),\n        s: BigInt('0x' + sig.s.toString(16))\n    };\n    const { r, s } = signature;\n    const z = hash;\n    // Check r and s are in [1, n - 1]\n    if (r <= Point_js_1.BI_ZERO || r >= Point_js_1.N_BIGINT || s <= Point_js_1.BI_ZERO || s >= Point_js_1.N_BIGINT) {\n        return false;\n    }\n    //  compute u = zs mod n  and  u = rs mod n \n    const w = (0, Point_js_1.modInvN)(s); // s mod n\n    if (w === 0n)\n        return false; // should never happen\n    const u1 = (0, Point_js_1.modMulN)(z, w);\n    const u2 = (0, Point_js_1.modMulN)(r, w);\n    //  R = uG + uQ  (Jacobian, windowNAF) \n    const RG = (0, Point_js_1.scalarMultiplyWNAF)(u1, { x: Point_js_1.GX_BIGINT, y: Point_js_1.GY_BIGINT });\n    const RQ = (0, Point_js_1.scalarMultiplyWNAF)(u2, publicKey);\n    const R = (0, Point_js_1.jpAdd)(RG, RQ);\n    if (R.Z === 0n)\n        return false; // point at infinity\n    //  affine xcoordinate of R  (mod p) \n    const zInv = (0, Point_js_1.biModInv)(R.Z); // (Z mod p)\n    const zInv2 = (0, Point_js_1.biModMul)(zInv, zInv); // Z\n    const xAff = (0, Point_js_1.biModMul)(R.X, zInv2); // X / Z  mod p\n    //  v = xAff mod n  and final check \n    const v = (0, Point_js_1.modN)(xAff);\n    return v === r;\n};\nexports.verify = verify;\n//# sourceMappingURL=ECDSA.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.pbkdf2 = exports.sha512hmac = exports.sha256hmac = exports.hash160 = exports.hash256 = exports.sha512 = exports.sha256 = exports.sha1 = exports.ripemd160 = exports.SHA512HMAC = exports.SHA1HMAC = exports.SHA256HMAC = exports.SHA512 = exports.SHA1 = exports.SHA256 = exports.RIPEMD160 = exports.toArray = void 0;\n// @ts-nocheck\n/* eslint-disable @typescript-eslint/naming-convention */\nconst assert = (expression, message = 'Hash assertion failed') => {\n    if (!expression) {\n        throw new Error(message);\n    }\n};\n/**\n * The BaseHash class is an abstract base class for cryptographic hash functions.\n * It provides a common structure and functionality for hash function classes.\n *\n * @class BaseHash\n *\n * @property pending - Stores partially processed message segments.\n * @property pendingTotal - The total number of characters that are being stored in `pending`\n * @property blockSize - The size of each block to processed.\n * @property outSize - The size of the final hash output.\n * @property endian - The endianness used during processing, can either be 'big' or 'little'.\n * @property _delta8 - The block size divided by 8, useful in various computations.\n * @property _delta32 - The block size divided by 32, useful in various computations.\n * @property padLength - The length of padding to be added to finalize the computation.\n * @property hmacStrength - The HMAC strength value.\n *\n * @param blockSize - The size of the block to be hashed.\n * @param outSize - The size of the resulting hash.\n * @param hmacStrength - The strength of the HMAC.\n * @param padLength - The length of the padding to be added.\n *\n * @example\n * Sub-classes would extend this base BaseHash class like:\n * class RIPEMD160 extends BaseHash {\n *   constructor () {\n *     super(512, 160, 192, 64);\n *     // ...\n *   }\n *   // ...\n * }\n */\nclass BaseHash {\n    constructor(blockSize, outSize, hmacStrength, padLength) {\n        this.pending = null;\n        this.pendingTotal = 0;\n        this.blockSize = blockSize;\n        this.outSize = outSize;\n        this.hmacStrength = hmacStrength;\n        this.padLength = padLength / 8;\n        this.endian = 'big';\n        this._delta8 = this.blockSize / 8;\n        this._delta32 = this.blockSize / 32;\n    }\n    _update(msg, start) {\n        throw new Error('Not implemented');\n    }\n    _digest() {\n        throw new Error('Not implemented');\n    }\n    _digestHex() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Converts the input message into an array, pads it, and joins into 32bit blocks.\n     * If there is enough data, it tries updating the hash computation.\n     *\n     * @method update\n     * @param msg - The message segment to include in the hashing computation.\n     * @param enc - The encoding of the message. If 'hex', the string will be treated as such, 'utf8' otherwise.\n     *\n     * @returns Returns the instance of the object for chaining.\n     *\n     * @example\n     * sha256.update('Hello World', 'utf8');\n     */\n    update(msg, enc) {\n        // Convert message to array, pad it, and join into 32bit blocks\n        msg = toArray(msg, enc);\n        if (this.pending == null) {\n            this.pending = msg;\n        }\n        else {\n            this.pending = this.pending.concat(msg);\n        }\n        this.pendingTotal += msg.length;\n        // Enough data, try updating\n        if (this.pending.length >= this._delta8) {\n            msg = this.pending;\n            // Process pending data in blocks\n            const r = msg.length % this._delta8;\n            this.pending = msg.slice(msg.length - r, msg.length);\n            if (this.pending.length === 0) {\n                this.pending = null;\n            }\n            msg = join32(msg, 0, msg.length - r, this.endian);\n            for (let i = 0; i < msg.length; i += this._delta32) {\n                this._update(msg, i);\n            }\n        }\n        return this;\n    }\n    /**\n     * Finalizes the hash computation and returns the hash value/result.\n     *\n     * @method digest\n     *\n     * @returns Returns the final hash value.\n     *\n     * @example\n     * const hash = sha256.digest();\n     */\n    digest() {\n        this.update(this._pad());\n        assert(this.pending === null);\n        return this._digest();\n    }\n    /**\n     * Finalizes the hash computation and returns the hash value/result as a hex string.\n     *\n     * @method digest\n     *\n     * @returns Returns the final hash value as a hex string.\n     *\n     * @example\n     * const hash = sha256.digestHex();\n     */\n    digestHex() {\n        this.update(this._pad());\n        assert(this.pending === null);\n        return this._digestHex();\n    }\n    /**\n     * [Private Method] Used internally to prepare the padding for the final stage of the hash computation.\n     *\n     * @method _pad\n     * @private\n     *\n     * @returns Returns an array denoting the padding.\n     */\n    _pad() {\n        //\n        let len = this.pendingTotal;\n        const bytes = this._delta8;\n        const k = bytes - ((len + this.padLength) % bytes);\n        const res = new Array(k + this.padLength);\n        res[0] = 0x80;\n        let i;\n        for (i = 1; i < k; i++) {\n            res[i] = 0;\n        }\n        // Append length\n        len <<= 3;\n        let t;\n        if (this.endian === 'big') {\n            for (t = 8; t < this.padLength; t++) {\n                res[i++] = 0;\n            }\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = (len >>> 24) & 0xff;\n            res[i++] = (len >>> 16) & 0xff;\n            res[i++] = (len >>> 8) & 0xff;\n            res[i++] = len & 0xff;\n        }\n        else {\n            res[i++] = len & 0xff;\n            res[i++] = (len >>> 8) & 0xff;\n            res[i++] = (len >>> 16) & 0xff;\n            res[i++] = (len >>> 24) & 0xff;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            for (t = 8; t < this.padLength; t++) {\n                res[i++] = 0;\n            }\n        }\n        return res;\n    }\n}\nfunction isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 0xfc00) !== 0xd800) {\n        return false;\n    }\n    if (i < 0 || i + 1 >= msg.length) {\n        return false;\n    }\n    return (msg.charCodeAt(i + 1) & 0xfc00) === 0xdc00;\n}\n/**\n *\n * @param msg\n * @param enc Optional. Encoding to use if msg is string. Default is 'utf8'.\n * @returns array of byte values from msg. If msg is an array, a copy is returned.\n */\nfunction toArray(msg, enc) {\n    if (Array.isArray(msg)) {\n        return msg.slice();\n    }\n    if (!msg) {\n        return [];\n    }\n    const res = [];\n    if (typeof msg === 'string') {\n        if (enc !== 'hex') {\n            // Inspired by stringToUtf8ByteArray() in closure-library by Google\n            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt#L117-L143\n            // Apache License 2.0\n            // https://github.com/google/closure-library/blob/master/LICENSE\n            let p = 0;\n            for (let i = 0; i < msg.length; i++) {\n                let c = msg.charCodeAt(i);\n                if (c < 128) {\n                    res[p++] = c;\n                }\n                else if (c < 2048) {\n                    res[p++] = (c >> 6) | 192;\n                    res[p++] = (c & 63) | 128;\n                }\n                else if (isSurrogatePair(msg, i)) {\n                    c = 0x10000 + ((c & 0x03ff) << 10) + (msg.charCodeAt(++i) & 0x03ff);\n                    res[p++] = (c >> 18) | 240;\n                    res[p++] = ((c >> 12) & 63) | 128;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n                else {\n                    res[p++] = (c >> 12) | 224;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n            }\n        }\n        else {\n            msg = msg.replace(/[^a-z0-9]+/gi, '');\n            if (msg.length % 2 !== 0) {\n                msg = '0' + msg;\n            }\n            for (let i = 0; i < msg.length; i += 2) {\n                res.push(parseInt(msg[i] + msg[i + 1], 16));\n            }\n        }\n    }\n    else {\n        msg = msg;\n        for (let i = 0; i < msg.length; i++) {\n            res[i] = msg[i] | 0;\n        }\n    }\n    return res;\n}\nexports.toArray = toArray;\nfunction htonl(w) {\n    const res = (w >>> 24) |\n        ((w >>> 8) & 0xff00) |\n        ((w << 8) & 0xff0000) |\n        ((w & 0xff) << 24);\n    return res >>> 0;\n}\nfunction toHex32(msg, endian) {\n    let res = '';\n    for (let i = 0; i < msg.length; i++) {\n        let w = msg[i];\n        if (endian === 'little') {\n            w = htonl(w);\n        }\n        res += zero8(w.toString(16));\n    }\n    return res;\n}\nfunction zero8(word) {\n    if (word.length === 7) {\n        return '0' + word;\n    }\n    else if (word.length === 6) {\n        return '00' + word;\n    }\n    else if (word.length === 5) {\n        return '000' + word;\n    }\n    else if (word.length === 4) {\n        return '0000' + word;\n    }\n    else if (word.length === 3) {\n        return '00000' + word;\n    }\n    else if (word.length === 2) {\n        return '000000' + word;\n    }\n    else if (word.length === 1) {\n        return '0000000' + word;\n    }\n    else {\n        return word;\n    }\n}\nfunction bytesToHex(data) {\n    let res = '';\n    for (const b of data)\n        res += b.toString(16).padStart(2, '0');\n    return res;\n}\nfunction join32(msg, start, end, endian) {\n    const len = end - start;\n    assert(len % 4 === 0);\n    const res = new Array(len / 4);\n    for (let i = 0, k = start; i < res.length; i++, k += 4) {\n        let w;\n        if (endian === 'big') {\n            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n        }\n        else {\n            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n        }\n        res[i] = w >>> 0;\n    }\n    return res;\n}\nfunction split32(msg, endian) {\n    const res = new Array(msg.length * 4);\n    for (let i = 0, k = 0; i < msg.length; i++, k += 4) {\n        const m = msg[i];\n        if (endian === 'big') {\n            res[k] = m >>> 24;\n            res[k + 1] = (m >>> 16) & 0xff;\n            res[k + 2] = (m >>> 8) & 0xff;\n            res[k + 3] = m & 0xff;\n        }\n        else {\n            res[k + 3] = m >>> 24;\n            res[k + 2] = (m >>> 16) & 0xff;\n            res[k + 1] = (m >>> 8) & 0xff;\n            res[k] = m & 0xff;\n        }\n    }\n    return res;\n}\nfunction rotr32(w, b) {\n    return (w >>> b) | (w << (32 - b));\n}\nfunction rotl32(w, b) {\n    return (w << b) | (w >>> (32 - b));\n}\nfunction sum32(a, b) {\n    return (a + b) >>> 0;\n}\nfunction SUM32_3(a, b, c) {\n    return (a + b + c) >>> 0;\n}\nfunction SUM32_4(a, b, c, d) {\n    return (a + b + c + d) >>> 0;\n}\nfunction SUM32_5(a, b, c, d, e) {\n    return (a + b + c + d + e) >>> 0;\n}\nfunction FT_1(s, x, y, z) {\n    if (s === 0) {\n        return ch32(x, y, z);\n    }\n    if (s === 1 || s === 3) {\n        return p32(x, y, z);\n    }\n    if (s === 2) {\n        return maj32(x, y, z);\n    }\n    return 0;\n}\nfunction ch32(x, y, z) {\n    return (x & y) ^ (~x & z);\n}\nfunction maj32(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n}\nfunction p32(x, y, z) {\n    return x ^ y ^ z;\n}\nfunction S0_256(x) {\n    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nfunction S1_256(x) {\n    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nfunction G0_256(x) {\n    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nfunction G1_256(x) {\n    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nconst r = [\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15,\n    3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11,\n    5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7,\n    12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\nconst rh = [\n    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,\n    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0,\n    4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1,\n    5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\nconst s = [\n    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7,\n    15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5,\n    12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5,\n    11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\nconst sh = [\n    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,\n    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,\n    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,\n    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\nfunction f(j, x, y, z) {\n    if (j <= 15) {\n        return x ^ y ^ z;\n    }\n    else if (j <= 31) {\n        return (x & y) | (~x & z);\n    }\n    else if (j <= 47) {\n        return (x | ~y) ^ z;\n    }\n    else if (j <= 63) {\n        return (x & z) | (y & ~z);\n    }\n    else {\n        return x ^ (y | ~z);\n    }\n}\nfunction K(j) {\n    if (j <= 15) {\n        return 0x00000000;\n    }\n    else if (j <= 31) {\n        return 0x5a827999;\n    }\n    else if (j <= 47) {\n        return 0x6ed9eba1;\n    }\n    else if (j <= 63) {\n        return 0x8f1bbcdc;\n    }\n    else {\n        return 0xa953fd4e;\n    }\n}\nfunction Kh(j) {\n    if (j <= 15) {\n        return 0x50a28be6;\n    }\n    else if (j <= 31) {\n        return 0x5c4dd124;\n    }\n    else if (j <= 47) {\n        return 0x6d703ef3;\n    }\n    else if (j <= 63) {\n        return 0x7a6d76e9;\n    }\n    else {\n        return 0x00000000;\n    }\n}\n/**\n * An implementation of RIPEMD160 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class RIPEMD160\n * @param None\n *\n * @constructor\n * Use the RIPEMD160 constructor to create an instance of RIPEMD160 hash function.\n *\n * @example\n * const ripemd160 = new RIPEMD160();\n *\n * @property h - Array that is updated iteratively as part of hashing computation.\n */\nclass RIPEMD160 extends BaseHash {\n    constructor() {\n        super(512, 160, 192, 64);\n        this.endian = 'little';\n        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n        this.endian = 'little';\n    }\n    _update(msg, start) {\n        let A = this.h[0];\n        let B = this.h[1];\n        let C = this.h[2];\n        let D = this.h[3];\n        let E = this.h[4];\n        let Ah = A;\n        let Bh = B;\n        let Ch = C;\n        let Dh = D;\n        let Eh = E;\n        let T;\n        for (let j = 0; j < 80; j++) {\n            T = sum32(rotl32(SUM32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n            A = E;\n            E = D;\n            D = rotl32(C, 10);\n            C = B;\n            B = T;\n            T = sum32(rotl32(SUM32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);\n            Ah = Eh;\n            Eh = Dh;\n            Dh = rotl32(Ch, 10);\n            Ch = Bh;\n            Bh = T;\n        }\n        T = SUM32_3(this.h[1], C, Dh);\n        this.h[1] = SUM32_3(this.h[2], D, Eh);\n        this.h[2] = SUM32_3(this.h[3], E, Ah);\n        this.h[3] = SUM32_3(this.h[4], A, Bh);\n        this.h[4] = SUM32_3(this.h[0], B, Ch);\n        this.h[0] = T;\n    }\n    _digest() {\n        return split32(this.h, 'little');\n    }\n    _digestHex() {\n        return toHex32(this.h, 'little');\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * An implementation of SHA256 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA256\n * @param None\n *\n * @constructor\n * Use the SHA256 constructor to create an instance of SHA256 hash function.\n *\n * @example\n * const sha256 = new SHA256();\n *\n * @property h - The initial hash constants\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-256\n */\nclass SHA256 {\n    constructor() {\n        this.h = new FastSHA256();\n    }\n    update(msg, enc) {\n        const data = Uint8Array.from(toArray(msg, enc));\n        this.h.update(data);\n        return this;\n    }\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\nexports.SHA256 = SHA256;\n/**\n * An implementation of SHA1 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA1\n * @param None\n *\n * @constructor\n * Use the SHA1 constructor to create an instance of SHA1 hash function.\n *\n * @example\n * const sha1 = new SHA1();\n *\n * @property h - The initial hash constants.\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-1.\n */\nclass SHA1 extends BaseHash {\n    constructor() {\n        super(512, 160, 80, 64);\n        this.k = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n        this.W = new Array(80);\n    }\n    _update(msg, start) {\n        const W = this.W;\n        // Default start to 0\n        if (start === undefined) {\n            start = 0;\n        }\n        let i;\n        for (i = 0; i < 16; i++) {\n            W[i] = msg[start + i];\n        }\n        for (; i < W.length; i++) {\n            W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n        }\n        let a = this.h[0];\n        let b = this.h[1];\n        let c = this.h[2];\n        let d = this.h[3];\n        let e = this.h[4];\n        for (i = 0; i < W.length; i++) {\n            const s = ~~(i / 20);\n            const t = SUM32_5(rotl32(a, 5), FT_1(s, b, c, d), e, W[i], this.k[s]);\n            e = d;\n            d = c;\n            c = rotl32(b, 30);\n            b = a;\n            a = t;\n        }\n        this.h[0] = sum32(this.h[0], a);\n        this.h[1] = sum32(this.h[1], b);\n        this.h[2] = sum32(this.h[2], c);\n        this.h[3] = sum32(this.h[3], d);\n        this.h[4] = sum32(this.h[4], e);\n    }\n    _digest() {\n        return split32(this.h, 'big');\n    }\n    _digestHex() {\n        return toHex32(this.h, 'big');\n    }\n}\nexports.SHA1 = SHA1;\n/**\n * An implementation of SHA512 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA512\n * @param None\n *\n * @constructor\n * Use the SHA512 constructor to create an instance of SHA512 hash function.\n *\n * @example\n * const sha512 = new SHA512();\n *\n * @property h - The initial hash constants.\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-512.\n */\nclass SHA512 {\n    constructor() {\n        this.h = new FastSHA512();\n    }\n    update(msg, enc) {\n        const data = Uint8Array.from(toArray(msg, enc));\n        this.h.update(data);\n        return this;\n    }\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\nexports.SHA512 = SHA512;\n/**\n * The `SHA256HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-256 cryptographic hash function.\n *\n * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.\n *\n * This class also uses the SHA-256 cryptographic hash algorithm that produces a 256-bit (32-byte) hash value.\n *\n * @property inner - Represents the inner hash of SHA-256.\n * @property outer - Represents the outer hash of SHA-256.\n * @property blockSize - The block size for the SHA-256 hash function, in bytes. It's set to 64 bytes.\n * @property outSize - The output size of the SHA-256 hash function, in bytes. It's set to 32 bytes.\n */\nclass SHA256HMAC {\n    /**\n     * The constructor for the `SHA256HMAC` class.\n     *\n     * It initializes the `SHA256HMAC` object and sets up the inner and outer padded keys.\n     * If the key size is larger than the blockSize, it is digested using SHA-256.\n     * If the key size is less than the blockSize, it is padded with zeroes.\n     *\n     * @constructor\n     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.\n     *\n     * @example\n     * const myHMAC = new SHA256HMAC('deadbeef');\n     */\n    constructor(key) {\n        this.blockSize = 64;\n        this.outSize = 32;\n        const k = Uint8Array.from(toArray(key, 'hex'));\n        this.h = new HMAC(sha256Fast, k);\n    }\n    /**\n     * Updates the `SHA256HMAC` object with part of the message to be hashed.\n     *\n     * @method update\n     * @param msg - Part of the message to hash. Can be a number array or a string.\n     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.\n     * @returns Returns the instance of `SHA256HMAC` for chaining calls.\n     *\n     * @example\n     * myHMAC.update('deadbeef', 'hex');\n     */\n    update(msg, enc) {\n        this.h.update(Uint8Array.from(toArray(msg, enc)));\n        return this;\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data. Can be a number array or a string.\n     *\n     * @example\n     * let hashedMessage = myHMAC.digest();\n     */\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash as a hex string.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a hex string\n     *\n     * @example\n     * let hashedMessage = myHMAC.digestHex();\n     */\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\nexports.SHA256HMAC = SHA256HMAC;\nclass SHA1HMAC {\n    constructor(key) {\n        this.blockSize = 64;\n        key = toArray(key, 'hex');\n        // Shorten key, if needed\n        if (key.length > this.blockSize) {\n            key = new SHA1().update(key).digest();\n        }\n        // Keys shorter than block size are padded with zeros on the right\n        let i;\n        for (i = key.length; i < this.blockSize; i++) {\n            key.push(0);\n        }\n        for (i = 0; i < key.length; i++) {\n            key[i] ^= 0x36;\n        }\n        this.inner = new SHA1().update(key);\n        // 0x36 ^ 0x5c = 0x6a\n        for (i = 0; i < key.length; i++) {\n            key[i] ^= 0x6a;\n        }\n        this.outer = new SHA1().update(key);\n    }\n    update(msg, enc) {\n        this.inner.update(msg, enc);\n        return this;\n    }\n    digest() {\n        this.outer.update(this.inner.digest());\n        return this.outer.digest();\n    }\n    digestHex() {\n        this.outer.update(this.inner.digest());\n        return this.outer.digestHex();\n    }\n}\nexports.SHA1HMAC = SHA1HMAC;\n/**\n * The `SHA512HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-512 cryptographic hash function.\n *\n * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.\n *\n * This class also uses the SHA-512 cryptographic hash algorithm that produces a 512-bit (64-byte) hash value.\n *\n * @property inner - Represents the inner hash of SHA-512.\n * @property outer - Represents the outer hash of SHA-512.\n * @property blockSize - The block size for the SHA-512 hash function, in bytes. It's set to 128 bytes.\n * @property outSize - The output size of the SHA-512 hash function, in bytes. It's set to 64 bytes.\n */\nclass SHA512HMAC {\n    /**\n     * The constructor for the `SHA512HMAC` class.\n     *\n     * It initializes the `SHA512HMAC` object and sets up the inner and outer padded keys.\n     * If the key size is larger than the blockSize, it is digested using SHA-512.\n     * If the key size is less than the blockSize, it is padded with zeroes.\n     *\n     * @constructor\n     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.\n     *\n     * @example\n     * const myHMAC = new SHA512HMAC('deadbeef');\n     */\n    constructor(key) {\n        this.blockSize = 128;\n        this.outSize = 32;\n        const k = Uint8Array.from(toArray(key, 'hex'));\n        this.h = new HMAC(sha512Fast, k);\n    }\n    /**\n     * Updates the `SHA512HMAC` object with part of the message to be hashed.\n     *\n     * @method update\n     * @param msg - Part of the message to hash. Can be a number array or a string.\n     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.\n     * @returns Returns the instance of `SHA512HMAC` for chaining calls.\n     *\n     * @example\n     * myHMAC.update('deadbeef', 'hex');\n     */\n    update(msg, enc) {\n        this.h.update(Uint8Array.from(toArray(msg, enc)));\n        return this;\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a number array.\n     *\n     * @example\n     * let hashedMessage = myHMAC.digest();\n     */\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash as a hex string.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a hex string\n     *\n     * @example\n     * let hashedMessage = myHMAC.digestHex();\n     */\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\nexports.SHA512HMAC = SHA512HMAC;\n/**\n * Computes RIPEMD160 hash of a given message.\n * @function ripemd160\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed RIPEMD160 hash of the message.\n *\n * @example\n * const digest = ripemd160('Hello, world!');\n */\nconst ripemd160 = (msg, enc) => {\n    return new RIPEMD160().update(msg, enc).digest();\n};\nexports.ripemd160 = ripemd160;\n/**\n * Computes SHA1 hash of a given message.\n * @function sha1\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA1 hash of the message.\n *\n * @example\n * const digest = sha1('Hello, world!');\n */\nconst sha1 = (msg, enc) => {\n    return new SHA1().update(msg, enc).digest();\n};\nexports.sha1 = sha1;\n/**\n * Computes SHA256 hash of a given message.\n * @function sha256\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA256 hash of the message.\n *\n * @example\n * const digest = sha256('Hello, world!');\n */\nconst sha256 = (msg, enc) => {\n    return new SHA256().update(msg, enc).digest();\n};\nexports.sha256 = sha256;\n/**\n * Computes SHA512 hash of a given message.\n * @function sha512\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA512 hash of the message.\n *\n * @example\n * const digest = sha512('Hello, world!');\n */\nconst sha512 = (msg, enc) => {\n    return new SHA512().update(msg, enc).digest();\n};\nexports.sha512 = sha512;\n/**\n * Performs a 'double hash' using SHA256. This means the data is hashed twice\n * with SHA256. First, the SHA256 hash of the message is computed, then the\n * SHA256 hash of the resulting hash is computed.\n * @function hash256\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the double hashed SHA256 output.\n *\n * @example\n * const doubleHash = hash256('Hello, world!');\n */\nconst hash256 = (msg, enc) => {\n    const first = new SHA256().update(msg, enc).digest();\n    return new SHA256().update(first).digest();\n};\nexports.hash256 = hash256;\n/**\n * Computes SHA256 hash of a given message and then computes a RIPEMD160 hash of the result.\n *\n * @function hash160\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the RIPEMD160 hash of the SHA256 hash of the input message.\n *\n * @example\n * const hash = hash160('Hello, world!');\n */\nconst hash160 = (msg, enc) => {\n    const first = new SHA256().update(msg, enc).digest();\n    return new RIPEMD160().update(first).digest();\n};\nexports.hash160 = hash160;\n/**\n * Computes SHA256 HMAC of a given message with a given key.\n * @function sha256hmac\n * @param key - The key used to compute the HMAC\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed HMAC of the message.\n *\n * @example\n * const digest = sha256hmac('deadbeef', 'ffff001d');\n */\nconst sha256hmac = (key, msg, enc) => {\n    return new SHA256HMAC(key).update(msg, enc).digest();\n};\nexports.sha256hmac = sha256hmac;\n/**\n * Computes SHA512 HMAC of a given message with a given key.\n * @function sha512hmac\n * @param key - The key used to compute the HMAC\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed HMAC of the message.\n *\n * @example\n * const digest = sha512hmac('deadbeef', 'ffff001d');\n */\nconst sha512hmac = (key, msg, enc) => {\n    return new SHA512HMAC(key).update(msg, enc).digest();\n};\nexports.sha512hmac = sha512hmac;\n// BEGIN fast-pbkdf2 helpers\n// Utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        throw new Error(`positive integer expected, got ${n}`);\n    }\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length)) {\n        const lens = lengths.join(',');\n        throw new Error(`Uint8Array expected of length ${lens}, got length=${b.length}`);\n    }\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function') {\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    }\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed === true)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished === true) {\n        throw new Error('Hash#digest() has already been called');\n    }\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++)\n        arrays[i].fill(0);\n}\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str));\n}\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\nclass Hash {\n}\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\n// u64 helpers\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    const Ah = new Uint32Array(len);\n    const Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        Ah[i] = h;\n        Al[i] = l;\n    }\n    return [Ah, Al];\n}\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// _md helpers\nclass HashMD extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        if (len % 4 !== 0)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen !== 0)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// sha256 fast constants\nconst SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\nconst K256 = Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nconst SHA256_W = new Uint32Array(64);\nclass FastSHA256 extends HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA256_W[i] = view.getUint32(offset);\n        }\n        for (let i = 16; i < 64; i++) {\n            const w15 = SHA256_W[i - 15];\n            const w2 = SHA256_W[i - 2];\n            const s0 = G0_256(w15);\n            const s1 = G1_256(w2);\n            SHA256_W[i] = sum32(sum32(s0, SHA256_W[i - 7]), sum32(s1, SHA256_W[i - 16]));\n        }\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const T1 = SUM32_5(H, S1_256(E), ch32(E, F, G), K256[i], SHA256_W[i]);\n            const T2 = sum32(S0_256(A), maj32(A, B, C));\n            H = G;\n            G = F;\n            F = E;\n            E = sum32(D, T1);\n            D = C;\n            C = B;\n            B = A;\n            A = sum32(T1, T2);\n        }\n        this.A = sum32(this.A, A);\n        this.B = sum32(this.B, B);\n        this.C = sum32(this.C, C);\n        this.D = sum32(this.D, D);\n        this.E = sum32(this.E, E);\n        this.F = sum32(this.F, F);\n        this.G = sum32(this.G, G);\n        this.H = sum32(this.H, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nconst sha256Fast = createHasher(() => new FastSHA256());\n// sha512\nconst SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179\n]);\nconst K512 = (() => split([\n    '0x428a2f98d728ae22',\n    '0x7137449123ef65cd',\n    '0xb5c0fbcfec4d3b2f',\n    '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538',\n    '0x59f111f1b605d019',\n    '0x923f82a4af194f9b',\n    '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242',\n    '0x12835b0145706fbe',\n    '0x243185be4ee4b28c',\n    '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f',\n    '0x80deb1fe3b1696b1',\n    '0x9bdc06a725c71235',\n    '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2',\n    '0xefbe4786384f25e3',\n    '0x0fc19dc68b8cd5b5',\n    '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275',\n    '0x4a7484aa6ea6e483',\n    '0x5cb0a9dcbd41fbd4',\n    '0x76f988da831153b5',\n    '0x983e5152ee66dfab',\n    '0xa831c66d2db43210',\n    '0xb00327c898fb213f',\n    '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2',\n    '0xd5a79147930aa725',\n    '0x06ca6351e003826f',\n    '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc',\n    '0x2e1b21385c26c926',\n    '0x4d2c6dfc5ac42aed',\n    '0x53380d139d95b3df',\n    '0x650a73548baf63de',\n    '0x766a0abb3c77b2a8',\n    '0x81c2c92e47edaee6',\n    '0x92722c851482353b',\n    '0xa2bfe8a14cf10364',\n    '0xa81a664bbc423001',\n    '0xc24b8b70d0f89791',\n    '0xc76c51a30654be30',\n    '0xd192e819d6ef5218',\n    '0xd69906245565a910',\n    '0xf40e35855771202a',\n    '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8',\n    '0x1e376c085141ab53',\n    '0x2748774cdf8eeb99',\n    '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63',\n    '0x4ed8aa4ae3418acb',\n    '0x5b9cca4f7763e373',\n    '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc',\n    '0x78a5636f43172f60',\n    '0x84c87814a1f0ab72',\n    '0x8cc702081a6439ec',\n    '0x90befffa23631e28',\n    '0xa4506cebde82bde9',\n    '0xbef9a3f7b2c67915',\n    '0xc67178f2e372532b',\n    '0xca273eceea26619c',\n    '0xd186b8c721c0c207',\n    '0xeada7dd6cde0eb1e',\n    '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba',\n    '0x0a637dc5a2c898a6',\n    '0x113f9804bef90dae',\n    '0x1b710b35131c471b',\n    '0x28db77f523047d84',\n    '0x32caab7b40c72493',\n    '0x3c9ebe0a15c9bebc',\n    '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6',\n    '0x597f299cfc657e2a',\n    '0x5fcb6fab3ad6faec',\n    '0x6c44198c4a475817'\n].map((n) => BigInt(n))))();\nconst SHA512_Kh = (() => K512[0])();\nconst SHA512_Kl = (() => K512[1])();\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass FastSHA512 extends HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        this.Ah = SHA512_IV[0] | 0;\n        this.Al = SHA512_IV[1] | 0;\n        this.Bh = SHA512_IV[2] | 0;\n        this.Bl = SHA512_IV[3] | 0;\n        this.Ch = SHA512_IV[4] | 0;\n        this.Cl = SHA512_IV[5] | 0;\n        this.Dh = SHA512_IV[6] | 0;\n        this.Dl = SHA512_IV[7] | 0;\n        this.Eh = SHA512_IV[8] | 0;\n        this.El = SHA512_IV[9] | 0;\n        this.Fh = SHA512_IV[10] | 0;\n        this.Fl = SHA512_IV[11] | 0;\n        this.Gh = SHA512_IV[12] | 0;\n        this.Gl = SHA512_IV[13] | 0;\n        this.Hh = SHA512_IV[14] | 0;\n        this.Hl = SHA512_IV[15] | 0;\n    }\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);\n            const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);\n            const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);\n            const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        for (let i = 0; i < 80; i++) {\n            const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);\n            const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);\n            const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const T2l = add3L(sigma0l, MAJl, T1l);\n            Ah = add3H(T2l, sigma0h, MAJh, T1h);\n            Al = T2l | 0;\n        }\n        ;\n        ({ h: Ah, l: Al } = add(Ah, Al, this.Ah, this.Al));\n        ({ h: Bh, l: Bl } = add(Bh, Bl, this.Bh, this.Bl));\n        ({ h: Ch, l: Cl } = add(Ch, Cl, this.Ch, this.Cl));\n        ({ h: Dh, l: Dl } = add(Dh, Dl, this.Dh, this.Dl));\n        ({ h: Eh, l: El } = add(Eh, El, this.Eh, this.El));\n        ({ h: Fh, l: Fl } = add(Fh, Fl, this.Fh, this.Fl));\n        ({ h: Gh, l: Gl } = add(Gh, Gl, this.Gh, this.Gl));\n        ({ h: Hh, l: Hl } = add(Hh, Hl, this.Hh, this.Hl));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nconst sha512Fast = createHasher(() => new FastSHA512());\nclass HMAC extends Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function') {\n            throw new Error('Expected instance of class which extends utils.Hash');\n        }\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        this.oHash = hash.create();\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash ?? undefined);\n        to.iHash = iHash._cloneInto(to.iHash ?? undefined);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nfunction pbkdf2Core(hash, password, salt, opts) {\n    ahash(hash);\n    const { c, dkLen } = Object.assign({ dkLen: 32 }, opts);\n    anumber(c);\n    anumber(dkLen);\n    if (c < 1)\n        throw new Error('iterations (c) should be >= 1');\n    const pwd = kdfInputToBytes(password);\n    const slt = kdfInputToBytes(salt);\n    const DK = new Uint8Array(dkLen);\n    const PRF = hmac.create(hash, pwd);\n    const PRFSalt = PRF._cloneInto().update(slt);\n    let prfW;\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW != null)\n        prfW.destroy();\n    clean(u);\n    return DK;\n}\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\nfunction pbkdf2Fast(password, salt, iterations, keylen) {\n    return pbkdf2Core(sha512Fast, password, salt, { c: iterations, dkLen: keylen });\n}\n// END fast-pbkdf2 helpers\n/**\n * Limited SHA-512-only PBKDF2 function for use in deprecated BIP39 code.\n * @function pbkdf2\n * @param password - The PBKDF2 password\n * @param salt - The PBKDF2 salt\n * @param iterations - The number of of iterations to run\n * @param keylen - The length of the key\n * @param digest - The digest (must be sha512 for this implementation)\n *\n * @returns The computed key\n */\nfunction pbkdf2(password, salt, iterations, keylen, digest = 'sha512') {\n    if (digest !== 'sha512') {\n        throw new Error('Only sha512 is supported in this PBKDF2 implementation');\n    }\n    // Attempt to use the native Node.js implementation if available as it is\n    // considerably faster than the pure TypeScript fallback below. If the crypto\n    // module isn't present (for example in a browser build) we'll silently fall\n    // back to the original implementation.\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const nodeCrypto = __webpack_require__(/*! crypto */ \"?706f\");\n        if (typeof nodeCrypto.pbkdf2Sync === 'function') {\n            const p = Buffer.from(password);\n            const s = Buffer.from(salt);\n            return [...nodeCrypto.pbkdf2Sync(p, s, iterations, keylen, digest)];\n        }\n    }\n    catch {\n        // ignore\n    }\n    const p = Uint8Array.from(password);\n    const s = Uint8Array.from(salt);\n    const out = pbkdf2Fast(p, s, iterations, keylen);\n    return Array.from(out);\n}\nexports.pbkdf2 = pbkdf2;\n//# sourceMappingURL=Hash.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/JacobianPoint.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/JacobianPoint.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BasePoint_js_1 = __importDefault(__webpack_require__(/*! ./BasePoint.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BasePoint.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Point_js_1 = __importDefault(__webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\"));\n/**\n * The `JacobianPoint` class extends the `BasePoint` class for handling Jacobian coordinates on an Elliptic Curve.\n * This class defines the properties and the methods needed to work with points in Jacobian coordinates.\n *\n * The Jacobian coordinates represent a point (x, y, z) on an Elliptic Curve such that the usual (x, y) coordinates are given by (x/z^2, y/z^3).\n *\n * @property x - The `x` coordinate of the point in the Jacobian form.\n * @property y - The `y` coordinate of the point in the Jacobian form.\n * @property z - The `z` coordinate of the point in the Jacobian form.\n * @property zOne - Flag that indicates if the `z` coordinate is one.\n *\n * @example\n * const pointJ = new JacobianPoint('3', '4', '1');\n */\nclass JacobianPoint extends BasePoint_js_1.default {\n    /**\n     * Constructs a new `JacobianPoint` instance.\n     *\n     * @param x - If `null`, the x-coordinate will default to the curve's defined 'one' constant.\n     * If `x` is not a BigNumber, `x` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @param y - If `null`, the y-coordinate will default to the curve's defined 'one' constant.\n     * If `y` is not a BigNumber, `y` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @param z - If `null`, the z-coordinate will default to 0.\n     * If `z` is not a BigNumber, `z` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @example\n     * const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity\n     * const pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)\n     */\n    constructor(x, y, z) {\n        super('jacobian');\n        if (x === null && y === null && z === null) {\n            this.x = this.curve.one;\n            this.y = this.curve.one;\n            this.z = new BigNumber_js_1.default(0);\n        }\n        else {\n            if (!BigNumber_js_1.default.isBN(x)) {\n                x = new BigNumber_js_1.default(x, 16);\n            }\n            this.x = x;\n            if (!BigNumber_js_1.default.isBN(y)) {\n                y = new BigNumber_js_1.default(y, 16);\n            }\n            this.y = y;\n            if (!BigNumber_js_1.default.isBN(z)) {\n                z = new BigNumber_js_1.default(z, 16);\n            }\n            this.z = z;\n        }\n        if (this.x.red == null) {\n            this.x = this.x.toRed(this.curve.red);\n        }\n        if (this.y.red == null) {\n            this.y = this.y.toRed(this.curve.red);\n        }\n        if (this.z.red == null) {\n            this.z = this.z.toRed(this.curve.red);\n        }\n        this.zOne = this.z === this.curve.one;\n    }\n    /**\n     * Converts the `JacobianPoint` object instance to standard affine `Point` format and returns `Point` type.\n     *\n     * @returns The `Point`(affine) object representing the same point as the original `JacobianPoint`.\n     *\n     * If the initial `JacobianPoint` represents point at infinity, an instance of `Point` at infinity is returned.\n     *\n     * @example\n     * const pointJ = new JacobianPoint('3', '4', '1');\n     * const pointP = pointJ.toP();  // The point in affine coordinates.\n     */\n    toP() {\n        if (this.isInfinity()) {\n            return new Point_js_1.default(null, null);\n        }\n        const zinv = this.z.redInvm();\n        const zinv2 = zinv.redSqr();\n        const ax = this.x.redMul(zinv2);\n        const ay = this.y.redMul(zinv2).redMul(zinv);\n        return new Point_js_1.default(ax, ay);\n    }\n    /**\n     * Negation operation. It returns the additive inverse of the Jacobian point.\n     *\n     * @method neg\n     * @returns Returns a new Jacobian point as the result of the negation.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.neg()\n     */\n    neg() {\n        return new JacobianPoint(this.x, this.y.redNeg(), this.z);\n    }\n    /**\n     * Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument\n     * and returns a new Jacobian point as a result of the addition. In the special cases,\n     * when either one of the points is the point at infinity, it will return the other point.\n     *\n     * @method add\n     * @param p - The Jacobian point to be added.\n     * @returns Returns a new Jacobian point as the result of the addition.\n     *\n     * @example\n     * const p1 = new JacobianPoint(x1, y1, z1)\n     * const p2 = new JacobianPoint(x2, y2, z2)\n     * const result = p1.add(p2)\n     */\n    add(p) {\n        // O + P = P\n        if (this.isInfinity()) {\n            return p;\n        }\n        // P + O = P\n        if (p.isInfinity()) {\n            return this;\n        }\n        // 12M + 4S + 7A\n        const pz2 = p.z.redSqr();\n        const z2 = this.z.redSqr();\n        const u1 = this.x.redMul(pz2);\n        const u2 = p.x.redMul(z2);\n        const s1 = this.y.redMul(pz2.redMul(p.z));\n        const s2 = p.y.redMul(z2.redMul(this.z));\n        const h = u1.redSub(u2);\n        const r = s1.redSub(s2);\n        if (h.cmpn(0) === 0) {\n            if (r.cmpn(0) !== 0) {\n                return new JacobianPoint(null, null, null);\n            }\n            else {\n                return this.dbl();\n            }\n        }\n        const h2 = h.redSqr();\n        const h3 = h2.redMul(h);\n        const v = u1.redMul(h2);\n        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n        const nz = this.z.redMul(p.z).redMul(h);\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Mixed addition operation. This function combines the standard point addition with\n     * the transformation from the affine to Jacobian coordinates. It first converts\n     * the affine point to Jacobian, and then preforms the addition.\n     *\n     * @method mixedAdd\n     * @param p - The affine point to be added.\n     * @returns Returns the result of the mixed addition as a new Jacobian point.\n     *\n     * @example\n     * const jp = new JacobianPoint(x1, y1, z1)\n     * const ap = new Point(x2, y2)\n     * const result = jp.mixedAdd(ap)\n     */\n    mixedAdd(p) {\n        // O + P = P\n        if (this.isInfinity()) {\n            return p.toJ();\n        }\n        // P + O = P\n        if (p.isInfinity()) {\n            return this;\n        }\n        // Ensure x and y are not null\n        if (p.x === null || p.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        // 8M + 3S + 7A\n        const z2 = this.z.redSqr();\n        const u1 = this.x;\n        const u2 = p.x.redMul(z2);\n        const s1 = this.y;\n        const s2 = p.y.redMul(z2).redMul(this.z);\n        const h = u1.redSub(u2);\n        const r = s1.redSub(s2);\n        if (h.cmpn(0) === 0) {\n            if (r.cmpn(0) !== 0) {\n                return new JacobianPoint(null, null, null);\n            }\n            else {\n                return this.dbl();\n            }\n        }\n        const h2 = h.redSqr();\n        const h3 = h2.redMul(h);\n        const v = u1.redMul(h2);\n        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n        const nz = this.z.redMul(h);\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.\n     *\n     * @method dblp\n     * @param pow - The number of times the point should be doubled.\n     * @returns Returns a new Jacobian point as the result of multiple doublings.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.dblp(3)\n     */\n    dblp(pow) {\n        if (pow === 0) {\n            return this;\n        }\n        if (this.isInfinity()) {\n            return this;\n        }\n        if (typeof pow === 'undefined') {\n            return this.dbl();\n        }\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let r = this;\n        for (let i = 0; i < pow; i++) {\n            r = r.dbl();\n        }\n        return r;\n    }\n    /**\n     * Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.\n     *\n     * @method dbl\n     * @returns Returns a new Jacobian point as the result of the doubling.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.dbl()\n     */\n    dbl() {\n        if (this.isInfinity()) {\n            return this;\n        }\n        let nx;\n        let ny;\n        let nz;\n        // Z = 1\n        if (this.zOne) {\n            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n            //     #doubling-mdbl-2007-bl\n            // 1M + 5S + 14A\n            // XX = X1^2\n            const xx = this.x.redSqr();\n            // YY = Y1^2\n            const yy = this.y.redSqr();\n            // YYYY = YY^2\n            const yyyy = yy.redSqr();\n            // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n            let s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n            s = s.redIAdd(s);\n            // M = 3 * XX + a; a = 0\n            const m = xx.redAdd(xx).redIAdd(xx);\n            // T = M ^ 2 - 2*S\n            const t = m.redSqr().redISub(s).redISub(s);\n            // 8 * YYYY\n            let yyyy8 = yyyy.redIAdd(yyyy);\n            yyyy8 = yyyy8.redIAdd(yyyy8);\n            yyyy8 = yyyy8.redIAdd(yyyy8);\n            // X3 = T\n            nx = t;\n            // Y3 = M * (S - T) - 8 * YYYY\n            ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n            // Z3 = 2*Y1\n            nz = this.y.redAdd(this.y);\n        }\n        else {\n            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n            //     #doubling-dbl-2009-l\n            // 2M + 5S + 13A\n            // A = X1^2\n            const a = this.x.redSqr();\n            // B = Y1^2\n            const b = this.y.redSqr();\n            // C = B^2\n            const c = b.redSqr();\n            // D = 2 * ((X1 + B)^2 - A - C)\n            let d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n            d = d.redIAdd(d);\n            // E = 3 * A\n            const e = a.redAdd(a).redIAdd(a);\n            // F = E^2\n            const f = e.redSqr();\n            // 8 * C\n            let c8 = c.redIAdd(c);\n            c8 = c8.redIAdd(c8);\n            c8 = c8.redIAdd(c8);\n            // X3 = F - 2 * D\n            nx = f.redISub(d).redISub(d);\n            // Y3 = E * (D - X3) - 8 * C\n            ny = e.redMul(d.redISub(nx)).redISub(c8);\n            // Z3 = 2 * Y1 * Z1\n            nz = this.y.redMul(this.z);\n            nz = nz.redIAdd(nz);\n        }\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.\n     *\n     * @method eq\n     * @param p - The affine or Jacobian point to compare with.\n     * @returns Returns true if the points are equal, otherwise returns false.\n     *\n     * @example\n     * const jp1 = new JacobianPoint(x1, y1, z1)\n     * const jp2 = new JacobianPoint(x2, y2, z2)\n     * const areEqual = jp1.eq(jp2)\n     */\n    eq(p) {\n        if (p.type === 'affine') {\n            return this.eq(p.toJ());\n        }\n        if (this === p) {\n            return true;\n        }\n        // x1 * z2^2 == x2 * z1^2\n        const z2 = this.z.redSqr();\n        p = p;\n        const pz2 = p.z.redSqr();\n        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) {\n            return false;\n        }\n        // y1 * z2^3 == y2 * z1^3\n        const z3 = z2.redMul(this.z);\n        const pz3 = pz2.redMul(p.z);\n        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n    }\n    /**\n     * Equality check operation in relation to an x coordinate of a point in projective coordinates.\n     * It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate\n     * of a point in projective coordinates.\n     *\n     * @method eqXToP\n     * @param x - The x coordinate of a point in projective coordinates.\n     * @returns Returns true if the x coordinates are equal, otherwise returns false.\n     *\n     * @example\n     * const jp = new JacobianPoint(x1, y1, z1)\n     * const isXEqual = jp.eqXToP(x2)\n     */\n    eqXToP(x) {\n        const zs = this.z.redSqr();\n        const rx = x.toRed(this.curve?.red).redMul(zs);\n        if (this.x.cmp(rx) === 0) {\n            return true;\n        }\n        const xc = x.clone();\n        if (this.curve === null || (this.curve.redN == null)) {\n            throw new Error('Curve or redN is not initialized.');\n        }\n        const t = this.curve.redN.redMul(zs);\n        while (xc.cmp(this.curve.p) < 0) {\n            xc.iadd(this.curve.n);\n            if (xc.cmp(this.curve.p) >= 0) {\n                return false;\n            }\n            rx.redIAdd(t);\n            if (this.x.cmp(rx) === 0) {\n                return true;\n            }\n        }\n        //  Ensure function always returns a boolean\n        return false;\n    }\n    /**\n     * Returns the string representation of the JacobianPoint instance.\n     * @method inspect\n     * @returns Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is '<EC JPoint Infinity>'. For a normal point, it returns the string description format as '<EC JPoint x: x-coordinate y: y-coordinate z: z-coordinate>'.\n     *\n     * @example\n     * const point = new JacobianPoint('5', '6', '1');\n     * console.log(point.inspect()); // Output: '<EC JPoint x: 5 y: 6 z: 1>'\n     */\n    inspect() {\n        if (this.isInfinity()) {\n            return '<EC JPoint Infinity>';\n        }\n        return ('<EC JPoint x: ' +\n            this.x.toString(16, 2) +\n            ' y: ' +\n            this.y.toString(16, 2) +\n            ' z: ' +\n            this.z.toString(16, 2) +\n            '>');\n    }\n    /**\n     * Checks whether the JacobianPoint instance represents a point at infinity.\n     * @method isInfinity\n     * @returns Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.\n     *\n     * @example\n     * const point = new JacobianPoint('5', '6', '0');\n     * console.log(point.isInfinity()); // Output: true\n     */\n    isInfinity() {\n        return this.z.cmpn(0) === 0;\n    }\n}\nexports[\"default\"] = JacobianPoint;\n//# sourceMappingURL=JacobianPoint.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/JacobianPoint.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/K256.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/K256.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Mersenne_js_1 = __importDefault(__webpack_require__(/*! ./Mersenne.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Mersenne.js\"));\n/**\n * A class representing K-256, a prime number with optimizations, specifically used in the secp256k1 curve.\n * It extends the functionalities of the Mersenne class.\n * K-256 prime is represented as 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'\n *\n * @class K256\n * @extends {Mersenne}\n *\n * @example\n * const k256 = new K256();\n */\nclass K256 extends Mersenne_js_1.default {\n    /**\n     * Constructor for the K256 class.\n     * Creates an instance of K256 using the super constructor from Mersenne.\n     *\n     * @constructor\n     *\n     * @example\n     * const k256 = new K256();\n     */\n    constructor() {\n        super('k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n    }\n    /**\n     * Splits a BigNumber into a new BigNumber based on specific computation\n     * rules. This method modifies the input and output big numbers.\n     *\n     * @method split\n     * @param input - The BigNumber to be split.\n     * @param output - The BigNumber that results from the split.\n     *\n     * @example\n     * const input = new BigNumber(3456);\n     * const output = new BigNumber(0);\n     * k256.split(input, output);\n     */\n    split(input, output) {\n        const mask = 0x3fffff; // 22 bits\n        const inputWords = input.words; // Access via getter\n        const inputNominalLength = input.length; // Access via getter, respects _nominalWordLength\n        const outLen = Math.min(inputNominalLength, 9);\n        const tempOutputWords = new Array(outLen + (inputNominalLength > 9 ? 1 : 0)).fill(0);\n        for (let i = 0; i < outLen; i++) {\n            tempOutputWords[i] = inputWords[i];\n        }\n        let currentOutputWordCount = outLen;\n        if (inputNominalLength <= 9) {\n            const finalOutputWords = new Array(currentOutputWordCount);\n            for (let i = 0; i < currentOutputWordCount; ++i)\n                finalOutputWords[i] = tempOutputWords[i];\n            output.words = finalOutputWords; // Use setter\n            input.words = [0]; // Use setter to set to 0\n            return;\n        }\n        // Shift by 9 limbs\n        let prev = inputWords[9];\n        tempOutputWords[currentOutputWordCount++] = prev & mask;\n        const finalOutputWords = new Array(currentOutputWordCount);\n        for (let i = 0; i < currentOutputWordCount; ++i)\n            finalOutputWords[i] = tempOutputWords[i];\n        output.words = finalOutputWords; // Use setter for output\n        // For input modification\n        const tempInputNewWords = new Array(Math.max(1, inputNominalLength - 9)).fill(0);\n        let currentInputNewWordCount = 0;\n        for (let i = 10; i < inputNominalLength; i++) {\n            const next = inputWords[i] | 0;\n            if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check\n                tempInputNewWords[currentInputNewWordCount++] = ((next & mask) << 4) | (prev >>> 22);\n            }\n            prev = next;\n        }\n        prev >>>= 22;\n        if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check\n            tempInputNewWords[currentInputNewWordCount++] = prev;\n        }\n        else if (prev !== 0 && tempInputNewWords.length > 0) { // If prev is non-zero but no space, this is an issue.\n            // This case implies original logic might have relied on array auto-expansion or specific length handling\n            // For safety, if there's still a carry and no space, the array should have been bigger.\n            // However, the original logic `input.length -= 9` suggests truncation.\n        }\n        const finalInputNewWords = new Array(currentInputNewWordCount);\n        for (let i = 0; i < currentInputNewWordCount; ++i)\n            finalInputNewWords[i] = tempInputNewWords[i];\n        input.words = finalInputNewWords; // Use setter, which will strip and set magnitude\n    }\n    /**\n     * Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result.\n     * 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].\n     *\n     * @method imulK\n     * @param num - The BigNumber to multiply with K.\n     * @returns Returns the mutated BigNumber after multiplication.\n     *\n     * @example\n     * const number = new BigNumber(12345);\n     * const result = k256.imulK(number);\n     */\n    imulK(num) {\n        const currentWords = num.words; // Get current words based on _magnitude and _nominalWordLength\n        const originalNominalLength = num.length; // Getter\n        const newNominalLength = originalNominalLength + 2;\n        const tempWords = new Array(newNominalLength).fill(0);\n        for (let i = 0; i < originalNominalLength; i++) {\n            tempWords[i] = currentWords[i];\n        }\n        // tempWords is now effectively num.words expanded with zeroes\n        let lo = 0;\n        for (let i = 0; i < newNominalLength; i++) { // Iterate up to new expanded length\n            const w = tempWords[i] | 0;\n            lo += w * 0x3d1; // 0x3d1 = 977\n            tempWords[i] = lo & 0x3ffffff; // 26-bit mask\n            lo = w * 0x40 + ((lo / 0x4000000) | 0); // 0x40 = 64. 0x4000000 = 2^26\n        }\n        num.words = tempWords; // Use setter to re-initialize from tempWords\n        // The setter will handle _magnitude, _sign, _nominalWordLength, and strip.\n        return num;\n    }\n}\nexports[\"default\"] = K256;\n//# sourceMappingURL=K256.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/K256.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Mersenne.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Mersenne.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\n/**\n * A representation of a pseudo-Mersenne prime.\n * A pseudo-Mersenne prime has the general form 2^n - k, where n and k are integers.\n *\n * @class Mersenne\n *\n * @property name - The identifier for the Mersenne instance.\n * @property p - BigNumber equivalent to 2^n - k.\n * @property k - The constant subtracted from 2^n to derive a pseudo-Mersenne prime.\n * @property n - The exponent which determines the magnitude of the prime.\n */\nclass Mersenne {\n    /**\n     * @constructor\n     * @param name - An identifier for the Mersenne instance.\n     * @param p - A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.\n     *\n     * @example\n     * const mersenne = new Mersenne('M31', '7FFFFFFF');\n     */\n    constructor(name, p) {\n        // P = 2 ^ N - K\n        this.name = name;\n        this.p = new BigNumber_js_1.default(p, 16);\n        this.n = this.p.bitLength();\n        this.k = new BigNumber_js_1.default(BigInt(1)).iushln(this.n).isub(this.p); // Use 1n for BigInt compatibility\n        this.tmp = this._tmp();\n    }\n    /**\n     * Creates a temporary BigNumber structure for computations,\n     * ensuring the appropriate number of words are initially allocated.\n     *\n     * @method _tmp\n     * @returns A BigNumber with scaled size depending on prime magnitude.\n     */\n    _tmp() {\n        const tmp = new BigNumber_js_1.default(BigInt(0)); // Initialize with BigInt 0\n        const requiredWords = Math.ceil(this.n / BigNumber_js_1.default.wordSize);\n        tmp.expand(Math.max(1, requiredWords)); // Expand sets _nominalWordLength\n        return tmp;\n    }\n    /**\n     * Reduces an input BigNumber in place, under the assumption that\n     * it is less than the square of the pseudo-Mersenne prime.\n     *\n     * @method ireduce\n     * @param num - The BigNumber to be reduced.\n     * @returns The reduced BigNumber.\n     *\n     * @example\n     * const reduced = mersenne.ireduce(new BigNumber('2345', 16));\n     */\n    ireduce(num) {\n        // Assumes that `num` is less than `P^2`\n        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n        const r = num; // num is directly modified\n        let rlen;\n        do {\n            this.split(r, this.tmp); // r is modified (becomes HI), this.tmp becomes LO\n            this.imulK(r); // r becomes HI * K\n            r.iadd(this.tmp); // r becomes HI * K + LO\n            rlen = r.bitLength();\n        } while (rlen > this.n);\n        const cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n        if (cmp === 0) {\n            r.words = [0]; // Set to zero using the words setter\n        }\n        else if (cmp > 0) {\n            r.isub(this.p);\n        }\n        // No explicit strip needed here if operations maintain correctness and setter handles it.\n        // However, ensuring it's stripped to minimal form after reduction is good.\n        r.strip();\n        return r;\n    }\n    /**\n     * Shifts bits of the input BigNumber to the right, in place,\n     * to meet the magnitude of the pseudo-Mersenne prime.\n     *\n     * @method split\n     * @param input - The BigNumber to be shifted (will contain HI part).\n     * @param out - The BigNumber to hold the shifted result (LO part).\n     *\n     * @example\n     * mersenne.split(new BigNumber('2345', 16), new BigNumber());\n     */\n    split(input, out) {\n        // out gets the LO bits (shifted out part)\n        // input gets modified to be the HI bits (remaining part after shift)\n        input.iushrn(this.n, 0, out);\n    }\n    /**\n     * Performs an in-place multiplication of the parameter by constant k.\n     *\n     * @method imulK\n     * @param num - The BigNumber to multiply with k.\n     * @returns The result of the multiplication, in BigNumber format.\n     *\n     * @example\n     * const multiplied = mersenne.imulK(new BigNumber('2345', 16));\n     */\n    imulK(num) {\n        return num.imul(this.k);\n    }\n}\nexports[\"default\"] = Mersenne;\n//# sourceMappingURL=Mersenne.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Mersenne.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/MontgomoryMethod.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/MontgomoryMethod.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ReductionContext_js_1 = __importDefault(__webpack_require__(/*! ./ReductionContext.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ReductionContext.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\n/**\n * Represents a Montgomery reduction context, which is a mathematical method\n * for performing modular multiplication without division.\n *\n * Montgomery reduction is an algorithm used mainly in cryptography which can\n * help to speed up calculations in contexts where there are many repeated\n * computations.\n *\n * This class extends the `ReductionContext` class.\n *\n * @class MontgomoryMethod\n * @extends {ReductionContext}\n *\n * @property shift - The number of bits in the modulus.\n * @property r - The 2^shift, shifted left by the bit length of modulus `m`.\n * @property r2 - The square of `r` modulo `m`.\n * @property rinv - The modular multiplicative inverse of `r` mod `m`.\n * @property minv - The modular multiplicative inverse of `m` mod `r`.\n */\nclass MontgomoryMethod extends ReductionContext_js_1.default {\n    /**\n     * @constructor\n     * @param m - The modulus to be used for the Montgomery method reductions.\n     */\n    constructor(m) {\n        super(m);\n        this.shift = this.m.bitLength();\n        if (this.shift % 26 !== 0) {\n            this.shift += 26 - (this.shift % 26);\n        }\n        this.r = new BigNumber_js_1.default(1).iushln(this.shift);\n        this.r2 = this.imod(this.r.sqr());\n        this.rinv = this.r._invmp(this.m);\n        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n        this.minv = this.minv.umod(this.r);\n        this.minv = this.r.sub(this.minv);\n    }\n    /**\n     * Converts a number into the Montgomery domain.\n     *\n     * @method convertTo\n     * @param num - The number to be converted into the Montgomery domain.\n     * @returns The result of the conversion into the Montgomery domain.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const convertedNum = montMethod.convertTo(num);\n     */\n    convertTo(num) {\n        return this.imod(num.ushln(this.shift));\n    }\n    /**\n     * Converts a number from the Montgomery domain back to the original domain.\n     *\n     * @method convertFrom\n     * @param num - The number to be converted from the Montgomery domain.\n     * @returns The result of the conversion from the Montgomery domain.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const convertedNum = montMethod.convertFrom(num);\n     */\n    convertFrom(num) {\n        const r = this.imod(num.mul(this.rinv));\n        r.red = null;\n        return r;\n    }\n    /**\n     * Performs an in-place multiplication of two numbers in the Montgomery domain.\n     *\n     * @method imul\n     * @param a - The first number to multiply.\n     * @param b - The second number to multiply.\n     * @returns The result of the in-place multiplication.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const product = montMethod.imul(a, b);\n     */\n    imul(a, b) {\n        if (a.isZero() || b.isZero()) {\n            a.words[0] = 0;\n            a.length = 1;\n            return a;\n        }\n        const t = a.imul(b);\n        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        const u = t.isub(c).iushrn(this.shift);\n        let res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        }\n        else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs the multiplication of two numbers in the Montgomery domain.\n     *\n     * @method mul\n     * @param a - The first number to multiply.\n     * @param b - The second number to multiply.\n     * @returns The result of the multiplication.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const product = montMethod.mul(a, b);\n     */\n    mul(a, b) {\n        if (a.isZero() || b.isZero())\n            return new BigNumber_js_1.default(0).forceRed(this);\n        const t = a.mul(b);\n        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        const u = t.isub(c).iushrn(this.shift);\n        let res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        }\n        else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Calculates the modular multiplicative inverse of a number in the Montgomery domain.\n     *\n     * @method invm\n     * @param a - The number to compute the modular multiplicative inverse of.\n     * @returns The modular multiplicative inverse of 'a'.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const inverse = montMethod.invm(a);\n     */\n    invm(a) {\n        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n        const res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res.forceRed(this);\n    }\n}\nexports[\"default\"] = MontgomoryMethod;\n//# sourceMappingURL=MontgomoryMethod.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/MontgomoryMethod.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.modInvN = exports.modMulN = exports.modN = exports.scalarMultiplyWNAF = exports.jpNeg = exports.jpAdd = exports.jpDouble = exports.GY_BIGINT = exports.GX_BIGINT = exports.biModSqrt = exports.P_PLUS1_DIV4 = exports.biModPow = exports.biModSqr = exports.biModInv = exports.biModAdd = exports.biModMul = exports.biModSub = exports.biMod = exports.red = exports.MASK_256 = exports.N_BIGINT = exports.P_BIGINT = exports.BI_EIGHT = exports.BI_FOUR = exports.BI_THREE = exports.BI_TWO = exports.BI_ONE = exports.BI_ZERO = void 0;\nconst BasePoint_js_1 = __importDefault(__webpack_require__(/*! ./BasePoint.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BasePoint.js\"));\nconst JacobianPoint_js_1 = __importDefault(__webpack_require__(/*! ./JacobianPoint.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/JacobianPoint.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n// -----------------------------------------------------------------------------\n// BigInt helpers & constants (secp256k1)  hoisted so we don't recreate them on\n// every Point.mul() call.\n// -----------------------------------------------------------------------------\nexports.BI_ZERO = 0n;\nexports.BI_ONE = 1n;\nexports.BI_TWO = 2n;\nexports.BI_THREE = 3n;\nexports.BI_FOUR = 4n;\nexports.BI_EIGHT = 8n;\nexports.P_BIGINT = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;\nexports.N_BIGINT = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;\nexports.MASK_256 = (1n << 256n) - 1n; // 0xffffffff (256 sones)\nfunction red(x) {\n    // first fold\n    let hi = x >> 256n;\n    x = (x & exports.MASK_256) + (hi << 32n) + hi * 977n;\n    // second fold  (hi  2 + 977 here, so one more pass is enough)\n    hi = x >> 256n;\n    x = (x & exports.MASK_256) + (hi << 32n) + hi * 977n;\n    // final conditional subtraction\n    if (x >= exports.P_BIGINT)\n        x -= exports.P_BIGINT;\n    return x;\n}\nexports.red = red;\nconst biMod = (a) => red((a % exports.P_BIGINT + exports.P_BIGINT) % exports.P_BIGINT);\nexports.biMod = biMod;\nconst biModSub = (a, b) => (a >= b ? a - b : exports.P_BIGINT - (b - a));\nexports.biModSub = biModSub;\nconst biModMul = (a, b) => red(a * b);\nexports.biModMul = biModMul;\nconst biModAdd = (a, b) => red(a + b);\nexports.biModAdd = biModAdd;\nconst biModInv = (a) => {\n    let lm = exports.BI_ONE;\n    let hm = exports.BI_ZERO;\n    let low = (0, exports.biMod)(a);\n    let high = exports.P_BIGINT;\n    while (low > exports.BI_ONE) {\n        const r = high / low;\n        [lm, hm] = [hm - lm * r, lm];\n        [low, high] = [high - low * r, low];\n    }\n    return (0, exports.biMod)(lm);\n};\nexports.biModInv = biModInv;\nconst biModSqr = (a) => (0, exports.biModMul)(a, a);\nexports.biModSqr = biModSqr;\nconst biModPow = (base, exp) => {\n    let result = exports.BI_ONE;\n    base = (0, exports.biMod)(base);\n    let e = exp;\n    while (e > exports.BI_ZERO) {\n        if ((e & exports.BI_ONE) === exports.BI_ONE)\n            result = (0, exports.biModMul)(result, base);\n        base = (0, exports.biModMul)(base, base);\n        e >>= exports.BI_ONE;\n    }\n    return result;\n};\nexports.biModPow = biModPow;\nexports.P_PLUS1_DIV4 = (exports.P_BIGINT + 1n) >> 2n;\nconst biModSqrt = (a) => {\n    const r = (0, exports.biModPow)(a, exports.P_PLUS1_DIV4);\n    return (0, exports.biModMul)(r, r) === (0, exports.biMod)(a) ? r : null;\n};\nexports.biModSqrt = biModSqrt;\nconst toBigInt = (x) => {\n    if (BigNumber_js_1.default.isBN(x))\n        return BigInt('0x' + x.toString(16));\n    if (typeof x === 'string')\n        return BigInt('0x' + x);\n    if (Array.isArray(x))\n        return BigInt('0x' + (0, utils_js_1.toHex)(x));\n    return BigInt(x);\n};\n// Generator point coordinates as bigint constants\nexports.GX_BIGINT = BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');\nexports.GY_BIGINT = BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8');\n// Cache for precomputed windowed tables keyed by 'window:x:y'\nconst WNAF_TABLE_CACHE = new Map();\nconst jpDouble = (P) => {\n    const { X: X1, Y: Y1, Z: Z1 } = P;\n    if (Y1 === exports.BI_ZERO)\n        return { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO };\n    const Y1sq = (0, exports.biModMul)(Y1, Y1);\n    const S = (0, exports.biModMul)(exports.BI_FOUR, (0, exports.biModMul)(X1, Y1sq));\n    const M = (0, exports.biModMul)(exports.BI_THREE, (0, exports.biModMul)(X1, X1));\n    const X3 = (0, exports.biModSub)((0, exports.biModMul)(M, M), (0, exports.biModMul)(exports.BI_TWO, S));\n    const Y3 = (0, exports.biModSub)((0, exports.biModMul)(M, (0, exports.biModSub)(S, X3)), (0, exports.biModMul)(exports.BI_EIGHT, (0, exports.biModMul)(Y1sq, Y1sq)));\n    const Z3 = (0, exports.biModMul)(exports.BI_TWO, (0, exports.biModMul)(Y1, Z1));\n    return { X: X3, Y: Y3, Z: Z3 };\n};\nexports.jpDouble = jpDouble;\nconst jpAdd = (P, Q) => {\n    if (P.Z === exports.BI_ZERO)\n        return Q;\n    if (Q.Z === exports.BI_ZERO)\n        return P;\n    const Z1Z1 = (0, exports.biModMul)(P.Z, P.Z);\n    const Z2Z2 = (0, exports.biModMul)(Q.Z, Q.Z);\n    const U1 = (0, exports.biModMul)(P.X, Z2Z2);\n    const U2 = (0, exports.biModMul)(Q.X, Z1Z1);\n    const S1 = (0, exports.biModMul)(P.Y, (0, exports.biModMul)(Z2Z2, Q.Z));\n    const S2 = (0, exports.biModMul)(Q.Y, (0, exports.biModMul)(Z1Z1, P.Z));\n    const H = (0, exports.biModSub)(U2, U1);\n    const r = (0, exports.biModSub)(S2, S1);\n    if (H === exports.BI_ZERO) {\n        if (r === exports.BI_ZERO)\n            return (0, exports.jpDouble)(P);\n        return { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO }; // Infinity\n    }\n    const HH = (0, exports.biModMul)(H, H);\n    const HHH = (0, exports.biModMul)(H, HH);\n    const V = (0, exports.biModMul)(U1, HH);\n    const X3 = (0, exports.biModSub)((0, exports.biModSub)((0, exports.biModMul)(r, r), HHH), (0, exports.biModMul)(exports.BI_TWO, V));\n    const Y3 = (0, exports.biModSub)((0, exports.biModMul)(r, (0, exports.biModSub)(V, X3)), (0, exports.biModMul)(S1, HHH));\n    const Z3 = (0, exports.biModMul)(H, (0, exports.biModMul)(P.Z, Q.Z));\n    return { X: X3, Y: Y3, Z: Z3 };\n};\nexports.jpAdd = jpAdd;\nconst jpNeg = (P) => {\n    if (P.Z === exports.BI_ZERO)\n        return P;\n    return { X: P.X, Y: exports.P_BIGINT - P.Y, Z: P.Z };\n};\nexports.jpNeg = jpNeg;\n// Fast windowed-NAF scalar multiplication (default window = 5) in Jacobian\n// coordinates.  Returns Q = k * P0 as a JacobianPoint.\nconst scalarMultiplyWNAF = (k, P0, window = 5) => {\n    const key = `${window}:${P0.x.toString(16)}:${P0.y.toString(16)}`;\n    let tbl = WNAF_TABLE_CACHE.get(key);\n    let P;\n    if (tbl === undefined) {\n        // Convert affine to Jacobian and pre-compute odd multiples\n        const tblSize = 1 << (window - 1); // e.g. w=5  16 entries\n        tbl = new Array(tblSize);\n        P = { X: P0.x, Y: P0.y, Z: exports.BI_ONE };\n        tbl[0] = P;\n        const twoP = (0, exports.jpDouble)(P);\n        for (let i = 1; i < tblSize; i++) {\n            tbl[i] = (0, exports.jpAdd)(tbl[i - 1], twoP);\n        }\n        WNAF_TABLE_CACHE.set(key, tbl);\n    }\n    else {\n        P = tbl[0];\n    }\n    // Build wNAF representation of k\n    const wnaf = [];\n    const wBig = 1n << BigInt(window);\n    const wHalf = wBig >> 1n;\n    let kTmp = k;\n    while (kTmp > 0n) {\n        if ((kTmp & exports.BI_ONE) === exports.BI_ZERO) {\n            wnaf.push(0);\n            kTmp >>= exports.BI_ONE;\n        }\n        else {\n            let z = kTmp & (wBig - 1n); // kTmp mod 2^w\n            if (z > wHalf)\n                z -= wBig; // make it odd & within (-2^{w-1}, 2^{w-1})\n            wnaf.push(Number(z));\n            kTmp -= z;\n            kTmp >>= exports.BI_ONE;\n        }\n    }\n    // Accumulate from MSB to LSB\n    let Q = { X: exports.BI_ZERO, Y: exports.BI_ONE, Z: exports.BI_ZERO }; // infinity\n    for (let i = wnaf.length - 1; i >= 0; i--) {\n        Q = (0, exports.jpDouble)(Q);\n        const di = wnaf[i];\n        if (di !== 0) {\n            const idx = Math.abs(di) >> 1; // (|di|-1)/2  because di is odd\n            const addend = di > 0 ? tbl[idx] : (0, exports.jpNeg)(tbl[idx]);\n            Q = (0, exports.jpAdd)(Q, addend);\n        }\n    }\n    return Q;\n};\nexports.scalarMultiplyWNAF = scalarMultiplyWNAF;\nconst modN = (a) => {\n    let r = a % exports.N_BIGINT;\n    if (r < 0n)\n        r += exports.N_BIGINT;\n    return r;\n};\nexports.modN = modN;\nconst modMulN = (a, b) => (0, exports.modN)(a * b);\nexports.modMulN = modMulN;\n/** modular inverse modulo n with plain extendedgcd (not constanttime) */\nconst modInvN = (a) => {\n    let lm = 1n;\n    let hm = 0n;\n    let low = (0, exports.modN)(a);\n    let high = exports.N_BIGINT;\n    while (low > 1n) {\n        const q = high / low;\n        [lm, hm] = [hm - lm * q, lm];\n        [low, high] = [high - low * q, low];\n    }\n    return (0, exports.modN)(lm);\n};\nexports.modInvN = modInvN;\n/**\n * `Point` class is a representation of an elliptic curve point with affine coordinates.\n * It extends the functionality of BasePoint and carries x, y coordinates of point on the curve.\n * It also introduces new methods for handling Point operations in elliptic curve.\n *\n * @class Point\n * @extends {BasePoint}\n *\n * @property x - The x-coordinate of the point.\n * @property y - The y-coordinate of the point.\n * @property inf - Flag to record if the point is at infinity in the Elliptic Curve.\n */\nclass Point extends BasePoint_js_1.default {\n    /**\n     * Creates a point object from a given Array. These numbers can represent coordinates in hex format, or points\n     * in multiple established formats.\n     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.\n     *\n     * @method fromDER\n     * @static\n     * @param bytes - The point representation number array.\n     * @returns Returns a new point representing the given string.\n     * @throws `Error` If the point number[] value has a wrong length.\n     * @throws `Error` If the point format is unknown.\n     *\n     * @example\n     * const derPoint = [ 2, 18, 123, 108, 125, 83, 1, 251, 164, 214, 16, 119, 200, 216, 210, 193, 251, 193, 129, 67, 97, 146, 210, 216, 77, 254, 18, 6, 150, 190, 99, 198, 128 ];\n     * const point = Point.fromDER(derPoint);\n     */\n    static fromDER(bytes) {\n        const len = 32;\n        // uncompressed, hybrid-odd, hybrid-even\n        if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n            bytes.length - 1 === 2 * len) {\n            if (bytes[0] === 0x06) {\n                if (bytes[bytes.length - 1] % 2 !== 0) {\n                    throw new Error('Point string value is wrong length');\n                }\n            }\n            else if (bytes[0] === 0x07) {\n                if (bytes[bytes.length - 1] % 2 !== 1) {\n                    throw new Error('Point string value is wrong length');\n                }\n            }\n            const res = new Point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n            return res;\n        }\n        else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n            bytes.length - 1 === len) {\n            return Point.fromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n        }\n        throw new Error('Unknown point format');\n    }\n    /**\n     * Creates a point object from a given string. This string can represent coordinates in hex format, or points\n     * in multiple established formats.\n     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.\n     *\n     * @method fromString\n     * @static\n     *\n     * @param str The point representation string.\n     * @returns Returns a new point representing the given string.\n     * @throws `Error` If the point string value has a wrong length.\n     * @throws `Error` If the point format is unknown.\n     *\n     * @example\n     * const pointStr = 'abcdef';\n     * const point = Point.fromString(pointStr);\n     */\n    static fromString(str) {\n        const bytes = (0, utils_js_1.toArray)(str, 'hex');\n        return Point.fromDER(bytes);\n    }\n    /**\n     * Generates a point from an x coordinate and a boolean indicating whether the corresponding\n     * y coordinate is odd.\n     *\n     * @method fromX\n     * @static\n     * @param x - The x coordinate of the point.\n     * @param odd - Boolean indicating whether the corresponding y coordinate is odd or not.\n     * @returns Returns the new point.\n     * @throws `Error` If the point is invalid.\n     *\n     * @example\n     * const xCoordinate = new BigNumber('10');\n     * const point = Point.fromX(xCoordinate, true);\n     */\n    static fromX(x, odd) {\n        let xBigInt = toBigInt(x);\n        xBigInt = (0, exports.biMod)(xBigInt);\n        const y2 = (0, exports.biModAdd)((0, exports.biModMul)((0, exports.biModSqr)(xBigInt), xBigInt), 7n);\n        const y = (0, exports.biModSqrt)(y2);\n        if (y === null)\n            throw new Error('Invalid point');\n        let yBig = y;\n        if ((yBig & exports.BI_ONE) !== (odd ? exports.BI_ONE : exports.BI_ZERO)) {\n            yBig = (0, exports.biModSub)(exports.P_BIGINT, yBig);\n        }\n        const xBN = new BigNumber_js_1.default(xBigInt.toString(16), 16);\n        const yBN = new BigNumber_js_1.default(yBig.toString(16), 16);\n        return new Point(xBN, yBN);\n    }\n    /**\n     * Generates a point from a serialized JSON object. The function accounts for different options in the JSON object,\n     * including precomputed values for optimization of EC operations, and calls another helper function to turn nested\n     * JSON points into proper Point objects.\n     *\n     * @method fromJSON\n     * @static\n     * @param obj - An object or array that holds the data for the point.\n     * @param isRed - A boolean to direct how the Point is constructed from the JSON object.\n     * @returns Returns a new point based on the deserialized JSON object.\n     *\n     * @example\n     * const serializedPoint = '{\"x\":52,\"y\":15}';\n     * const point = Point.fromJSON(serializedPoint, true);\n     */\n    static fromJSON(obj, isRed) {\n        if (typeof obj === 'string') {\n            obj = JSON.parse(obj);\n        }\n        const res = new Point(obj[0], obj[1], isRed);\n        if (typeof obj[2] !== 'object') {\n            return res;\n        }\n        const obj2point = (obj) => {\n            return new Point(obj[0], obj[1], isRed);\n        };\n        const pre = obj[2];\n        res.precomputed = {\n            beta: null,\n            doubles: typeof pre.doubles === 'object' && pre.doubles !== null\n                ? {\n                    step: pre.doubles.step,\n                    points: [res].concat(pre.doubles.points.map(obj2point))\n                }\n                : undefined,\n            naf: typeof pre.naf === 'object' && pre.naf !== null\n                ? {\n                    wnd: pre.naf.wnd,\n                    points: [res].concat(pre.naf.points.map(obj2point))\n                }\n                : undefined\n        };\n        return res;\n    }\n    /**\n     * @constructor\n     * @param x - The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.\n     * @param y - The y-coordinate of the point, similar to x.\n     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.\n     *\n     * @example\n     * new Point('abc123', 'def456');\n     * new Point(null, null); // Generates Infinity point.\n     */\n    constructor(x, y, isRed = true) {\n        super('affine');\n        this.precomputed = null;\n        if (x === null && y === null) {\n            this.x = null;\n            this.y = null;\n            this.inf = true;\n        }\n        else {\n            if (!BigNumber_js_1.default.isBN(x)) {\n                x = new BigNumber_js_1.default(x, 16);\n            }\n            this.x = x;\n            if (!BigNumber_js_1.default.isBN(y)) {\n                y = new BigNumber_js_1.default(y, 16);\n            }\n            this.y = y;\n            // Force redgomery representation when loading from JSON\n            if (isRed) {\n                this.x.forceRed(this.curve.red);\n                this.y.forceRed(this.curve.red);\n            }\n            if (this.x.red === null) {\n                this.x = this.x.toRed(this.curve.red);\n            }\n            if (this.y.red === null) {\n                this.y = this.y.toRed(this.curve.red);\n            }\n            this.inf = false;\n        }\n    }\n    /**\n     * Validates if a point belongs to the curve. Follows the short Weierstrass\n     * equation for elliptic curves: y^2 = x^3 + ax + b.\n     *\n     * @method validate\n     * @returns {boolean} true if the point is on the curve, false otherwise.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const isValid = aPoint.validate();\n     */\n    validate() {\n        return this.curve.validate(this);\n    }\n    /**\n     * Encodes the coordinates of a point into an array or a hexadecimal string.\n     * The details of encoding are determined by the optional compact and enc parameters.\n     *\n     * @method encode\n     * @param compact - If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.\n     * @param enc - Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.\n     * @throws Will throw an error if the specified encoding method is not recognized. Expects 'hex'.\n     * @returns If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const encodedPointArray = aPoint.encode();\n     * const encodedPointHex = aPoint.encode(true, 'hex');\n     */\n    encode(compact = true, enc) {\n        const len = this.curve.p.byteLength();\n        const x = this.getX().toArray('be', len);\n        let res;\n        if (compact) {\n            res = [this.getY().isEven() ? 0x02 : 0x03].concat(x);\n        }\n        else {\n            res = [0x04].concat(x, this.getY().toArray('be', len));\n        }\n        if (enc !== 'hex') {\n            return res;\n        }\n        else {\n            return (0, utils_js_1.toHex)(res);\n        }\n    }\n    /**\n     * Converts the point coordinates to a hexadecimal string. A wrapper method\n     * for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.\n     *\n     * @method toString\n     * @returns {string} A hexadecimal string representation of the point coordinates.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const stringPoint = aPoint.toString();\n     */\n    toString() {\n        return this.encode(true, 'hex');\n    }\n    /**\n     * Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.\n     *\n     * @method toJSON\n     * @returns An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const jsonPoint = aPoint.toJSON();\n     */\n    toJSON() {\n        if (this.precomputed == null) {\n            return [this.x, this.y];\n        }\n        return [\n            this.x,\n            this.y,\n            typeof this.precomputed === 'object' && this.precomputed !== null\n                ? {\n                    doubles: this.precomputed.doubles != null\n                        ? {\n                            step: this.precomputed.doubles.step,\n                            points: this.precomputed.doubles.points.slice(1)\n                        }\n                        : undefined,\n                    naf: this.precomputed.naf != null\n                        ? {\n                            wnd: this.precomputed.naf.wnd,\n                            points: this.precomputed.naf.points.slice(1)\n                        }\n                        : undefined\n                }\n                : undefined\n        ];\n    }\n    /**\n     * Provides the point coordinates in a human-readable string format for debugging purposes.\n     *\n     * @method inspect\n     * @returns String of the format '<EC Point x: x-coordinate y: y-coordinate>', or '<EC Point Infinity>' if the point is at infinity.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * console.log(aPoint.inspect());\n     */\n    inspect() {\n        if (this.isInfinity()) {\n            return '<EC Point Infinity>';\n        }\n        return ('<EC Point x: ' +\n            (this.x?.fromRed()?.toString(16, 2) ?? 'undefined') +\n            ' y: ' +\n            (this.y?.fromRed()?.toString(16, 2) ?? 'undefined') +\n            '>');\n    }\n    /**\n     * Checks if the point is at infinity.\n     * @method isInfinity\n     * @returns Returns whether or not the point is at infinity.\n     *\n     * @example\n     * const p = new Point(null, null);\n     * console.log(p.isInfinity()); // outputs: true\n     */\n    isInfinity() {\n        return this.inf;\n    }\n    /**\n     * Adds another Point to this Point, returning a new Point.\n     *\n     * @method add\n     * @param p - The Point to add to this one.\n     * @returns A new Point that results from the addition.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.add(p2);\n     */\n    add(p) {\n        // O + P = P\n        if (this.inf) {\n            return p;\n        }\n        // P + O = P\n        if (p.inf) {\n            return this;\n        }\n        // P + P = 2P\n        if (this.eq(p)) {\n            return this.dbl();\n        }\n        // P + (-P) = O\n        if (this.neg().eq(p)) {\n            return new Point(null, null);\n        }\n        // P + Q = O\n        if (this.x?.cmp(p.x ?? new BigNumber_js_1.default(0)) === 0) {\n            return new Point(null, null);\n        }\n        const P1 = {\n            X: BigInt('0x' + this.x.fromRed().toString(16)),\n            Y: BigInt('0x' + this.y.fromRed().toString(16)),\n            Z: exports.BI_ONE\n        };\n        const Q1 = {\n            X: BigInt('0x' + p.x.fromRed().toString(16)),\n            Y: BigInt('0x' + p.y.fromRed().toString(16)),\n            Z: exports.BI_ONE\n        };\n        const R = (0, exports.jpAdd)(P1, Q1);\n        if (R.Z === exports.BI_ZERO)\n            return new Point(null, null);\n        const zInv = (0, exports.biModInv)(R.Z);\n        const zInv2 = (0, exports.biModMul)(zInv, zInv);\n        const xRes = (0, exports.biModMul)(R.X, zInv2);\n        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));\n        return new Point(xRes.toString(16), yRes.toString(16));\n    }\n    /**\n     * Doubles the current point.\n     *\n     * @method dbl\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const result = P.dbl();\n     * */\n    dbl() {\n        if (this.inf)\n            return this;\n        if (this.x === null || this.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        const X = BigInt('0x' + this.x.fromRed().toString(16));\n        const Y = BigInt('0x' + this.y.fromRed().toString(16));\n        if (Y === exports.BI_ZERO)\n            return new Point(null, null);\n        const R = (0, exports.jpDouble)({ X, Y, Z: exports.BI_ONE });\n        const zInv = (0, exports.biModInv)(R.Z);\n        const zInv2 = (0, exports.biModMul)(zInv, zInv);\n        const xRes = (0, exports.biModMul)(R.X, zInv2);\n        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));\n        return new Point(xRes.toString(16), yRes.toString(16));\n    }\n    /**\n     * Returns X coordinate of point\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const x = P.getX();\n     */\n    getX() {\n        return (this.x ?? new BigNumber_js_1.default(0)).fromRed();\n    }\n    /**\n     * Returns X coordinate of point\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const x = P.getX();\n     */\n    getY() {\n        return (this.y ?? new BigNumber_js_1.default(0)).fromRed();\n    }\n    /**\n     * Multiplies this Point by a scalar value, returning a new Point.\n     *\n     * @method mul\n     * @param k - The scalar value to multiply this Point by.\n     * @returns  A new Point that results from the multiplication.\n     *\n     * @example\n     * const p = new Point(1, 2);\n     * const result = p.mul(2); // this doubles the Point\n     */\n    mul(k) {\n        if (!BigNumber_js_1.default.isBN(k)) {\n            k = new BigNumber_js_1.default(k, 16);\n        }\n        k = k;\n        if (this.inf) {\n            return this;\n        }\n        let kBig = BigInt('0x' + k.toString(16));\n        const isNeg = kBig < exports.BI_ZERO;\n        if (isNeg)\n            kBig = -kBig;\n        kBig = (0, exports.biMod)(kBig);\n        if (kBig === exports.BI_ZERO) {\n            return new Point(null, null);\n        }\n        if (this.x === null || this.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        let Px;\n        let Py;\n        if (this === this.curve.g) {\n            Px = exports.GX_BIGINT;\n            Py = exports.GY_BIGINT;\n        }\n        else {\n            Px = BigInt('0x' + this.x.fromRed().toString(16));\n            Py = BigInt('0x' + this.y.fromRed().toString(16));\n        }\n        const R = (0, exports.scalarMultiplyWNAF)(kBig, { x: Px, y: Py });\n        if (R.Z === exports.BI_ZERO) {\n            return new Point(null, null);\n        }\n        const zInv = (0, exports.biModInv)(R.Z);\n        const zInv2 = (0, exports.biModMul)(zInv, zInv);\n        const xRes = (0, exports.biModMul)(R.X, zInv2);\n        const yRes = (0, exports.biModMul)(R.Y, (0, exports.biModMul)(zInv2, zInv));\n        const xBN = new BigNumber_js_1.default(xRes.toString(16), 16);\n        const yBN = new BigNumber_js_1.default(yRes.toString(16), 16);\n        const result = new Point(xBN, yBN);\n        if (isNeg) {\n            return result.neg();\n        }\n        return result;\n    }\n    /**\n     * Performs a multiplication and addition operation in a single step.\n     * Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.\n     *\n     * @method mulAdd\n     * @param k1 - The scalar value to multiply this Point by.\n     * @param p2 - The other Point to be involved in the operation.\n     * @param k2 - The scalar value to multiply the Point p2 by.\n     * @returns A Point that results from the combined multiplication and addition operations.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.mulAdd(2, p2, 3);\n     */\n    mulAdd(k1, p2, k2) {\n        const points = [this, p2];\n        const coeffs = [k1, k2];\n        return this._endoWnafMulAdd(points, coeffs);\n    }\n    /**\n     * Performs the Jacobian multiplication and addition operation in a single\n     * step. Instead of returning a regular Point, the result is a JacobianPoint.\n     *\n     * @method jmulAdd\n     * @param k1 - The scalar value to multiply this Point by.\n     * @param p2 - The other Point to be involved in the operation\n     * @param k2 - The scalar value to multiply the Point p2 by.\n     * @returns A JacobianPoint that results from the combined multiplication and addition operation.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.jmulAdd(2, p2, 3);\n     */\n    jmulAdd(k1, p2, k2) {\n        const points = [this, p2];\n        const coeffs = [k1, k2];\n        return this._endoWnafMulAdd(points, coeffs, true);\n    }\n    /**\n     * Checks if the Point instance is equal to another given Point.\n     *\n     * @method eq\n     * @param p - The Point to be checked if equal to the current instance.\n     *\n     * @returns Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.\n     *\n     * @example\n     * const p1 = new Point(5, 20);\n     * const p2 = new Point(5, 20);\n     * const areEqual = p1.eq(p2); // returns true\n     */\n    eq(p) {\n        return (this === p ||\n            (this.inf === p.inf &&\n                (this.inf || ((this.x ?? new BigNumber_js_1.default(0)).cmp(p.x ?? new BigNumber_js_1.default(0)) === 0 && (this.y ?? new BigNumber_js_1.default(0)).cmp(p.y ?? new BigNumber_js_1.default(0)) === 0))));\n    }\n    /**\n     * Negate a point. The negation of a point P is the mirror of P about x-axis.\n     *\n     * @method neg\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const result = P.neg();\n     */\n    neg(_precompute) {\n        if (this.inf) {\n            return this;\n        }\n        const res = new Point(this.x, (this.y ?? new BigNumber_js_1.default(0)).redNeg());\n        if (_precompute === true && this.precomputed != null) {\n            const pre = this.precomputed;\n            const negate = (p) => p.neg();\n            res.precomputed = {\n                naf: pre.naf != null\n                    ? {\n                        wnd: pre.naf.wnd,\n                        points: pre.naf.points.map(negate)\n                    }\n                    : undefined,\n                doubles: pre.doubles != null\n                    ? {\n                        step: pre.doubles.step,\n                        points: pre.doubles.points.map((p) => p.neg())\n                    }\n                    : undefined,\n                beta: undefined\n            };\n        }\n        return res;\n    }\n    /**\n     * Performs the \"doubling\" operation on the Point a given number of times.\n     * This is used in elliptic curve operations to perform multiplication by 2, multiple times.\n     * If the point is at infinity, it simply returns the point because doubling\n     * a point at infinity is still infinity.\n     *\n     * @method dblp\n     * @param k - The number of times the \"doubling\" operation is to be performed on the Point.\n     * @returns The Point after 'k' \"doubling\" operations have been performed.\n     *\n     * @example\n     * const p = new Point(5, 20);\n     * const doubledPoint = p.dblp(10); // returns the point after \"doubled\" 10 times\n     */\n    dblp(k) {\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let r = this;\n        for (let i = 0; i < k; i++) {\n            r = r.dbl();\n        }\n        return r;\n    }\n    /**\n     * Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point\n     * will also be at infinity.\n     *\n     * @method toJ\n     * @returns Returns a new Jacobian point based on the current point.\n     *\n     * @example\n     * const point = new Point(xCoordinate, yCoordinate);\n     * const jacobianPoint = point.toJ();\n     */\n    toJ() {\n        if (this.inf) {\n            return new JacobianPoint_js_1.default(null, null, null);\n        }\n        const res = new JacobianPoint_js_1.default(this.x, this.y, this.curve.one);\n        return res;\n    }\n    _getBeta() {\n        if (typeof this.curve.endo !== 'object') {\n            return;\n        }\n        const pre = this.precomputed;\n        if (typeof pre === 'object' &&\n            pre !== null &&\n            typeof pre.beta === 'object' &&\n            pre.beta !== null) {\n            return pre.beta;\n        }\n        const beta = new Point((this.x ?? new BigNumber_js_1.default(0)).redMul(this.curve.endo.beta), this.y);\n        if (pre != null) {\n            const curve = this.curve;\n            const endoMul = (p) => {\n                if (p.x === null) {\n                    throw new Error('p.x is null');\n                }\n                if (curve.endo === undefined || curve.endo === null) {\n                    throw new Error('curve.endo is undefined');\n                }\n                return new Point(p.x.redMul(curve.endo.beta), p.y);\n            };\n            pre.beta = beta;\n            beta.precomputed = {\n                beta: null,\n                naf: pre.naf != null\n                    ? {\n                        wnd: pre.naf.wnd,\n                        points: pre.naf.points.map(endoMul)\n                    }\n                    : undefined,\n                doubles: pre.doubles != null\n                    ? {\n                        step: pre.doubles.step,\n                        points: pre.doubles.points.map(endoMul)\n                    }\n                    : undefined\n            };\n        }\n        return beta;\n    }\n    _fixedNafMul(k) {\n        if (typeof this.precomputed !== 'object' || this.precomputed === null) {\n            throw new Error('_fixedNafMul requires precomputed values for the point');\n        }\n        const doubles = this._getDoubles();\n        const naf = this.curve.getNAF(k, 1, this.curve._bitLength);\n        let I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n        I /= 3;\n        // Translate into more windowed form\n        const repr = [];\n        for (let j = 0; j < naf.length; j += doubles.step) {\n            let nafW = 0;\n            for (let k = j + doubles.step - 1; k >= j; k--) {\n                nafW = (nafW << 1) + naf[k];\n            }\n            repr.push(nafW);\n        }\n        let a = new JacobianPoint_js_1.default(null, null, null);\n        let b = new JacobianPoint_js_1.default(null, null, null);\n        for (let i = I; i > 0; i--) {\n            for (let j = 0; j < repr.length; j++) {\n                const nafW = repr[j];\n                if (nafW === i) {\n                    b = b.mixedAdd(doubles.points[j]);\n                }\n                else if (nafW === -i) {\n                    b = b.mixedAdd(doubles.points[j].neg());\n                }\n            }\n            a = a.add(b);\n        }\n        return a.toP();\n    }\n    _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {\n        const wndWidth = this.curve._wnafT1.map(num => num.toNumber()); // Convert BigNumber to number\n        const wnd = this.curve._wnafT2.map(() => []); // Initialize as empty Point[][] array\n        const naf = this.curve._wnafT3.map(() => []); // Initialize as empty number[][] array\n        // Fill all arrays\n        let max = 0;\n        for (let i = 0; i < len; i++) {\n            const p = points[i];\n            const nafPoints = p._getNAFPoints(defW);\n            wndWidth[i] = nafPoints.wnd; // Ensure correct type\n            wnd[i] = nafPoints.points; // Ensure correct type\n        }\n        // Comb small window NAFs\n        for (let i = len - 1; i >= 1; i -= 2) {\n            const a = i - 1;\n            const b = i;\n            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n                naf[a] = this.curve.getNAF(coeffs[a], wndWidth[a], this.curve._bitLength);\n                naf[b] = this.curve.getNAF(coeffs[b], wndWidth[b], this.curve._bitLength);\n                max = Math.max(naf[a].length, max);\n                max = Math.max(naf[b].length, max);\n                continue;\n            }\n            const comb = [\n                points[a] /* 1 */,\n                null /* 3 */,\n                null /* 5 */,\n                points[b] /* 7 */\n            ];\n            // Try to avoid Projective points, if possible\n            if ((points[a].y ?? new BigNumber_js_1.default(0)).cmp(points[b].y ?? new BigNumber_js_1.default(0)) === 0) {\n                comb[1] = points[a].add(points[b]);\n                comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n            }\n            else if ((points[a].y ?? new BigNumber_js_1.default(0)).cmp((points[b].y ?? new BigNumber_js_1.default(0)).redNeg()) === 0) {\n                comb[1] = points[a].toJ().mixedAdd(points[b]);\n                comb[2] = points[a].add(points[b].neg());\n            }\n            else {\n                comb[1] = points[a].toJ().mixedAdd(points[b]);\n                comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n            }\n            const index = [\n                -3 /* -1 -1 */, -1 /* -1 0 */, -5 /* -1 1 */, -7 /* 0 -1 */,\n                0 /* 0 0 */, 7 /* 0 1 */, 5 /* 1 -1 */, 1 /* 1 0 */, 3 /* 1 1 */\n            ];\n            const jsf = this.curve.getJSF(coeffs[a], coeffs[b]);\n            max = Math.max(jsf[0].length, max);\n            naf[a] = new Array(max);\n            naf[b] = new Array(max);\n            for (let j = 0; j < max; j++) {\n                const ja = jsf[0][j] | 0;\n                const jb = jsf[1][j] | 0;\n                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n                naf[b][j] = 0;\n                wnd[a] = comb;\n            }\n        }\n        let acc = new JacobianPoint_js_1.default(null, null, null);\n        const tmp = this.curve._wnafT4;\n        for (let i = max; i >= 0; i--) {\n            let k = 0;\n            while (i >= 0) {\n                let zero = true;\n                for (let j = 0; j < len; j++) {\n                    tmp[j] = new BigNumber_js_1.default(typeof naf[j][i] === 'number' ? naf[j][i] : 0); // Ensure type consistency\n                    if (!tmp[j].isZero()) { // Use BigNumber's built-in comparison\n                        zero = false;\n                    }\n                }\n                if (!zero) {\n                    break;\n                }\n                k++;\n                i--;\n            }\n            if (i >= 0) {\n                k++;\n            }\n            acc = acc.dblp(k);\n            if (i < 0) {\n                break;\n            }\n            const one = new BigNumber_js_1.default(1);\n            const two = new BigNumber_js_1.default(2);\n            for (let j = 0; j < len; j++) {\n                const z = tmp[j];\n                let p;\n                if (z.cmpn(0) === 0) { // Check if z is 0\n                    continue;\n                }\n                else if (!z.isNeg()) { // If z is positive\n                    p = wnd[j][z.sub(one).div(two).toNumber()];\n                }\n                else { // If z is negative\n                    p = wnd[j][z.neg().sub(one).div(two).toNumber()].neg();\n                }\n                if (p.type === 'affine') {\n                    acc = acc.mixedAdd(p);\n                }\n                else {\n                    acc = acc.add(p);\n                }\n            }\n        }\n        // Zeroify references\n        for (let i = 0; i < len; i++) {\n            wnd[i] = [];\n        }\n        if (jacobianResult === true) {\n            return acc;\n        }\n        else {\n            return acc.toP();\n        }\n    }\n    _endoWnafMulAdd(points, coeffs, // Explicitly type coeffs\n    jacobianResult) {\n        const npoints = new Array(points.length * 2);\n        const ncoeffs = new Array(points.length * 2);\n        let i;\n        for (i = 0; i < points.length; i++) {\n            const split = this.curve._endoSplit(coeffs[i]);\n            let p = points[i];\n            let beta = p._getBeta() ?? new Point(null, null);\n            if (split.k1.negative !== 0) {\n                split.k1.ineg();\n                p = p.neg(true);\n            }\n            if (split.k2.negative !== 0) {\n                split.k2.ineg();\n                beta = beta.neg(true);\n            }\n            npoints[i * 2] = p;\n            npoints[i * 2 + 1] = beta;\n            ncoeffs[i * 2] = split.k1;\n            ncoeffs[i * 2 + 1] = split.k2;\n        }\n        const res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n        // Clean-up references to points and coefficients\n        for (let j = 0; j < i * 2; j++) {\n            npoints[j] = null;\n            ncoeffs[j] = null;\n        }\n        return res;\n    }\n    _hasDoubles(k) {\n        if (this.precomputed == null) {\n            return false;\n        }\n        const doubles = this.precomputed.doubles;\n        if (typeof doubles !== 'object') {\n            return false;\n        }\n        return (doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step));\n    }\n    _getDoubles(step, power) {\n        if (typeof this.precomputed === 'object' &&\n            this.precomputed !== null &&\n            typeof this.precomputed.doubles === 'object' &&\n            this.precomputed.doubles !== null) {\n            return this.precomputed.doubles;\n        }\n        const doubles = [this];\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let acc = this;\n        for (let i = 0; i < (power ?? 0); i += (step ?? 1)) {\n            for (let j = 0; j < (step ?? 1); j++) {\n                acc = acc.dbl();\n            }\n            doubles.push(acc);\n        }\n        return {\n            step: step ?? 1,\n            points: doubles\n        };\n    }\n    _getNAFPoints(wnd) {\n        if (typeof this.precomputed === 'object' &&\n            this.precomputed !== null &&\n            typeof this.precomputed.naf === 'object' &&\n            this.precomputed.naf !== null) {\n            return this.precomputed.naf;\n        }\n        const res = [this];\n        const max = (1 << wnd) - 1;\n        const dbl = max === 1 ? null : this.dbl();\n        for (let i = 1; i < max; i++) {\n            if (dbl !== null) {\n                res[i] = res[i - 1].add(dbl);\n            }\n        }\n        return {\n            wnd,\n            points: res\n        };\n    }\n}\nexports[\"default\"] = Point;\n//# sourceMappingURL=Point.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Polynomial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Polynomial.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PointInFiniteField = void 0;\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nclass PointInFiniteField {\n    constructor(x, y) {\n        const P = new Curve_js_1.default().p; // arithmetic is mod P\n        this.x = x.umod(P);\n        this.y = y.umod(P);\n    }\n    toString() {\n        return (0, utils_js_1.toBase58)(this.x.toArray()) + '.' + (0, utils_js_1.toBase58)(this.y.toArray());\n    }\n    static fromString(str) {\n        const [x, y] = str.split('.');\n        return new PointInFiniteField(new BigNumber_js_1.default((0, utils_js_1.fromBase58)(x)), new BigNumber_js_1.default((0, utils_js_1.fromBase58)(y)));\n    }\n}\nexports.PointInFiniteField = PointInFiniteField;\n/**\n * Polynomial class\n *\n * This class is used to create a polynomial with a given threshold and a private key.\n * The polynomial is used to create shares of the private key.\n *\n * @param key - The private key to split\n * @param threshold - The number of shares required to recombine the private key\n *\n * @example\n * const key = new PrivateKey()\n * const threshold = 2\n * const polynomial = new Polynomial(key, threshold)\n *\n */\nclass Polynomial {\n    constructor(points, threshold) {\n        this.points = points;\n        this.threshold = threshold ?? points.length; //  Handles undefined safely\n    }\n    static fromPrivateKey(key, threshold) {\n        const P = new Curve_js_1.default().p; // arithmetic is mod P\n        // The key is the y-intercept of the polynomial where x=0.\n        const points = [\n            new PointInFiniteField(new BigNumber_js_1.default(0), new BigNumber_js_1.default(key.toArray()))\n        ];\n        // The other values are random\n        for (let i = 1; i < threshold; i++) {\n            const randomX = new BigNumber_js_1.default((0, Random_js_1.default)(32)).umod(P);\n            const randomY = new BigNumber_js_1.default((0, Random_js_1.default)(32)).umod(P);\n            points.push(new PointInFiniteField(randomX, randomY));\n        }\n        return new Polynomial(points);\n    }\n    // Evaluate the polynomial at x by using Lagrange interpolation\n    valueAt(x) {\n        const P = new Curve_js_1.default().p; // arithmetic is mod P\n        let y = new BigNumber_js_1.default(0);\n        for (let i = 0; i < this.threshold; i++) {\n            let term = this.points[i].y;\n            for (let j = 0; j < this.threshold; j++) {\n                if (i !== j) {\n                    const xj = this.points[j].x;\n                    const xi = this.points[i].x;\n                    const numerator = x.sub(xj).umod(P);\n                    const denominator = xi.sub(xj).umod(P);\n                    const denominatorInverse = denominator.invm(P);\n                    const fraction = numerator.mul(denominatorInverse).umod(P);\n                    term = term.mul(fraction).umod(P);\n                }\n            }\n            y = y.add(term).umod(P);\n        }\n        return y;\n    }\n}\nexports[\"default\"] = Polynomial;\n//# sourceMappingURL=Polynomial.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Polynomial.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyShares = void 0;\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst ECDSA_js_1 = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\");\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Polynomial_js_1 = __importStar(__webpack_require__(/*! ./Polynomial.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Polynomial.js\"));\n/**\n * @class KeyShares\n *\n * This class is used to store the shares of a private key.\n *\n * @param shares - An array of shares\n * @param threshold - The number of shares required to recombine the private key\n *\n * @returns KeyShares\n *\n * @example\n * const key = PrivateKey.fromShares(shares)\n *\n */\nclass KeyShares {\n    constructor(points, threshold, integrity) {\n        this.points = points;\n        this.threshold = threshold;\n        this.integrity = integrity;\n    }\n    static fromBackupFormat(shares) {\n        let threshold = 0;\n        let integrity = '';\n        const points = shares.map((share, idx) => {\n            const shareParts = share.split('.');\n            if (shareParts.length !== 4) {\n                throw new Error('Invalid share format in share ' +\n                    idx.toString() +\n                    '. Expected format: \"x.y.t.i\" - received ' +\n                    share);\n            }\n            const [x, y, t, i] = shareParts;\n            if (t === undefined)\n                throw new Error('Threshold not found in share ' + idx.toString());\n            if (i === undefined)\n                throw new Error('Integrity not found in share ' + idx.toString());\n            const tInt = parseInt(t);\n            if (idx !== 0 && threshold !== tInt) {\n                throw new Error('Threshold mismatch in share ' + idx.toString());\n            }\n            if (idx !== 0 && integrity !== i) {\n                throw new Error('Integrity mismatch in share ' + idx.toString());\n            }\n            threshold = tInt;\n            integrity = i;\n            return Polynomial_js_1.PointInFiniteField.fromString([x, y].join('.'));\n        });\n        return new KeyShares(points, threshold, integrity);\n    }\n    toBackupFormat() {\n        return this.points.map((share) => share.toString() + '.' + this.threshold.toString() + '.' + this.integrity);\n    }\n}\nexports.KeyShares = KeyShares;\n/**\n * Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.\n *\n * The `PrivateKey` class extends from the `BigNumber` class. It offers methods to create signatures, verify them,\n * create a corresponding public key and derive a shared secret from a public key.\n *\n * @extends {BigNumber}\n * @see {@link BigNumber} for more information on BigNumber.\n */\nclass PrivateKey extends BigNumber_js_1.default {\n    /**\n     * Generates a private key randomly.\n     *\n     * @method fromRandom\n     * @static\n     * @returns The newly generated Private Key.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     */\n    static fromRandom() {\n        return new PrivateKey((0, Random_js_1.default)(32));\n    }\n    /**\n     * Generates a private key from a string.\n     *\n     * @method fromString\n     * @static\n     * @param str - The string to generate the private key from.\n     * @param base - The base of the string.\n     * @returns The generated Private Key.\n     * @throws Will throw an error if the string is not valid.\n     **/\n    static fromString(str, base = 'hex') {\n        return new PrivateKey(super.fromString(str, base).toArray());\n    }\n    /**\n     * Generates a private key from a hexadecimal string.\n     *\n     * @method fromHex\n     * @static\n     * @param {string} str - The hexadecimal string representing the private key. The string must represent a valid private key in big-endian format.\n     * @returns {PrivateKey} The generated Private Key instance.\n     * @throws {Error} If the string is not a valid hexadecimal or represents an invalid private key.\n     **/\n    static fromHex(str) {\n        return new PrivateKey(super.fromHex(str, 'big'));\n    }\n    /**\n     * Generates a private key from a WIF (Wallet Import Format) string.\n     *\n     * @method fromWif\n     * @static\n     * @param wif - The WIF string to generate the private key from.\n     * @param base - The base of the string.\n     * @returns The generated Private Key.\n     * @throws Will throw an error if the string is not a valid WIF.\n     **/\n    static fromWif(wif, prefixLength = 1) {\n        const decoded = (0, utils_js_1.fromBase58Check)(wif, undefined, prefixLength);\n        if (decoded.data.length !== 33) {\n            throw new Error('Invalid WIF length');\n        }\n        if (decoded.data[32] !== 1) {\n            throw new Error('Invalid WIF padding');\n        }\n        return new PrivateKey(decoded.data.slice(0, 32));\n    }\n    /**\n     * @constructor\n     *\n     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.\n     *\n     * @param base - The base of number provided. By default is 10. Ignored if number is BigNumber.\n     *\n     * @param endian - The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.\n     *\n     * @param modN - Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw new Error('Input is out of field'). If 'nocheck', assumes input is in field.\n     *\n     * @example\n     * import PrivateKey from './PrivateKey';\n     * import BigNumber from './BigNumber';\n     * const privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));\n     */\n    constructor(number = 0, base = 10, endian = 'be', modN = 'apply') {\n        if (number instanceof BigNumber_js_1.default) {\n            super();\n            number.copy(this);\n        }\n        else {\n            super(number, base, endian);\n        }\n        if (modN !== 'nocheck') {\n            const check = this.checkInField();\n            if (!check.inField) {\n                if (modN === 'error') {\n                    throw new Error('Input is out of field');\n                }\n                // Force the PrivateKey BigNumber value to lie in the field limited by curve.n\n                BigNumber_js_1.default.move(this, check.modN);\n            }\n        }\n    }\n    /**\n     * A utility function to check that the value of this PrivateKey lies in the field limited by curve.n\n     * @returns { inField, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.\n     */\n    checkInField() {\n        const curve = new Curve_js_1.default();\n        const modN = this.mod(curve.n);\n        const inField = this.cmp(modN) === 0;\n        return { inField, modN };\n    }\n    /**\n     * @returns true if the PrivateKey's current BigNumber value lies in the field limited by curve.n\n     */\n    isValid() {\n        return this.checkInField().inField;\n    }\n    /**\n     * Signs a message using the private key.\n     *\n     * @method sign\n     * @param msg - The message (array of numbers or string) to be signed.\n     * @param enc - If 'hex' the string will be treated as hex, utf8 otherwise.\n     * @param forceLowS - If true (the default), the signature will be forced to have a low S value.\n     * @param customK  If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.\n     * @returns A digital signature generated from the hash of the message and the private key.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const signature = privateKey.sign('Hello, World!');\n     */\n    sign(msg, enc, forceLowS = true, customK) {\n        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);\n        return (0, ECDSA_js_1.sign)(msgHash, this, forceLowS, customK);\n    }\n    /**\n     * Verifies a message's signature using the public key associated with this private key.\n     *\n     * @method verify\n     * @param msg - The original message which has been signed.\n     * @param sig - The signature to be verified.\n     * @param enc - The data encoding method.\n     * @returns Whether or not the signature is valid.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const signature = privateKey.sign('Hello, World!');\n     * const isSignatureValid = privateKey.verify('Hello, World!', signature);\n     */\n    verify(msg, sig, enc) {\n        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);\n        return (0, ECDSA_js_1.verify)(msgHash, sig, this.toPublicKey());\n    }\n    /**\n     * Converts the private key to its corresponding public key.\n     *\n     * The public key is generated by multiplying the base point G of the curve and the private key.\n     *\n     * @method toPublicKey\n     * @returns The generated PublicKey.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const publicKey = privateKey.toPublicKey();\n     */\n    toPublicKey() {\n        const c = new Curve_js_1.default();\n        const p = c.g.mul(this);\n        return new PublicKey_js_1.default(p.x, p.y);\n    }\n    /**\n     * Converts the private key to a Wallet Import Format (WIF) string.\n     *\n     * Base58Check encoding is used for encoding the private key.\n     * The prefix\n     *\n     * @method toWif\n     * @returns The WIF string.\n     *\n     * @param prefix defaults to [0x80] for mainnet, set it to [0xef] for testnet.\n     *\n     * @throws Error('Value is out of field') if current BigNumber value is out of field limited by curve.n\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const wif = privateKey.toWif();\n     * const testnetWif = privateKey.toWif([0xef]);\n     */\n    toWif(prefix = [0x80]) {\n        if (!this.isValid()) {\n            throw new Error('Value is out of field');\n        }\n        return (0, utils_js_1.toBase58Check)([...this.toArray('be', 32), 1], prefix);\n    }\n    /**\n     * Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type.\n     * Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".\n     *\n     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'\n     *\n     * @returns Returns the address encoding associated with the hash of the public key associated with this private key.\n     *\n     * @example\n     * const address = privkey.toAddress()\n     * const address = privkey.toAddress('mainnet')\n     * const testnetAddress = privkey.toAddress([0x6f])\n     * const testnetAddress = privkey.toAddress('testnet')\n     */\n    toAddress(prefix = [0x00]) {\n        return this.toPublicKey().toAddress(prefix);\n    }\n    /**\n     * Converts this PrivateKey to a hexadecimal string.\n     *\n     * @method toHex\n     * @param length - The minimum length of the hex string\n     * @returns Returns a string representing the hexadecimal value of this BigNumber.\n     *\n     * @example\n     * const bigNumber = new BigNumber(255);\n     * const hex = bigNumber.toHex();\n     */\n    toHex() {\n        return super.toHex(32);\n    }\n    /**\n     * Converts this PrivateKey to a string representation.\n     *\n     * @method toString\n     * @param {number | 'hex'} [base='hex'] - The base for representing the number. Default is hexadecimal ('hex').\n     * @param {number} [padding=64] - The minimum number of digits for the output string. Default is 64, ensuring a 256-bit representation in hexadecimal.\n     * @returns {string} A string representation of the PrivateKey in the specified base, padded to the specified length.\n     *\n     **/\n    toString(base = 'hex', padding = 64) {\n        return super.toString(base, padding);\n    }\n    /**\n     * Derives a shared secret from the public key.\n     *\n     * @method deriveSharedSecret\n     * @param key - The public key to derive the shared secret from.\n     * @returns The derived shared secret (a point on the curve).\n     * @throws Will throw an error if the public key is not valid.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const publicKey = privateKey.toPublicKey();\n     * const sharedSecret = privateKey.deriveSharedSecret(publicKey);\n     */\n    deriveSharedSecret(key) {\n        if (!key.validate()) {\n            throw new Error('Public key not valid for ECDH secret derivation');\n        }\n        return key.mul(this);\n    }\n    /**\n     * Derives a child key with BRC-42.\n     * @param publicKey The public key of the other party\n     * @param invoiceNumber The invoice number used to derive the child key\n     * @param cacheSharedSecret Optional function to cache shared secrets\n     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache\n     * @returns The derived child key.\n     */\n    deriveChild(publicKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {\n        let sharedSecret;\n        if (typeof retrieveCachedSharedSecret === 'function') {\n            const retrieved = retrieveCachedSharedSecret(this, publicKey);\n            if (typeof retrieved !== 'undefined') {\n                sharedSecret = retrieved;\n            }\n            else {\n                sharedSecret = this.deriveSharedSecret(publicKey);\n                if (typeof cacheSharedSecret === 'function') {\n                    cacheSharedSecret(this, publicKey, sharedSecret);\n                }\n            }\n        }\n        else {\n            sharedSecret = this.deriveSharedSecret(publicKey);\n        }\n        const invoiceNumberBin = (0, utils_js_1.toArray)(invoiceNumber, 'utf8');\n        const hmac = (0, Hash_js_1.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);\n        const curve = new Curve_js_1.default();\n        return new PrivateKey(this.add(new BigNumber_js_1.default(hmac)).mod(curve.n).toArray());\n    }\n    /**\n     * Splits the private key into shares using Shamir's Secret Sharing Scheme.\n     *\n     * @param threshold The minimum number of shares required to reconstruct the private key.\n     * @param totalShares The total number of shares to generate.\n     * @param prime The prime number to be used in Shamir's Secret Sharing Scheme.\n     * @returns An array of shares.\n     *\n     * @example\n     * const key = PrivateKey.fromRandom()\n     * const shares = key.toKeyShares(2, 5)\n     */\n    toKeyShares(threshold, totalShares) {\n        if (typeof threshold !== 'number' || typeof totalShares !== 'number') {\n            throw new Error('threshold and totalShares must be numbers');\n        }\n        if (threshold < 2)\n            throw new Error('threshold must be at least 2');\n        if (totalShares < 2)\n            throw new Error('totalShares must be at least 2');\n        if (threshold > totalShares) {\n            throw new Error('threshold should be less than or equal to totalShares');\n        }\n        const poly = Polynomial_js_1.default.fromPrivateKey(this, threshold);\n        const points = [];\n        for (let i = 0; i < totalShares; i++) {\n            const x = new BigNumber_js_1.default(PrivateKey.fromRandom().toArray());\n            const y = poly.valueAt(x);\n            points.push(new Polynomial_js_1.PointInFiniteField(x, y));\n        }\n        const integrity = this.toPublicKey().toHash('hex').slice(0, 8);\n        return new KeyShares(points, threshold, integrity);\n    }\n    /**\n     * @method toBackupShares\n     *\n     * Creates a backup of the private key by splitting it into shares.\n     *\n     *\n     * @param threshold The number of shares which will be required to reconstruct the private key.\n     * @param totalShares The number of shares to generate for distribution.\n     * @returns\n     */\n    toBackupShares(threshold, totalShares) {\n        return this.toKeyShares(threshold, totalShares).toBackupFormat();\n    }\n    /**\n     *\n     * @method fromBackupShares\n     *\n     * Creates a private key from backup shares.\n     *\n     * @param shares\n     * @returns PrivateKey\n     *\n     * @example\n     *\n     * const share1 = '3znuzt7DZp8HzZTfTh5MF9YQKNX3oSxTbSYmSRGrH2ev.2Nm17qoocmoAhBTCs8TEBxNXCskV9N41rB2PckcgYeqV.2.35449bb9'\n     * const share2 = 'Cm5fuUc39X5xgdedao8Pr1kvCSm8Gk7Cfenc7xUKcfLX.2juyK9BxCWn2DiY5JUAgj9NsQ77cc9bWksFyW45haXZm.2.35449bb9'\n     *\n     * const recoveredKey = PrivateKey.fromBackupShares([share1, share2])\n     */\n    static fromBackupShares(shares) {\n        return PrivateKey.fromKeyShares(KeyShares.fromBackupFormat(shares));\n    }\n    /**\n     * Combines shares to reconstruct the private key.\n     *\n     * @param shares An array of points (shares) to be used to reconstruct the private key.\n     * @param threshold The minimum number of shares required to reconstruct the private key.\n     *\n     * @returns The reconstructed private key.\n     *\n     **/\n    static fromKeyShares(keyShares) {\n        const { points, threshold, integrity } = keyShares;\n        if (threshold < 2)\n            throw new Error('threshold must be at least 2');\n        if (points.length < threshold) {\n            throw new Error(`At least ${threshold} shares are required to reconstruct the private key`);\n        }\n        // check to see if two points have the same x value\n        for (let i = 0; i < threshold; i++) {\n            for (let j = i + 1; j < threshold; j++) {\n                if (points[i].x.eq(points[j].x)) {\n                    throw new Error('Duplicate share detected, each must be unique.');\n                }\n            }\n        }\n        const poly = new Polynomial_js_1.default(points, threshold);\n        const privateKey = new PrivateKey(poly.valueAt(new BigNumber_js_1.default(0)).toArray());\n        const integrityHash = privateKey.toPublicKey().toHash('hex').slice(0, 8);\n        if (integrityHash !== integrity) {\n            throw new Error('Integrity hash mismatch');\n        }\n        return privateKey;\n    }\n}\nexports[\"default\"] = PrivateKey;\n//# sourceMappingURL=PrivateKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Point_js_1 = __importDefault(__webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst ECDSA_js_1 = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\");\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst Signature_js_1 = __importDefault(__webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n/**\n * The PublicKey class extends the Point class. It is used in public-key cryptography to derive shared secret, verify message signatures, and encode the public key in the DER format.\n * The class comes with static methods to generate PublicKey instances from private keys or from strings.\n *\n * @extends {Point}\n * @see {@link Point} for more information on Point.\n */\nclass PublicKey extends Point_js_1.default {\n    /**\n     * Static factory method to derive a public key from a private key.\n     * It multiplies the generator point 'g' on the elliptic curve by the private key.\n     *\n     * @static\n     * @method fromPrivateKey\n     *\n     * @param key - The private key from which to derive the public key.\n     *\n     * @returns Returns the PublicKey derived from the given PrivateKey.\n     *\n     * @example\n     * const myPrivKey = new PrivateKey(...)\n     * const myPubKey = PublicKey.fromPrivateKey(myPrivKey)\n     */\n    static fromPrivateKey(key) {\n        const c = new Curve_js_1.default();\n        const p = c.g.mul(key);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * Static factory method to create a PublicKey instance from a string.\n     *\n     * @param str - A string representing a public key.\n     *\n     * @returns Returns the PublicKey created from the string.\n     *\n     * @example\n     * const myPubKey = PublicKey.fromString(\"03....\")\n     */\n    static fromString(str) {\n        const p = Point_js_1.default.fromString(str);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * Static factory method to create a PublicKey instance from a number array.\n     *\n     * @param bytes - A number array representing a public key.\n     *\n     * @returns Returns the PublicKey created from the number array.\n     *\n     * @example\n     * const myPubKey = PublicKey.fromString(\"03....\")\n     */\n    static fromDER(bytes) {\n        const p = Point_js_1.default.fromDER(bytes);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * @constructor\n     * @param x - A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.\n     * @param y - If x is not a point, the y-coordinate of the point, similar to x.\n     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.\n     *\n     * @example\n     * new PublicKey(point1);\n     * new PublicKey('abc123', 'def456');\n     */\n    constructor(x, y = null, isRed = true) {\n        if (x instanceof Point_js_1.default) {\n            super(x.getX(), x.getY());\n        }\n        else {\n            // Common gotcha: constructing PublicKey with a DER value when you should use .fromString()\n            if (y === null && isRed && typeof x === 'string') {\n                if (x.length === 66 || x.length === 130) {\n                    throw new Error('You are using the \"new PublicKey()\" constructor with a DER hex string. You need to use \"PublicKey.fromString()\" instead.');\n                }\n            }\n            super(x, y, isRed);\n        }\n    }\n    /**\n     * Derive a shared secret from a public key and a private key for use in symmetric encryption.\n     * This method multiplies the public key (an instance of Point) with a private key.\n     *\n     * @param priv - The private key to use in deriving the shared secret.\n     *\n     * @returns Returns the Point representing the shared secret.\n     *\n     * @throws Will throw an error if the public key is not valid for ECDH secret derivation.\n     *\n     * @example\n     * const myPrivKey = new PrivateKey(...)\n     * const sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)\n     */\n    deriveSharedSecret(priv) {\n        if (!this.validate()) {\n            throw new Error('Public key not valid for ECDH secret derivation');\n        }\n        return this.mul(priv);\n    }\n    /**\n     * Verify a signature of a message using this public key.\n     *\n     * @param msg - The message to verify. It can be a string or an array of numbers.\n     * @param sig - The Signature of the message that needs verification.\n     * @param enc - The encoding of the message. It defaults to 'utf8'.\n     *\n     * @returns Returns true if the signature is verified successfully, otherwise false.\n     *\n     * @example\n     * const myMessage = \"Hello, world!\"\n     * const mySignature = new Signature(...)\n     * const isVerified = myPubKey.verify(myMessage, mySignature)\n     */\n    verify(msg, sig, enc) {\n        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);\n        return (0, ECDSA_js_1.verify)(msgHash, sig, this);\n    }\n    /**\n     * Encode the public key to DER (Distinguished Encoding Rules) format.\n     *\n     * @returns Returns the DER-encoded public key in number array or string.\n     *\n     * @param enc - The encoding of the DER string. undefined = number array, 'hex' = hex string.\n     *\n     * @example\n     * const derPublicKey = myPubKey.toDER()\n     */\n    toDER(enc) {\n        if (enc === 'hex')\n            return this.encode(true, enc);\n        return this.encode(true);\n    }\n    /**\n     * Hash sha256 and ripemd160 of the public key.\n     *\n     * @returns Returns the hash of the public key.\n     *\n     * @example\n     * const publicKeyHash = pubkey.toHash()\n     */\n    toHash(enc) {\n        const pkh = (0, Hash_js_1.hash160)(this.encode(true));\n        if (enc === 'hex') {\n            return (0, utils_js_1.toHex)(pkh);\n        }\n        return pkh;\n    }\n    /**\n     * Base58Check encodes the hash of the public key with a prefix to indicate locking script type.\n     * Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".\n     *\n     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'\n     *\n     * @returns Returns the address encoding associated with the hash of the public key.\n     *\n     * @example\n     * const address = pubkey.toAddress()\n     * const address = pubkey.toAddress('mainnet')\n     * const testnetAddress = pubkey.toAddress([0x6f])\n     * const testnetAddress = pubkey.toAddress('testnet')\n     */\n    toAddress(prefix = [0x00]) {\n        if (typeof prefix === 'string') {\n            if (prefix === 'testnet' || prefix === 'test') {\n                prefix = [0x6f];\n            }\n            else if (prefix === 'mainnet' || prefix === 'main') {\n                prefix = [0x00];\n            }\n            else {\n                throw new Error(`Invalid prefix ${prefix}`);\n            }\n        }\n        return (0, utils_js_1.toBase58Check)(this.toHash(), prefix);\n    }\n    /**\n     * Derives a child key with BRC-42.\n     * @param privateKey The private key of the other party\n     * @param invoiceNumber The invoice number used to derive the child key\n     * @param cacheSharedSecret Optional function to cache shared secrets\n     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache\n     * @returns The derived child key.\n     */\n    deriveChild(privateKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {\n        let sharedSecret;\n        if (typeof retrieveCachedSharedSecret === 'function') {\n            const retrieved = retrieveCachedSharedSecret(privateKey, this);\n            if (typeof retrieved !== 'undefined') {\n                sharedSecret = retrieved;\n            }\n            else {\n                sharedSecret = this.deriveSharedSecret(privateKey);\n                if (typeof cacheSharedSecret === 'function') {\n                    cacheSharedSecret(privateKey, this, sharedSecret);\n                }\n            }\n        }\n        else {\n            sharedSecret = this.deriveSharedSecret(privateKey);\n        }\n        const invoiceNumberBin = (0, utils_js_1.toArray)(invoiceNumber, 'utf8');\n        const hmac = (0, Hash_js_1.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);\n        const curve = new Curve_js_1.default();\n        const point = curve.g.mul(new BigNumber_js_1.default(hmac));\n        const finalPoint = this.add(point);\n        return new PublicKey(finalPoint.x, finalPoint.y);\n    }\n    /**\n     * Takes an array of numbers or a string and returns a new PublicKey instance.\n     * This method will throw an error if the Compact encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     * compactByte value 27-30 means uncompressed public key.\n     * 31-34 means compressed public key.\n     * The range represents the recovery param which can be 0,1,2,3.\n     *\n     * @static\n     * @method fromMsgHashAndCompactSignature\n     * @param msgHash - The message hash which was signed.\n     * @param signature - The signature in compact format.\n     * @param enc - The encoding of the signature string.\n     * @returns A PublicKey instance derived from the message hash and compact signature.\n     * @example\n     * const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');\n     */\n    static fromMsgHashAndCompactSignature(msgHash, signature, enc) {\n        const data = (0, utils_js_1.toArray)(signature, enc);\n        if (data.length !== 65) {\n            throw new Error('Invalid Compact Signature');\n        }\n        const compactByte = data[0];\n        if (compactByte < 27 || compactByte >= 35) {\n            throw new Error('Invalid Compact Byte');\n        }\n        let r = data[0] - 27;\n        // NOTE: We don't use uncompressed pubkeys in this library,\n        // but whether the key is compressed is captured in the recovery param.\n        // Code below is commented out for reference of how you could capture this.\n        // let compressed = false\n        if (r > 3) {\n            // compressed = true\n            r -= 4;\n        }\n        const s = new Signature_js_1.default(new BigNumber_js_1.default(data.slice(1, 33)), new BigNumber_js_1.default(data.slice(33, 65)));\n        return s.RecoverPublicKey(r, msgHash);\n    }\n}\nexports[\"default\"] = PublicKey;\n//# sourceMappingURL=PublicKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass Rand {\n    constructor() {\n        const noRand = () => {\n            throw new Error('No secure random number generator is available in this environment.');\n        };\n        this._rand = noRand; // Assign the function\n        if (typeof self === 'object') {\n            /* eslint-disable-next-line */\n            if (self.crypto?.getRandomValues) {\n                this._rand = (n) => {\n                    const arr = new Uint8Array(n);\n                    /* eslint-disable-next-line */\n                    self.crypto.getRandomValues(arr);\n                    return [...arr];\n                };\n            } /* if (typeof window === 'object') */\n            else {\n                this._rand = noRand;\n            }\n        }\n        else {\n            try {\n                /* eslint-disable-next-line */\n                const crypto = __webpack_require__(/*! crypto */ \"?706f\");\n                if (typeof crypto.randomBytes === 'function') {\n                    this._rand = (n) => [...crypto.randomBytes(n)];\n                }\n            }\n            catch {\n                this._rand = noRand;\n            }\n        }\n    }\n    generate(len) {\n        return this._rand(len);\n    }\n}\nlet ayn = null;\n/**\n * Generates a sequence of pseudo-random bytes with the given length.\n *\n * @param len - The number of bytes to generate\n *\n * @returns The generated bytes\n *\n * @example\n * import Random from '@bsv/sdk/primitives/Random'\n * const bytes = Random(32) // Produces 32 random bytes\n */\nexports[\"default\"] = (len) => {\n    if (ayn == null) {\n        ayn = new Rand();\n    }\n    return ayn.generate(len);\n};\n//# sourceMappingURL=Random.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/ReductionContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/ReductionContext.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst K256_js_1 = __importDefault(__webpack_require__(/*! ./K256.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/K256.js\"));\n/**\n * A base reduction engine that provides several arithmetic operations over\n * big numbers under a modulus context. It's particularly suitable for\n * calculations required in cryptography algorithms and encoding schemas.\n *\n * @class ReductionContext\n *\n * @property prime - The prime number utilised in the reduction context, typically an instance of Mersenne class.\n * @property m - The modulus used for reduction operations.\n */\nclass ReductionContext {\n    /**\n     * Constructs a new ReductionContext.\n     *\n     * @constructor\n     * @param m - A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.\n     *\n     * @example\n     * new ReductionContext(new BigNumber(11));\n     * new ReductionContext('k256');\n     */\n    constructor(m) {\n        if (m === 'k256') {\n            const prime = new K256_js_1.default();\n            this.m = prime.p;\n            this.prime = prime;\n        }\n        else {\n            this.assert(m.gtn(1), 'modulus must be greater than 1');\n            this.m = m;\n            this.prime = null;\n        }\n    }\n    /**\n     * Asserts that given value is truthy. Throws an Error with a provided message\n     * if the value is falsy.\n     *\n     * @private\n     * @param val - The value to be checked.\n     * @param msg - The error message to be thrown if the value is falsy.\n     *\n     * @example\n     * this.assert(1 < 2, '1 is not less than 2');\n     * this.assert(2 < 1, '2 is less than 1'); // throws an Error with message '2 is less than 1'\n     */\n    assert(val, msg = 'Assertion failed') {\n        if (!val)\n            throw new Error(msg);\n    }\n    /**\n     * Verifies that a BigNumber is positive and red. Throws an error if these\n     * conditions are not met.\n     *\n     * @param a - The BigNumber to be verified.\n     *\n     * @example\n     * this.verify1(new BigNumber(10).toRed());\n     * this.verify1(new BigNumber(-10).toRed()); //throws an Error\n     * this.verify1(new BigNumber(10)); //throws an Error\n     */\n    verify1(a) {\n        this.assert(a.negative === 0, 'red works only with positives');\n        this.assert(a.red, 'red works only with red numbers');\n    }\n    /**\n     * Verifies that two BigNumbers are both positive and red. Also checks\n     * that they have the same reduction context. Throws an error if these\n     * conditions are not met.\n     *\n     * @param a - The first BigNumber to be verified.\n     * @param b - The second BigNumber to be verified.\n     *\n     * @example\n     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));\n     * this.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error\n     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error\n     */\n    verify2(a, b) {\n        this.assert((a.negative | b.negative) === 0, 'red works only with positives');\n        this.assert(a.red != null && a.red === b.red, 'red works only with red numbers');\n    }\n    /**\n     * Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.\n     *\n     * @method imod\n     *\n     * @param a - BigNumber to be reduced.\n     *\n     * @returns Returns the reduced result.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.imod(new BigNumber(19)); // Returns 5\n     */\n    imod(a) {\n        if (this.prime != null)\n            return this.prime.ireduce(a).forceRed(this);\n        BigNumber_js_1.default.move(a, a.umod(this.m).forceRed(this));\n        return a;\n    }\n    /**\n     * Negates a BigNumber in the context of the modulus.\n     *\n     * @method neg\n     *\n     * @param a - BigNumber to negate.\n     *\n     * @returns Returns the negation of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.neg(new BigNumber(3)); // Returns 4\n     */\n    neg(a) {\n        if (a.isZero()) {\n            return a.clone();\n        }\n        return this.m.sub(a).forceRed(this);\n    }\n    /**\n     * Performs the addition operation on two BigNumbers in the reduction context.\n     *\n     * @method add\n     *\n     * @param a - First BigNumber to add.\n     * @param b - Second BigNumber to add.\n     *\n     * @returns Returns the result of 'a + b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * context.add(new BigNumber(2), new BigNumber(4)); // Returns 1\n     */\n    add(a, b) {\n        this.verify2(a, b);\n        const res = a.add(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs an in-place addition operation on two BigNumbers in the reduction context\n     * in order to avoid creating a new BigNumber, it modifies the first one with the result.\n     *\n     * @method iadd\n     *\n     * @param a - First BigNumber to add.\n     * @param b - Second BigNumber to add.\n     *\n     * @returns Returns the modified 'a' after addition with 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * const a = new BigNumber(2);\n     * context.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1\n     */\n    iadd(a, b) {\n        this.verify2(a, b);\n        const res = a.iadd(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res;\n    }\n    /**\n     * Subtracts one BigNumber from another BigNumber in the reduction context.\n     *\n     * @method sub\n     *\n     * @param a - BigNumber to be subtracted from.\n     * @param b - BigNumber to subtract.\n     *\n     * @returns Returns the result of 'a - b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.sub(new BigNumber(3), new BigNumber(2)); // Returns 1\n     */\n    sub(a, b) {\n        this.verify2(a, b);\n        const res = a.sub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs in-place subtraction of one BigNumber from another in the reduction context,\n     * it modifies the first BigNumber with the result.\n     *\n     * @method isub\n     *\n     * @param a - BigNumber to be subtracted from.\n     * @param b - BigNumber to subtract.\n     *\n     * @returns Returns the modified 'a' after subtraction of 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * const a = new BigNumber(4);\n     * context.isub(a, new BigNumber(2)); // Modifies 'a' to be 2\n     */\n    isub(a, b) {\n        this.verify2(a, b);\n        const res = a.isub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res;\n    }\n    /**\n     * Performs bitwise shift left operation on a BigNumber in the reduction context.\n     *\n     * @method shl\n     *\n     * @param a - BigNumber to perform shift on.\n     * @param num - The number of positions to shift.\n     *\n     * @returns Returns the result of shifting 'a' left by 'num' positions in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(32));\n     * context.shl(new BigNumber(4), 2); // Returns 16\n     */\n    shl(a, num) {\n        this.verify1(a);\n        return this.imod(a.ushln(num));\n    }\n    /**\n     * Performs in-place multiplication of two BigNumbers in the reduction context,\n     * modifying the first BigNumber with the result.\n     *\n     * @method imul\n     *\n     * @param a - First BigNumber to multiply.\n     * @param b - Second BigNumber to multiply.\n     *\n     * @returns Returns the modified 'a' after multiplication with 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = new BigNumber(3);\n     * context.imul(a, new BigNumber(2)); // Modifies 'a' to be 6\n     */\n    imul(a, b) {\n        this.verify2(a, b);\n        return this.imod(a.imul(b));\n    }\n    /**\n     * Multiplies two BigNumbers in the reduction context.\n     *\n     * @method mul\n     *\n     * @param a - First BigNumber to multiply.\n     * @param b - Second BigNumber to multiply.\n     *\n     * @returns Returns the result of 'a * b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.mul(new BigNumber(3), new BigNumber(2)); // Returns 6\n     */\n    mul(a, b) {\n        this.verify2(a, b);\n        return this.imod(a.mul(b));\n    }\n    /**\n     * Calculates the square of a BigNumber in the reduction context,\n     * modifying the original BigNumber with the result.\n     *\n     * @method isqr\n     *\n     * @param a - BigNumber to be squared.\n     *\n     * @returns Returns the squared 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = new BigNumber(3);\n     * context.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)\n     */\n    isqr(a) {\n        return this.imul(a, a.clone());\n    }\n    /**\n     * Calculates the square of a BigNumber in the reduction context.\n     *\n     * @method sqr\n     *\n     * @param a - BigNumber to be squared.\n     *\n     * @returns Returns the result of 'a^2' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)\n     */\n    sqr(a) {\n        return this.mul(a, a);\n    }\n    /**\n     * Calculates the square root of a BigNumber in the reduction context.\n     *\n     * @method sqrt\n     *\n     * @param a - The BigNumber to calculate the square root of.\n     *\n     * @returns Returns the square root of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(9));\n     * context.sqrt(new BigNumber(4)); // Returns 2\n     */\n    sqrt(a) {\n        if (a.isZero())\n            return a.clone();\n        const mod3 = this.m.andln(3);\n        this.assert(mod3 % 2 === 1);\n        // Fast case\n        if (mod3 === 3) {\n            const pow = this.m.add(new BigNumber_js_1.default(1)).iushrn(2);\n            return this.pow(a, pow);\n        }\n        // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n        //\n        // Find Q and S, that Q * 2 ^ S = (P - 1)\n        const q = this.m.subn(1);\n        let s = 0;\n        while (!q.isZero() && q.andln(1) === 0) {\n            s++;\n            q.iushrn(1);\n        }\n        this.assert(!q.isZero());\n        const one = new BigNumber_js_1.default(1).toRed(this);\n        const nOne = one.redNeg();\n        // Find quadratic non-residue\n        // NOTE: Max is such because of generalized Riemann hypothesis.\n        const lpow = this.m.subn(1).iushrn(1);\n        const zl = this.m.bitLength();\n        const z = new BigNumber_js_1.default(2 * zl * zl).toRed(this);\n        while (this.pow(z, lpow).cmp(nOne) !== 0) {\n            z.redIAdd(nOne);\n        }\n        let c = this.pow(z, q);\n        let r = this.pow(a, q.addn(1).iushrn(1));\n        let t = this.pow(a, q);\n        let m = s;\n        while (t.cmp(one) !== 0) {\n            let tmp = t;\n            let i = 0;\n            for (; tmp.cmp(one) !== 0; i++) {\n                tmp = tmp.redSqr();\n            }\n            this.assert(i < m);\n            const b = this.pow(c, new BigNumber_js_1.default(1).iushln(m - i - 1));\n            r = r.redMul(b);\n            c = b.redSqr();\n            t = t.redMul(c);\n            m = i;\n        }\n        return r;\n    }\n    /**\n     * Calculates the multiplicative inverse of a BigNumber in the reduction context.\n     *\n     * @method invm\n     *\n     * @param a - The BigNumber to find the multiplicative inverse of.\n     *\n     * @returns Returns the multiplicative inverse of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(11));\n     * context.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)\n     */\n    invm(a) {\n        const inv = a._invmp(this.m);\n        if (inv.negative !== 0) {\n            inv.negative = 0;\n            return this.imod(inv).redNeg();\n        }\n        else {\n            return this.imod(inv);\n        }\n    }\n    /**\n     * Raises a BigNumber to a power in the reduction context.\n     *\n     * @method pow\n     *\n     * @param a - The BigNumber to be raised to a power.\n     * @param num - The power to raise the BigNumber to.\n     *\n     * @returns Returns the result of 'a' raised to the power of 'num' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)\n     */\n    pow(a, num) {\n        if (num.isZero())\n            return new BigNumber_js_1.default(1).toRed(this);\n        if (num.cmpn(1) === 0)\n            return a.clone();\n        const windowSize = 4;\n        const wnd = new Array(1 << windowSize);\n        wnd[0] = new BigNumber_js_1.default(1).toRed(this);\n        wnd[1] = a;\n        let i = 2;\n        for (; i < wnd.length; i++) {\n            wnd[i] = this.mul(wnd[i - 1], a);\n        }\n        let res = wnd[0];\n        let current = 0;\n        let currentLen = 0;\n        let start = num.bitLength() % 26;\n        if (start === 0) {\n            start = 26;\n        }\n        for (i = num.length - 1; i >= 0; i--) {\n            const word = num.words[i];\n            for (let j = start - 1; j >= 0; j--) {\n                const bit = (word >> j) & 1;\n                if (res !== wnd[0]) {\n                    res = this.sqr(res);\n                }\n                if (bit === 0 && current === 0) {\n                    currentLen = 0;\n                    continue;\n                }\n                current <<= 1;\n                current |= bit;\n                currentLen++;\n                if (currentLen !== windowSize && (i !== 0 || j !== 0))\n                    continue;\n                res = this.mul(res, wnd[current]);\n                currentLen = 0;\n                current = 0;\n            }\n            start = 26;\n        }\n        return res;\n    }\n    /**\n     * Converts a BigNumber to its equivalent in the reduction context.\n     *\n     * @method convertTo\n     *\n     * @param num - The BigNumber to convert to the reduction context.\n     *\n     * @returns Returns the converted BigNumber compatible with the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)\n     */\n    convertTo(num) {\n        const r = num.umod(this.m);\n        return r === num ? r.clone() : r;\n    }\n    /**\n     * Converts a BigNumber from reduction context to its regular form.\n     *\n     * @method convertFrom\n     *\n     * @param num - The BigNumber to convert from the reduction context.\n     *\n     * @returns Returns the converted BigNumber in its regular form.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context\n     * context.convertFrom(a); // Returns 1\n     */\n    convertFrom(num) {\n        const res = num.clone();\n        res.red = null;\n        return res;\n    }\n}\nexports[\"default\"] = ReductionContext;\n//# sourceMappingURL=ReductionContext.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/ReductionContext.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Schnorr.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Schnorr.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst index_js_1 = __webpack_require__(/*! ./index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\n/**\n * Class representing the Schnorr Zero-Knowledge Proof (ZKP) protocol.\n *\n * This class provides methods to generate and verify proofs that demonstrate knowledge of a secret without revealing it.\n * Specifically, it allows one party to prove to another that they know the private key corresponding to a public key\n * and have correctly computed a shared secret, without disclosing the private key itself.\n *\n * The protocol involves two main methods:\n * - `generateProof`: Generates a proof linking a public key `A` and a shared secret `S`, proving knowledge of the corresponding private key `a`.\n * - `verifyProof`: Verifies the provided proof, ensuring its validity without revealing any secret information.\n *\n * The class utilizes elliptic curve cryptography (ECC) and the SHA-256 hash function to compute challenges within the proof.\n *\n * @example\n * ```typescript\n * const schnorr = new Schnorr();\n * const a = PrivateKey.fromRandom(); // Prover's private key\n * const A = a.toPublicKey();         // Prover's public key\n * const b = PrivateKey.fromRandom(); // Other party's private key\n * const B = b.toPublicKey();         // Other party's public key\n * const S = B.mul(a);                // Shared secret\n *\n * // Prover generates the proof\n * const proof = schnorr.generateProof(a, A, B, S);\n *\n * // Verifier verifies the proof\n * const isValid = schnorr.verifyProof(A.point, B.point, S.point, proof);\n * console.log(`Proof is valid: ${isValid}`);\n * ```\n */\nclass Schnorr {\n    constructor() {\n        this.curve = new Curve_js_1.default();\n    }\n    /**\n     * Generates a proof that demonstrates the link between public key A and shared secret S\n     * @param a Private key corresponding to public key A\n     * @param A Public key\n     * @param B Other party's public key\n     * @param S Shared secret\n     * @returns Proof (R, S', z)\n     */\n    generateProof(aArg, AArg, BArg, S) {\n        const r = index_js_1.PrivateKey.fromRandom();\n        const R = r.toPublicKey();\n        const SPrime = BArg.mul(r);\n        const e = this.computeChallenge(AArg, BArg, S, SPrime, R);\n        const z = r.add(e.mul(aArg)).umod(this.curve.n);\n        return { R, SPrime, z };\n    }\n    /**\n     * Verifies the proof of the link between public key A and shared secret S\n     * @param A Public key\n     * @param B Other party's public key\n     * @param S Shared secret\n     * @param proof Proof (R, S', z)\n     * @returns True if the proof is valid, false otherwise\n     */\n    verifyProof(A, B, S, proof) {\n        const { R, SPrime, z } = proof;\n        const e = this.computeChallenge(A, B, S, SPrime, R);\n        // Check zG = R + eA\n        const zG = this.curve.g.mul(z);\n        const RpluseA = R.add(A.mul(e));\n        if (!zG.eq(RpluseA)) {\n            return false;\n        }\n        // Check zB = S' + eS\n        const zB = B.mul(z);\n        const SprimeeS = SPrime.add(S.mul(e));\n        if (!zB.eq(SprimeeS)) {\n            return false;\n        }\n        return true;\n    }\n    computeChallenge(A, B, S, SPrime, R) {\n        const message = [\n            ...A.encode(true),\n            ...B.encode(true),\n            ...S.encode(true),\n            ...SPrime.encode(true),\n            ...R.encode(true)\n        ];\n        const hash = (0, Hash_js_1.sha256)(message);\n        return new BigNumber_js_1.default(hash).umod(this.curve.n);\n    }\n}\nexports[\"default\"] = Schnorr;\n//# sourceMappingURL=Schnorr.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Schnorr.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst ECDSA_js_1 = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\");\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Point_js_1 = __importDefault(__webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\"));\nconst Curve_js_1 = __importDefault(__webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\"));\n/**\n * Represents a digital signature.\n *\n * A digital signature is a mathematical scheme for verifying the authenticity of\n * digital messages or documents. In many scenarios, it is equivalent to a handwritten signature or stamped seal.\n * The signature pair (R, S) corresponds to the raw ECDSA ([Elliptic Curve Digital Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) signature.\n * Signatures are often serialized into a format known as '[DER encoding](https://en.wikipedia.org/wiki/X.690#DER_encoding)' for transmission.\n *\n * @class Signature\n */\nclass Signature {\n    /**\n     * Takes an array of numbers or a string and returns a new Signature instance.\n     * This method will throw an error if the DER encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     *\n     * @static\n     * @method fromDER\n     * @param data - The sequence to decode from DER encoding.\n     * @param enc - The encoding of the data string.\n     * @returns The decoded data in the form of Signature instance.\n     *\n     * @example\n     * const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');\n     */\n    static fromDER(data, enc) {\n        const getLength = (buf, p) => {\n            const initial = buf[p.place++];\n            if ((initial & 0x80) === 0) {\n                return initial;\n            }\n            else {\n                throw new Error('Invalid DER entity length');\n            }\n        };\n        class Position {\n            constructor() {\n                this.place = 0;\n            }\n        }\n        data = (0, utils_js_1.toArray)(data, enc);\n        const p = new Position();\n        if (data[p.place++] !== 0x30) {\n            throw new Error('Signature DER must start with 0x30');\n        }\n        const len = getLength(data, p);\n        if (len + p.place !== data.length) {\n            throw new Error('Signature DER invalid');\n        }\n        if (data[p.place++] !== 0x02) {\n            throw new Error('Signature DER invalid');\n        }\n        const rlen = getLength(data, p);\n        let r = data.slice(p.place, rlen + p.place);\n        p.place += rlen;\n        if (data[p.place++] !== 0x02) {\n            throw new Error('Signature DER invalid');\n        }\n        const slen = getLength(data, p);\n        if (data.length !== slen + p.place) {\n            throw new Error('Invalid R-length in signature DER');\n        }\n        let s = data.slice(p.place, slen + p.place);\n        if (r[0] === 0) {\n            if ((r[1] & 0x80) !== 0) {\n                r = r.slice(1);\n            }\n            else {\n                throw new Error('Invalid R-value in signature DER');\n            }\n        }\n        if (s[0] === 0) {\n            if ((s[1] & 0x80) !== 0) {\n                s = s.slice(1);\n            }\n            else {\n                throw new Error('Invalid S-value in signature DER');\n            }\n        }\n        return new Signature(new BigNumber_js_1.default(r), new BigNumber_js_1.default(s));\n    }\n    /**\n     * Takes an array of numbers or a string and returns a new Signature instance.\n     * This method will throw an error if the Compact encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     * compactByte value 27-30 means uncompressed public key.\n     * 31-34 means compressed public key.\n     * The range represents the recovery param which can be 0,1,2,3.\n     * We could support recovery functions in future if there's demand.\n     *\n     * @static\n     * @method fromCompact\n     * @param data - The sequence to decode from Compact encoding.\n     * @param enc - The encoding of the data string.\n     * @returns The decoded data in the form of Signature instance.\n     *\n     * @example\n     * const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');\n     */\n    static fromCompact(data, enc) {\n        data = (0, utils_js_1.toArray)(data, enc);\n        if (data.length !== 65) {\n            throw new Error('Invalid Compact Signature');\n        }\n        const compactByte = data[0];\n        if (compactByte < 27 || compactByte >= 35) {\n            throw new Error('Invalid Compact Byte');\n        }\n        return new Signature(new BigNumber_js_1.default(data.slice(1, 33)), new BigNumber_js_1.default(data.slice(33, 65)));\n    }\n    /**\n     * Creates an instance of the Signature class.\n     *\n     * @constructor\n     * @param r - The R component of the signature.\n     * @param s - The S component of the signature.\n     *\n     * @example\n     * const r = new BigNumber('208755674028...');\n     * const s = new BigNumber('564745627577...');\n     * const signature = new Signature(r, s);\n     */\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    /**\n     * Verifies a digital signature.\n     *\n     * This method will return true if the signature, key, and message hash match.\n     * If the data or key do not match the signature, the function returns false.\n     *\n     * @method verify\n     * @param msg - The message to verify.\n     * @param key - The public key used to sign the original message.\n     * @param enc - The encoding of the msg string.\n     * @returns A boolean representing whether the signature is valid.\n     *\n     * @example\n     * const msg = 'The quick brown fox jumps over the lazy dog';\n     * const publicKey = PublicKey.fromString('04188ca1050...');\n     * const isVerified = signature.verify(msg, publicKey);\n     */\n    verify(msg, key, enc) {\n        const msgHash = new BigNumber_js_1.default((0, Hash_js_1.sha256)(msg, enc), 16);\n        return (0, ECDSA_js_1.verify)(msgHash, this, key);\n    }\n    /**\n     * Converts an instance of Signature into DER encoding.\n     * An alias for the toDER method.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toDER\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const der = signature.toString('base64');\n     */\n    toString(enc) {\n        return this.toDER(enc);\n    }\n    /**\n     * Converts an instance of Signature into DER encoding.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toDER\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const der = signature.toDER('hex');\n     */\n    toDER(enc) {\n        const constructLength = (arr, len) => {\n            if (len < 0x80) {\n                arr.push(len);\n            }\n            else {\n                throw new Error('len must be < 0x80');\n            }\n        };\n        const rmPadding = (buf) => {\n            let i = 0;\n            const len = buf.length - 1;\n            while (buf[i] === 0 && (buf[i + 1] & 0x80) === 0 && i < len) {\n                i++;\n            }\n            if (i === 0) {\n                return buf;\n            }\n            return buf.slice(i);\n        };\n        let r = this.r.toArray();\n        let s = this.s.toArray();\n        // Pad values\n        if ((r[0] & 0x80) !== 0) {\n            r = [0].concat(r);\n        }\n        // Pad values\n        if ((s[0] & 0x80) !== 0) {\n            s = [0].concat(s);\n        }\n        r = rmPadding(r);\n        s = rmPadding(s);\n        while (s[0] === 0 && (s[1] & 0x80) === 0) {\n            s = s.slice(1);\n        }\n        let arr = [0x02];\n        constructLength(arr, r.length);\n        arr = arr.concat(r);\n        arr.push(0x02);\n        constructLength(arr, s.length);\n        const backHalf = arr.concat(s);\n        let res = [0x30];\n        constructLength(res, backHalf.length);\n        res = res.concat(backHalf);\n        if (enc === 'hex') {\n            return (0, utils_js_1.toHex)(res);\n        }\n        else if (enc === 'base64') {\n            return (0, utils_js_1.toBase64)(res);\n        }\n        else {\n            return res;\n        }\n    }\n    /**\n     * Converts an instance of Signature into Compact encoding.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toCompact\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const compact = signature.toCompact(3, true, 'base64');\n     */\n    toCompact(recovery, compressed, enc) {\n        if (recovery < 0 || recovery > 3)\n            throw new Error('Invalid recovery param');\n        if (typeof compressed !== 'boolean') {\n            throw new Error('Invalid compressed param');\n        }\n        let compactByte = 27 + recovery;\n        if (compressed) {\n            compactByte += 4;\n        }\n        let arr = [compactByte];\n        arr = arr.concat(this.r.toArray('be', 32));\n        arr = arr.concat(this.s.toArray('be', 32));\n        if (enc === 'hex') {\n            return (0, utils_js_1.toHex)(arr);\n        }\n        else if (enc === 'base64') {\n            return (0, utils_js_1.toBase64)(arr);\n        }\n        else {\n            return arr;\n        }\n    }\n    /**\n     * Recovers the public key from a signature.\n     * This method will return the public key if it finds a valid public key.\n     * If it does not find a valid public key, it will throw an error.\n     * The recovery factor is a number between 0 and 3.\n     * @method RecoverPublicKey\n     * @param recovery - The recovery factor.\n     * @param e - The message hash.\n     * @returns The public key associated with the signature.\n     *\n     * @example\n     * const publicKey = signature.RecoverPublicKey(0, msgHash);\n     */\n    RecoverPublicKey(recovery, e) {\n        const r = this.r;\n        const s = this.s;\n        // A set LSB signifies that the y-coordinate is odd\n        const isYOdd = (recovery & 1) !== 0;\n        // The more significant bit specifies whether we should use the\n        // first or second candidate key.\n        const isSecondKey = recovery >> 1;\n        const curve = new Curve_js_1.default();\n        const n = curve.n;\n        const G = curve.g;\n        // 1.1 LEt x = r + jn\n        const x = isSecondKey !== 0 ? r.add(n) : r;\n        const R = Point_js_1.default.fromX(x, isYOdd);\n        // 1.4 Check that nR is at infinity\n        const nR = R.mul(n);\n        if (!nR.isInfinity()) {\n            throw new Error('nR is not at infinity');\n        }\n        // Compute -e from e\n        const eNeg = e.neg().umod(n);\n        // 1.6.1 Compute Q = r^-1 (sR - eG)\n        // Q = r^-1 (sR + -eG)\n        const rInv = r.invm(n);\n        // const Q = R.multiplyTwo(s, G, eNeg).mul(rInv)\n        const srInv = rInv.mul(s).umod(n);\n        const eInvrInv = rInv.mul(eNeg).umod(n);\n        const Q = G.mul(eInvrInv).add(R.mul(srInv));\n        const pubKey = new PublicKey_js_1.default(Q);\n        pubKey.validate();\n        return pubKey;\n    }\n    /**\n     * Calculates the recovery factor which will work for a particular public key and message hash.\n     * This method will return the recovery factor if it finds a valid recovery factor.\n     * If it does not find a valid recovery factor, it will throw an error.\n     * The recovery factor is a number between 0 and 3.\n     *\n     * @method CalculateRecoveryFactor\n     * @param msgHash - The message hash.\n     * @returns the recovery factor: number\n     * /\n     * @example\n     * const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);\n     */\n    CalculateRecoveryFactor(pubkey, msgHash) {\n        for (let recovery = 0; recovery < 4; recovery++) {\n            let Qprime;\n            try {\n                Qprime = this.RecoverPublicKey(recovery, msgHash);\n            }\n            catch {\n                continue;\n            }\n            if (pubkey.eq(Qprime)) {\n                return recovery;\n            }\n        }\n        throw new Error('Unable to find valid recovery factor');\n    }\n}\nexports[\"default\"] = Signature;\n//# sourceMappingURL=Signature.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst AESGCM_js_1 = __webpack_require__(/*! ./AESGCM.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/AESGCM.js\");\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n/**\n * `SymmetricKey` is a class that extends the `BigNumber` class and implements symmetric encryption and decryption methods.\n * Symmetric-Key encryption is a form of encryption where the same key is used to encrypt and decrypt the message.\n * It leverages the Advanced Encryption Standard Galois/Counter Mode (AES-GCM) for encryption and decryption of messages.\n *\n * @class SymmetricKey\n * @extends {BigNumber}\n */\nclass SymmetricKey extends BigNumber_js_1.default {\n    /**\n     * Generates a symmetric key randomly.\n     *\n     * @method fromRandom\n     * @static\n     * @returns The newly generated Symmetric Key.\n     *\n     * @example\n     * const symmetricKey = SymmetricKey.fromRandom();\n     */\n    static fromRandom() {\n        return new SymmetricKey((0, Random_js_1.default)(32));\n    }\n    /**\n     * Encrypts a given message using AES-GCM encryption.\n     * The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes.\n     * The OpenSSL format of |IV|encryptedContent|authTag| is used.\n     *\n     * @method encrypt\n     * @param msg - The message to be encrypted. It can be a string or an array of numbers.\n     * @param enc - optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.\n     * @returns Returns the encrypted message as a string or an array of numbers, depending on `enc` argument.\n     *\n     * @example\n     * const key = new SymmetricKey(1234);\n     * const encryptedMessage = key.encrypt('plainText', 'utf8');\n     */\n    encrypt(msg, enc) {\n        const iv = (0, Random_js_1.default)(32);\n        msg = (0, utils_js_1.toArray)(msg, enc);\n        const { result, authenticationTag } = (0, AESGCM_js_1.AESGCM)(msg, [], iv, this.toArray('be', 32));\n        return (0, utils_js_1.encode)([...iv, ...result, ...authenticationTag], enc);\n    }\n    /**\n     * Decrypts a given AES-GCM encrypted message using the same key that was used for encryption.\n     * The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it.\n     * If the decryption fails (e.g., due to message tampering), an error is thrown.\n     *\n     * @method decrypt\n     * @param msg - The encrypted message to be decrypted. It can be a string or an array of numbers.\n     * @param enc - optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).\n     * @returns Returns the decrypted message as a string or an array of numbers, depending on `enc` argument. If absent, an array of numbers is returned.\n     *\n     * @example\n     * const key = new SymmetricKey(1234);\n     * const decryptedMessage = key.decrypt(encryptedMessage, 'utf8');\n     *\n     * @throws {Error} Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.\n     */\n    decrypt(msg, enc) {\n        msg = (0, utils_js_1.toArray)(msg, enc);\n        const iv = msg.slice(0, 32);\n        const ciphertextWithTag = msg.slice(32);\n        const messageTag = ciphertextWithTag.slice(-16);\n        const ciphertext = ciphertextWithTag.slice(0, -16);\n        const result = (0, AESGCM_js_1.AESGCMDecrypt)(ciphertext, [], iv, messageTag, this.toArray());\n        if (result === null) {\n            throw new Error('Decryption failed!');\n        }\n        return (0, utils_js_1.encode)(result, enc);\n    }\n}\nexports[\"default\"] = SymmetricKey;\n//# sourceMappingURL=SymmetricKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Signature_js_1 = __importDefault(__webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Hash = __importStar(__webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst utils_js_1 = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nclass TransactionSignature extends Signature_js_1.default {\n    static format(params) {\n        const currentInput = {\n            sourceTXID: params.sourceTXID,\n            sourceOutputIndex: params.sourceOutputIndex,\n            sequence: params.inputSequence\n        };\n        const inputs = [...params.otherInputs];\n        inputs.splice(params.inputIndex, 0, currentInput);\n        const getPrevoutHash = () => {\n            const writer = new utils_js_1.Writer();\n            for (const input of inputs) {\n                if (typeof input.sourceTXID === 'undefined') {\n                    if (input.sourceTransaction == null) {\n                        throw new Error('Missing sourceTransaction for input');\n                    }\n                    writer.write(input.sourceTransaction.hash());\n                }\n                else {\n                    writer.writeReverse((0, utils_js_1.toArray)(input.sourceTXID, 'hex'));\n                }\n                writer.writeUInt32LE(input.sourceOutputIndex);\n            }\n            const buf = writer.toArray();\n            const ret = Hash.hash256(buf);\n            return ret;\n        };\n        const getSequenceHash = () => {\n            const writer = new utils_js_1.Writer();\n            for (const input of inputs) {\n                const sequence = input.sequence ?? 0xffffffff; // Default to max sequence number\n                writer.writeUInt32LE(sequence);\n            }\n            const buf = writer.toArray();\n            const ret = Hash.hash256(buf);\n            return ret;\n        };\n        function getOutputsHash(outputIndex) {\n            const writer = new utils_js_1.Writer();\n            if (typeof outputIndex === 'undefined') {\n                for (const output of params.outputs) {\n                    const satoshis = output.satoshis ?? 0; // Default to 0 if undefined\n                    writer.writeUInt64LE(satoshis);\n                    const script = output.lockingScript?.toBinary() ?? [];\n                    writer.writeVarIntNum(script.length);\n                    writer.write(script);\n                }\n            }\n            else {\n                const output = params.outputs[outputIndex];\n                if (output === undefined) { //  Explicitly check for undefined\n                    throw new Error(`Output at index ${outputIndex} does not exist`);\n                }\n                const satoshis = output.satoshis ?? 0; // Default to 0 if undefined\n                writer.writeUInt64LE(satoshis);\n                const script = output.lockingScript?.toBinary() ?? [];\n                writer.writeVarIntNum(script.length);\n                writer.write(script);\n            }\n            const buf = writer.toArray();\n            const ret = Hash.hash256(buf);\n            return ret;\n        }\n        let hashPrevouts = new Array(32).fill(0);\n        let hashSequence = new Array(32).fill(0);\n        let hashOutputs = new Array(32).fill(0);\n        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0) {\n            hashPrevouts = getPrevoutHash();\n        }\n        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0 &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {\n            hashSequence = getSequenceHash();\n        }\n        if ((params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {\n            hashOutputs = getOutputsHash();\n        }\n        else if ((params.scope & 31) === TransactionSignature.SIGHASH_SINGLE &&\n            params.inputIndex < params.outputs.length) {\n            hashOutputs = getOutputsHash(params.inputIndex);\n        }\n        const writer = new utils_js_1.Writer();\n        // Version\n        writer.writeInt32LE(params.transactionVersion);\n        // Input prevouts/nSequence (none/all, depending on flags)\n        writer.write(hashPrevouts);\n        writer.write(hashSequence);\n        //  outpoint (32-byte hash + 4-byte little endian)\n        writer.writeReverse((0, utils_js_1.toArray)(params.sourceTXID, 'hex'));\n        writer.writeUInt32LE(params.sourceOutputIndex);\n        // scriptCode of the input (serialized as scripts inside CTxOuts)\n        const subscriptBin = params.subscript.toBinary();\n        writer.writeVarIntNum(subscriptBin.length);\n        writer.write(subscriptBin);\n        // value of the output spent by this input (8-byte little endian)\n        writer.writeUInt64LE(params.sourceSatoshis);\n        // nSequence of the input (4-byte little endian)\n        const sequenceNumber = currentInput.sequence;\n        writer.writeUInt32LE(sequenceNumber);\n        // Outputs (none/one/all, depending on flags)\n        writer.write(hashOutputs);\n        // Locktime\n        writer.writeUInt32LE(params.lockTime);\n        // sighashType\n        writer.writeUInt32LE(params.scope >>> 0);\n        const buf = writer.toArray();\n        return buf;\n    }\n    // The format used in a tx\n    static fromChecksigFormat(buf) {\n        if (buf.length === 0) {\n            // allow setting a \"blank\" signature\n            const r = new BigNumber_js_1.default(1);\n            const s = new BigNumber_js_1.default(1);\n            const scope = 1;\n            return new TransactionSignature(r, s, scope);\n        }\n        const scope = buf[buf.length - 1];\n        const derbuf = buf.slice(0, buf.length - 1);\n        const tempSig = Signature_js_1.default.fromDER(derbuf);\n        return new TransactionSignature(tempSig.r, tempSig.s, scope);\n    }\n    constructor(r, s, scope) {\n        super(r, s);\n        this.scope = scope;\n    }\n    /**\n     * Compares to bitcoind's IsLowDERSignature\n     * See also Ecdsa signature algorithm which enforces this.\n     * See also Bip 62, \"low S values in signatures\"\n     */\n    hasLowS() {\n        if (this.s.ltn(1) ||\n            this.s.gt(new BigNumber_js_1.default('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n            return false;\n        }\n        return true;\n    }\n    toChecksigFormat() {\n        const derbuf = this.toDER();\n        return [...derbuf, this.scope];\n    }\n}\nTransactionSignature.SIGHASH_ALL = 0x00000001;\nTransactionSignature.SIGHASH_NONE = 0x00000002;\nTransactionSignature.SIGHASH_SINGLE = 0x00000003;\nTransactionSignature.SIGHASH_FORKID = 0x00000040;\nTransactionSignature.SIGHASH_ANYONECANPAY = 0x00000080;\nexports[\"default\"] = TransactionSignature;\n//# sourceMappingURL=TransactionSignature.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Schnorr = exports.PointInFiniteField = exports.Polynomial = exports.TransactionSignature = exports.Random = exports.Hash = exports.Utils = exports.ECDSA = exports.DRBG = exports.SymmetricKey = exports.KeyShares = exports.PrivateKey = exports.Signature = exports.PublicKey = exports.Point = exports.Curve = exports.BigNumber = void 0;\nvar BigNumber_js_1 = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\");\nObject.defineProperty(exports, \"BigNumber\", ({ enumerable: true, get: function () { return __importDefault(BigNumber_js_1).default; } }));\nvar Curve_js_1 = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Curve.js\");\nObject.defineProperty(exports, \"Curve\", ({ enumerable: true, get: function () { return __importDefault(Curve_js_1).default; } }));\nvar Point_js_1 = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Point.js\");\nObject.defineProperty(exports, \"Point\", ({ enumerable: true, get: function () { return __importDefault(Point_js_1).default; } }));\nvar PublicKey_js_1 = __webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\");\nObject.defineProperty(exports, \"PublicKey\", ({ enumerable: true, get: function () { return __importDefault(PublicKey_js_1).default; } }));\nvar Signature_js_1 = __webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Signature.js\");\nObject.defineProperty(exports, \"Signature\", ({ enumerable: true, get: function () { return __importDefault(Signature_js_1).default; } }));\nvar PrivateKey_js_1 = __webpack_require__(/*! ./PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\");\nObject.defineProperty(exports, \"PrivateKey\", ({ enumerable: true, get: function () { return __importDefault(PrivateKey_js_1).default; } }));\nObject.defineProperty(exports, \"KeyShares\", ({ enumerable: true, get: function () { return PrivateKey_js_1.KeyShares; } }));\nvar SymmetricKey_js_1 = __webpack_require__(/*! ./SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/SymmetricKey.js\");\nObject.defineProperty(exports, \"SymmetricKey\", ({ enumerable: true, get: function () { return __importDefault(SymmetricKey_js_1).default; } }));\nvar DRBG_js_1 = __webpack_require__(/*! ./DRBG.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/DRBG.js\");\nObject.defineProperty(exports, \"DRBG\", ({ enumerable: true, get: function () { return __importDefault(DRBG_js_1).default; } }));\nexports.ECDSA = __importStar(__webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\"));\nexports.Utils = __importStar(__webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nexports.Hash = __importStar(__webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nvar Random_js_1 = __webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\");\nObject.defineProperty(exports, \"Random\", ({ enumerable: true, get: function () { return __importDefault(Random_js_1).default; } }));\nvar TransactionSignature_js_1 = __webpack_require__(/*! ./TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js\");\nObject.defineProperty(exports, \"TransactionSignature\", ({ enumerable: true, get: function () { return __importDefault(TransactionSignature_js_1).default; } }));\nvar Polynomial_js_1 = __webpack_require__(/*! ./Polynomial.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Polynomial.js\");\nObject.defineProperty(exports, \"Polynomial\", ({ enumerable: true, get: function () { return __importDefault(Polynomial_js_1).default; } }));\nObject.defineProperty(exports, \"PointInFiniteField\", ({ enumerable: true, get: function () { return Polynomial_js_1.PointInFiniteField; } }));\nvar Schnorr_js_1 = __webpack_require__(/*! ./Schnorr.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Schnorr.js\");\nObject.defineProperty(exports, \"Schnorr\", ({ enumerable: true, get: function () { return __importDefault(Schnorr_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.minimallyEncode = exports.Reader = exports.Writer = exports.fromBase58Check = exports.toBase58Check = exports.toBase58 = exports.fromBase58 = exports.toBase64 = exports.encode = exports.toUTF8 = exports.toArray = exports.toHex = exports.zero2 = void 0;\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst Hash_js_1 = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\n/**\n * Prepends a '0' to an odd character length word to ensure it has an even number of characters.\n * @param {string} word - The input word.\n * @returns {string} - The word with a leading '0' if it's an odd character length; otherwise, the original word.\n */\nconst zero2 = (word) => {\n    if (word.length % 2 === 1) {\n        return '0' + word;\n    }\n    else {\n        return word;\n    }\n};\nexports.zero2 = zero2;\n/**\n * Converts an array of numbers to a hexadecimal string representation.\n * @param {number[]} msg - The input array of numbers.\n * @returns {string} - The hexadecimal string representation of the input array.\n */\nconst toHex = (msg) => {\n    let res = '';\n    for (const num of msg) {\n        res += (0, exports.zero2)(num.toString(16));\n    }\n    return res;\n};\nexports.toHex = toHex;\n/**\n * Converts various message formats into an array of numbers.\n * Supports arrays, hexadecimal strings, base64 strings, and UTF-8 strings.\n *\n * @param {any} msg - The input message (array or string).\n * @param {('hex' | 'utf8' | 'base64')} enc - Specifies the string encoding, if applicable.\n * @returns {any[]} - Array representation of the input.\n */\nconst toArray = (msg, enc) => {\n    if (Array.isArray(msg))\n        return msg.slice();\n    if (msg === undefined)\n        return [];\n    if (typeof msg !== 'string') {\n        return Array.from(msg, (item) => item | 0);\n    }\n    switch (enc) {\n        case 'hex':\n            return hexToArray(msg);\n        case 'base64':\n            return base64ToArray(msg);\n        default:\n            return utf8ToArray(msg);\n    }\n};\nexports.toArray = toArray;\nconst hexToArray = (msg) => {\n    msg = msg.replace(/[^a-z0-9]+/gi, '');\n    if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n    const res = [];\n    for (let i = 0; i < msg.length; i += 2) {\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n    return res;\n};\nconst base64ToArray = (msg) => {\n    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const result = [];\n    let currentBit = 0;\n    let currentByte = 0;\n    for (const char of msg.replace(/=+$/, '')) {\n        currentBit = (currentBit << 6) | base64Chars.indexOf(char);\n        currentByte += 6;\n        if (currentByte >= 8) {\n            currentByte -= 8;\n            result.push((currentBit >> currentByte) & 0xff);\n            currentBit &= (1 << currentByte) - 1;\n        }\n    }\n    return result;\n};\n/**\n * Encodes a string into an array of bytes representing its UTF-8 encoding.\n * Any lone surrogates are replaced with the Unicode replacement character (U+FFFD).\n *\n * @param str - The string to encode.\n * @returns An array of numbers, each representing a byte in the UTF-8 encoded string.\n */\nfunction utf8ToArray(str) {\n    const result = [];\n    for (let i = 0; i < str.length; i++) {\n        const cp = str.codePointAt(i);\n        if (cp === undefined) {\n            // Should never be out of range.\n            throw new Error(`Index out of range: ${i}`);\n        }\n        let codePoint = cp;\n        if (codePoint > 0xFFFF) {\n            // Valid surrogate pair => skip the next code unit because codePointAt\n            // has already combined them into a single code point.\n            i++;\n        }\n        else {\n            // Check if codePoint is a lone (unpaired) high surrogate or low surrogate.\n            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n                // Replace with the replacement character (U+FFFD).\n                codePoint = 0xFFFD;\n            }\n        }\n        // Encode according to the UTF-8 standard\n        if (codePoint <= 0x7F) {\n            result.push(codePoint);\n        }\n        else if (codePoint <= 0x7FF) {\n            result.push(0xC0 | (codePoint >> 6), 0x80 | (codePoint & 0x3F));\n        }\n        else if (codePoint <= 0xFFFF) {\n            result.push(0xE0 | (codePoint >> 12), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));\n        }\n        else {\n            result.push(0xF0 | (codePoint >> 18), 0x80 | ((codePoint >> 12) & 0x3F), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));\n        }\n    }\n    return result;\n}\n/**\n * Converts an array of numbers to a UTF-8 encoded string.\n * @param {number[]} arr - The input array of numbers.\n * @returns {string} - The UTF-8 encoded string.\n */\nconst toUTF8 = (arr) => {\n    let result = '';\n    let skip = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const byte = arr[i];\n        // this byte is part of a multi-byte sequence, skip it\n        // added to avoid modifying i within the loop which is considered unsafe.\n        if (skip > 0) {\n            skip--;\n            continue;\n        }\n        // 1-byte sequence (0xxxxxxx)\n        if (byte <= 0x7f) {\n            result += String.fromCharCode(byte);\n        }\n        else if (byte >= 0xc0 && byte <= 0xdf) {\n            // 2-byte sequence (110xxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            skip = 1;\n            const codePoint = ((byte & 0x1f) << 6) | (byte2 & 0x3f);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte >= 0xe0 && byte <= 0xef) {\n            // 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            skip = 2;\n            const codePoint = ((byte & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte >= 0xf0 && byte <= 0xf7) {\n            // 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            const byte4 = arr[i + 3];\n            skip = 3;\n            const codePoint = ((byte & 0x07) << 18) |\n                ((byte2 & 0x3f) << 12) |\n                ((byte3 & 0x3f) << 6) |\n                (byte4 & 0x3f);\n            // Convert to UTF-16 surrogate pair\n            const surrogate1 = 0xd800 + ((codePoint - 0x10000) >> 10);\n            const surrogate2 = 0xdc00 + ((codePoint - 0x10000) & 0x3ff);\n            result += String.fromCharCode(surrogate1, surrogate2);\n        }\n    }\n    return result;\n};\nexports.toUTF8 = toUTF8;\n/**\n * Encodes an array of numbers into a specified encoding ('hex' or 'utf8'). If no encoding is provided, returns the original array.\n * @param {number[]} arr - The input array of numbers.\n * @param {('hex' | 'utf8')} enc - The desired encoding.\n * @returns {string | number[]} - The encoded message as a string (for 'hex' and 'utf8') or the original array.\n */\nconst encode = (arr, enc) => {\n    switch (enc) {\n        case 'hex':\n            return (0, exports.toHex)(arr);\n        case 'utf8':\n            return (0, exports.toUTF8)(arr);\n        // If no encoding is provided, return the original array\n        default:\n            return arr;\n    }\n};\nexports.encode = encode;\n/**\n * Converts an array of bytes (each between 0 and 255) into a base64 encoded string.\n *\n * @param {number[]} byteArray - An array of numbers where each number is a byte (0-255).\n * @returns {string} The base64 encoded string.\n *\n * @example\n * const bytes = [72, 101, 108, 108, 111]; // Represents the string \"Hello\"\n * console.log(toBase64(bytes)); // Outputs: SGVsbG8=\n */\nfunction toBase64(byteArray) {\n    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    let result = '';\n    let i;\n    for (i = 0; i < byteArray.length; i += 3) {\n        const byte1 = byteArray[i];\n        const byte2 = i + 1 < byteArray.length ? byteArray[i + 1] : 0;\n        const byte3 = i + 2 < byteArray.length ? byteArray[i + 2] : 0;\n        const encoded1 = byte1 >> 2;\n        const encoded2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n        const encoded3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n        const encoded4 = byte3 & 0x3f;\n        result += base64Chars.charAt(encoded1) + base64Chars.charAt(encoded2);\n        result += i + 1 < byteArray.length ? base64Chars.charAt(encoded3) : '=';\n        result += i + 2 < byteArray.length ? base64Chars.charAt(encoded4) : '=';\n    }\n    return result;\n}\nexports.toBase64 = toBase64;\nconst base58chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n/**\n * Converts a string from base58 to a binary array\n * @param str - The string representation\n * @returns The binary representation\n */\nconst fromBase58 = (str) => {\n    if (str === '' || typeof str !== 'string') {\n        throw new Error(`Expected base58 string but got ${str}`);\n    }\n    const match = str.match(/[IOl0]/gmu);\n    if (match !== null) {\n        throw new Error(`Invalid base58 character ${match.join('')}`);\n    }\n    const lz = str.match(/^1+/gmu);\n    const psz = (lz !== null) ? lz[0].length : 0;\n    const size = ((str.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;\n    const uint8 = new Uint8Array([\n        ...new Uint8Array(psz),\n        ...(str.match(/./gmu) ?? [] //  Safe Fix: If null, use []\n        )\n            .map((i) => base58chars.indexOf(i))\n            .reduce((acc, i) => {\n            acc = acc.map((j) => {\n                const x = j * 58 + i;\n                i = x >> 8;\n                return x;\n            });\n            return acc;\n        }, new Uint8Array(size))\n            .reverse()\n            .filter(((lastValue) => (value) => \n        // @ts-expect-error\n        (lastValue = lastValue || value))(false))\n    ]);\n    return [...uint8];\n};\nexports.fromBase58 = fromBase58;\n/**\n * Converts a binary array into a base58 string\n * @param bin - The binary array to convert to base58\n * @returns The base58 string representation\n */\nconst toBase58 = (bin) => {\n    const base58Map = Array(256).fill(-1);\n    for (let i = 0; i < base58chars.length; ++i) {\n        base58Map[base58chars.charCodeAt(i)] = i;\n    }\n    const result = [];\n    for (const byte of bin) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry !== 0) {\n            result.push(base58chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bin) {\n        if (byte !== 0)\n            break;\n        else\n            result.push('1'.charCodeAt(0));\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n};\nexports.toBase58 = toBase58;\n/**\n * Converts a binary array into a base58check string with a checksum\n * @param bin - The binary array to convert to base58check\n * @returns The base58check string representation\n */\nconst toBase58Check = (bin, prefix = [0]) => {\n    let hash = (0, Hash_js_1.hash256)([...prefix, ...bin]);\n    hash = [...prefix, ...bin, ...hash.slice(0, 4)];\n    return (0, exports.toBase58)(hash);\n};\nexports.toBase58Check = toBase58Check;\n/**\n * Converts a base58check string into a binary array after validating the checksum\n * @param str - The base58check string to convert to binary\n * @param enc - If hex, the return values will be hex strings, arrays of numbers otherwise\n * @param prefixLength - The length of the prefix. Optional, defaults to 1.\n * @returns The binary array representation\n */\nconst fromBase58Check = (str, enc, prefixLength = 1) => {\n    const bin = (0, exports.fromBase58)(str);\n    let prefix = bin.slice(0, prefixLength);\n    let data = bin.slice(prefixLength, -4);\n    let hash = [...prefix, ...data];\n    hash = (0, Hash_js_1.hash256)(hash);\n    bin.slice(-4).forEach((check, index) => {\n        if (check !== hash[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    if (enc === 'hex') {\n        prefix = (0, exports.toHex)(prefix);\n        data = (0, exports.toHex)(data);\n    }\n    return { prefix, data };\n};\nexports.fromBase58Check = fromBase58Check;\nclass Writer {\n    constructor(bufs) {\n        this.bufs = bufs !== undefined ? bufs : [];\n        this.length = 0;\n        for (const b of this.bufs)\n            this.length += b.length;\n    }\n    getLength() {\n        return this.length;\n    }\n    toArray() {\n        const totalLength = this.length;\n        const ret = new Array(totalLength);\n        let offset = 0;\n        for (const buf of this.bufs) {\n            for (const value of buf) {\n                ret[offset++] = value;\n            }\n        }\n        return ret;\n    }\n    write(buf) {\n        this.bufs.push(buf);\n        this.length += buf.length;\n        return this;\n    }\n    writeReverse(buf) {\n        const buf2 = new Array(buf.length);\n        for (let i = 0; i < buf2.length; i++) {\n            buf2[i] = buf[buf.length - 1 - i];\n        }\n        this.bufs.push(buf2);\n        this.length += buf2.length;\n        return this;\n    }\n    writeUInt8(n) {\n        const buf = new Array(1);\n        buf[0] = n;\n        this.write(buf);\n        return this;\n    }\n    writeInt8(n) {\n        const buf = new Array(1);\n        buf[0] = n & 0xff;\n        this.write(buf);\n        return this;\n    }\n    writeUInt16BE(n) {\n        const buf = [\n            (n >> 8) & 0xff,\n            n & 0xff // low byte is just the last 8 bits\n        ];\n        this.bufs.push(buf);\n        this.length += 2;\n        return this;\n    }\n    writeInt16BE(n) {\n        return this.writeUInt16BE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits\n    }\n    writeUInt16LE(n) {\n        const buf = [\n            n & 0xff,\n            (n >> 8) & 0xff // shift right 8 bits to get the high byte\n        ];\n        this.bufs.push(buf);\n        this.length += 2;\n        return this;\n    }\n    writeInt16LE(n) {\n        return this.writeUInt16LE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits\n    }\n    writeUInt32BE(n) {\n        const buf = [\n            (n >> 24) & 0xff,\n            (n >> 16) & 0xff,\n            (n >> 8) & 0xff,\n            n & 0xff // lowest byte\n        ];\n        this.bufs.push(buf);\n        this.length += 4;\n        return this;\n    }\n    writeInt32BE(n) {\n        return this.writeUInt32BE(n >>> 0); // Using unsigned right shift to handle negative numbers\n    }\n    writeUInt32LE(n) {\n        const buf = [\n            n & 0xff,\n            (n >> 8) & 0xff,\n            (n >> 16) & 0xff,\n            (n >> 24) & 0xff // highest byte\n        ];\n        this.bufs.push(buf);\n        this.length += 4;\n        return this;\n    }\n    writeInt32LE(n) {\n        return this.writeUInt32LE(n >>> 0); // Using unsigned right shift to handle negative numbers\n    }\n    writeUInt64BEBn(bn) {\n        const buf = bn.toArray('be', 8);\n        this.write(buf);\n        return this;\n    }\n    writeUInt64LEBn(bn) {\n        const buf = bn.toArray('be', 8);\n        this.writeReverse(buf);\n        return this;\n    }\n    writeUInt64LE(n) {\n        const buf = new BigNumber_js_1.default(n).toArray('be', 8);\n        this.writeReverse(buf);\n        return this;\n    }\n    writeVarIntNum(n) {\n        const buf = Writer.varIntNum(n);\n        this.write(buf);\n        return this;\n    }\n    writeVarIntBn(bn) {\n        const buf = Writer.varIntBn(bn);\n        this.write(buf);\n        return this;\n    }\n    static varIntNum(n) {\n        let buf;\n        if (n < 0) {\n            return this.varIntBn(new BigNumber_js_1.default(n));\n        }\n        if (n < 253) {\n            buf = [n]; // 1 byte\n        }\n        else if (n < 0x10000) {\n            // 253 followed by the number in little-endian format\n            buf = [\n                253,\n                n & 0xff,\n                (n >> 8) & 0xff // high byte\n            ];\n        }\n        else if (n < 0x100000000) {\n            // 254 followed by the number in little-endian format\n            buf = [\n                254,\n                n & 0xff,\n                (n >> 8) & 0xff,\n                (n >> 16) & 0xff,\n                (n >> 24) & 0xff\n            ];\n        }\n        else {\n            // 255 followed by the number in little-endian format\n            // Since JavaScript bitwise operations work on 32 bits, we need to handle 64-bit numbers in two parts\n            const low = n & 0xffffffff;\n            const high = Math.floor(n / 0x100000000) & 0xffffffff;\n            buf = [\n                255,\n                low & 0xff,\n                (low >> 8) & 0xff,\n                (low >> 16) & 0xff,\n                (low >> 24) & 0xff,\n                high & 0xff,\n                (high >> 8) & 0xff,\n                (high >> 16) & 0xff,\n                (high >> 24) & 0xff\n            ];\n        }\n        return buf;\n    }\n    static varIntBn(bn) {\n        let buf;\n        if (bn.isNeg()) {\n            bn = bn.add(OverflowUint64); // Adjust for negative numbers\n        }\n        if (bn.ltn(253)) {\n            const n = bn.toNumber();\n            // No need for bitwise operation as the value is within a byte's range\n            buf = [n];\n        }\n        else if (bn.ltn(0x10000)) {\n            const n = bn.toNumber();\n            // Value fits in a uint16\n            buf = [253, n & 0xff, (n >> 8) & 0xff];\n        }\n        else if (bn.lt(new BigNumber_js_1.default(0x100000000))) {\n            const n = bn.toNumber();\n            // Value fits in a uint32\n            buf = [\n                254,\n                n & 0xff,\n                (n >> 8) & 0xff,\n                (n >> 16) & 0xff,\n                (n >> 24) & 0xff\n            ];\n        }\n        else {\n            const bw = new Writer();\n            bw.writeUInt8(255);\n            bw.writeUInt64LEBn(bn);\n            buf = bw.toArray();\n        }\n        return buf;\n    }\n}\nexports.Writer = Writer;\nclass Reader {\n    constructor(bin = [], pos = 0) {\n        this.bin = bin;\n        this.pos = pos;\n        this.length = bin.length;\n    }\n    eof() {\n        return this.pos >= this.length;\n    }\n    read(len = this.length) {\n        const start = this.pos;\n        const end = this.pos + len;\n        this.pos = end;\n        return this.bin.slice(start, end);\n    }\n    readReverse(len = this.length) {\n        const buf2 = new Array(len);\n        for (let i = 0; i < len; i++) {\n            buf2[i] = this.bin[this.pos + len - 1 - i];\n        }\n        this.pos += len;\n        return buf2;\n    }\n    readUInt8() {\n        const val = this.bin[this.pos];\n        this.pos += 1;\n        return val;\n    }\n    readInt8() {\n        const val = this.bin[this.pos];\n        this.pos += 1;\n        // If the sign bit is set, convert to negative value\n        return (val & 0x80) !== 0 ? val - 0x100 : val;\n    }\n    readUInt16BE() {\n        const val = (this.bin[this.pos] << 8) | this.bin[this.pos + 1];\n        this.pos += 2;\n        return val;\n    }\n    readInt16BE() {\n        const val = this.readUInt16BE();\n        // If the sign bit is set, convert to negative value\n        return (val & 0x8000) !== 0 ? val - 0x10000 : val;\n    }\n    readUInt16LE() {\n        const val = this.bin[this.pos] | (this.bin[this.pos + 1] << 8);\n        this.pos += 2;\n        return val;\n    }\n    readInt16LE() {\n        const val = this.readUInt16LE();\n        // If the sign bit is set, convert to negative value\n        const x = (val & 0x8000) !== 0 ? val - 0x10000 : val;\n        return x;\n    }\n    readUInt32BE() {\n        const val = this.bin[this.pos] * 0x1000000 + // Shift the first byte by 24 bits\n            ((this.bin[this.pos + 1] << 16) | // Shift the second byte by 16 bits\n                (this.bin[this.pos + 2] << 8) | // Shift the third byte by 8 bits\n                this.bin[this.pos + 3]); // The fourth byte\n        this.pos += 4;\n        return val;\n    }\n    readInt32BE() {\n        const val = this.readUInt32BE();\n        // If the sign bit is set, convert to negative value\n        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;\n    }\n    readUInt32LE() {\n        const val = (this.bin[this.pos] |\n            (this.bin[this.pos + 1] << 8) |\n            (this.bin[this.pos + 2] << 16) |\n            (this.bin[this.pos + 3] << 24)) >>>\n            0;\n        this.pos += 4;\n        return val;\n    }\n    readInt32LE() {\n        const val = this.readUInt32LE();\n        // Explicitly check if the sign bit is set and then convert to a negative value\n        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;\n    }\n    readUInt64BEBn() {\n        const bin = this.bin.slice(this.pos, this.pos + 8);\n        const bn = new BigNumber_js_1.default(bin);\n        this.pos = this.pos + 8;\n        return bn;\n    }\n    readUInt64LEBn() {\n        const bin = this.readReverse(8);\n        const bn = new BigNumber_js_1.default(bin);\n        return bn;\n    }\n    readInt64LEBn() {\n        const bin = this.readReverse(8);\n        let bn = new BigNumber_js_1.default(bin);\n        if (bn.gte(OverflowInt64)) {\n            bn = bn.sub(OverflowUint64); // Adjust for negative numbers\n        }\n        return bn;\n    }\n    readVarIntNum(signed = true) {\n        const first = this.readUInt8();\n        let bn;\n        switch (first) {\n            case 0xfd:\n                return this.readUInt16LE();\n            case 0xfe:\n                return this.readUInt32LE();\n            case 0xff:\n                bn = signed ? this.readInt64LEBn() : this.readUInt64LEBn();\n                if (bn.lte(new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(53)))) {\n                    return bn.toNumber();\n                }\n                else {\n                    throw new Error('number too large to retain precision - use readVarIntBn');\n                }\n            default:\n                return first;\n        }\n    }\n    readVarInt() {\n        const first = this.bin[this.pos];\n        switch (first) {\n            case 0xfd:\n                return this.read(1 + 2);\n            case 0xfe:\n                return this.read(1 + 4);\n            case 0xff:\n                return this.read(1 + 8);\n            default:\n                return this.read(1);\n        }\n    }\n    readVarIntBn() {\n        const first = this.readUInt8();\n        switch (first) {\n            case 0xfd:\n                return new BigNumber_js_1.default(this.readUInt16LE());\n            case 0xfe:\n                return new BigNumber_js_1.default(this.readUInt32LE());\n            case 0xff:\n                return this.readUInt64LEBn();\n            default:\n                return new BigNumber_js_1.default(first);\n        }\n    }\n}\nexports.Reader = Reader;\nconst minimallyEncode = (buf) => {\n    if (buf.length === 0) {\n        return buf;\n    }\n    // If the last byte is not 0x00 or 0x80, we are minimally encoded.\n    const last = buf[buf.length - 1];\n    if ((last & 0x7f) !== 0) {\n        return buf;\n    }\n    // If the script is one byte long, then we have a zero, which encodes as an\n    // empty array.\n    if (buf.length === 1) {\n        return [];\n    }\n    // If the next byte has it sign bit set, then we are minimaly encoded.\n    if ((buf[buf.length - 2] & 0x80) !== 0) {\n        return buf;\n    }\n    // We are not minimally encoded, we need to figure out how much to trim.\n    for (let i = buf.length - 1; i > 0; i--) {\n        // We found a non zero byte, time to encode.\n        if (buf[i - 1] !== 0) {\n            if ((buf[i - 1] & 0x80) !== 0) {\n                // We found a byte with it sign bit set so we need one more\n                // byte.\n                buf[i] = last;\n                return buf.slice(0, i + 1);\n            }\n            else {\n                // the sign bit is clear, we can use it.\n                buf[i - 1] |= last;\n                return buf.slice(0, i);\n            }\n        }\n    }\n    // If we found the whole thing is zeros, then we have a zero.\n    return [];\n};\nexports.minimallyEncode = minimallyEncode;\nconst OverflowInt64 = new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(63));\nconst OverflowUint64 = new BigNumber_js_1.default(2).pow(new BigNumber_js_1.default(64));\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/registry/RegistryClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/registry/RegistryClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeWalletProtocol = exports.RegistryClient = void 0;\nconst index_js_1 = __webpack_require__(/*! ../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\nconst index_js_3 = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js\");\nconst index_js_4 = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js\");\nconst index_js_5 = __webpack_require__(/*! ../script/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/index.js\");\nconst REGISTRANT_TOKEN_AMOUNT = 1;\n/**\n * RegistryClient manages on-chain registry definitions for three types:\n * - basket (basket-based items)\n * - protocol (protocol-based items)\n * - certificate (certificate-based items)\n *\n * It provides methods to:\n * - Register new definitions using pushdrop-based UTXOs.\n * - Resolve existing definitions using a lookup service.\n * - List registry entries associated with the operator's wallet.\n * - Revoke an existing registry entry by spending its UTXO.\n *\n * Registry operators use this client to establish and manage\n * canonical references for baskets, protocols, and certificate types.\n */\nclass RegistryClient {\n    constructor(wallet = new index_js_1.WalletClient()) {\n        this.wallet = wallet;\n    }\n    /**\n     * Publishes a new on-chain definition for baskets, protocols, or certificates.\n     * The definition data is encoded in a pushdrop-based UTXO.\n     *\n     * Registry operators (i.e., identity key owners) can create these definitions\n     * to establish canonical references for basket IDs, protocol specs, or certificate schemas.\n     *\n     * @param data - Structured information about a 'basket', 'protocol', or 'certificate'.\n     * @returns A promise with the broadcast result or failure.\n     */\n    async registerDefinition(data) {\n        const registryOperator = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;\n        const pushdrop = new index_js_5.PushDrop(this.wallet);\n        // Convert definition data into PushDrop fields\n        const fields = this.buildPushDropFields(data, registryOperator);\n        // Convert the user-friendly definitionType to the actual wallet protocol\n        const protocol = this.mapDefinitionTypeToWalletProtocol(data.definitionType);\n        // Lock the fields into a pushdrop-based UTXO\n        const lockingScript = await pushdrop.lock(fields, protocol, '1', 'anyone', true);\n        // Create a transaction\n        const { tx } = await this.wallet.createAction({\n            description: `Register a new ${data.definitionType} item`,\n            outputs: [\n                {\n                    satoshis: REGISTRANT_TOKEN_AMOUNT,\n                    lockingScript: lockingScript.toHex(),\n                    outputDescription: `New ${data.definitionType} registration token`,\n                    basket: this.mapDefinitionTypeToBasketName(data.definitionType)\n                }\n            ],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        if (tx === undefined) {\n            throw new Error(`Failed to create ${data.definitionType} registration transaction!`);\n        }\n        // Broadcast to the relevant topic\n        const broadcaster = new index_js_4.TopicBroadcaster([this.mapDefinitionTypeToTopic(data.definitionType)], {\n            networkPreset: this.network ?? (this.network = (await this.wallet.getNetwork({})).network)\n        });\n        return await broadcaster.broadcast(index_js_3.Transaction.fromAtomicBEEF(tx));\n    }\n    /**\n     * Resolves registrant tokens of a particular type using a lookup service.\n     *\n     * The query object shape depends on the registry type:\n     * - For \"basket\", the query is of type BasketMapQuery:\n     *   { basketID?: string; name?: string; registryOperators?: string[]; }\n     * - For \"protocol\", the query is of type ProtoMapQuery:\n     *   { name?: string; registryOperators?: string[]; protocolID?: WalletProtocol; }\n     * - For \"certificate\", the query is of type CertMapQuery:\n     *   { type?: string; name?: string; registryOperators?: string[]; }\n     *\n     * @param definitionType - The registry type, which can be 'basket', 'protocol', or 'certificate'.\n     * @param query - The query object used to filter registry records, whose shape is determined by the registry type.\n     * @returns A promise that resolves to an array of matching registry records.\n     */\n    async resolve(definitionType, query) {\n        const resolver = new index_js_4.LookupResolver();\n        const serviceName = this.mapDefinitionTypeToServiceName(definitionType);\n        // Make the lookup query\n        const result = await resolver.query({ service: serviceName, query });\n        if (result.type !== 'output-list') {\n            return [];\n        }\n        const parsedRegistryRecords = [];\n        for (const output of result.outputs) {\n            try {\n                const parsedTx = index_js_3.Transaction.fromBEEF(output.beef);\n                const lockingScript = parsedTx.outputs[output.outputIndex].lockingScript;\n                const record = await this.parseLockingScript(definitionType, lockingScript);\n                parsedRegistryRecords.push(record);\n            }\n            catch {\n                // Skip invalid or non-pushdrop outputs\n            }\n        }\n        return parsedRegistryRecords;\n    }\n    /**\n     * Lists the registry operator's published definitions for the given type.\n     *\n     * Returns parsed registry records including transaction details such as txid, outputIndex, satoshis, and the locking script.\n     *\n     * @param definitionType - The type of registry definition to list ('basket', 'protocol', or 'certificate').\n     * @returns A promise that resolves to an array of RegistryRecord objects.\n     */\n    async listOwnRegistryEntries(definitionType) {\n        const relevantBasketName = this.mapDefinitionTypeToBasketName(definitionType);\n        const { outputs, BEEF } = await this.wallet.listOutputs({\n            basket: relevantBasketName,\n            include: 'entire transactions'\n        });\n        const results = [];\n        for (const output of outputs) {\n            if (!output.spendable) {\n                continue;\n            }\n            try {\n                const [txid, outputIndex] = output.outpoint.split('.');\n                const tx = index_js_3.Transaction.fromBEEF(BEEF);\n                const lockingScript = tx.outputs[outputIndex].lockingScript;\n                const record = await this.parseLockingScript(definitionType, lockingScript);\n                results.push({\n                    ...record,\n                    txid,\n                    outputIndex: Number(outputIndex),\n                    satoshis: output.satoshis,\n                    lockingScript: lockingScript.toHex(),\n                    beef: BEEF\n                });\n            }\n            catch {\n                // Ignore parse errors\n            }\n        }\n        return results;\n    }\n    /**\n     * Revokes a registry record by spending its associated UTXO.\n     *\n     * @param registryRecord - Must have valid txid, outputIndex, and lockingScript.\n     * @returns Broadcast success/failure.\n     */\n    async revokeOwnRegistryEntry(registryRecord) {\n        if (registryRecord.txid === undefined || typeof registryRecord.outputIndex === 'undefined' || registryRecord.lockingScript === undefined) {\n            throw new Error('Invalid registry record. Missing txid, outputIndex, or lockingScript.');\n        }\n        // Check if the registry record belongs to the current user\n        const currentIdentityKey = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;\n        if (registryRecord.registryOperator !== currentIdentityKey) {\n            throw new Error('This registry token does not belong to the current wallet.');\n        }\n        // Create a descriptive label for the item were revoking\n        const itemIdentifier = registryRecord.definitionType === 'basket'\n            ? registryRecord.basketID\n            : registryRecord.definitionType === 'protocol'\n                ? registryRecord.name\n                : registryRecord.definitionType === 'certificate'\n                    ? (registryRecord.name !== undefined ? registryRecord.name : registryRecord.type)\n                    : 'unknown';\n        const outpoint = `${registryRecord.txid}.${registryRecord.outputIndex}`;\n        const { signableTransaction } = await this.wallet.createAction({\n            description: `Revoke ${registryRecord.definitionType} item: ${itemIdentifier}`,\n            inputBEEF: registryRecord.beef,\n            inputs: [\n                {\n                    outpoint,\n                    unlockingScriptLength: 73,\n                    inputDescription: `Revoking ${registryRecord.definitionType} token`\n                }\n            ]\n        });\n        if (signableTransaction === undefined) {\n            throw new Error('Failed to create signable transaction.');\n        }\n        const partialTx = index_js_3.Transaction.fromBEEF(signableTransaction.tx);\n        // Prepare the unlocker\n        const pushdrop = new index_js_5.PushDrop(this.wallet);\n        const unlocker = await pushdrop.unlock(this.mapDefinitionTypeToWalletProtocol(registryRecord.definitionType), '1', 'anyone', 'all', false, registryRecord.satoshis, index_js_5.LockingScript.fromHex(registryRecord.lockingScript));\n        // Convert to Transaction, apply signature\n        const finalUnlockScript = await unlocker.sign(partialTx, registryRecord.outputIndex);\n        // Complete signing with the final unlock script\n        const { tx: signedTx } = await this.wallet.signAction({\n            reference: signableTransaction.reference,\n            spends: {\n                [registryRecord.outputIndex]: {\n                    unlockingScript: finalUnlockScript.toHex()\n                }\n            },\n            options: {\n                acceptDelayedBroadcast: false\n            }\n        });\n        if (signedTx === undefined) {\n            throw new Error('Failed to finalize the transaction signature.');\n        }\n        // Broadcast\n        const broadcaster = new index_js_4.TopicBroadcaster([this.mapDefinitionTypeToTopic(registryRecord.definitionType)], {\n            networkPreset: this.network ?? (this.network = (await this.wallet.getNetwork({})).network)\n        });\n        return await broadcaster.broadcast(index_js_3.Transaction.fromAtomicBEEF(signedTx));\n    }\n    // --------------------------------------------------------------------------\n    // INTERNAL UTILITY METHODS\n    // --------------------------------------------------------------------------\n    /**\n     * Convert definition data into an array of pushdrop fields (strings).\n     * Each definition type has a slightly different shape.\n     */\n    buildPushDropFields(data, registryOperator) {\n        let fields;\n        switch (data.definitionType) {\n            case 'basket':\n                fields = [\n                    data.basketID,\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL\n                ];\n                break;\n            case 'protocol':\n                fields = [\n                    JSON.stringify(data.protocolID),\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL\n                ];\n                break;\n            case 'certificate':\n                fields = [\n                    data.type,\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL,\n                    JSON.stringify(data.fields)\n                ];\n                break;\n            default:\n                throw new Error('Unsupported definition type');\n        }\n        // Append the operator's public identity key last\n        fields.push(registryOperator);\n        return fields.map(field => index_js_2.Utils.toArray(field));\n    }\n    /**\n     * Decodes a pushdrop locking script for a given definition type,\n     * returning a typed record with the appropriate fields.\n     */\n    async parseLockingScript(definitionType, lockingScript) {\n        const decoded = index_js_5.PushDrop.decode(lockingScript);\n        if (decoded.fields.length === 0) {\n            throw new Error('Not a valid registry pushdrop script.');\n        }\n        let registryOperator;\n        let parsedData;\n        switch (definitionType) {\n            case 'basket': {\n                if (decoded.fields.length !== 7) {\n                    throw new Error('Unexpected field count for basket type.');\n                }\n                const [basketID, name, iconURL, description, docURL, operator] = decoded.fields;\n                registryOperator = index_js_2.Utils.toUTF8(operator);\n                parsedData = {\n                    definitionType: 'basket',\n                    basketID: index_js_2.Utils.toUTF8(basketID),\n                    name: index_js_2.Utils.toUTF8(name),\n                    iconURL: index_js_2.Utils.toUTF8(iconURL),\n                    description: index_js_2.Utils.toUTF8(description),\n                    documentationURL: index_js_2.Utils.toUTF8(docURL)\n                };\n                break;\n            }\n            case 'protocol': {\n                if (decoded.fields.length !== 7) {\n                    throw new Error('Unexpected field count for protocol type.');\n                }\n                const [protocolID, name, iconURL, description, docURL, operator] = decoded.fields;\n                registryOperator = index_js_2.Utils.toUTF8(operator);\n                parsedData = {\n                    definitionType: 'protocol',\n                    protocolID: deserializeWalletProtocol(index_js_2.Utils.toUTF8(protocolID)),\n                    name: index_js_2.Utils.toUTF8(name),\n                    iconURL: index_js_2.Utils.toUTF8(iconURL),\n                    description: index_js_2.Utils.toUTF8(description),\n                    documentationURL: index_js_2.Utils.toUTF8(docURL)\n                };\n                break;\n            }\n            case 'certificate': {\n                if (decoded.fields.length !== 8) {\n                    throw new Error('Unexpected field count for certificate type.');\n                }\n                const [certType, name, iconURL, description, docURL, fieldsJSON, operator] = decoded.fields;\n                registryOperator = index_js_2.Utils.toUTF8(operator);\n                let parsedFields = {};\n                try {\n                    parsedFields = JSON.parse(index_js_2.Utils.toUTF8(fieldsJSON));\n                }\n                catch {\n                    // If there's a JSON parse error, assume empty\n                }\n                parsedData = {\n                    definitionType: 'certificate',\n                    type: index_js_2.Utils.toUTF8(certType),\n                    name: index_js_2.Utils.toUTF8(name),\n                    iconURL: index_js_2.Utils.toUTF8(iconURL),\n                    description: index_js_2.Utils.toUTF8(description),\n                    documentationURL: index_js_2.Utils.toUTF8(docURL),\n                    fields: parsedFields\n                };\n                break;\n            }\n            default:\n                throw new Error(`Unsupported definition type: ${definitionType}`);\n        }\n        // Return the typed data plus the operator key\n        return { ...parsedData, registryOperator };\n    }\n    /**\n     * Convert our definitionType to the wallet protocol format ([protocolID, keyID]).\n     */\n    mapDefinitionTypeToWalletProtocol(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return [1, 'basketmap'];\n            case 'protocol':\n                return [1, 'protomap'];\n            case 'certificate':\n                return [1, 'certmap'];\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the basket name used by the wallet.\n     */\n    mapDefinitionTypeToBasketName(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'basketmap';\n            case 'protocol':\n                return 'protomap';\n            case 'certificate':\n                return 'certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the broadcast topic name.\n     */\n    mapDefinitionTypeToTopic(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'tm_basketmap';\n            case 'protocol':\n                return 'tm_protomap';\n            case 'certificate':\n                return 'tm_certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the lookup service name.\n     */\n    mapDefinitionTypeToServiceName(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'ls_basketmap';\n            case 'protocol':\n                return 'ls_protomap';\n            case 'certificate':\n                return 'ls_certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n}\nexports.RegistryClient = RegistryClient;\nfunction deserializeWalletProtocol(str) {\n    // Parse the JSON string back into a JavaScript value.\n    const parsed = JSON.parse(str);\n    // Validate that the parsed value is an array with exactly two elements.\n    if (!Array.isArray(parsed) || parsed.length !== 2) {\n        throw new Error('Invalid wallet protocol format.');\n    }\n    const [security, protocolString] = parsed;\n    // Validate that the security level is one of the allowed numbers.\n    if (![0, 1, 2].includes(security)) {\n        throw new Error('Invalid security level.');\n    }\n    // Validate that the protocol string is a string and its length is within the allowed bounds.\n    if (typeof protocolString !== 'string') {\n        throw new Error('Invalid protocolID');\n    }\n    return [security, protocolString];\n}\nexports.deserializeWalletProtocol = deserializeWalletProtocol;\n//# sourceMappingURL=RegistryClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/registry/RegistryClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/registry/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/registry/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./RegistryClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/registry/RegistryClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/registry/types/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/registry/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/registry/types/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/registry/types/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/registry/types/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Script_js_1 = __importDefault(__webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js\"));\n/**\n * The LockingScript class represents a locking script in a Bitcoin SV transaction.\n * It extends the Script class and is used specifically for output scripts that lock funds.\n *\n * Inherits all properties and methods from the Script class.\n *\n * @extends {Script}\n * @see {@link Script} for more information on Script.\n */\nclass LockingScript extends Script_js_1.default {\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns {boolean} Always returns true for a LockingScript instance.\n     */\n    isLockingScript() {\n        return true;\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns {boolean} Always returns false for a LockingScript instance.\n     */\n    isUnlockingScript() {\n        return false;\n    }\n}\nexports[\"default\"] = LockingScript;\n//# sourceMappingURL=LockingScript.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * An object mapping opcode names (such as OP_DUP) to their corresponding numbers (such as 0x76), and vice versa.\n */\nconst OP = {\n    // push value\n    OP_FALSE: 0x00,\n    OP_0: 0x00,\n    OP_PUSHDATA1: 0x4c,\n    OP_PUSHDATA2: 0x4d,\n    OP_PUSHDATA4: 0x4e,\n    OP_1NEGATE: 0x4f,\n    OP_RESERVED: 0x50,\n    OP_TRUE: 0x51,\n    OP_1: 0x51,\n    OP_2: 0x52,\n    OP_3: 0x53,\n    OP_4: 0x54,\n    OP_5: 0x55,\n    OP_6: 0x56,\n    OP_7: 0x57,\n    OP_8: 0x58,\n    OP_9: 0x59,\n    OP_10: 0x5a,\n    OP_11: 0x5b,\n    OP_12: 0x5c,\n    OP_13: 0x5d,\n    OP_14: 0x5e,\n    OP_15: 0x5f,\n    OP_16: 0x60,\n    // control\n    OP_NOP: 0x61,\n    OP_VER: 0x62,\n    OP_IF: 0x63,\n    OP_NOTIF: 0x64,\n    OP_VERIF: 0x65,\n    OP_VERNOTIF: 0x66,\n    OP_ELSE: 0x67,\n    OP_ENDIF: 0x68,\n    OP_VERIFY: 0x69,\n    OP_RETURN: 0x6a,\n    // stack ops\n    OP_TOALTSTACK: 0x6b,\n    OP_FROMALTSTACK: 0x6c,\n    OP_2DROP: 0x6d,\n    OP_2DUP: 0x6e,\n    OP_3DUP: 0x6f,\n    OP_2OVER: 0x70,\n    OP_2ROT: 0x71,\n    OP_2SWAP: 0x72,\n    OP_IFDUP: 0x73,\n    OP_DEPTH: 0x74,\n    OP_DROP: 0x75,\n    OP_DUP: 0x76,\n    OP_NIP: 0x77,\n    OP_OVER: 0x78,\n    OP_PICK: 0x79,\n    OP_ROLL: 0x7a,\n    OP_ROT: 0x7b,\n    OP_SWAP: 0x7c,\n    OP_TUCK: 0x7d,\n    // data manipulation ops\n    OP_CAT: 0x7e,\n    OP_SUBSTR: 0x7f,\n    OP_SPLIT: 0x7f,\n    OP_LEFT: 0x80,\n    OP_NUM2BIN: 0x80,\n    OP_RIGHT: 0x81,\n    OP_BIN2NUM: 0x81,\n    OP_SIZE: 0x82,\n    // bit logic\n    OP_INVERT: 0x83,\n    OP_AND: 0x84,\n    OP_OR: 0x85,\n    OP_XOR: 0x86,\n    OP_EQUAL: 0x87,\n    OP_EQUALVERIFY: 0x88,\n    OP_RESERVED1: 0x89,\n    OP_RESERVED2: 0x8a,\n    // numeric\n    OP_1ADD: 0x8b,\n    OP_1SUB: 0x8c,\n    OP_2MUL: 0x8d,\n    OP_2DIV: 0x8e,\n    OP_NEGATE: 0x8f,\n    OP_ABS: 0x90,\n    OP_NOT: 0x91,\n    OP_0NOTEQUAL: 0x92,\n    OP_ADD: 0x93,\n    OP_SUB: 0x94,\n    OP_MUL: 0x95,\n    OP_DIV: 0x96,\n    OP_MOD: 0x97,\n    OP_LSHIFT: 0x98,\n    OP_RSHIFT: 0x99,\n    OP_BOOLAND: 0x9a,\n    OP_BOOLOR: 0x9b,\n    OP_NUMEQUAL: 0x9c,\n    OP_NUMEQUALVERIFY: 0x9d,\n    OP_NUMNOTEQUAL: 0x9e,\n    OP_LESSTHAN: 0x9f,\n    OP_GREATERTHAN: 0xa0,\n    OP_LESSTHANOREQUAL: 0xa1,\n    OP_GREATERTHANOREQUAL: 0xa2,\n    OP_MIN: 0xa3,\n    OP_MAX: 0xa4,\n    OP_WITHIN: 0xa5,\n    // crypto\n    OP_RIPEMD160: 0xa6,\n    OP_SHA1: 0xa7,\n    OP_SHA256: 0xa8,\n    OP_HASH160: 0xa9,\n    OP_HASH256: 0xaa,\n    OP_CODESEPARATOR: 0xab,\n    OP_CHECKSIG: 0xac,\n    OP_CHECKSIGVERIFY: 0xad,\n    OP_CHECKMULTISIG: 0xae,\n    OP_CHECKMULTISIGVERIFY: 0xaf,\n    // expansion\n    OP_NOP1: 0xb0,\n    OP_NOP2: 0xb1,\n    OP_NOP3: 0xb2,\n    OP_NOP4: 0xb3,\n    OP_NOP5: 0xb4,\n    OP_NOP6: 0xb5,\n    OP_NOP7: 0xb6,\n    OP_NOP8: 0xb7,\n    OP_NOP9: 0xb8,\n    OP_NOP10: 0xb9,\n    OP_NOP11: 0xba,\n    OP_NOP12: 0xbb,\n    OP_NOP13: 0xbc,\n    OP_NOP14: 0xbd,\n    OP_NOP15: 0xbe,\n    OP_NOP16: 0xbf,\n    OP_NOP17: 0xc0,\n    OP_NOP18: 0xc1,\n    OP_NOP19: 0xc2,\n    OP_NOP20: 0xc3,\n    OP_NOP21: 0xc4,\n    OP_NOP22: 0xc5,\n    OP_NOP23: 0xc6,\n    OP_NOP24: 0xc7,\n    OP_NOP25: 0xc8,\n    OP_NOP26: 0xc9,\n    OP_NOP27: 0xca,\n    OP_NOP28: 0xcb,\n    OP_NOP29: 0xcc,\n    OP_NOP30: 0xcd,\n    OP_NOP31: 0xce,\n    OP_NOP32: 0xcf,\n    OP_NOP33: 0xd0,\n    OP_NOP34: 0xd1,\n    OP_NOP35: 0xd2,\n    OP_NOP36: 0xd3,\n    OP_NOP37: 0xd4,\n    OP_NOP38: 0xd5,\n    OP_NOP39: 0xd6,\n    OP_NOP40: 0xd7,\n    OP_NOP41: 0xd8,\n    OP_NOP42: 0xd9,\n    OP_NOP43: 0xda,\n    OP_NOP44: 0xdb,\n    OP_NOP45: 0xdc,\n    OP_NOP46: 0xdd,\n    OP_NOP47: 0xde,\n    OP_NOP48: 0xdf,\n    OP_NOP49: 0xe0,\n    OP_NOP50: 0xe1,\n    OP_NOP51: 0xe2,\n    OP_NOP52: 0xe3,\n    OP_NOP53: 0xe4,\n    OP_NOP54: 0xe5,\n    OP_NOP55: 0xe6,\n    OP_NOP56: 0xe7,\n    OP_NOP57: 0xe8,\n    OP_NOP58: 0xe9,\n    OP_NOP59: 0xea,\n    OP_NOP60: 0xeb,\n    OP_NOP61: 0xec,\n    OP_NOP62: 0xed,\n    OP_NOP63: 0xee,\n    OP_NOP64: 0xef,\n    OP_NOP65: 0xf0,\n    OP_NOP66: 0xf1,\n    OP_NOP67: 0xf2,\n    OP_NOP68: 0xf3,\n    OP_NOP69: 0xf4,\n    OP_NOP70: 0xf5,\n    OP_NOP71: 0xf6,\n    OP_NOP72: 0xf7,\n    OP_NOP73: 0xf8,\n    OP_NOP77: 0xfc,\n    // template matching params\n    OP_SMALLDATA: 0xf9,\n    OP_SMALLINTEGER: 0xfa,\n    OP_PUBKEYS: 0xfb,\n    OP_PUBKEYHASH: 0xfd,\n    OP_PUBKEY: 0xfe,\n    OP_INVALIDOPCODE: 0xff\n};\nfor (const name in OP) {\n    OP[OP[name]] = name;\n}\nexports[\"default\"] = OP;\n//# sourceMappingURL=OP.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst OP_js_1 = __importDefault(__webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\n/**\n * The Script class represents a script in a Bitcoin SV transaction,\n * encapsulating the functionality to construct, parse, and serialize\n * scripts used in both locking (output) and unlocking (input) scripts.\n *\n * @property {ScriptChunk[]} chunks - An array of script chunks that make up the script.\n */\nclass Script {\n    /**\n     * @method fromASM\n     * Static method to construct a Script instance from an ASM (Assembly) formatted string.\n     * @param asm - The script in ASM string format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromASM(\"OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG\")\n     */\n    static fromASM(asm) {\n        const chunks = [];\n        const tokens = asm.split(' ');\n        let i = 0;\n        while (i < tokens.length) {\n            const token = tokens[i];\n            let opCode;\n            let opCodeNum = 0;\n            if (token.startsWith('OP_') && typeof OP_js_1.default[token] !== 'undefined') {\n                opCode = token;\n                opCodeNum = OP_js_1.default[token];\n            }\n            // we start with two special cases, 0 and -1, which are handled specially in\n            // toASM. see _chunkToString.\n            if (token === '0') {\n                opCodeNum = 0;\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (token === '-1') {\n                opCodeNum = OP_js_1.default.OP_1NEGATE;\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (opCode === undefined) {\n                let hex = tokens[i];\n                if (hex.length % 2 !== 0) {\n                    hex = '0' + hex;\n                }\n                const arr = (0, utils_js_1.toArray)(hex, 'hex');\n                if ((0, utils_js_1.encode)(arr, 'hex') !== hex) {\n                    throw new Error('invalid hex string in script');\n                }\n                const len = arr.length;\n                if (len >= 0 && len < OP_js_1.default.OP_PUSHDATA1) {\n                    opCodeNum = len;\n                }\n                else if (len < Math.pow(2, 8)) {\n                    opCodeNum = OP_js_1.default.OP_PUSHDATA1;\n                }\n                else if (len < Math.pow(2, 16)) {\n                    opCodeNum = OP_js_1.default.OP_PUSHDATA2;\n                }\n                else if (len < Math.pow(2, 32)) {\n                    opCodeNum = OP_js_1.default.OP_PUSHDATA4;\n                }\n                chunks.push({\n                    data: arr,\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (opCodeNum === OP_js_1.default.OP_PUSHDATA1 ||\n                opCodeNum === OP_js_1.default.OP_PUSHDATA2 ||\n                opCodeNum === OP_js_1.default.OP_PUSHDATA4) {\n                chunks.push({\n                    data: (0, utils_js_1.toArray)(tokens[i + 2], 'hex'),\n                    op: opCodeNum\n                });\n                i = i + 3;\n            }\n            else {\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n        }\n        return new Script(chunks);\n    }\n    /**\n     * @method fromHex\n     * Static method to construct a Script instance from a hexadecimal string.\n     * @param hex - The script in hexadecimal format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromHex(\"76a9...\");\n     */\n    static fromHex(hex) {\n        if (hex.length === 0)\n            return Script.fromBinary([]);\n        if (hex.length % 2 !== 0) {\n            throw new Error('There is an uneven number of characters in the string which suggests it is not hex encoded.');\n        }\n        if (!/^[0-9a-fA-F]+$/.test(hex)) {\n            throw new Error('Some elements in this string are not hex encoded.');\n        }\n        return Script.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));\n    }\n    /**\n     * @method fromBinary\n     * Static method to construct a Script instance from a binary array.\n     * @param bin - The script in binary array format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromBinary([0x76, 0xa9, ...])\n     */\n    static fromBinary(bin) {\n        bin = [...bin];\n        const chunks = [];\n        let inConditionalBlock = 0;\n        const br = new utils_js_1.Reader(bin);\n        while (!br.eof()) {\n            const op = br.readUInt8();\n            // if OP_RETURN and not in a conditional block, do not parse the rest of the data,\n            // rather just return the last chunk as data without prefixing with data length.\n            if (op === OP_js_1.default.OP_RETURN && inConditionalBlock === 0) {\n                chunks.push({\n                    op,\n                    data: br.read()\n                });\n                break;\n            }\n            if (op === OP_js_1.default.OP_IF || op === OP_js_1.default.OP_NOTIF || op === OP_js_1.default.OP_VERIF || op === OP_js_1.default.OP_VERNOTIF) {\n                inConditionalBlock++;\n            }\n            else if (op === OP_js_1.default.OP_ENDIF) {\n                inConditionalBlock--;\n            }\n            let len = 0;\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            let data = [];\n            if (op > 0 && op < OP_js_1.default.OP_PUSHDATA1) {\n                len = op;\n                chunks.push({\n                    data: br.read(len),\n                    op\n                });\n            }\n            else if (op === OP_js_1.default.OP_PUSHDATA1) {\n                try {\n                    len = br.readUInt8();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else if (op === OP_js_1.default.OP_PUSHDATA2) {\n                try {\n                    len = br.readUInt16LE();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else if (op === OP_js_1.default.OP_PUSHDATA4) {\n                try {\n                    len = br.readUInt32LE();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else {\n                chunks.push({\n                    op\n                });\n            }\n        }\n        return new Script(chunks);\n    }\n    /**\n     * @constructor\n     * Constructs a new Script object.\n     * @param chunks=[] - An array of script chunks to directly initialize the script.\n     */\n    constructor(chunks = []) {\n        this.chunks = chunks;\n    }\n    /**\n     * @method toASM\n     * Serializes the script to an ASM formatted string.\n     * @returns The script in ASM string format.\n     */\n    toASM() {\n        let str = '';\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            str += this._chunkToString(chunk);\n        }\n        return str.slice(1);\n    }\n    /**\n     * @method toHex\n     * Serializes the script to a hexadecimal string.\n     * @returns The script in hexadecimal format.\n     */\n    toHex() {\n        return (0, utils_js_1.encode)(this.toBinary(), 'hex');\n    }\n    /**\n     * @method toBinary\n     * Serializes the script to a binary array.\n     * @returns The script in binary array format.\n     */\n    toBinary() {\n        const writer = new utils_js_1.Writer();\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            const op = chunk.op;\n            writer.writeUInt8(op);\n            if (op === OP_js_1.default.OP_RETURN && chunk.data != null) { // special case for unformatted data\n                writer.write(chunk.data);\n                break;\n            }\n            else if (chunk.data != null) {\n                if (op < OP_js_1.default.OP_PUSHDATA1) {\n                    writer.write(chunk.data);\n                }\n                else if (op === OP_js_1.default.OP_PUSHDATA1) {\n                    writer.writeUInt8(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n                else if (op === OP_js_1.default.OP_PUSHDATA2) {\n                    writer.writeUInt16LE(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n                else if (op === OP_js_1.default.OP_PUSHDATA4) {\n                    writer.writeUInt32LE(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * @method writeScript\n     * Appends another script to this script.\n     * @param script - The script to append.\n     * @returns This script instance for chaining.\n     */\n    writeScript(script) {\n        this.chunks = this.chunks.concat(script.chunks);\n        return this;\n    }\n    /**\n     * @method writeOpCode\n     * Appends an opcode to the script.\n     * @param op - The opcode to append.\n     * @returns This script instance for chaining.\n     */\n    writeOpCode(op) {\n        this.chunks.push({ op });\n        return this;\n    }\n    /**\n     * @method setChunkOpCode\n     * Sets the opcode of a specific chunk in the script.\n     * @param i - The index of the chunk.\n     * @param op - The opcode to set.\n     * @returns This script instance for chaining.\n     */\n    setChunkOpCode(i, op) {\n        this.chunks[i] = { op };\n        return this;\n    }\n    /**\n     * @method writeBn\n     * Appends a BigNumber to the script as an opcode.\n     * @param bn - The BigNumber to append.\n     * @returns This script instance for chaining.\n     */\n    writeBn(bn) {\n        if (bn.cmpn(0) === OP_js_1.default.OP_0) {\n            this.chunks.push({\n                op: OP_js_1.default.OP_0\n            });\n        }\n        else if (bn.cmpn(-1) === 0) {\n            this.chunks.push({\n                op: OP_js_1.default.OP_1NEGATE\n            });\n        }\n        else if (bn.cmpn(1) >= 0 && bn.cmpn(16) <= 0) {\n            // see OP_1 - OP_16\n            this.chunks.push({\n                op: bn.toNumber() + OP_js_1.default.OP_1 - 1\n            });\n        }\n        else {\n            const buf = bn.toSm('little');\n            this.writeBin(buf);\n        }\n        return this;\n    }\n    /**\n     * @method writeBin\n     * Appends binary data to the script, determining the appropriate opcode based on length.\n     * @param bin - The binary data to append.\n     * @returns This script instance for chaining.\n     * @throws {Error} Throws an error if the data is too large to be pushed.\n     */\n    writeBin(bin) {\n        let op;\n        if (bin.length > 0 && bin.length < OP_js_1.default.OP_PUSHDATA1) {\n            op = bin.length;\n        }\n        else if (bin.length === 0) {\n            op = OP_js_1.default.OP_0;\n        }\n        else if (bin.length < Math.pow(2, 8)) {\n            op = OP_js_1.default.OP_PUSHDATA1;\n        }\n        else if (bin.length < Math.pow(2, 16)) {\n            op = OP_js_1.default.OP_PUSHDATA2;\n        }\n        else if (bin.length < Math.pow(2, 32)) {\n            op = OP_js_1.default.OP_PUSHDATA4;\n        }\n        else {\n            throw new Error(\"You can't push that much data\");\n        }\n        this.chunks.push({\n            data: bin,\n            op\n        });\n        return this;\n    }\n    /**\n     * @method writeNumber\n     * Appends a number to the script.\n     * @param num - The number to append.\n     * @returns This script instance for chaining.\n     */\n    writeNumber(num) {\n        this.writeBn(new BigNumber_js_1.default(num));\n        return this;\n    }\n    /**\n     * @method removeCodeseparators\n     * Removes all OP_CODESEPARATOR opcodes from the script.\n     * @returns This script instance for chaining.\n     */\n    removeCodeseparators() {\n        const chunks = [];\n        for (let i = 0; i < this.chunks.length; i++) {\n            if (this.chunks[i].op !== OP_js_1.default.OP_CODESEPARATOR) {\n                chunks.push(this.chunks[i]);\n            }\n        }\n        this.chunks = chunks;\n        return this;\n    }\n    /**\n     * Deletes the given item wherever it appears in the current script.\n     *\n     * @param script - The script containing the item to delete from the current script.\n     *\n     * @returns This script instance for chaining.\n     */\n    findAndDelete(script) {\n        const buf = script.toHex();\n        for (let i = 0; i < this.chunks.length; i++) {\n            const script2 = new Script([this.chunks[i]]);\n            const buf2 = script2.toHex();\n            if (buf === buf2) {\n                this.chunks.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * @method isPushOnly\n     * Checks if the script contains only push data operations.\n     * @returns True if the script is push-only, otherwise false.\n     */\n    isPushOnly() {\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            const opCodeNum = chunk.op;\n            if (opCodeNum > OP_js_1.default.OP_16) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns True if the script is a locking script, otherwise false.\n     */\n    isLockingScript() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns True if the script is an unlocking script, otherwise false.\n     */\n    isUnlockingScript() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * @private\n     * @method _chunkToString\n     * Converts a script chunk to its string representation.\n     * @param chunk - The script chunk.\n     * @returns The string representation of the chunk.\n     */\n    _chunkToString(chunk) {\n        const op = chunk.op;\n        let str = '';\n        if (typeof chunk.data === 'undefined') {\n            const val = OP_js_1.default[op];\n            str = `${str} ${val}`;\n        }\n        else {\n            str = `${str} ${(0, utils_js_1.toHex)(chunk.data)}`;\n        }\n        return str;\n    }\n}\nexports[\"default\"] = Script;\n//# sourceMappingURL=Script.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/ScriptEvaluationError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/ScriptEvaluationError.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nclass ScriptEvaluationError extends Error {\n    constructor(params) {\n        const stackHex = params.stackState.map(s => s != null && typeof s.length !== 'undefined' ? (0, utils_js_1.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');\n        const altStackHex = params.altStackState.map(s => s != null && typeof s.length !== 'undefined' ? (0, utils_js_1.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');\n        const pcInfo = `Context: ${params.context}, PC: ${params.programCounter}`;\n        const stackInfo = `Stack: [${stackHex}] (len: ${params.stackState.length}, mem: ${params.stackMem})`;\n        const altStackInfo = `AltStack: [${altStackHex}] (len: ${params.altStackState.length}, mem: ${params.altStackMem})`;\n        const ifStackInfo = `IfStack: [${params.ifStackState.join(', ')}]`;\n        const fullMessage = `Script evaluation error: ${params.message}\\nTXID: ${params.txid}, OutputIdx: ${params.outputIndex}\\n${pcInfo}\\n${stackInfo}\\n${altStackInfo}\\n${ifStackInfo}`;\n        super(fullMessage);\n        this.name = this.constructor.name;\n        this.txid = params.txid;\n        this.outputIndex = params.outputIndex;\n        this.context = params.context;\n        this.programCounter = params.programCounter;\n        this.stackState = params.stackState.map(s => s.slice());\n        this.altStackState = params.altStackState.map(s => s.slice());\n        this.ifStackState = params.ifStackState.slice();\n        this.stackMem = params.stackMem;\n        this.altStackMem = params.altStackMem;\n    }\n}\nexports[\"default\"] = ScriptEvaluationError;\n//# sourceMappingURL=ScriptEvaluationError.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/ScriptEvaluationError.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/Spend.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/Spend.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Script_js_1 = __importDefault(__webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js\"));\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\nconst OP_js_1 = __importDefault(__webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst ScriptEvaluationError_js_1 = __importDefault(__webpack_require__(/*! ./ScriptEvaluationError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/ScriptEvaluationError.js\"));\nconst Hash = __importStar(__webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\"));\nconst TransactionSignature_js_1 = __importDefault(__webpack_require__(/*! ../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js\"));\nconst PublicKey_js_1 = __importDefault(__webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PublicKey.js\"));\nconst ECDSA_js_1 = __webpack_require__(/*! ../primitives/ECDSA.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/ECDSA.js\");\n// These constants control the current behavior of the interpreter.\nconst maxScriptElementSize = 1024 * 1024 * 1024;\nconst maxMultisigKeyCount = Math.pow(2, 31) - 1;\nconst requireMinimalPush = true;\nconst requirePushOnlyUnlockingScripts = true;\nconst requireLowSSignatures = true;\nconst requireCleanStack = true;\n// --- Optimization: Pre-computed script numbers ---\nconst SCRIPTNUM_NEG_1 = Object.freeze(new BigNumber_js_1.default(-1).toScriptNum());\nconst SCRIPTNUMS_0_TO_16 = Object.freeze(Array.from({ length: 17 }, (_, i) => Object.freeze(new BigNumber_js_1.default(i).toScriptNum())));\n// --- Helper functions ---\nfunction compareNumberArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\nfunction isMinimallyEncodedHelper(buf, maxNumSize = Number.MAX_SAFE_INTEGER) {\n    if (buf.length > maxNumSize) {\n        return false;\n    }\n    if (buf.length > 0) {\n        if ((buf[buf.length - 1] & 0x7f) === 0) {\n            if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction isChecksigFormatHelper(buf) {\n    // This is a simplified check. The full DER check is more complex and typically\n    // done by TransactionSignature.fromChecksigFormat which can throw.\n    // This helper is mostly for early bailout or non-throwing checks if needed.\n    if (buf.length < 9 || buf.length > 73)\n        return false;\n    if (buf[0] !== 0x30)\n        return false; // DER SEQUENCE\n    if (buf[1] !== buf.length - 3)\n        return false; // Total length (excluding type and length byte for sequence, and hash type)\n    const rMarker = buf[2];\n    const rLen = buf[3];\n    if (rMarker !== 0x02)\n        return false; // DER INTEGER\n    if (rLen === 0)\n        return false; // R length is zero\n    if (5 + rLen >= buf.length)\n        return false; // S length misplaced or R too long\n    const sMarkerOffset = 4 + rLen;\n    const sMarker = buf[sMarkerOffset];\n    const sLen = buf[sMarkerOffset + 1];\n    if (sMarker !== 0x02)\n        return false; // DER INTEGER\n    if (sLen === 0)\n        return false; // S length is zero\n    // Check R value negative or excessively padded\n    if ((buf[4] & 0x80) !== 0)\n        return false; // R value negative\n    if (rLen > 1 && buf[4] === 0x00 && (buf[5] & 0x80) === 0)\n        return false; // R value excessively padded\n    // Check S value negative or excessively padded\n    const sValueOffset = sMarkerOffset + 2;\n    if ((buf[sValueOffset] & 0x80) !== 0)\n        return false; // S value negative\n    if (sLen > 1 && buf[sValueOffset] === 0x00 && (buf[sValueOffset + 1] & 0x80) === 0)\n        return false; // S value excessively padded\n    if (rLen + sLen + 7 !== buf.length)\n        return false; // Final length check including hash type\n    return true;\n}\nfunction isOpcodeDisabledHelper(op) {\n    return (op === OP_js_1.default.OP_2MUL ||\n        op === OP_js_1.default.OP_2DIV ||\n        op === OP_js_1.default.OP_VERIF ||\n        op === OP_js_1.default.OP_VERNOTIF ||\n        op === OP_js_1.default.OP_VER);\n}\nfunction isChunkMinimalPushHelper(chunk) {\n    const data = chunk.data;\n    const op = chunk.op;\n    if (!Array.isArray(data))\n        return true;\n    if (data.length === 0)\n        return op === OP_js_1.default.OP_0;\n    if (data.length === 1 && data[0] >= 1 && data[0] <= 16)\n        return op === OP_js_1.default.OP_1 + (data[0] - 1);\n    if (data.length === 1 && data[0] === 0x81)\n        return op === OP_js_1.default.OP_1NEGATE;\n    if (data.length <= 75)\n        return op === data.length;\n    if (data.length <= 255)\n        return op === OP_js_1.default.OP_PUSHDATA1;\n    if (data.length <= 65535)\n        return op === OP_js_1.default.OP_PUSHDATA2;\n    return true;\n}\n/**\n * The Spend class represents a spend action within a Bitcoin SV transaction.\n * It encapsulates all the necessary data required for spending a UTXO (Unspent Transaction Output)\n * and includes details about the source transaction, output, and the spending transaction itself.\n *\n * @property {string} sourceTXID - The transaction ID of the source UTXO.\n * @property {number} sourceOutputIndex - The index of the output in the source transaction.\n * @property {BigNumber} sourceSatoshis - The amount of satoshis in the source UTXO.\n * @property {LockingScript} lockingScript - The locking script associated with the UTXO.\n * @property {number} transactionVersion - The version of the current transaction.\n * @property {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} otherInputs -\n *           An array of other inputs in the transaction, each with a txid, outputIndex, and sequence number.\n * @property {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} outputs -\n *           An array of outputs of the current transaction, including the satoshi value and locking script for each.\n * @property {number} inputIndex - The index of this input in the current transaction.\n * @property {UnlockingScript} unlockingScript - The unlocking script that unlocks the UTXO for spending.\n * @property {number} inputSequence - The sequence number of this input.\n * @property {number} lockTime - The lock time of the transaction.\n */\nclass Spend {\n    /**\n     * @constructor\n     * Constructs the Spend object with necessary transaction details.\n     * @param {string} params.sourceTXID - The transaction ID of the source UTXO.\n     * @param {number} params.sourceOutputIndex - The index of the output in the source transaction.\n     * @param {BigNumber} params.sourceSatoshis - The amount of satoshis in the source UTXO.\n     * @param {LockingScript} params.lockingScript - The locking script associated with the UTXO.\n     * @param {number} params.transactionVersion - The version of the current transaction.\n     * @param {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} params.otherInputs -\n     *        An array of other inputs in the transaction.\n     * @param {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} params.outputs -\n     *        The outputs of the current transaction.\n     * @param {number} params.inputIndex - The index of this input in the current transaction.\n     * @param {UnlockingScript} params.unlockingScript - The unlocking script for this spend.\n     * @param {number} params.inputSequence - The sequence number of this input.\n     * @param {number} params.lockTime - The lock time of the transaction.\n     *\n     * @example\n     * const spend = new Spend({\n     *   sourceTXID: \"abcd1234\", // sourceTXID\n     *   sourceOutputIndex: 0, // sourceOutputIndex\n     *   sourceSatoshis: new BigNumber(1000), // sourceSatoshis\n     *   lockingScript: LockingScript.fromASM(\"OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG\"),\n     *   transactionVersion: 1, // transactionVersion\n     *   otherInputs: [{ sourceTXID: \"abcd1234\", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs\n     *   outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM(\"OP_DUP...\") }], // outputs\n     *   inputIndex: 0, // inputIndex\n     *   unlockingScript: UnlockingScript.fromASM(\"3045... 02ab...\"),\n     *   inputSequence: 0xffffffff // inputSequence\n     *   memoryLimit: 100000 // memoryLimit\n     * });\n     */\n    constructor(params) {\n        this.sourceTXID = params.sourceTXID;\n        this.sourceOutputIndex = params.sourceOutputIndex;\n        this.sourceSatoshis = params.sourceSatoshis;\n        this.lockingScript = params.lockingScript;\n        this.transactionVersion = params.transactionVersion;\n        this.otherInputs = params.otherInputs;\n        this.outputs = params.outputs;\n        this.inputIndex = params.inputIndex;\n        this.unlockingScript = params.unlockingScript;\n        this.inputSequence = params.inputSequence;\n        this.lockTime = params.lockTime;\n        this.memoryLimit = params.memoryLimit ?? 32000000;\n        this.stack = [];\n        this.altStack = [];\n        this.ifStack = [];\n        this.stackMem = 0;\n        this.altStackMem = 0;\n        this.reset();\n    }\n    reset() {\n        this.context = 'UnlockingScript';\n        this.programCounter = 0;\n        this.lastCodeSeparator = null;\n        this.stack = [];\n        this.altStack = [];\n        this.ifStack = [];\n        this.stackMem = 0;\n        this.altStackMem = 0;\n    }\n    ensureStackMem(additional) {\n        if (this.stackMem + additional > this.memoryLimit) {\n            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n        }\n    }\n    ensureAltStackMem(additional) {\n        if (this.altStackMem + additional > this.memoryLimit) {\n            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n        }\n    }\n    pushStack(item) {\n        this.ensureStackMem(item.length);\n        this.stack.push(item);\n        this.stackMem += item.length;\n    }\n    pushStackCopy(item) {\n        this.ensureStackMem(item.length);\n        const copy = item.slice();\n        this.stack.push(copy);\n        this.stackMem += copy.length;\n    }\n    popStack() {\n        if (this.stack.length === 0) {\n            this.scriptEvaluationError('Attempted to pop from an empty stack.');\n        }\n        const item = this.stack.pop();\n        this.stackMem -= item.length;\n        return item;\n    }\n    stackTop(index = -1) {\n        // index = -1 for top, -2 for second top, etc.\n        // stack.length + index provides 0-based index from start\n        if (this.stack.length === 0 || this.stack.length < Math.abs(index) || (index >= 0 && index >= this.stack.length)) {\n            this.scriptEvaluationError(`Stack underflow accessing element at index ${index}. Stack length is ${this.stack.length}.`);\n        }\n        return this.stack[this.stack.length + index];\n    }\n    pushAltStack(item) {\n        this.ensureAltStackMem(item.length);\n        this.altStack.push(item);\n        this.altStackMem += item.length;\n    }\n    popAltStack() {\n        if (this.altStack.length === 0) {\n            this.scriptEvaluationError('Attempted to pop from an empty alt stack.');\n        }\n        const item = this.altStack.pop();\n        this.altStackMem -= item.length;\n        return item;\n    }\n    checkSignatureEncoding(buf) {\n        if (buf.length === 0)\n            return true;\n        if (!isChecksigFormatHelper(buf)) {\n            this.scriptEvaluationError('The signature format is invalid.'); // Generic message like original\n            return false;\n        }\n        try {\n            const sig = TransactionSignature_js_1.default.fromChecksigFormat(buf); // This can throw for stricter DER rules\n            if (requireLowSSignatures && !sig.hasLowS()) {\n                this.scriptEvaluationError('The signature must have a low S value.');\n                return false;\n            }\n            if ((sig.scope & TransactionSignature_js_1.default.SIGHASH_FORKID) === 0) {\n                this.scriptEvaluationError('The signature must use SIGHASH_FORKID.');\n                return false;\n            }\n        }\n        catch (e) {\n            this.scriptEvaluationError('The signature format is invalid.');\n            return false;\n        }\n        return true;\n    }\n    checkPublicKeyEncoding(buf) {\n        if (buf.length === 0) {\n            this.scriptEvaluationError('Public key is empty.');\n            return false;\n        }\n        if (buf.length < 33) {\n            this.scriptEvaluationError('The public key is too short, it must be at least 33 bytes.');\n            return false;\n        }\n        if (buf[0] === 0x04) {\n            if (buf.length !== 65) {\n                this.scriptEvaluationError('The non-compressed public key must be 65 bytes.');\n                return false;\n            }\n        }\n        else if (buf[0] === 0x02 || buf[0] === 0x03) {\n            if (buf.length !== 33) {\n                this.scriptEvaluationError('The compressed public key must be 33 bytes.');\n                return false;\n            }\n        }\n        else {\n            this.scriptEvaluationError('The public key is in an unknown format.');\n            return false;\n        }\n        try {\n            PublicKey_js_1.default.fromDER(buf); // This can throw for stricter DER rules\n        }\n        catch (e) {\n            this.scriptEvaluationError('The public key is in an unknown format.');\n            return false;\n        }\n        return true;\n    }\n    verifySignature(sig, pubkey, subscript) {\n        const preimage = TransactionSignature_js_1.default.format({\n            sourceTXID: this.sourceTXID,\n            sourceOutputIndex: this.sourceOutputIndex,\n            sourceSatoshis: this.sourceSatoshis,\n            transactionVersion: this.transactionVersion,\n            otherInputs: this.otherInputs,\n            outputs: this.outputs,\n            inputIndex: this.inputIndex,\n            subscript,\n            inputSequence: this.inputSequence,\n            lockTime: this.lockTime,\n            scope: sig.scope\n        });\n        const hash = new BigNumber_js_1.default(Hash.hash256(preimage));\n        return (0, ECDSA_js_1.verify)(hash, sig, pubkey);\n    }\n    step() {\n        if (this.stackMem > this.memoryLimit) {\n            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n            return false; // Error thrown\n        }\n        if (this.altStackMem > this.memoryLimit) {\n            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n            return false; // Error thrown\n        }\n        if (this.context === 'UnlockingScript' &&\n            this.programCounter >= this.unlockingScript.chunks.length) {\n            this.context = 'LockingScript';\n            this.programCounter = 0;\n        }\n        const currentScript = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n        if (this.programCounter >= currentScript.chunks.length) {\n            return false;\n        }\n        const operation = currentScript.chunks[this.programCounter];\n        const currentOpcode = operation.op;\n        if (typeof currentOpcode === 'undefined') {\n            this.scriptEvaluationError(`Missing opcode in ${this.context} at pc=${this.programCounter}.`); // Error thrown\n        }\n        if (Array.isArray(operation.data) && operation.data.length > maxScriptElementSize) {\n            this.scriptEvaluationError(`Data push > ${maxScriptElementSize} bytes (pc=${this.programCounter}).`); // Error thrown\n        }\n        const isScriptExecuting = !this.ifStack.includes(false);\n        if (isScriptExecuting && isOpcodeDisabledHelper(currentOpcode)) {\n            this.scriptEvaluationError(`This opcode is currently disabled. (Opcode: ${OP_js_1.default[currentOpcode]}, PC: ${this.programCounter})`); // Error thrown\n        }\n        if (isScriptExecuting && currentOpcode >= 0 && currentOpcode <= OP_js_1.default.OP_PUSHDATA4) {\n            if (requireMinimalPush && !isChunkMinimalPushHelper(operation)) {\n                this.scriptEvaluationError(`This data is not minimally-encoded. (PC: ${this.programCounter})`); // Error thrown\n            }\n            this.pushStack(Array.isArray(operation.data) ? operation.data : []);\n        }\n        else if (isScriptExecuting || (currentOpcode >= OP_js_1.default.OP_IF && currentOpcode <= OP_js_1.default.OP_ENDIF)) {\n            let buf, buf1, buf2, buf3;\n            let x1, x2, x3;\n            let bn, bn1, bn2, bn3;\n            let n, size, fValue, fSuccess, subscript;\n            let bufSig, bufPubkey;\n            let sig, pubkey;\n            let i, ikey, isig, nKeysCount, nSigsCount, fOk;\n            switch (currentOpcode) {\n                case OP_js_1.default.OP_1NEGATE:\n                    this.pushStackCopy(SCRIPTNUM_NEG_1);\n                    break;\n                case OP_js_1.default.OP_0:\n                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[0]);\n                    break;\n                case OP_js_1.default.OP_1:\n                case OP_js_1.default.OP_2:\n                case OP_js_1.default.OP_3:\n                case OP_js_1.default.OP_4:\n                case OP_js_1.default.OP_5:\n                case OP_js_1.default.OP_6:\n                case OP_js_1.default.OP_7:\n                case OP_js_1.default.OP_8:\n                case OP_js_1.default.OP_9:\n                case OP_js_1.default.OP_10:\n                case OP_js_1.default.OP_11:\n                case OP_js_1.default.OP_12:\n                case OP_js_1.default.OP_13:\n                case OP_js_1.default.OP_14:\n                case OP_js_1.default.OP_15:\n                case OP_js_1.default.OP_16:\n                    n = currentOpcode - (OP_js_1.default.OP_1 - 1);\n                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[n]);\n                    break;\n                case OP_js_1.default.OP_NOP:\n                case OP_js_1.default.OP_NOP2: // Formerly CHECKLOCKTIMEVERIFY\n                case OP_js_1.default.OP_NOP3: // Formerly CHECKSEQUENCEVERIFY\n                case OP_js_1.default.OP_NOP1:\n                case OP_js_1.default.OP_NOP4:\n                case OP_js_1.default.OP_NOP5:\n                case OP_js_1.default.OP_NOP6:\n                case OP_js_1.default.OP_NOP7:\n                case OP_js_1.default.OP_NOP8:\n                case OP_js_1.default.OP_NOP9:\n                case OP_js_1.default.OP_NOP10:\n                /* falls through */\n                // eslint-disable-next-line no-fallthrough\n                // eslint-disable-next-line no-fallthrough\n                case OP_js_1.default.OP_NOP11:\n                case OP_js_1.default.OP_NOP12:\n                case OP_js_1.default.OP_NOP13:\n                case OP_js_1.default.OP_NOP14:\n                case OP_js_1.default.OP_NOP15:\n                case OP_js_1.default.OP_NOP16:\n                case OP_js_1.default.OP_NOP17:\n                case OP_js_1.default.OP_NOP18:\n                case OP_js_1.default.OP_NOP19:\n                case OP_js_1.default.OP_NOP20:\n                case OP_js_1.default.OP_NOP21:\n                case OP_js_1.default.OP_NOP22:\n                case OP_js_1.default.OP_NOP23:\n                case OP_js_1.default.OP_NOP24:\n                case OP_js_1.default.OP_NOP25:\n                case OP_js_1.default.OP_NOP26:\n                case OP_js_1.default.OP_NOP27:\n                case OP_js_1.default.OP_NOP28:\n                case OP_js_1.default.OP_NOP29:\n                case OP_js_1.default.OP_NOP30:\n                case OP_js_1.default.OP_NOP31:\n                case OP_js_1.default.OP_NOP32:\n                case OP_js_1.default.OP_NOP33:\n                case OP_js_1.default.OP_NOP34:\n                case OP_js_1.default.OP_NOP35:\n                case OP_js_1.default.OP_NOP36:\n                case OP_js_1.default.OP_NOP37:\n                case OP_js_1.default.OP_NOP38:\n                case OP_js_1.default.OP_NOP39:\n                case OP_js_1.default.OP_NOP40:\n                case OP_js_1.default.OP_NOP41:\n                case OP_js_1.default.OP_NOP42:\n                case OP_js_1.default.OP_NOP43:\n                case OP_js_1.default.OP_NOP44:\n                case OP_js_1.default.OP_NOP45:\n                case OP_js_1.default.OP_NOP46:\n                case OP_js_1.default.OP_NOP47:\n                case OP_js_1.default.OP_NOP48:\n                case OP_js_1.default.OP_NOP49:\n                case OP_js_1.default.OP_NOP50:\n                case OP_js_1.default.OP_NOP51:\n                case OP_js_1.default.OP_NOP52:\n                case OP_js_1.default.OP_NOP53:\n                case OP_js_1.default.OP_NOP54:\n                case OP_js_1.default.OP_NOP55:\n                case OP_js_1.default.OP_NOP56:\n                case OP_js_1.default.OP_NOP57:\n                case OP_js_1.default.OP_NOP58:\n                case OP_js_1.default.OP_NOP59:\n                case OP_js_1.default.OP_NOP60:\n                case OP_js_1.default.OP_NOP61:\n                case OP_js_1.default.OP_NOP62:\n                case OP_js_1.default.OP_NOP63:\n                case OP_js_1.default.OP_NOP64:\n                case OP_js_1.default.OP_NOP65:\n                case OP_js_1.default.OP_NOP66:\n                case OP_js_1.default.OP_NOP67:\n                case OP_js_1.default.OP_NOP68:\n                case OP_js_1.default.OP_NOP69:\n                case OP_js_1.default.OP_NOP70:\n                case OP_js_1.default.OP_NOP71:\n                case OP_js_1.default.OP_NOP72:\n                case OP_js_1.default.OP_NOP73:\n                case OP_js_1.default.OP_NOP77:\n                    break;\n                case OP_js_1.default.OP_IF:\n                case OP_js_1.default.OP_NOTIF:\n                    fValue = false;\n                    if (isScriptExecuting) {\n                        if (this.stack.length < 1)\n                            this.scriptEvaluationError('OP_IF and OP_NOTIF require at least one item on the stack when they are used!');\n                        buf = this.popStack();\n                        fValue = this.castToBool(buf);\n                        if (currentOpcode === OP_js_1.default.OP_NOTIF)\n                            fValue = !fValue;\n                    }\n                    this.ifStack.push(fValue);\n                    break;\n                case OP_js_1.default.OP_ELSE:\n                    if (this.ifStack.length === 0)\n                        this.scriptEvaluationError('OP_ELSE requires a preceeding OP_IF.');\n                    this.ifStack[this.ifStack.length - 1] = !this.ifStack[this.ifStack.length - 1];\n                    break;\n                case OP_js_1.default.OP_ENDIF:\n                    if (this.ifStack.length === 0)\n                        this.scriptEvaluationError('OP_ENDIF requires a preceeding OP_IF.');\n                    this.ifStack.pop();\n                    break;\n                case OP_js_1.default.OP_VERIFY:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_VERIFY requires at least one item to be on the stack.');\n                    buf1 = this.stackTop();\n                    fValue = this.castToBool(buf1);\n                    if (!fValue)\n                        this.scriptEvaluationError('OP_VERIFY requires the top stack value to be truthy.');\n                    this.popStack();\n                    break;\n                case OP_js_1.default.OP_RETURN:\n                    if (this.context === 'UnlockingScript')\n                        this.programCounter = this.unlockingScript.chunks.length;\n                    else\n                        this.programCounter = this.lockingScript.chunks.length;\n                    this.ifStack = [];\n                    this.programCounter--; // To counteract the final increment and ensure loop termination\n                    break;\n                case OP_js_1.default.OP_TOALTSTACK:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_TOALTSTACK requires at oeast one item to be on the stack.');\n                    this.pushAltStack(this.popStack());\n                    break;\n                case OP_js_1.default.OP_FROMALTSTACK:\n                    if (this.altStack.length < 1)\n                        this.scriptEvaluationError('OP_FROMALTSTACK requires at least one item to be on the stack.'); // \"stack\" here means altstack\n                    this.pushStack(this.popAltStack());\n                    break;\n                case OP_js_1.default.OP_2DROP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_2DROP requires at least two items to be on the stack.');\n                    this.popStack();\n                    this.popStack();\n                    break;\n                case OP_js_1.default.OP_2DUP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_2DUP requires at least two items to be on the stack.');\n                    buf1 = this.stackTop(-2);\n                    buf2 = this.stackTop(-1);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    break;\n                case OP_js_1.default.OP_3DUP:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_3DUP requires at least three items to be on the stack.');\n                    buf1 = this.stackTop(-3);\n                    buf2 = this.stackTop(-2);\n                    buf3 = this.stackTop(-1);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    this.pushStackCopy(buf3);\n                    break;\n                case OP_js_1.default.OP_2OVER:\n                    if (this.stack.length < 4)\n                        this.scriptEvaluationError('OP_2OVER requires at least four items to be on the stack.');\n                    buf1 = this.stackTop(-4);\n                    buf2 = this.stackTop(-3);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    break;\n                case OP_js_1.default.OP_2ROT: {\n                    if (this.stack.length < 6)\n                        this.scriptEvaluationError('OP_2ROT requires at least six items to be on the stack.');\n                    const rot6 = this.popStack();\n                    const rot5 = this.popStack();\n                    const rot4 = this.popStack();\n                    const rot3 = this.popStack();\n                    const rot2 = this.popStack();\n                    const rot1 = this.popStack();\n                    this.pushStack(rot3);\n                    this.pushStack(rot4);\n                    this.pushStack(rot5);\n                    this.pushStack(rot6);\n                    this.pushStack(rot1);\n                    this.pushStack(rot2);\n                    break;\n                }\n                case OP_js_1.default.OP_2SWAP: {\n                    if (this.stack.length < 4)\n                        this.scriptEvaluationError('OP_2SWAP requires at least four items to be on the stack.');\n                    const swap4 = this.popStack();\n                    const swap3 = this.popStack();\n                    const swap2 = this.popStack();\n                    const swap1 = this.popStack();\n                    this.pushStack(swap3);\n                    this.pushStack(swap4);\n                    this.pushStack(swap1);\n                    this.pushStack(swap2);\n                    break;\n                }\n                case OP_js_1.default.OP_IFDUP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_IFDUP requires at least one item to be on the stack.');\n                    buf1 = this.stackTop();\n                    if (this.castToBool(buf1)) {\n                        this.pushStackCopy(buf1);\n                    }\n                    break;\n                case OP_js_1.default.OP_DEPTH:\n                    this.pushStack(new BigNumber_js_1.default(this.stack.length).toScriptNum());\n                    break;\n                case OP_js_1.default.OP_DROP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_DROP requires at least one item to be on the stack.');\n                    this.popStack();\n                    break;\n                case OP_js_1.default.OP_DUP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_DUP requires at least one item to be on the stack.');\n                    this.pushStackCopy(this.stackTop());\n                    break;\n                case OP_js_1.default.OP_NIP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_NIP requires at least two items to be on the stack.');\n                    buf2 = this.popStack();\n                    this.popStack();\n                    this.pushStack(buf2);\n                    break;\n                case OP_js_1.default.OP_OVER:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_OVER requires at least two items to be on the stack.');\n                    this.pushStackCopy(this.stackTop(-2));\n                    break;\n                case OP_js_1.default.OP_PICK:\n                case OP_js_1.default.OP_ROLL: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);\n                    bn = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush);\n                    n = bn.toNumber();\n                    if (n < 0 || n >= this.stack.length) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top stack element to be 0 or a positive number less than the current size of the stack.`);\n                    }\n                    const itemToMoveOrCopy = this.stack[this.stack.length - 1 - n];\n                    if (currentOpcode === OP_js_1.default.OP_ROLL) {\n                        this.stack.splice(this.stack.length - 1 - n, 1);\n                        this.stackMem -= itemToMoveOrCopy.length;\n                        this.pushStack(itemToMoveOrCopy);\n                    }\n                    else { // OP_PICK\n                        this.pushStackCopy(itemToMoveOrCopy);\n                    }\n                    break;\n                }\n                case OP_js_1.default.OP_ROT:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_ROT requires at least three items to be on the stack.');\n                    x3 = this.popStack();\n                    x2 = this.popStack();\n                    x1 = this.popStack();\n                    this.pushStack(x2);\n                    this.pushStack(x3);\n                    this.pushStack(x1);\n                    break;\n                case OP_js_1.default.OP_SWAP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_SWAP requires at least two items to be on the stack.');\n                    x2 = this.popStack();\n                    x1 = this.popStack();\n                    this.pushStack(x2);\n                    this.pushStack(x1);\n                    break;\n                case OP_js_1.default.OP_TUCK:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_TUCK requires at least two items to be on the stack.');\n                    buf1 = this.stackTop(-1); // Top element (x2)\n                    // stack is [... rest, x1, x2]\n                    // We want [... rest, x2_copy, x1, x2]\n                    this.ensureStackMem(buf1.length);\n                    this.stack.splice(this.stack.length - 2, 0, buf1.slice()); // Insert copy of x2 before x1\n                    this.stackMem += buf1.length; // Account for the new copy\n                    break;\n                case OP_js_1.default.OP_SIZE:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_SIZE requires at least one item to be on the stack.');\n                    this.pushStack(new BigNumber_js_1.default(this.stackTop().length).toScriptNum());\n                    break;\n                case OP_js_1.default.OP_AND:\n                case OP_js_1.default.OP_OR:\n                case OP_js_1.default.OP_XOR: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    if (buf1.length !== buf2.length)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top two stack items to be the same size.`);\n                    const resultBufBitwiseOp = new Array(buf1.length);\n                    for (let k = 0; k < buf1.length; k++) {\n                        if (currentOpcode === OP_js_1.default.OP_AND)\n                            resultBufBitwiseOp[k] = buf1[k] & buf2[k];\n                        else if (currentOpcode === OP_js_1.default.OP_OR)\n                            resultBufBitwiseOp[k] = buf1[k] | buf2[k];\n                        else\n                            resultBufBitwiseOp[k] = buf1[k] ^ buf2[k];\n                    }\n                    this.pushStack(resultBufBitwiseOp);\n                    break;\n                }\n                case OP_js_1.default.OP_INVERT: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_INVERT requires at least one item to be on the stack.');\n                    buf = this.popStack();\n                    const invertedBufOp = new Array(buf.length);\n                    for (let k = 0; k < buf.length; k++) {\n                        invertedBufOp[k] = (~buf[k]) & 0xff;\n                    }\n                    this.pushStack(invertedBufOp);\n                    break;\n                }\n                case OP_js_1.default.OP_LSHIFT:\n                case OP_js_1.default.OP_RSHIFT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);\n                    bn2 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // n (shift amount)\n                    buf1 = this.popStack(); // value to shift\n                    n = bn2.toNumber();\n                    if (n < 0)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the top item on the stack not to be negative.`);\n                    if (buf1.length === 0) {\n                        this.pushStack([]);\n                        break;\n                    }\n                    bn1 = new BigNumber_js_1.default(buf1);\n                    let shiftedBn;\n                    if (currentOpcode === OP_js_1.default.OP_LSHIFT)\n                        shiftedBn = bn1.ushln(n);\n                    else\n                        shiftedBn = bn1.ushrn(n);\n                    const shiftedArr = shiftedBn.toArray('le', buf1.length);\n                    this.pushStack(shiftedArr);\n                    break;\n                }\n                case OP_js_1.default.OP_EQUAL:\n                case OP_js_1.default.OP_EQUALVERIFY:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    fValue = compareNumberArrays(buf1, buf2);\n                    this.pushStack(fValue ? [1] : []);\n                    if (currentOpcode === OP_js_1.default.OP_EQUALVERIFY) {\n                        if (!fValue)\n                            this.scriptEvaluationError('OP_EQUALVERIFY requires the top two stack items to be equal.');\n                        this.popStack();\n                    }\n                    break;\n                case OP_js_1.default.OP_1ADD:\n                case OP_js_1.default.OP_1SUB:\n                case OP_js_1.default.OP_NEGATE:\n                case OP_js_1.default.OP_ABS:\n                case OP_js_1.default.OP_NOT:\n                case OP_js_1.default.OP_0NOTEQUAL:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least one item to be on the stack.`);\n                    bn = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush);\n                    switch (currentOpcode) {\n                        case OP_js_1.default.OP_1ADD:\n                            bn = bn.add(new BigNumber_js_1.default(1));\n                            break;\n                        case OP_js_1.default.OP_1SUB:\n                            bn = bn.sub(new BigNumber_js_1.default(1));\n                            break;\n                        case OP_js_1.default.OP_NEGATE:\n                            bn = bn.neg();\n                            break;\n                        case OP_js_1.default.OP_ABS:\n                            if (bn.isNeg())\n                                bn = bn.neg();\n                            break;\n                        case OP_js_1.default.OP_NOT:\n                            bn = new BigNumber_js_1.default(bn.cmpn(0) === 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_0NOTEQUAL:\n                            bn = new BigNumber_js_1.default(bn.cmpn(0) !== 0 ? 1 : 0);\n                            break;\n                    }\n                    this.pushStack(bn.toScriptNum());\n                    break;\n                case OP_js_1.default.OP_ADD:\n                case OP_js_1.default.OP_SUB:\n                case OP_js_1.default.OP_MUL:\n                case OP_js_1.default.OP_DIV:\n                case OP_js_1.default.OP_MOD:\n                case OP_js_1.default.OP_BOOLAND:\n                case OP_js_1.default.OP_BOOLOR:\n                case OP_js_1.default.OP_NUMEQUAL:\n                case OP_js_1.default.OP_NUMEQUALVERIFY:\n                case OP_js_1.default.OP_NUMNOTEQUAL:\n                case OP_js_1.default.OP_LESSTHAN:\n                case OP_js_1.default.OP_GREATERTHAN:\n                case OP_js_1.default.OP_LESSTHANOREQUAL:\n                case OP_js_1.default.OP_GREATERTHANOREQUAL:\n                case OP_js_1.default.OP_MIN:\n                case OP_js_1.default.OP_MAX: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    bn2 = BigNumber_js_1.default.fromScriptNum(buf2, requireMinimalPush);\n                    bn1 = BigNumber_js_1.default.fromScriptNum(buf1, requireMinimalPush);\n                    let predictedLen = 0;\n                    switch (currentOpcode) {\n                        case OP_js_1.default.OP_MUL:\n                            predictedLen = bn1.byteLength() + bn2.byteLength();\n                            break;\n                        case OP_js_1.default.OP_ADD:\n                        case OP_js_1.default.OP_SUB:\n                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength()) + 1;\n                            break;\n                        default:\n                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength());\n                    }\n                    this.ensureStackMem(predictedLen);\n                    let resultBnArithmetic = new BigNumber_js_1.default(0);\n                    switch (currentOpcode) {\n                        case OP_js_1.default.OP_ADD:\n                            resultBnArithmetic = bn1.add(bn2);\n                            break;\n                        case OP_js_1.default.OP_SUB:\n                            resultBnArithmetic = bn1.sub(bn2);\n                            break;\n                        case OP_js_1.default.OP_MUL:\n                            resultBnArithmetic = bn1.mul(bn2);\n                            break;\n                        case OP_js_1.default.OP_DIV:\n                            if (bn2.cmpn(0) === 0)\n                                this.scriptEvaluationError('OP_DIV cannot divide by zero!');\n                            resultBnArithmetic = bn1.div(bn2);\n                            break;\n                        case OP_js_1.default.OP_MOD:\n                            if (bn2.cmpn(0) === 0)\n                                this.scriptEvaluationError('OP_MOD cannot divide by zero!');\n                            resultBnArithmetic = bn1.mod(bn2);\n                            break;\n                        case OP_js_1.default.OP_BOOLAND:\n                            resultBnArithmetic = new BigNumber_js_1.default((bn1.cmpn(0) !== 0 && bn2.cmpn(0) !== 0) ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_BOOLOR:\n                            resultBnArithmetic = new BigNumber_js_1.default((bn1.cmpn(0) !== 0 || bn2.cmpn(0) !== 0) ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_NUMEQUAL:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) === 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_NUMEQUALVERIFY:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) === 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_NUMNOTEQUAL:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) !== 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_LESSTHAN:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) < 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_GREATERTHAN:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) > 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_LESSTHANOREQUAL:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) <= 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_GREATERTHANOREQUAL:\n                            resultBnArithmetic = new BigNumber_js_1.default(bn1.cmp(bn2) >= 0 ? 1 : 0);\n                            break;\n                        case OP_js_1.default.OP_MIN:\n                            resultBnArithmetic = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n                            break;\n                        case OP_js_1.default.OP_MAX:\n                            resultBnArithmetic = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n                            break;\n                    }\n                    this.pushStack(resultBnArithmetic.toScriptNum());\n                    if (currentOpcode === OP_js_1.default.OP_NUMEQUALVERIFY) {\n                        if (!this.castToBool(this.stackTop()))\n                            this.scriptEvaluationError('OP_NUMEQUALVERIFY requires the top stack item to be truthy.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case OP_js_1.default.OP_WITHIN:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_WITHIN requires at least three items to be on the stack.');\n                    bn3 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // max\n                    bn2 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // min\n                    bn1 = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush); // x\n                    fValue = bn1.cmp(bn2) >= 0 && bn1.cmp(bn3) < 0;\n                    this.pushStack(fValue ? [1] : []);\n                    break;\n                case OP_js_1.default.OP_RIPEMD160:\n                case OP_js_1.default.OP_SHA1:\n                case OP_js_1.default.OP_SHA256:\n                case OP_js_1.default.OP_HASH160:\n                case OP_js_1.default.OP_HASH256: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least one item to be on the stack.`);\n                    buf = this.popStack();\n                    let hashResult = []; // Initialize to empty, to satisfy TS compiler\n                    if (currentOpcode === OP_js_1.default.OP_RIPEMD160)\n                        hashResult = Hash.ripemd160(buf);\n                    else if (currentOpcode === OP_js_1.default.OP_SHA1)\n                        hashResult = Hash.sha1(buf);\n                    else if (currentOpcode === OP_js_1.default.OP_SHA256)\n                        hashResult = Hash.sha256(buf);\n                    else if (currentOpcode === OP_js_1.default.OP_HASH160)\n                        hashResult = Hash.hash160(buf);\n                    else if (currentOpcode === OP_js_1.default.OP_HASH256)\n                        hashResult = Hash.hash256(buf);\n                    this.pushStack(hashResult);\n                    break;\n                }\n                case OP_js_1.default.OP_CODESEPARATOR:\n                    this.lastCodeSeparator = this.programCounter;\n                    break;\n                case OP_js_1.default.OP_CHECKSIG:\n                case OP_js_1.default.OP_CHECKSIGVERIFY: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least two items to be on the stack.`);\n                    bufPubkey = this.popStack();\n                    bufSig = this.popStack();\n                    if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {\n                        // Error already thrown by helpers\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires correct encoding for the public key and signature.`); // Fallback, should be unreachable\n                    }\n                    const scriptForChecksig = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n                    const scriptCodeChunks = scriptForChecksig.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);\n                    subscript = new Script_js_1.default(scriptCodeChunks);\n                    subscript.findAndDelete(new Script_js_1.default().writeBin(bufSig));\n                    fSuccess = false;\n                    if (bufSig.length > 0) {\n                        try {\n                            sig = TransactionSignature_js_1.default.fromChecksigFormat(bufSig);\n                            pubkey = PublicKey_js_1.default.fromDER(bufPubkey);\n                            fSuccess = this.verifySignature(sig, pubkey, subscript);\n                        }\n                        catch (e) {\n                            fSuccess = false;\n                        }\n                    }\n                    this.pushStack(fSuccess ? [1] : []);\n                    if (currentOpcode === OP_js_1.default.OP_CHECKSIGVERIFY) {\n                        if (!fSuccess)\n                            this.scriptEvaluationError('OP_CHECKSIGVERIFY requires that a valid signature is provided.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case OP_js_1.default.OP_CHECKMULTISIG:\n                case OP_js_1.default.OP_CHECKMULTISIGVERIFY: {\n                    i = 1;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires at least 1 item for nKeys.`);\n                    }\n                    nKeysCount = BigNumber_js_1.default.fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();\n                    if (nKeysCount < 0 || nKeysCount > maxMultisigKeyCount) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires a key count between 0 and ${maxMultisigKeyCount}.`);\n                    }\n                    ikey = ++i;\n                    i += nKeysCount;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} stack too small for nKeys and keys. Need ${i}, have ${this.stack.length}.`);\n                    }\n                    nSigsCount = BigNumber_js_1.default.fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the number of signatures to be no greater than the number of keys.`);\n                    }\n                    isig = ++i;\n                    i += nSigsCount;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} stack too small for N, keys, M, sigs, and dummy. Need ${i}, have ${this.stack.length}.`);\n                    }\n                    const baseScriptCMS = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n                    const subscriptChunksCMS = baseScriptCMS.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);\n                    subscript = new Script_js_1.default(subscriptChunksCMS);\n                    for (let k = 0; k < nSigsCount; k++) {\n                        bufSig = this.stackTop(-isig - k); // Sigs are closer to top than keys\n                        subscript.findAndDelete(new Script_js_1.default().writeBin(bufSig));\n                    }\n                    fSuccess = true;\n                    while (fSuccess && nSigsCount > 0) {\n                        if (nKeysCount === 0) { // No more keys to check against but still sigs left\n                            fSuccess = false;\n                            break;\n                        }\n                        bufSig = this.stackTop(-isig);\n                        bufPubkey = this.stackTop(-ikey);\n                        if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {\n                            this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires correct encoding for the public key and signature.`);\n                        }\n                        fOk = false;\n                        if (bufSig.length > 0) {\n                            try {\n                                sig = TransactionSignature_js_1.default.fromChecksigFormat(bufSig);\n                                pubkey = PublicKey_js_1.default.fromDER(bufPubkey);\n                                fOk = this.verifySignature(sig, pubkey, subscript);\n                            }\n                            catch (e) {\n                                fOk = false;\n                            }\n                        }\n                        if (fOk) {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n                        if (nSigsCount > nKeysCount) {\n                            fSuccess = false;\n                        }\n                    }\n                    // Correct total items consumed by op (N_val, keys, M_val, sigs, dummy)\n                    const itemsConsumedByOp = 1 + // N_val\n                        BigNumber_js_1.default.fromScriptNum(this.stackTop(-1), false).toNumber() + // keys\n                        1 + // M_val\n                        BigNumber_js_1.default.fromScriptNum(this.stackTop(-(1 + BigNumber_js_1.default.fromScriptNum(this.stackTop(-1), false).toNumber() + 1)), false).toNumber() + // sigs\n                        1; // dummy\n                    let popCount = itemsConsumedByOp - 1; // Pop all except dummy\n                    while (popCount > 0) {\n                        this.popStack();\n                        popCount--;\n                    }\n                    // Check and pop dummy\n                    if (this.stack.length < 1) {\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires an extra item (dummy) to be on the stack.`);\n                    }\n                    const dummyBuf = this.popStack();\n                    if (dummyBuf.length > 0) { // SCRIPT_VERIFY_NULLDUMMY\n                        this.scriptEvaluationError(`${OP_js_1.default[currentOpcode]} requires the extra stack item (dummy) to be empty.`);\n                    }\n                    this.pushStack(fSuccess ? [1] : []);\n                    if (currentOpcode === OP_js_1.default.OP_CHECKMULTISIGVERIFY) {\n                        if (!fSuccess)\n                            this.scriptEvaluationError('OP_CHECKMULTISIGVERIFY requires that a sufficient number of valid signatures are provided.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case OP_js_1.default.OP_CAT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_CAT requires at least two items to be on the stack.');\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    const catResult = (buf1).concat(buf2);\n                    if (catResult.length > maxScriptElementSize)\n                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);\n                    this.pushStack(catResult);\n                    break;\n                }\n                case OP_js_1.default.OP_SPLIT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_SPLIT requires at least two items to be on the stack.');\n                    const posBuf = this.popStack();\n                    const dataToSplit = this.popStack();\n                    n = BigNumber_js_1.default.fromScriptNum(posBuf, requireMinimalPush).toNumber();\n                    if (n < 0 || n > dataToSplit.length) {\n                        this.scriptEvaluationError('OP_SPLIT requires the first stack item to be a non-negative number less than or equal to the size of the second-from-top stack item.');\n                    }\n                    this.pushStack(dataToSplit.slice(0, n));\n                    this.pushStack(dataToSplit.slice(n));\n                    break;\n                }\n                case OP_js_1.default.OP_NUM2BIN: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_NUM2BIN requires at least two items to be on the stack.');\n                    size = BigNumber_js_1.default.fromScriptNum(this.popStack(), requireMinimalPush).toNumber();\n                    if (size > maxScriptElementSize || size < 0) { // size can be 0\n                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes or negative size.`);\n                    }\n                    let rawnum = this.popStack(); // This is the number to convert\n                    rawnum = (0, utils_js_1.minimallyEncode)(rawnum); // Get its minimal scriptnum form\n                    if (rawnum.length > size) {\n                        this.scriptEvaluationError('OP_NUM2BIN requires that the size expressed in the top stack item is large enough to hold the value expressed in the second-from-top stack item.');\n                    }\n                    if (rawnum.length === size) {\n                        this.pushStack(rawnum);\n                        break;\n                    }\n                    const resultN2B = new Array(size).fill(0x00);\n                    let signbit = 0x00;\n                    if (rawnum.length > 0) {\n                        signbit = rawnum[rawnum.length - 1] & 0x80; // Store sign bit\n                        rawnum[rawnum.length - 1] &= 0x7f; // Remove sign bit for padding\n                    }\n                    // Copy rawnum (now positive magnitude) into the result\n                    for (let k = 0; k < rawnum.length; k++) {\n                        resultN2B[k] = rawnum[k];\n                    }\n                    // If the original number was negative, the sign bit must be set on the new MSB\n                    if (signbit !== 0) {\n                        resultN2B[size - 1] |= 0x80;\n                    }\n                    this.pushStack(resultN2B);\n                    break;\n                }\n                case OP_js_1.default.OP_BIN2NUM: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_BIN2NUM requires at least one item to be on the stack.');\n                    buf1 = this.popStack();\n                    const b2nResult = (0, utils_js_1.minimallyEncode)(buf1);\n                    if (!isMinimallyEncodedHelper(b2nResult)) {\n                        this.scriptEvaluationError('OP_BIN2NUM requires that the resulting number is valid.');\n                    }\n                    this.pushStack(b2nResult);\n                    break;\n                }\n                default:\n                    this.scriptEvaluationError(`Invalid opcode ${currentOpcode} (pc=${this.programCounter}).`);\n            }\n        }\n        this.programCounter++;\n        return true;\n    }\n    /**\n     * @method validate\n     * Validates the spend action by interpreting the locking and unlocking scripts.\n     * @returns {boolean} Returns true if the scripts are valid and the spend is legitimate, otherwise false.\n     * @example\n     * if (spend.validate()) {\n     *   console.log(\"Spend is valid!\");\n     * } else {\n     *   console.log(\"Invalid spend!\");\n     * }\n     */\n    validate() {\n        if (requirePushOnlyUnlockingScripts && !this.unlockingScript.isPushOnly()) {\n            this.scriptEvaluationError('Unlocking scripts can only contain push operations, and no other opcodes.');\n        }\n        while (this.step()) {\n            if (this.context === 'LockingScript' &&\n                this.programCounter >= this.lockingScript.chunks.length) {\n                break;\n            }\n        }\n        if (this.ifStack.length > 0) {\n            this.scriptEvaluationError('Every OP_IF, OP_NOTIF, or OP_ELSE must be terminated with OP_ENDIF prior to the end of the script.');\n        }\n        if (requireCleanStack) {\n            if (this.stack.length !== 1) {\n                this.scriptEvaluationError(`The clean stack rule requires exactly one item to be on the stack after script execution, found ${this.stack.length}.`);\n            }\n        }\n        if (this.stack.length === 0) {\n            this.scriptEvaluationError('The top stack element must be truthy after script evaluation (stack is empty).');\n        }\n        else if (!this.castToBool(this.stackTop())) {\n            this.scriptEvaluationError('The top stack element must be truthy after script evaluation.');\n        }\n        return true;\n    }\n    castToBool(val) {\n        if (val.length === 0)\n            return false;\n        for (let i = 0; i < val.length; i++) {\n            if (val[i] !== 0) {\n                return !(i === val.length - 1 && val[i] === 0x80);\n            }\n        }\n        return false;\n    }\n    scriptEvaluationError(str) {\n        throw new ScriptEvaluationError_js_1.default({\n            message: str,\n            txid: this.sourceTXID,\n            outputIndex: this.sourceOutputIndex,\n            context: this.context,\n            programCounter: this.programCounter,\n            stackState: this.stack,\n            altStackState: this.altStack,\n            ifStackState: this.ifStack,\n            stackMem: this.stackMem,\n            altStackMem: this.altStackMem\n        });\n    }\n}\nexports[\"default\"] = Spend;\n//# sourceMappingURL=Spend.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/Spend.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Script_js_1 = __importDefault(__webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js\"));\n/**\n * The UnlockingScript class represents an unlocking script in a Bitcoin SV transaction.\n * It extends the Script class and is used specifically for input scripts that unlock funds.\n *\n * Inherits all properties and methods from the Script class.\n *\n * @extends {Script}\n * @see {@link Script} for more information on Script.\n */\nclass UnlockingScript extends Script_js_1.default {\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns {boolean} Always returns false for an UnlockingScript instance.\n     */\n    isLockingScript() {\n        return false;\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns {boolean} Always returns true for an UnlockingScript instance.\n     */\n    isUnlockingScript() {\n        return true;\n    }\n}\nexports[\"default\"] = UnlockingScript;\n//# sourceMappingURL=UnlockingScript.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScriptEvaluationError = exports.Spend = exports.UnlockingScript = exports.LockingScript = exports.Script = exports.OP = void 0;\nvar OP_js_1 = __webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js\");\nObject.defineProperty(exports, \"OP\", ({ enumerable: true, get: function () { return __importDefault(OP_js_1).default; } }));\nvar Script_js_1 = __webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js\");\nObject.defineProperty(exports, \"Script\", ({ enumerable: true, get: function () { return __importDefault(Script_js_1).default; } }));\nvar LockingScript_js_1 = __webpack_require__(/*! ./LockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js\");\nObject.defineProperty(exports, \"LockingScript\", ({ enumerable: true, get: function () { return __importDefault(LockingScript_js_1).default; } }));\nvar UnlockingScript_js_1 = __webpack_require__(/*! ./UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js\");\nObject.defineProperty(exports, \"UnlockingScript\", ({ enumerable: true, get: function () { return __importDefault(UnlockingScript_js_1).default; } }));\nvar Spend_js_1 = __webpack_require__(/*! ./Spend.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Spend.js\");\nObject.defineProperty(exports, \"Spend\", ({ enumerable: true, get: function () { return __importDefault(Spend_js_1).default; } }));\nvar ScriptEvaluationError_js_1 = __webpack_require__(/*! ./ScriptEvaluationError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/ScriptEvaluationError.js\");\nObject.defineProperty(exports, \"ScriptEvaluationError\", ({ enumerable: true, get: function () { return __importDefault(ScriptEvaluationError_js_1).default; } }));\n__exportStar(__webpack_require__(/*! ./templates/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst OP_js_1 = __importDefault(__webpack_require__(/*! ../OP.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst LockingScript_js_1 = __importDefault(__webpack_require__(/*! ../LockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js\"));\nconst UnlockingScript_js_1 = __importDefault(__webpack_require__(/*! ../UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js\"));\nconst TransactionSignature_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js\"));\nconst Hash_js_1 = __webpack_require__(/*! ../../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('must have value');\n    return v;\n}\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nclass P2PKH {\n    /**\n     * Creates a P2PKH locking script for a given public key hash or address string\n     *\n     * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.\n     * @returns {LockingScript} - A P2PKH locking script.\n     */\n    lock(pubkeyhash) {\n        let data;\n        if (typeof pubkeyhash === 'string') {\n            const hash = (0, utils_js_1.fromBase58Check)(pubkeyhash);\n            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f) {\n                throw new Error('only P2PKH is supported');\n            }\n            data = hash.data;\n        }\n        else {\n            data = pubkeyhash;\n        }\n        if (data.length !== 20) {\n            throw new Error('P2PKH hash length must be 20 bytes');\n        }\n        return new LockingScript_js_1.default([\n            { op: OP_js_1.default.OP_DUP },\n            { op: OP_js_1.default.OP_HASH160 },\n            { op: data.length, data },\n            { op: OP_js_1.default.OP_EQUALVERIFY },\n            { op: OP_js_1.default.OP_CHECKSIG }\n        ]);\n    }\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} privateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(privateKey, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = TransactionSignature_js_1.default.SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');\n                if (sourceTXID == null || sourceTXID === undefined) {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                if (sourceTXID === '') {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                sourceSatoshis || (sourceSatoshis = input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis);\n                if (sourceSatoshis == null || sourceSatoshis === undefined) {\n                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');\n                }\n                lockingScript || (lockingScript = input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                    .lockingScript);\n                if (lockingScript == null) {\n                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');\n                }\n                const preimage = TransactionSignature_js_1.default.format({\n                    sourceTXID,\n                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: verifyTruthy(input.sequence),\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const rawSignature = privateKey.sign((0, Hash_js_1.sha256)(preimage));\n                const sig = new TransactionSignature_js_1.default(rawSignature.r, rawSignature.s, signatureScope);\n                const sigForScript = sig.toChecksigFormat();\n                const pubkeyForScript = privateKey\n                    .toPublicKey()\n                    .encode(true);\n                return new UnlockingScript_js_1.default([\n                    { op: sigForScript.length, data: sigForScript },\n                    { op: pubkeyForScript.length, data: pubkeyForScript }\n                ]);\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 108;\n            }\n        };\n    }\n}\nexports[\"default\"] = P2PKH;\n//# sourceMappingURL=P2PKH.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst index_js_1 = __webpack_require__(/*! ../index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/index.js\");\nconst index_js_2 = __webpack_require__(/*! ../../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('must have value');\n    return v;\n}\n/**\n * For a given piece of data to push onto the stack in script, creates the correct minimally-encoded script chunk,\n * including the correct push operation.\n *\n * TODO: This should be made into a TS-SDK util (distinct from the `minimallyEncode` util)\n */\nconst createMinimallyEncodedScriptChunk = (data) => {\n    if (data.length === 0) {\n        // Could have used OP_0.\n        return { op: 0 };\n    }\n    if (data.length === 1 && data[0] === 0) {\n        // Could have used OP_0.\n        return { op: 0 };\n    }\n    if (data.length === 1 && data[0] > 0 && data[0] <= 16) {\n        // Could have used OP_0 .. OP_16.\n        return { op: 0x50 + data[0] };\n    }\n    if (data.length === 1 && data[0] === 0x81) {\n        // Could have used OP_1NEGATE.\n        return { op: 0x4f };\n    }\n    if (data.length <= 75) {\n        // Could have used a direct push (opcode indicating number of bytes\n        // pushed + those bytes).\n        return { op: data.length, data };\n    }\n    if (data.length <= 255) {\n        // Could have used OP_PUSHDATA.\n        return { op: 0x4c, data };\n    }\n    if (data.length <= 65535) {\n        // Could have used OP_PUSHDATA2.\n        return { op: 0x4d, data };\n    }\n    return { op: 0x4e, data };\n};\nclass PushDrop {\n    /**\n     * Decodes a PushDrop script back into its token fields and the locking public key. If a signature was present, it will be the last field returned.\n     * Warning: Only works with a P2PK lock at the beginning of the script.\n     * @param script PushDrop script to decode back into token fields\n     * @returns An object containing PushDrop token fields and the locking public key. If a signature was included, it will be the last field.\n     */\n    static decode(script) {\n        const lockingPublicKey = index_js_2.PublicKey.fromString(index_js_2.Utils.toHex(verifyTruthy(script.chunks[0].data)) //  Ensure not undefined\n        );\n        const fields = [];\n        for (let i = 2; i < script.chunks.length; i++) {\n            const nextOpcode = script.chunks[i + 1]?.op; //  Prevent accessing `op` from `undefined`\n            let chunk = script.chunks[i].data ?? []; //  Ensure `chunk` is always `number[]`\n            if (chunk.length === 0) {\n                //  Only modify `chunk` if it was empty\n                if (script.chunks[i].op >= 80 && script.chunks[i].op <= 95) {\n                    chunk = [script.chunks[i].op - 80];\n                }\n                else if (script.chunks[i].op === 0) {\n                    chunk = [0];\n                }\n                else if (script.chunks[i].op === 0x4f) {\n                    chunk = [0x81];\n                }\n            }\n            fields.push(chunk);\n            // If the next value is DROP or 2DROP then this is the final field\n            if (nextOpcode === index_js_1.OP.OP_DROP || nextOpcode === index_js_1.OP.OP_2DROP) {\n                break;\n            }\n        }\n        return {\n            fields,\n            lockingPublicKey\n        };\n    }\n    /**\n     * Constructs a new instance of the PushDrop class.\n     *\n     * @param {WalletInterface} wallet - The wallet interface used for creating signatures and accessing public keys.\n     * @param {string} originator  The originator to use with Wallet requests\n     */\n    constructor(wallet, originator) {\n        this.wallet = wallet;\n        this.originator = originator;\n    }\n    /**\n     * Creates a PushDrop locking script with arbitrary data fields and a public key lock.\n     *\n     * @param {number[][]} fields - The token fields to include in the locking script.\n     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.\n     * @param {string} keyID - The key ID to use.\n     * @param {string} counterparty - The counterparty involved in the transaction, \"self\" or \"anyone\".\n     * @param {boolean} [forSelf=false] - Flag indicating if the lock is for the creator (default no).\n     * @param {boolean} [includeSignature=true] - Flag indicating if a signature should be included in the script (default yes).\n     * @returns {Promise<LockingScript>} The generated PushDrop locking script.\n     */\n    async lock(fields, protocolID, keyID, counterparty, forSelf = false, includeSignature = true, lockPosition = 'before') {\n        const { publicKey } = await this.wallet.getPublicKey({\n            protocolID,\n            keyID,\n            counterparty,\n            forSelf\n        }, this.originator);\n        const lockChunks = [];\n        const pushDropChunks = [];\n        lockChunks.push({\n            op: publicKey.length / 2,\n            data: index_js_2.Utils.toArray(publicKey, 'hex')\n        });\n        lockChunks.push({ op: index_js_1.OP.OP_CHECKSIG });\n        if (includeSignature) {\n            const dataToSign = fields.reduce((a, e) => [...a, ...e], []);\n            const { signature } = await this.wallet.createSignature({\n                data: dataToSign,\n                protocolID,\n                keyID,\n                counterparty\n            }, this.originator);\n            fields.push(signature);\n        }\n        for (const field of fields) {\n            pushDropChunks.push(createMinimallyEncodedScriptChunk(field));\n        }\n        let notYetDropped = fields.length;\n        while (notYetDropped > 1) {\n            pushDropChunks.push({ op: index_js_1.OP.OP_2DROP });\n            notYetDropped -= 2;\n        }\n        if (notYetDropped !== 0) {\n            pushDropChunks.push({ op: index_js_1.OP.OP_DROP });\n        }\n        if (lockPosition === 'before') {\n            return new index_js_1.LockingScript([...lockChunks, ...pushDropChunks]);\n        }\n        else {\n            return new index_js_1.LockingScript([...pushDropChunks, ...lockChunks]);\n        }\n    }\n    /**\n     * Creates an unlocking script for spending a PushDrop token output.\n     *\n     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.\n     * @param {string} keyID - The key ID to use.\n     * @param {string} counterparty - The counterparty involved in the transaction, \"self\" or \"anyone\".\n     * @param {string} [sourceTXID] - The TXID of the source transaction.\n     * @param {number} [sourceSatoshis] - The number of satoshis in the source output.\n     * @param {LockingScript} [lockingScript] - The locking script of the source output.\n     * @param {'all' | 'none' | 'single'} [signOutputs='all'] - Specifies which outputs to sign.\n     * @param {boolean} [anyoneCanPay=false] - Specifies if the anyone-can-pay flag is set.\n     * @returns {Object} An object containing functions to sign the transaction and estimate the script length.\n     */\n    unlock(protocolID, keyID, counterparty, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = index_js_2.TransactionSignature.SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= index_js_2.TransactionSignature.SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');\n                if (sourceTXID == null || sourceTXID === undefined) {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                sourceSatoshis || (sourceSatoshis = input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis);\n                if (sourceSatoshis == null || sourceSatoshis === undefined) {\n                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');\n                }\n                lockingScript || (lockingScript = input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                    .lockingScript);\n                if (lockingScript == null) {\n                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');\n                }\n                const preimage = index_js_2.TransactionSignature.format({\n                    sourceTXID,\n                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence ?? 0xffffffff,\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const preimageHash = index_js_2.Hash.sha256(preimage);\n                const { signature: bareSignature } = await this.wallet.createSignature({\n                    data: preimageHash,\n                    protocolID,\n                    keyID,\n                    counterparty\n                }, this.originator);\n                const signature = index_js_2.Signature.fromDER([...bareSignature]);\n                const txSignature = new index_js_2.TransactionSignature(signature.r, signature.s, signatureScope);\n                const sigForScript = txSignature.toChecksigFormat();\n                return new index_js_1.UnlockingScript([\n                    { op: sigForScript.length, data: sigForScript }\n                ]);\n            },\n            estimateLength: async () => 73\n        };\n    }\n}\nexports[\"default\"] = PushDrop;\n//# sourceMappingURL=PushDrop.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/templates/RPuzzle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/templates/RPuzzle.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst OP_js_1 = __importDefault(__webpack_require__(/*! ../OP.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/OP.js\"));\nconst LockingScript_js_1 = __importDefault(__webpack_require__(/*! ../LockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js\"));\nconst UnlockingScript_js_1 = __importDefault(__webpack_require__(/*! ../UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js\"));\nconst PrivateKey_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/PrivateKey.js\"));\nconst TransactionSignature_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/TransactionSignature.js\"));\nconst Hash_js_1 = __webpack_require__(/*! ../../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst Script_js_1 = __importDefault(__webpack_require__(/*! ../Script.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Script.js\"));\n/**\n * RPuzzle class implementing ScriptTemplate.\n *\n * This class provides methods to create R Puzzle and R Puzzle Hash locking and unlocking scripts, including the unlocking of UTXOs with the correct K value.\n */\nclass RPuzzle {\n    /**\n     * @constructor\n     * Constructs an R Puzzle template instance for a given puzzle type\n     *\n     * @param {'raw'|'SHA1'|'SHA256'|'HASH256'|'RIPEMD160'|'HASH160'} type Denotes the type of puzzle to create\n     */\n    constructor(type = 'raw') {\n        this.type = 'raw';\n        this.type = type;\n    }\n    /**\n     * Creates an R puzzle locking script for a given R value or R value hash.\n     *\n     * @param {number[]} value - An array representing the R value or its hash.\n     * @returns {LockingScript} - An R puzzle locking script.\n     */\n    lock(value) {\n        const chunks = [\n            { op: OP_js_1.default.OP_OVER },\n            { op: OP_js_1.default.OP_3 },\n            { op: OP_js_1.default.OP_SPLIT },\n            { op: OP_js_1.default.OP_NIP },\n            { op: OP_js_1.default.OP_1 },\n            { op: OP_js_1.default.OP_SPLIT },\n            { op: OP_js_1.default.OP_SWAP },\n            { op: OP_js_1.default.OP_SPLIT },\n            { op: OP_js_1.default.OP_DROP }\n        ];\n        if (this.type !== 'raw') {\n            chunks.push({\n                op: OP_js_1.default['OP_' + this.type]\n            });\n        }\n        chunks.push({ op: value.length, data: value });\n        chunks.push({ op: OP_js_1.default.OP_EQUALVERIFY });\n        chunks.push({ op: OP_js_1.default.OP_CHECKSIG });\n        return new LockingScript_js_1.default(chunks);\n    }\n    /**\n     * Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for an R puzzle locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {BigNumber} k  The K-value used to unlock the R-puzzle.\n     * @param {PrivateKey} privateKey - The private key used for signing the transaction. If not provided, a random key will be generated.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(k, privateKey, signOutputs = 'all', anyoneCanPay = false) {\n        return {\n            sign: async (tx, inputIndex) => {\n                if (typeof privateKey === 'undefined') {\n                    privateKey = PrivateKey_js_1.default.fromRandom();\n                }\n                let signatureScope = TransactionSignature_js_1.default.SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= TransactionSignature_js_1.default.SIGHASH_ANYONECANPAY;\n                }\n                const otherInputs = [...tx.inputs];\n                const [input] = otherInputs.splice(inputIndex, 1);\n                if (typeof input.sourceTransaction !== 'object') {\n                    throw new Error('The source transaction is needed for transaction signing.');\n                }\n                const preimage = TransactionSignature_js_1.default.format({\n                    sourceTXID: input.sourceTransaction?.id('hex') ?? '',\n                    sourceOutputIndex: input.sourceOutputIndex ?? 0,\n                    sourceSatoshis: input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        ?.satoshis ?? 0,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence ?? 0xffffffff,\n                    subscript: input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        ?.lockingScript ?? new Script_js_1.default(),\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const rawSignature = privateKey.sign((0, Hash_js_1.sha256)(preimage), undefined, true, k);\n                const sig = new TransactionSignature_js_1.default(rawSignature.r, rawSignature.s, signatureScope);\n                const sigForScript = sig.toChecksigFormat();\n                const pubkeyForScript = privateKey\n                    .toPublicKey()\n                    .encode(true);\n                return new UnlockingScript_js_1.default([\n                    { op: sigForScript.length, data: sigForScript },\n                    { op: pubkeyForScript.length, data: pubkeyForScript }\n                ]);\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 108;\n            }\n        };\n    }\n}\nexports[\"default\"] = RPuzzle;\n//# sourceMappingURL=RPuzzle.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/templates/RPuzzle.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/script/templates/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/script/templates/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PushDrop = exports.RPuzzle = exports.P2PKH = void 0;\nvar P2PKH_js_1 = __webpack_require__(/*! ./P2PKH.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js\");\nObject.defineProperty(exports, \"P2PKH\", ({ enumerable: true, get: function () { return __importDefault(P2PKH_js_1).default; } }));\nvar RPuzzle_js_1 = __webpack_require__(/*! ./RPuzzle.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/RPuzzle.js\");\nObject.defineProperty(exports, \"RPuzzle\", ({ enumerable: true, get: function () { return __importDefault(RPuzzle_js_1).default; } }));\nvar PushDrop_js_1 = __webpack_require__(/*! ./PushDrop.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js\");\nObject.defineProperty(exports, \"PushDrop\", ({ enumerable: true, get: function () { return __importDefault(PushDrop_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/script/templates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageDownloader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageDownloader.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageDownloader = void 0;\nconst index_js_1 = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/overlay-tools/index.js\");\nconst index_js_2 = __webpack_require__(/*! ./index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/index.js\");\nconst PushDrop_js_1 = __importDefault(__webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/PushDrop.js\"));\nconst Transaction_js_1 = __importDefault(__webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js\"));\nconst index_js_3 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\nclass StorageDownloader {\n    constructor(config) {\n        this.networkPreset = 'mainnet';\n        this.networkPreset = config?.networkPreset;\n    }\n    /**\n     * Resolves the UHRP URL to a list of HTTP URLs where content can be downloaded.\n     * @param uhrpUrl The UHRP URL to resolve.\n     * @returns A promise that resolves to an array of HTTP URLs.\n     */\n    async resolve(uhrpUrl) {\n        // Use UHRP lookup service\n        const lookupResolver = new index_js_1.LookupResolver({ networkPreset: this.networkPreset });\n        const response = await lookupResolver.query({ service: 'ls_uhrp', query: { uhrpUrl } });\n        if (response.type !== 'output-list') {\n            throw new Error('Lookup answer must be an output list');\n        }\n        const decodedResults = [];\n        const currentTime = Math.floor(Date.now() / 1000);\n        for (let i = 0; i < response.outputs.length; i++) {\n            const tx = Transaction_js_1.default.fromBEEF(response.outputs[i].beef);\n            const { fields } = PushDrop_js_1.default.decode(tx.outputs[response.outputs[i].outputIndex].lockingScript);\n            const expiryTime = new index_js_3.Utils.Reader(fields[3]).readVarIntNum();\n            if (expiryTime < currentTime) {\n                continue;\n            }\n            decodedResults.push(index_js_3.Utils.toUTF8(fields[2]));\n        }\n        return decodedResults;\n    }\n    /**\n     * Downloads the content from the UHRP URL after validating the hash for integrity.\n     * @param uhrpUrl The UHRP URL to download.\n     * @returns A promise that resolves to the downloaded content.\n     */\n    async download(uhrpUrl) {\n        if (!index_js_2.StorageUtils.isValidURL(uhrpUrl)) {\n            throw new Error('Invalid parameter UHRP url');\n        }\n        const hash = index_js_2.StorageUtils.getHashFromURL(uhrpUrl);\n        const downloadURLs = await this.resolve(uhrpUrl);\n        if (!Array.isArray(downloadURLs) || downloadURLs.length === 0) {\n            throw new Error('No one currently hosts this file!');\n        }\n        for (let i = 0; i < downloadURLs.length; i++) {\n            try {\n                // The url is fetched\n                const result = await fetch(downloadURLs[i], { method: 'GET' });\n                // If the request fails, continue to the next url\n                if (!result.ok || result.status >= 400) {\n                    continue;\n                }\n                const body = await result.arrayBuffer();\n                // The body is loaded into a number array\n                const content = [...new Uint8Array(body)];\n                const contentHash = index_js_3.Hash.sha256(content);\n                for (let i = 0; i < contentHash.length; ++i) {\n                    if (contentHash[i] !== hash[i]) {\n                        throw new Error('Value of content does not match hash of the url given');\n                    }\n                }\n                return {\n                    data: content,\n                    mimeType: result.headers.get('Content-Type')\n                };\n            }\n            catch (error) {\n                continue;\n            }\n        }\n        throw new Error(`Unable to download content from ${uhrpUrl}`);\n    }\n}\nexports.StorageDownloader = StorageDownloader;\n//# sourceMappingURL=StorageDownloader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageDownloader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUploader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUploader.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageUploader = void 0;\nconst AuthFetch_js_1 = __webpack_require__(/*! ../auth/clients/AuthFetch.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/clients/AuthFetch.js\");\nconst StorageUtils = __importStar(__webpack_require__(/*! ./StorageUtils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUtils.js\"));\n/**\n * The StorageUploader class provides client-side methods for:\n * - Uploading files with a specified retention period\n * - Finding file metadata by UHRP URL\n * - Listing all user uploads\n * - Renewing an existing advertisement's expiry time\n */\nclass StorageUploader {\n    /**\n     * Creates a new StorageUploader instance.\n     * @param {UploaderConfig} config - An object containing the storage server's URL and a wallet interface\n     */\n    constructor(config) {\n        this.baseURL = config.storageURL;\n        this.authFetch = new AuthFetch_js_1.AuthFetch(config.wallet);\n    }\n    /**\n     * Requests information from the server to upload a file (including presigned URL and headers).\n     * @private\n     * @param {number} fileSize - The size of the file, in bytes\n     * @param {number} retentionPeriod - The desired hosting time, in minutes\n     * @returns {Promise<{ uploadURL: string; requiredHeaders: Record<string, string>; amount?: number }>}\n     * @throws {Error} If the server returns a non-OK response or an error status\n     */\n    async getUploadInfo(fileSize, retentionPeriod) {\n        const url = `${this.baseURL}/upload`;\n        const body = { fileSize, retentionPeriod };\n        const response = await this.authFetch.fetch(url, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body)\n        });\n        if (!response.ok) {\n            throw new Error(`Upload info request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            throw new Error('Upload route returned an error.');\n        }\n        return {\n            uploadURL: data.uploadURL,\n            requiredHeaders: data.requiredHeaders,\n            amount: data.amount\n        };\n    }\n    /**\n     * Performs the actual file upload (HTTP PUT) to the presigned URL returned by the server.\n     * @private\n     * @param {string} uploadURL - The presigned URL where the file is to be uploaded\n     * @param {UploadableFile} file - The file to upload, including its raw data and MIME type\n     * @param {Record<string, string>} requiredHeaders - Additional headers required by the server (e.g. content-length)\n     * @returns {Promise<UploadFileResult>} An object indicating whether publishing was successful and the resulting UHRP URL\n     * @throws {Error} If the server returns a non-OK response\n     */\n    async uploadFile(uploadURL, file, requiredHeaders) {\n        const body = Uint8Array.from(file.data);\n        const response = await fetch(uploadURL, {\n            method: 'PUT',\n            body,\n            headers: {\n                'Content-Type': file.type,\n                ...requiredHeaders\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`File upload failed: HTTP ${response.status}`);\n        }\n        const uhrpURL = await StorageUtils.getURLForFile(file.data);\n        return {\n            published: true,\n            uhrpURL\n        };\n    }\n    /**\n     * Publishes a file to the storage server with the specified retention period.\n     *\n     * This will:\n     * 1. Request an upload URL from the server.\n     * 2. Perform an HTTP PUT to upload the files raw bytes.\n     * 3. Return a UHRP URL referencing the file once published.\n     *\n     * @param {Object} params\n     * @param {UploadableFile} params.file - The file data + type\n     * @param {number} params.retentionPeriod - Number of minutes to host the file\n     * @returns {Promise<UploadFileResult>} An object with the file's UHRP URL\n     * @throws {Error} If the server or upload step returns a non-OK response\n     */\n    async publishFile(params) {\n        const { file, retentionPeriod } = params;\n        const fileSize = file.data.length;\n        const { uploadURL, requiredHeaders } = await this.getUploadInfo(fileSize, retentionPeriod);\n        return await this.uploadFile(uploadURL, file, requiredHeaders);\n    }\n    /**\n     * Retrieves metadata for a file matching the given UHRP URL from the `/find` route.\n     * @param {string} uhrpUrl - The UHRP URL, e.g. \"uhrp://abcd...\"\n     * @returns {Promise<FindFileData>} An object with file name, size, MIME type, and expiry time\n     * @throws {Error} If the server or the route returns an error\n     */\n    async findFile(uhrpUrl) {\n        const url = new URL(`${this.baseURL}/find`);\n        url.searchParams.set('uhrpUrl', uhrpUrl);\n        const response = await this.authFetch.fetch(url.toString(), {\n            method: 'GET'\n        });\n        if (!response.ok) {\n            throw new Error(`findFile request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`findFile returned an error: ${errCode} - ${errDesc}`);\n        }\n        return data.data;\n    }\n    /**\n     * Lists all advertisements belonging to the user from the `/list` route.\n     * @returns {Promise<any>} The array of uploads returned by the server\n     * @throws {Error} If the server or the route returns an error\n     */\n    async listUploads() {\n        const url = `${this.baseURL}/list`;\n        const response = await this.authFetch.fetch(url, {\n            method: 'GET'\n        });\n        if (!response.ok) {\n            throw new Error(`listUploads request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`listUploads returned an error: ${errCode} - ${errDesc}`);\n        }\n        return data.uploads;\n    }\n    /**\n     * Renews the hosting time for an existing file advertisement identified by uhrpUrl.\n     * Calls the `/renew` route to add `additionalMinutes` to the GCS customTime\n     * and re-mint the advertisement token on-chain.\n     *\n     * @param {string} uhrpUrl - The UHRP URL of the file (e.g., \"uhrp://abcd1234...\")\n     * @param {number} additionalMinutes - The number of minutes to extend\n     * @returns {Promise<RenewFileResult>} An object with the new and previous expiry times, plus any cost\n     * @throws {Error} If the request fails or the server returns an error\n     */\n    async renewFile(uhrpUrl, additionalMinutes) {\n        const url = `${this.baseURL}/renew`;\n        const body = { uhrpUrl, additionalMinutes };\n        const response = await this.authFetch.fetch(url, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body)\n        });\n        if (!response.ok) {\n            throw new Error(`renewFile request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`renewFile returned an error: ${errCode} - ${errDesc}`);\n        }\n        return {\n            status: data.status,\n            prevExpiryTime: data.prevExpiryTime,\n            newExpiryTime: data.newExpiryTime,\n            amount: data.amount\n        };\n    }\n}\nexports.StorageUploader = StorageUploader;\n//# sourceMappingURL=StorageUploader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUploader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUtils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUtils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isValidURL = exports.getHashFromURL = exports.getURLForFile = exports.getURLForHash = exports.normalizeURL = void 0;\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\n/**\n * Takes a UHRP URL and removes any prefixes.\n * @param {string} URL - The UHRP URL.\n * @returns {string} - Normalized URL.\n */\nconst normalizeURL = (URL) => {\n    if (URL.toLowerCase().startsWith('uhrp:'))\n        URL = URL.slice(5);\n    if (URL.startsWith('//'))\n        URL = URL.slice(2);\n    return URL;\n};\nexports.normalizeURL = normalizeURL;\n/**\n * Generates a UHRP URL from a given SHA-256 hash.\n * @param {number[]} hash - 32-byte SHA-256 hash.\n * @returns {string} - Base58Check encoded URL.\n */\nconst getURLForHash = (hash) => {\n    if (hash.length !== 32) {\n        throw new Error('Hash length must be 32 bytes (sha256)');\n    }\n    return (0, utils_js_1.toBase58Check)(hash, (0, utils_js_1.toArray)('ce00', 'hex'));\n};\nexports.getURLForHash = getURLForHash;\n/**\n * Generates a UHRP URL for a given file.\n * @param {number[] | string} file - File content as number array or string.\n * @returns {string} - Base58Check encoded URL.\n */\nconst getURLForFile = (file) => {\n    const hash = (0, Hash_js_1.sha256)(file);\n    return (0, exports.getURLForHash)(hash);\n};\nexports.getURLForFile = getURLForFile;\n/**\n * Extracts the hash from a UHRP URL.\n * @param {string} URL - UHRP URL.\n * @returns {number[]} - Extracted SHA-256 hash.\n */\nconst getHashFromURL = (URL) => {\n    URL = (0, exports.normalizeURL)(URL);\n    const { data, prefix } = (0, utils_js_1.fromBase58Check)(URL, undefined, 2);\n    if (data.length !== 32) {\n        throw new Error('Invalid length!');\n    }\n    if ((0, utils_js_1.toHex)(prefix) !== 'ce00') {\n        throw new Error('Bad prefix');\n    }\n    return data;\n};\nexports.getHashFromURL = getHashFromURL;\n/**\n * Checks if a URL is a valid UHRP URL.\n * @param {string} URL - The URL to validate.\n * @returns {boolean} - True if valid, false otherwise.\n */\nconst isValidURL = (URL) => {\n    try {\n        (0, exports.getHashFromURL)(URL);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.isValidURL = isValidURL;\n//# sourceMappingURL=StorageUtils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUtils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/storage/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/storage/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageDownloader = exports.StorageUploader = exports.StorageUtils = void 0;\nexports.StorageUtils = __importStar(__webpack_require__(/*! ./StorageUtils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUtils.js\"));\nvar StorageUploader_js_1 = __webpack_require__(/*! ./StorageUploader.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageUploader.js\");\nObject.defineProperty(exports, \"StorageUploader\", ({ enumerable: true, get: function () { return StorageUploader_js_1.StorageUploader; } }));\nvar StorageDownloader_js_1 = __webpack_require__(/*! ./StorageDownloader.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/storage/StorageDownloader.js\");\nObject.defineProperty(exports, \"StorageDownloader\", ({ enumerable: true, get: function () { return StorageDownloader_js_1.StorageDownloader; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/storage/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/totp/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/totp/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./totp.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/totp/totp.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/totp/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/totp/totp.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/totp/totp.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TOTP = void 0;\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst BigNumber_js_1 = __importDefault(__webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/BigNumber.js\"));\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass TOTP {\n    /**\n     * Generates a Time-based One-Time Password (TOTP).\n     * @param {number[]} secret - The secret key for TOTP.\n     * @param {TOTPOptions} options - Optional parameters for TOTP.\n     * @returns {string} The generated TOTP.\n     */\n    static generate(secret, options) {\n        const _options = this.withDefaultOptions(options);\n        const counter = this.getCounter(_options.timestamp, _options.period);\n        const otp = generateHOTP(secret, counter, _options);\n        return otp;\n    }\n    /**\n     * Validates a Time-based One-Time Password (TOTP).\n     * @param {number[]} secret - The secret key for TOTP.\n     * @param {string} passcode - The passcode to validate.\n     * @param {TOTPValidateOptions} options - Optional parameters for TOTP validation.\n     * @returns {boolean} A boolean indicating whether the passcode is valid.\n     */\n    static validate(secret, passcode, options) {\n        const _options = this.withDefaultValidateOptions(options);\n        passcode = passcode.trim();\n        if (passcode.length !== _options.digits) {\n            return false;\n        }\n        const counter = this.getCounter(_options.timestamp, _options.period);\n        const counters = [counter];\n        for (let i = 1; i <= _options.skew; i++) {\n            counters.push(counter + i);\n            counters.push(counter - i);\n        }\n        for (const c of counters) {\n            if (passcode === generateHOTP(secret, c, _options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static getCounter(timestamp, period) {\n        const epochSeconds = Math.floor(timestamp / 1000);\n        const counter = Math.floor(epochSeconds / period);\n        return counter;\n    }\n    static withDefaultOptions(options) {\n        return {\n            digits: 2,\n            algorithm: 'SHA-1',\n            period: 30,\n            timestamp: Date.now(),\n            ...options\n        };\n    }\n    static withDefaultValidateOptions(options) {\n        return { skew: 1, ...this.withDefaultOptions(options) };\n    }\n}\nexports.TOTP = TOTP;\nfunction generateHOTP(secret, counter, options) {\n    const timePad = new BigNumber_js_1.default(counter).toArray('be', 8);\n    const hmac = calcHMAC(secret, timePad, options.algorithm);\n    const signature = hmac.digest();\n    // RFC 4226 https://datatracker.ietf.org/doc/html/rfc4226#section-5.4\n    const offset = signature[signature.length - 1] & 0x0f; // offset is the last byte in the hmac\n    const fourBytesRange = signature.slice(offset, offset + 4); // starting from offset, get 4 bytes\n    const mask = 0x7fffffff; // 32-bit number with a leading 0 followed by 31 ones [0111 (...) 1111]\n    const masked = new BigNumber_js_1.default(fourBytesRange).toNumber() & mask;\n    const otp = masked.toString().slice(-options.digits);\n    return otp;\n}\nfunction calcHMAC(secret, timePad, algorithm) {\n    switch (algorithm) {\n        case 'SHA-1':\n            return new Hash_js_1.SHA1HMAC(secret).update(timePad);\n        case 'SHA-256':\n            return new Hash_js_1.SHA256HMAC(secret).update(timePad);\n        case 'SHA-512':\n            return new Hash_js_1.SHA512HMAC(secret).update(timePad);\n        default:\n            throw new Error('unsupported HMAC algorithm');\n    }\n}\n//# sourceMappingURL=totp.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/totp/totp.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Beef = exports.TX_DATA_FORMAT = exports.ATOMIC_BEEF = exports.BEEF_V2 = exports.BEEF_V1 = void 0;\nconst MerklePath_js_1 = __importDefault(__webpack_require__(/*! ./MerklePath.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/MerklePath.js\"));\nconst BeefTx_js_1 = __importDefault(__webpack_require__(/*! ./BeefTx.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefTx.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('Expected a valid value, but got undefined.');\n    return v;\n}\nexports.BEEF_V1 = 4022206465; // 0100BEEF in LE order\nexports.BEEF_V2 = 4022206466; // 0200BEEF in LE order\nexports.ATOMIC_BEEF = 0x01010101; // 01010101\nvar TX_DATA_FORMAT;\n(function (TX_DATA_FORMAT) {\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"RAWTX\"] = 0] = \"RAWTX\";\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"RAWTX_AND_BUMP_INDEX\"] = 1] = \"RAWTX_AND_BUMP_INDEX\";\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"TXID_ONLY\"] = 2] = \"TXID_ONLY\";\n})(TX_DATA_FORMAT || (exports.TX_DATA_FORMAT = TX_DATA_FORMAT = {}));\n/*\n * BEEF standard: BRC-62: Background Evaluation Extended Format (BEEF) Transactions\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0062.md\n *\n * BUMP standard: BRC-74: BSV Unified Merkle Path (BUMP) Format\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0074.md\n *\n * BRC-95: Atomic BEEF Transactions\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0095.md\n *\n * The Atomic BEEF format is supported by the binary deserialization static method `fromBinary`.\n *\n * BRC-96: BEEF V2, Txid Only Extension\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0096.md\n *\n * A valid serialized BEEF is the cornerstone of Simplified Payment Validation (SPV)\n * where they are exchanged between two non-trusting parties to establish the\n * validity of a newly constructed bitcoin transaction and its inputs from prior\n * transactions.\n *\n * A `Beef` is fundamentally an list of `BUMP`s and a list of transactions.\n *\n * A `BUMP` is a partial merkle tree for a 'mined' bitcoin block.\n * It can therefore be used to prove the validity of transaction data\n * for each transaction txid whose merkle path is included in the tree.\n *\n * To be valid, the list of transactions must be sorted in dependency order:\n * oldest transaction first;\n * and each transaction must either\n * have a merkle path in one of the BUMPs, or\n * have all of its input transactions included in the list of transactions.\n *\n * The `Beef` class supports the construction of valid BEEFs by allowing BUMPs\n * (merkle paths) and transactions to be merged sequentially.\n *\n * The `Beef` class also extends the standard by supporting 'known' transactions.\n * A 'known' transaction is represented solely by its txid.\n * To become valid, all the 'known' transactions in a `Beef` must be replaced by full\n * transactions and merkle paths, if they are mined.\n *\n * The purpose of supporting 'known' transactions is that one or both parties\n * generating and exchanging BEEFs often possess partial knowledge of valid transactions\n * due to their history.\n *\n * A valid `Beef` is only required when sent to a party with no shared history,\n * such as a transaction processor.\n *\n * IMPORTANT NOTE:\n * It is fundamental to the BEEF value proposition that only valid transactions and valid\n * merkle path (BUMP) data be added to it. Merging invalid data breaks the `verify` and `isValid`\n * functions. There is no support for removing invalid data. A `Beef` that becomes invalid\n * must be discarded.\n */\nclass Beef {\n    constructor(version = exports.BEEF_V2) {\n        this.bumps = [];\n        this.txs = [];\n        this.version = exports.BEEF_V2;\n        this.atomicTxid = undefined;\n        this.version = version;\n    }\n    /**\n     * @param txid of `beefTx` to find\n     * @returns `BeefTx` in `txs` with `txid`.\n     */\n    findTxid(txid) {\n        return this.txs.find((tx) => tx.txid === txid);\n    }\n    /**\n     * Replaces `BeefTx` for this txid with txidOnly.\n     *\n     * Replacement is done so that a `clone()` can be\n     * updated by this method without affecting the\n     * original.\n     *\n     * @param txid\n     * @returns undefined if txid is unknown.\n     */\n    makeTxidOnly(txid) {\n        const i = this.txs.findIndex((tx) => tx.txid === txid);\n        if (i === -1)\n            return undefined;\n        let btx = this.txs[i];\n        if (btx.isTxidOnly) {\n            return btx;\n        }\n        this.txs.splice(i, 1);\n        btx = this.mergeTxidOnly(txid);\n        return btx;\n    }\n    /**\n     * @returns `MerklePath` with level zero hash equal to txid or undefined.\n     */\n    findBump(txid) {\n        return this.bumps.find((b) => b.path[0].some((leaf) => leaf.hash === txid) //  Ensure boolean return with `.some()`\n        );\n    }\n    /**\n     * Finds a Transaction in this `Beef`\n     * and adds any missing input SourceTransactions from this `Beef`.\n     *\n     * The result is suitable for signing.\n     *\n     * @param txid The id of the target transaction.\n     * @returns Transaction with all available input `SourceTransaction`s from this Beef.\n     */\n    findTransactionForSigning(txid) {\n        const beefTx = this.findTxid(txid);\n        if ((beefTx == null) || (beefTx.tx == null))\n            return undefined; // Ensure beefTx.tx exists before using it\n        for (const i of beefTx.tx.inputs) {\n            if (i.sourceTransaction == null) {\n                const itx = this.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid\n                if (itx != null) {\n                    i.sourceTransaction = itx.tx;\n                }\n            }\n        }\n        return beefTx.tx;\n    }\n    /**\n     * Builds the proof tree rooted at a specific `Transaction`.\n     *\n     * To succeed, the Beef must contain all the required transaction and merkle path data.\n     *\n     * @param txid The id of the target transaction.\n     * @returns Transaction with input `SourceTransaction` and `MerklePath` populated from this Beef.\n     */\n    findAtomicTransaction(txid) {\n        const beefTx = this.findTxid(txid);\n        if ((beefTx == null) || (beefTx.tx == null))\n            return undefined; // Ensure beefTx.tx exists before using it\n        const addInputProof = (beef, tx) => {\n            const mp = beef.findBump(tx.id('hex'));\n            if (mp != null) {\n                tx.merklePath = mp;\n            }\n            else {\n                for (const i of tx.inputs) {\n                    if (i.sourceTransaction == null) {\n                        const itx = beef.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid\n                        if (itx != null) {\n                            i.sourceTransaction = itx.tx;\n                        }\n                    }\n                    if (i.sourceTransaction != null) {\n                        const mp = beef.findBump(i.sourceTransaction.id('hex'));\n                        if (mp != null) {\n                            i.sourceTransaction.merklePath = mp;\n                        }\n                        else {\n                            addInputProof(beef, i.sourceTransaction);\n                        }\n                    }\n                }\n            }\n        };\n        addInputProof(this, beefTx.tx); // Safe because we checked that beefTx.tx exists\n        return beefTx.tx;\n    }\n    /**\n     * Merge a MerklePath that is assumed to be fully valid.\n     * @param bump\n     * @returns index of merged bump\n     */\n    mergeBump(bump) {\n        let bumpIndex;\n        // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.\n        for (let i = 0; i < this.bumps.length; i++) {\n            const b = this.bumps[i];\n            if (b === bump) {\n                // Literally the same\n                return i;\n            }\n            if (b.blockHeight === bump.blockHeight) {\n                // Probably the same...\n                const rootA = b.computeRoot();\n                const rootB = bump.computeRoot();\n                if (rootA === rootB) {\n                    // Definitely the same... combine them to save space\n                    b.combine(bump);\n                    bumpIndex = i;\n                    break;\n                }\n            }\n        }\n        // if the proof is not yet added, add a new path.\n        if (bumpIndex === undefined) {\n            bumpIndex = this.bumps.length;\n            this.bumps.push(bump);\n        }\n        // Review if any transactions are proven by this bump\n        const b = this.bumps[bumpIndex];\n        for (const tx of this.txs) {\n            const txid = tx.txid;\n            if (tx.bumpIndex == null) { //  Explicitly check for null or undefined\n                for (const n of b.path[0]) {\n                    if (n.hash === txid) {\n                        tx.bumpIndex = bumpIndex;\n                        n.txid = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return bumpIndex;\n    }\n    /**\n     * Merge a serialized transaction.\n     *\n     * Checks that a transaction with the same txid hasn't already been merged.\n     *\n     * Replaces existing transaction with same txid.\n     *\n     * @param rawTx\n     * @param bumpIndex Optional. If a number, must be valid index into bumps array.\n     * @returns txid of rawTx\n     */\n    mergeRawTx(rawTx, bumpIndex) {\n        const newTx = new BeefTx_js_1.default(rawTx, bumpIndex);\n        this.removeExistingTxid(newTx.txid);\n        this.txs.push(newTx);\n        this.tryToValidateBumpIndex(newTx);\n        return newTx;\n    }\n    /**\n     * Merge a `Transaction` and any referenced `merklePath` and `sourceTransaction`, recursifely.\n     *\n     * Replaces existing transaction with same txid.\n     *\n     * Attempts to match an existing bump to the new transaction.\n     *\n     * @param tx\n     * @returns txid of tx\n     */\n    mergeTransaction(tx) {\n        const txid = tx.id('hex');\n        this.removeExistingTxid(txid);\n        let bumpIndex;\n        if (tx.merklePath != null) {\n            bumpIndex = this.mergeBump(tx.merklePath);\n        }\n        const newTx = new BeefTx_js_1.default(tx, bumpIndex);\n        this.txs.push(newTx);\n        this.tryToValidateBumpIndex(newTx);\n        bumpIndex = newTx.bumpIndex;\n        if (bumpIndex === undefined) {\n            for (const input of tx.inputs) {\n                if (input.sourceTransaction != null) {\n                    this.mergeTransaction(input.sourceTransaction);\n                }\n            }\n        }\n        return newTx;\n    }\n    /**\n     * Removes an existing transaction from the BEEF, given its TXID\n     * @param txid TXID of the transaction to remove\n     */\n    removeExistingTxid(txid) {\n        const existingTxIndex = this.txs.findIndex((t) => t.txid === txid);\n        if (existingTxIndex >= 0) {\n            this.txs.splice(existingTxIndex, 1);\n        }\n    }\n    mergeTxidOnly(txid) {\n        let tx = this.txs.find((t) => t.txid === txid);\n        if (tx == null) {\n            tx = new BeefTx_js_1.default(txid);\n            this.txs.push(tx);\n            this.tryToValidateBumpIndex(tx);\n        }\n        return tx;\n    }\n    mergeBeefTx(btx) {\n        let beefTx = this.findTxid(btx.txid);\n        if (btx.isTxidOnly && (beefTx == null)) {\n            beefTx = this.mergeTxidOnly(btx.txid);\n        }\n        else if ((btx._tx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {\n            beefTx = this.mergeTransaction(btx._tx);\n        }\n        else if ((btx._rawTx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {\n            beefTx = this.mergeRawTx(btx._rawTx);\n        }\n        if (beefTx == null) {\n            throw new Error(`Failed to merge BeefTx for txid: ${btx.txid}`);\n        }\n        return beefTx;\n    }\n    mergeBeef(beef) {\n        const b = Array.isArray(beef) ? Beef.fromBinary(beef) : beef;\n        for (const bump of b.bumps) {\n            this.mergeBump(bump);\n        }\n        for (const tx of b.txs) {\n            this.mergeBeefTx(tx);\n        }\n    }\n    /**\n     * Sorts `txs` and checks structural validity of beef.\n     *\n     * Does NOT verify merkle roots.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param allowTxidOnly optional. If true, transaction txid only is assumed valid\n     */\n    isValid(allowTxidOnly) {\n        return this.verifyValid(allowTxidOnly).valid;\n    }\n    /**\n     * Sorts `txs` and confirms validity of transaction data contained in beef\n     * by validating structure of this beef and confirming computed merkle roots\n     * using `chainTracker`.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param chainTracker Used to verify computed merkle path roots for all bump txids.\n     * @param allowTxidOnly optional. If true, transaction txid is assumed valid\n     */\n    async verify(chainTracker, allowTxidOnly) {\n        const r = this.verifyValid(allowTxidOnly);\n        if (!r.valid)\n            return false;\n        for (const height of Object.keys(r.roots)) {\n            const isValid = await chainTracker.isValidRootForHeight(r.roots[height], Number(height));\n            if (!isValid) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sorts `txs` and confirms validity of transaction data contained in beef\n     * by validating structure of this beef.\n     *\n     * Returns block heights and merkle root values to be confirmed by a chaintracker.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param allowTxidOnly optional. If true, transaction txid is assumed valid\n     * @returns {{valid: boolean, roots: Record<number, string>}}\n     * `valid` is true iff this Beef is structuraly valid.\n     * `roots` is a record where keys are block heights and values are the corresponding merkle roots to be validated.\n     */\n    verifyValid(allowTxidOnly) {\n        const r = {\n            valid: false,\n            roots: {}\n        };\n        const sr = this.sortTxs();\n        if (sr.missingInputs.length > 0 ||\n            sr.notValid.length > 0 ||\n            (sr.txidOnly.length > 0 && allowTxidOnly !== true) ||\n            sr.withMissingInputs.length > 0) {\n            return r;\n        }\n        // valid txids: only txids if allowed, bump txids, then txids with input's in txids\n        const txids = {};\n        for (const tx of this.txs) {\n            if (tx.isTxidOnly) {\n                if (allowTxidOnly !== true)\n                    return r; //  Explicit check for `true`\n                txids[tx.txid] = true;\n            }\n        }\n        const confirmComputedRoot = (b, txid) => {\n            const root = b.computeRoot(txid);\n            if (r.roots[b.blockHeight] === undefined || r.roots[b.blockHeight] === '') {\n                // accept the root as valid for this block and reuse for subsequent txids\n                r.roots[b.blockHeight] = root;\n            }\n            if (r.roots[b.blockHeight] !== root) {\n                return false;\n            }\n            return true;\n        };\n        for (const b of this.bumps) {\n            for (const n of b.path[0]) {\n                if (n.txid === true && typeof n.hash === 'string' && n.hash.length > 0) {\n                    txids[n.hash] = true;\n                    // All txid hashes in all bumps must agree on computed merkle path roots\n                    if (!confirmComputedRoot(b, n.hash)) {\n                        return r;\n                    }\n                }\n            }\n        }\n        // All txs with a bumpIndex have matching txid leaf at level zero of BUMP.\n        for (const t of this.txs) {\n            if (t.bumpIndex !== undefined) {\n                const leaf = this.bumps[t.bumpIndex].path[0].find(l => l.hash === t.txid);\n                if (leaf == null) {\n                    return r;\n                }\n            }\n        }\n        for (const t of this.txs) {\n            // all input txids must be included before they are referenced\n            for (const i of t.inputTxids) {\n                if (!txids[i])\n                    return r;\n            }\n            txids[t.txid] = true;\n        }\n        r.valid = true;\n        return r;\n    }\n    /**\n     * Serializes this data to `writer`\n     * @param writer\n     */\n    toWriter(writer) {\n        writer.writeUInt32LE(this.version);\n        writer.writeVarIntNum(this.bumps.length);\n        for (const b of this.bumps) {\n            writer.write(b.toBinary());\n        }\n        writer.writeVarIntNum(this.txs.length);\n        for (const tx of this.txs) {\n            tx.toWriter(writer, this.version);\n        }\n    }\n    /**\n     * Returns a binary array representing the serialized BEEF\n     * @returns A binary array representing the BEEF\n     */\n    toBinary() {\n        // Always serialize in dependency sorted order.\n        this.sortTxs();\n        const writer = new utils_js_1.Writer();\n        this.toWriter(writer);\n        return writer.toArray();\n    }\n    /**\n     * Serialize this Beef as AtomicBEEF.\n     *\n     * `txid` must exist\n     *\n     * after sorting, if txid is not last txid, creates a clone and removes newer txs\n     *\n     * @param txid\n     * @returns serialized contents of this Beef with AtomicBEEF prefix.\n     */\n    toBinaryAtomic(txid) {\n        this.sortTxs();\n        const tx = this.findTxid(txid);\n        if (tx == null) {\n            throw new Error(`${txid} does not exist in this Beef`);\n        }\n        // If the transaction is not the last one, clone and modify\n        const beef = (this.txs[this.txs.length - 1] === tx) ? this : this.clone();\n        if (beef !== this) {\n            const i = this.txs.findIndex((t) => t.txid === txid);\n            beef.txs.splice(i + 1);\n        }\n        const writer = new utils_js_1.Writer();\n        writer.writeUInt32LE(exports.ATOMIC_BEEF);\n        writer.writeReverse((0, utils_js_1.toArray)(txid, 'hex'));\n        beef.toWriter(writer);\n        return writer.toArray();\n    }\n    /**\n     * Returns a hex string representing the serialized BEEF\n     * @returns A hex string representing the BEEF\n     */\n    toHex() {\n        return (0, utils_js_1.toHex)(this.toBinary());\n    }\n    static fromReader(br) {\n        let version = br.readUInt32LE();\n        let atomicTxid;\n        if (version === exports.ATOMIC_BEEF) {\n            // Skip the txid and re-read the BEEF version\n            atomicTxid = (0, utils_js_1.toHex)(br.readReverse(32));\n            version = br.readUInt32LE();\n        }\n        if (version !== exports.BEEF_V1 && version !== exports.BEEF_V2) {\n            throw new Error(`Serialized BEEF must start with ${exports.BEEF_V1} or ${exports.BEEF_V2} but starts with ${version}`);\n        }\n        const beef = new Beef(version);\n        const bumpsLength = br.readVarIntNum();\n        for (let i = 0; i < bumpsLength; i++) {\n            const bump = MerklePath_js_1.default.fromReader(br, false);\n            beef.bumps.push(bump);\n        }\n        const txsLength = br.readVarIntNum();\n        for (let i = 0; i < txsLength; i++) {\n            const beefTx = BeefTx_js_1.default.fromReader(br, version);\n            beef.txs.push(beefTx);\n        }\n        beef.atomicTxid = atomicTxid;\n        return beef;\n    }\n    /**\n     * Constructs an instance of the Beef class based on the provided binary array\n     * @param bin The binary array from which to construct BEEF\n     * @returns An instance of the Beef class constructed from the binary data\n     */\n    static fromBinary(bin) {\n        const br = new utils_js_1.Reader(bin);\n        return Beef.fromReader(br);\n    }\n    /**\n     * Constructs an instance of the Beef class based on the provided string\n     * @param s The string value from which to construct BEEF\n     * @param enc The encoding of the string value from which BEEF should be constructed\n     * @returns An instance of the Beef class constructed from the string\n     */\n    static fromString(s, enc = 'hex') {\n        const bin = (0, utils_js_1.toArray)(s, enc);\n        const br = new utils_js_1.Reader(bin);\n        return Beef.fromReader(br);\n    }\n    /**\n     * Try to validate newTx.bumpIndex by looking for an existing bump\n     * that proves newTx.txid\n     *\n     * @param newTx A new `BeefTx` that has been added to this.txs\n     * @returns true if a bump was found, false otherwise\n     */\n    tryToValidateBumpIndex(newTx) {\n        if (newTx.bumpIndex !== undefined) {\n            return true;\n        }\n        const txid = newTx.txid;\n        for (let i = 0; i < this.bumps.length; i++) {\n            const j = this.bumps[i].path[0].findIndex((b) => b.hash === txid);\n            if (j >= 0) {\n                newTx.bumpIndex = i;\n                this.bumps[i].path[0][j].txid = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Sort the `txs` by input txid dependency order:\n     * - Oldest Tx Anchored by Path or txid only\n     * - Newer Txs depending on Older parents\n     * - Newest Tx\n     *\n     * with proof (MerklePath) last, longest chain of dependencies first\n     *\n     * @returns `{ missingInputs, notValid, valid, withMissingInputs }`\n     */\n    sortTxs() {\n        // Hashtable of valid txids (with proof or all inputs chain to proof)\n        const validTxids = {};\n        // Hashtable of all transaction txids to transaction\n        const txidToTx = {};\n        // queue of unsorted transactions ...\n        let queue = [];\n        // sorted transactions: hasProof to with longest dependency chain\n        const result = [];\n        const txidOnly = [];\n        for (const tx of this.txs) {\n            txidToTx[tx.txid] = tx;\n            tx.isValid = tx.hasProof;\n            if (tx.isValid) {\n                validTxids[tx.txid] = true;\n                result.push(tx);\n            }\n            else if (tx.isTxidOnly && tx.inputTxids.length === 0) {\n                validTxids[tx.txid] = true;\n                txidOnly.push(tx);\n            }\n            else {\n                queue.push(tx);\n            }\n        }\n        // Hashtable of unknown input txids used to fund transactions without their own proof.\n        const missingInputs = {};\n        // transactions with one or more missing inputs\n        const txsMissingInputs = [];\n        const possiblyMissingInputs = queue;\n        queue = [];\n        // all tx are isValid false, hasProof false.\n        // if isTxidOnly then has inputTxids\n        for (const tx of possiblyMissingInputs) {\n            let hasMissingInput = false;\n            // For all the unproven transactions,\n            // link their inputs that exist in this beef,\n            // make a note of missing inputs.\n            for (const inputTxid of tx.inputTxids) {\n                if (txidToTx[inputTxid] === undefined) { // Explicitly check for undefined\n                    missingInputs[inputTxid] = true;\n                    hasMissingInput = true;\n                }\n            }\n            if (hasMissingInput) {\n                txsMissingInputs.push(tx);\n            }\n            else {\n                queue.push(tx);\n            }\n        }\n        // As long as we have unsorted transactions...\n        while (queue.length > 0) {\n            const oldQueue = queue;\n            queue = [];\n            // all tx are isValid false, hasProof false.\n            // if isTxidOnly then has inputTxids\n            for (const tx of oldQueue) {\n                if (tx.inputTxids.every((txid) => validTxids[txid])) {\n                    validTxids[tx.txid] = true;\n                    result.push(tx);\n                }\n                else {\n                    queue.push(tx);\n                }\n            }\n            if (oldQueue.length === queue.length) {\n                break;\n            }\n        }\n        // transactions that don't have proofs and don't chain to proofs\n        const txsNotValid = queue;\n        // New order of txs is unsortable (missing inputs or depends on missing inputs), txidOnly, sorted (so newest sorted is last)\n        this.txs = txsMissingInputs\n            .concat(txsNotValid)\n            .concat(txidOnly)\n            .concat(result);\n        return {\n            missingInputs: Object.keys(missingInputs),\n            notValid: txsNotValid.map((tx) => tx.txid),\n            valid: Object.keys(validTxids),\n            withMissingInputs: txsMissingInputs.map((tx) => tx.txid),\n            txidOnly: txidOnly.map((tx) => tx.txid)\n        };\n    }\n    /**\n     * @returns a shallow copy of this beef\n     */\n    clone() {\n        const c = new Beef();\n        c.version = this.version;\n        c.bumps = Array.from(this.bumps);\n        c.txs = Array.from(this.txs);\n        return c;\n    }\n    /**\n     * Ensure that all the txids in `knownTxids` are txidOnly\n     * @param knownTxids\n     */\n    trimKnownTxids(knownTxids) {\n        for (let i = 0; i < this.txs.length;) {\n            const tx = this.txs[i];\n            if (tx.isTxidOnly && knownTxids.includes(tx.txid)) {\n                this.txs.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n        // TODO: bumps could be trimmed to eliminate unreferenced proofs.\n    }\n    /**\n     * @returns array of transaction txids that either have a proof or whose inputs chain back to a proven transaction.\n     */\n    getValidTxids() {\n        const r = this.sortTxs();\n        return r.valid;\n    }\n    /**\n     * @returns Summary of `Beef` contents as multi-line string.\n     */\n    toLogString() {\n        let log = '';\n        log += `BEEF with ${this.bumps.length} BUMPS and ${this.txs.length} Transactions, isValid ${this.isValid().toString()}\\n`;\n        let i = -1;\n        for (const b of this.bumps) {\n            i++;\n            log += `  BUMP ${i}\\n    block: ${b.blockHeight}\\n    txids: [\\n${b.path[0]\n                .filter((n) => n.txid === true) //  Explicitly check if txid is `true`\n                .map((n) => `      '${n.hash ?? ''}'`)\n                .join(',\\n')}\\n    ]\\n`;\n        }\n        i = -1;\n        for (const t of this.txs) {\n            i++;\n            log += `  TX ${i}\\n    txid: ${t.txid}\\n`;\n            if (t.bumpIndex !== undefined) {\n                log += `    bumpIndex: ${t.bumpIndex}\\n`;\n            }\n            if (t.isTxidOnly) {\n                log += '    txidOnly\\n';\n            }\n            else {\n                log += `    rawTx length=${t.rawTx?.length ?? 0}\\n`; //  Fix applied here\n            }\n            if (t.inputTxids.length > 0) {\n                log += `    inputs: [\\n${t.inputTxids\n                    .map((it) => `      '${it}'`)\n                    .join(',\\n')}\\n    ]\\n`;\n            }\n        }\n        return log;\n    }\n    /**\n   * In some circumstances it may be helpful for the BUMP MerklePaths to include\n   * leaves that can be computed from row zero.\n   */\n    addComputedLeaves() {\n        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());\n        for (const bump of this.bumps) { //  Use `this` instead of `beef`\n            for (let row = 1; row < bump.path.length; row++) {\n                for (const leafL of bump.path[row - 1]) {\n                    if (typeof leafL.hash === 'string' && (leafL.offset & 1) === 0) {\n                        const leafR = bump.path[row - 1].find((l) => l.offset === leafL.offset + 1);\n                        const offsetOnRow = leafL.offset >> 1;\n                        if (leafR !== undefined &&\n                            typeof leafR.hash === 'string' &&\n                            bump.path[row].every((l) => l.offset !== offsetOnRow)) {\n                            // Computable leaf is missing... add it.\n                            bump.path[row].push({\n                                offset: offsetOnRow,\n                                // String concatenation puts the right leaf on the left of the left leaf hash\n                                hash: hash(leafR.hash + leafL.hash)\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nexports.Beef = Beef;\n//# sourceMappingURL=Beef.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefParty.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefParty.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BeefParty = void 0;\nconst Beef_js_1 = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js\");\n/**\n * Extends `Beef` that is used to exchange transaction validity data with more than one external party.\n *\n * Use `addKnownTxidsForParty` to keep track of who knows what to reduce re-transmission of potentially large transactions.\n *\n * Use `getTrimmedBeefForParty` to obtain a `Beef` trimmed of transaction validity data known to a specific party.\n *\n * Typical usage scenario:\n *\n * 1. Query a wallet storage provider for spendable outputs.\n * 2. The provider replies with a Beef validating the returned outputs.\n * 3. Construct a new transaction using some of the queried outputs as inputs, including Beef validating all the inputs.\n * 4. Receive new valid raw transaction after processing and Beef validating change outputs added to original inputs.\n * 5. Return to step 1, continuing to build on old and new spendable outputs.\n *\n * By default, each Beef is required to be complete and valid: All transactions appear as full serialized bitcoin transactions and\n * each transaction either has a merkle path proof (it has been mined) or all of its input transactions are included.\n *\n * The size and redundancy of these Beefs becomes a problem when chained transaction creation out-paces the block mining rate.\n *\n */\nclass BeefParty extends Beef_js_1.Beef {\n    /**\n     *\n     * @param parties Optional array of initial unique party identifiers.\n     */\n    constructor(parties) {\n        super();\n        /**\n         * keys are party identifiers.\n         * values are records of txids with truthy value for which the party already has validity proof.\n         */\n        this.knownTo = {};\n        if (parties != null) {\n            for (const party of parties) {\n                this.addParty(party);\n            }\n        }\n    }\n    /**\n     * @param party\n     * @returns `true` if `party` has already been added to this `BeefParty`.\n     */\n    isParty(party) {\n        const r = Object.keys(this.knownTo).includes(party);\n        return r;\n    }\n    /**\n     * Adds a new unique party identifier to this `BeefParty`.\n     * @param party\n     */\n    addParty(party) {\n        if (this.isParty(party)) {\n            throw new Error(`Party ${party} already exists.`);\n        }\n        this.knownTo[party] = {};\n    }\n    /**\n     * @param party\n     * @returns Array of txids \"known\" to `party`.\n     */\n    getKnownTxidsForParty(party) {\n        const knownTxids = this.knownTo[party];\n        if (knownTxids === undefined) { //  Explicitly check for undefined\n            throw new Error(`Party ${party} is unknown.`);\n        }\n        return Object.keys(knownTxids);\n    }\n    /**\n     * @param party\n     * @returns trimmed beef of unknown transactions and proofs for `party`\n     */\n    getTrimmedBeefForParty(party) {\n        const knownTxids = this.getKnownTxidsForParty(party);\n        const prunedBeef = this.clone();\n        prunedBeef.trimKnownTxids(knownTxids);\n        return prunedBeef;\n    }\n    /**\n     * Make note of additional txids \"known\" to `party`.\n     * @param party unique identifier, added if new.\n     * @param knownTxids\n     */\n    addKnownTxidsForParty(party, knownTxids) {\n        if (!this.isParty(party)) {\n            this.addParty(party);\n        }\n        const kts = this.knownTo[party];\n        for (const txid of knownTxids) {\n            kts[txid] = true;\n            this.mergeTxidOnly(txid);\n        }\n    }\n    /**\n     * Merge a `beef` received from a specific `party`.\n     *\n     * Updates this `BeefParty` to track all the txids\n     * corresponding to transactions for which `party`\n     * has raw transaction and validity proof data.\n     *\n     * @param party\n     * @param beef\n     */\n    mergeBeefFromParty(party, beef) {\n        const b = Array.isArray(beef) ? Beef_js_1.Beef.fromBinary(beef) : beef;\n        const knownTxids = b.getValidTxids();\n        this.mergeBeef(b);\n        this.addKnownTxidsForParty(party, knownTxids);\n    }\n}\nexports.BeefParty = BeefParty;\nexports[\"default\"] = BeefParty;\n//# sourceMappingURL=BeefParty.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefParty.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefTx.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefTx.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Transaction_js_1 = __importDefault(__webpack_require__(/*! ./Transaction.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js\"));\nconst Beef_js_1 = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js\");\n/**\n * A single bitcoin transaction associated with a `Beef` validity proof set.\n *\n * Simple case is transaction data included directly, either as raw bytes or fully parsed data, or both.\n *\n * Supports 'known' transactions which are represented by just their txid.\n * It is assumed that intended consumer of this beef already has validity proof for such a transaction,\n * which they can merge if necessary to create a valid beef.\n */\nclass BeefTx {\n    get bumpIndex() {\n        return this._bumpIndex;\n    }\n    set bumpIndex(v) {\n        this._bumpIndex = v;\n        this.updateInputTxids();\n    }\n    get hasProof() {\n        return this._bumpIndex !== undefined;\n    }\n    get isTxidOnly() {\n        return this._txid !== undefined && this._txid !== null && (this._rawTx == null) && (this._tx == null);\n    }\n    get txid() {\n        if (this._txid !== undefined && this._txid !== null && this._txid !== '')\n            return this._txid;\n        if (this._tx != null) {\n            this._txid = this._tx.id('hex');\n            return this._txid;\n        }\n        if (this._rawTx != null) {\n            this._txid = (0, utils_js_1.toHex)((0, Hash_js_1.hash256)(this._rawTx));\n            return this._txid;\n        }\n        throw new Error('Internal');\n    }\n    get tx() {\n        if (this._tx != null)\n            return this._tx;\n        if (this._rawTx != null) {\n            this._tx = Transaction_js_1.default.fromBinary(this._rawTx);\n            return this._tx;\n        }\n        return undefined;\n    }\n    get rawTx() {\n        if (this._rawTx != null)\n            return this._rawTx;\n        if (this._tx != null) {\n            this._rawTx = this._tx.toBinary();\n            return this._rawTx;\n        }\n        return undefined;\n    }\n    /**\n     * @param tx If string, must be a valid txid. If `number[]` must be a valid serialized transaction.\n     * @param bumpIndex If transaction already has a proof in the beef to which it will be added.\n     */\n    constructor(tx, bumpIndex) {\n        this.inputTxids = [];\n        /**\n         * true if `hasProof` or all inputs chain to `hasProof`.\n         *\n         * Typically set by sorting transactions by proven dependency chains.\n         */\n        this.isValid = undefined;\n        if (typeof tx === 'string') {\n            this._txid = tx;\n        }\n        else if (Array.isArray(tx)) {\n            this._rawTx = tx;\n        }\n        else {\n            this._tx = tx;\n        }\n        this.bumpIndex = bumpIndex;\n        this.updateInputTxids();\n    }\n    static fromTx(tx, bumpIndex) {\n        return new BeefTx(tx, bumpIndex);\n    }\n    static fromRawTx(rawTx, bumpIndex) {\n        return new BeefTx(rawTx, bumpIndex);\n    }\n    static fromTxid(txid, bumpIndex) {\n        return new BeefTx(txid, bumpIndex);\n    }\n    updateInputTxids() {\n        if (this.hasProof || (this.tx == null)) {\n            // If we have a proof, or don't have a parsed transaction\n            this.inputTxids = [];\n        }\n        else {\n            const inputTxids = {}; //  Explicit object type\n            for (const input of this.tx.inputs) {\n                if (input.sourceTXID !== undefined && input.sourceTXID !== null && input.sourceTXID !== '') {\n                    //  Ensure sourceTXID is defined\n                    inputTxids[input.sourceTXID] = true;\n                }\n            }\n            this.inputTxids = Object.keys(inputTxids);\n        }\n    }\n    toWriter(writer, version) {\n        const writeByte = (bb) => {\n            writer.writeUInt8(bb);\n        };\n        const writeTxid = () => {\n            if (this._txid == null) {\n                throw new Error('Transaction ID (_txid) is undefined');\n            }\n            writer.writeReverse((0, utils_js_1.toArray)(this._txid, 'hex'));\n        };\n        const writeTx = () => {\n            if (this._rawTx != null) {\n                writer.write(this._rawTx);\n            }\n            else if (this._tx != null) {\n                writer.write(this._tx.toBinary());\n            }\n            else {\n                throw new Error('a valid serialized Transaction is expected');\n            }\n        };\n        const writeBumpIndex = () => {\n            if (this.bumpIndex === undefined) {\n                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX); // 0\n            }\n            else {\n                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX); // 1\n                writer.writeVarIntNum(this.bumpIndex); // the index of the associated bump\n            }\n        };\n        if (version === Beef_js_1.BEEF_V2) {\n            if (this.isTxidOnly) {\n                writeByte(Beef_js_1.TX_DATA_FORMAT.TXID_ONLY);\n                writeTxid();\n            }\n            else if (this.bumpIndex !== undefined) {\n                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX);\n                writer.writeVarIntNum(this.bumpIndex);\n                writeTx();\n            }\n            else {\n                writeByte(Beef_js_1.TX_DATA_FORMAT.RAWTX);\n                writeTx();\n            }\n        }\n        else {\n            writeTx();\n            writeBumpIndex();\n        }\n    }\n    static fromReader(br, version) {\n        let data;\n        let bumpIndex;\n        let beefTx;\n        if (version === Beef_js_1.BEEF_V2) {\n            // V2\n            const format = br.readUInt8();\n            if (format === Beef_js_1.TX_DATA_FORMAT.TXID_ONLY) {\n                beefTx = BeefTx.fromTxid((0, utils_js_1.toHex)(br.readReverse(32)));\n            }\n            else {\n                if (format === Beef_js_1.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX) {\n                    bumpIndex = br.readVarIntNum();\n                }\n                data = Transaction_js_1.default.fromReader(br);\n                beefTx = BeefTx.fromTx(data, bumpIndex);\n            }\n        }\n        else {\n            // V1\n            data = Transaction_js_1.default.fromReader(br);\n            bumpIndex = br.readUInt8() !== 0 ? br.readVarIntNum() : undefined;\n            beefTx = BeefTx.fromTx(data, bumpIndex);\n        }\n        return beefTx;\n    }\n}\nexports[\"default\"] = BeefTx;\n//# sourceMappingURL=BeefTx.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefTx.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/Broadcaster.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/Broadcaster.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isBroadcastFailure = exports.isBroadcastResponse = void 0;\n/**\n * Convenience type guard for response from `Broadcaster.broadcast`\n */\nfunction isBroadcastResponse(r) {\n    return r.status === 'success';\n}\nexports.isBroadcastResponse = isBroadcastResponse;\n/**\n * Convenience type guard for response from `Broadcaster.broadcast`\n */\nfunction isBroadcastFailure(r) {\n    return r.status === 'error';\n}\nexports.isBroadcastFailure = isBroadcastFailure;\n//# sourceMappingURL=Broadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/Broadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/MerklePath.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/MerklePath.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\n/**\n * Represents a Merkle Path, which is used to provide a compact proof of inclusion for a\n * transaction in a block. This class encapsulates all the details required for creating\n * and verifying Merkle Proofs.\n *\n * @class MerklePath\n * @property {number} blockHeight - The height of the block in which the transaction is included.\n * @property {Array<Array<{offset: number, hash?: string, txid?: boolean, duplicate?: boolean}>>} path -\n *           A tree structure representing the Merkle Path, with each level containing information\n *           about the nodes involved in constructing the proof.\n *\n * @example\n * // Creating and verifying a Merkle Path\n * const merklePath = MerklePath.fromHex('...');\n * const isValid = merklePath.verify(txid, chainTracker);\n *\n * @description\n * The MerklePath class is useful for verifying transactions in a lightweight and efficient manner without\n * needing the entire block data. This class offers functionalities for creating, converting,\n * and verifying these proofs.\n */\nclass MerklePath {\n    /**\n     * Creates a MerklePath instance from a hexadecimal string.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the Merkle Path.\n     * @returns {MerklePath} - A new MerklePath instance.\n     */\n    static fromHex(hex) {\n        return MerklePath.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));\n    }\n    static fromReader(reader, legalOffsetsOnly = true) {\n        const blockHeight = reader.readVarIntNum();\n        const treeHeight = reader.readUInt8();\n        // Explicitly define the type of path as an array of arrays of leaf objects\n        const path = Array(treeHeight)\n            .fill(null)\n            .map(() => []);\n        let flags, offset, nLeavesAtThisHeight;\n        for (let level = 0; level < treeHeight; level++) {\n            nLeavesAtThisHeight = reader.readVarIntNum();\n            while (nLeavesAtThisHeight > 0) {\n                offset = reader.readVarIntNum();\n                flags = reader.readUInt8();\n                const leaf = { offset };\n                if ((flags & 1) !== 0) {\n                    leaf.duplicate = true;\n                }\n                else {\n                    if ((flags & 2) !== 0) {\n                        leaf.txid = true;\n                    }\n                    leaf.hash = (0, utils_js_1.toHex)(reader.read(32).reverse());\n                }\n                // Ensure path[level] exists before pushing\n                if (!Array.isArray(path[level]) || path[level].length === 0) {\n                    path[level] = [];\n                }\n                path[level].push(leaf);\n                nLeavesAtThisHeight--;\n            }\n            // Sort the array based on the offset property\n            path[level].sort((a, b) => a.offset - b.offset);\n        }\n        return new MerklePath(blockHeight, path, legalOffsetsOnly);\n    }\n    /**\n     * Creates a MerklePath instance from a binary array.\n     *\n     * @static\n     * @param {number[]} bump - The binary array representation of the Merkle Path.\n     * @returns {MerklePath} - A new MerklePath instance.\n     */\n    static fromBinary(bump) {\n        const reader = new utils_js_1.Reader(bump);\n        return MerklePath.fromReader(reader);\n    }\n    /**\n     *\n     * @static fromCoinbaseTxid\n     *\n     * Creates a MerklePath instance for a coinbase transaction in an empty block.\n     * This edge case is difficult to retrieve from standard APIs.\n     *\n     * @param {string} txid - The coinbase txid.\n     * @param {number} height - The height of the block.\n     * @returns {MerklePath} - A new MerklePath instance which assumes the tx is in a block with no other transactions.\n     */\n    static fromCoinbaseTxidAndHeight(txid, height) {\n        return new MerklePath(height, [[{ offset: 0, hash: txid, txid: true }]]);\n    }\n    constructor(blockHeight, path, legalOffsetsOnly = true) {\n        this.blockHeight = blockHeight;\n        this.path = path;\n        // store all of the legal offsets which we expect given the txid indices.\n        const legalOffsets = Array(this.path.length)\n            .fill(0)\n            .map(() => new Set());\n        this.path.forEach((leaves, height) => {\n            if (leaves.length === 0 && height === 0) {\n                throw new Error(`Empty level at height: ${height}`);\n            }\n            const offsetsAtThisHeight = new Set();\n            leaves.forEach((leaf) => {\n                if (offsetsAtThisHeight.has(leaf.offset)) {\n                    throw new Error(`Duplicate offset: ${leaf.offset}, at height: ${height}`);\n                }\n                offsetsAtThisHeight.add(leaf.offset);\n                if (height === 0) {\n                    if (leaf.duplicate !== true) {\n                        for (let h = 1; h < this.path.length; h++) {\n                            legalOffsets[h].add((leaf.offset >> h) ^ 1);\n                        }\n                    }\n                }\n                else {\n                    if (legalOffsetsOnly && !legalOffsets[height].has(leaf.offset)) {\n                        throw new Error(`Invalid offset: ${leaf.offset}, at height: ${height}, with legal offsets: ${Array.from(legalOffsets[height]).join(', ')}`);\n                    }\n                }\n            });\n        });\n        // every txid must calculate to the same root.\n        let root;\n        this.path[0].forEach((leaf, idx) => {\n            if (idx === 0)\n                root = this.computeRoot(leaf.hash);\n            if (root !== this.computeRoot(leaf.hash)) {\n                throw new Error('Mismatched roots');\n            }\n        });\n    }\n    /**\n     * Converts the MerklePath to a binary array format.\n     *\n     * @returns {number[]} - The binary array representation of the Merkle Path.\n     */\n    toBinary() {\n        const writer = new utils_js_1.Writer();\n        writer.writeVarIntNum(this.blockHeight);\n        const treeHeight = this.path.length;\n        writer.writeUInt8(treeHeight);\n        for (let level = 0; level < treeHeight; level++) {\n            const nLeaves = Object.keys(this.path[level]).length;\n            writer.writeVarIntNum(nLeaves);\n            for (const leaf of this.path[level]) {\n                writer.writeVarIntNum(leaf.offset);\n                let flags = 0;\n                if (leaf?.duplicate === true) {\n                    flags |= 1;\n                }\n                if (leaf?.txid !== undefined && leaf.txid !== null) {\n                    flags |= 2;\n                }\n                writer.writeUInt8(flags);\n                if ((flags & 1) === 0) {\n                    writer.write((0, utils_js_1.toArray)(leaf.hash, 'hex').reverse());\n                }\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * Converts the MerklePath to a hexadecimal string format.\n     *\n     * @returns {string} - The hexadecimal string representation of the Merkle Path.\n     */\n    toHex() {\n        return (0, utils_js_1.toHex)(this.toBinary());\n    }\n    //\n    indexOf(txid) {\n        const leaf = this.path[0].find((l) => l.hash === txid);\n        if (leaf === null || leaf === undefined) {\n            throw new Error(`Transaction ID ${txid} not found in the Merkle Path`);\n        }\n        return leaf.offset;\n    }\n    /**\n     * Computes the Merkle root from the provided transaction ID.\n     *\n     * @param {string} txid - The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!\n     * @returns {string} - The computed Merkle root as a hexadecimal string.\n     * @throws {Error} - If the transaction ID is not part of the Merkle Path.\n     */\n    computeRoot(txid) {\n        if (typeof txid !== 'string') {\n            const foundLeaf = this.path[0].find((leaf) => Boolean(leaf?.hash));\n            if (foundLeaf === null || foundLeaf === undefined) {\n                throw new Error('No valid leaf found in the Merkle Path');\n            }\n            txid = foundLeaf.hash;\n        }\n        // Find the index of the txid at the lowest level of the Merkle tree\n        if (typeof txid !== 'string') {\n            throw new Error('Transaction ID is undefined');\n        }\n        const index = this.indexOf(txid);\n        if (typeof index !== 'number') {\n            throw new Error(`This proof does not contain the txid: ${txid ?? 'undefined'}`);\n        }\n        // Calculate the root using the index as a way to determine which direction to concatenate.\n        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());\n        let workingHash = txid;\n        // special case for blocks with only one transaction\n        if (this.path.length === 1 && this.path[0].length === 1)\n            return workingHash;\n        for (let height = 0; height < this.path.length; height++) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const leaves = this.path[height];\n            const offset = (index >> height) ^ 1;\n            const leaf = this.findOrComputeLeaf(height, offset);\n            if (typeof leaf !== 'object') {\n                throw new Error(`Missing hash for index ${index} at height ${height}`);\n            }\n            if (leaf.duplicate === true) {\n                workingHash = hash((workingHash ?? '') + (workingHash ?? ''));\n            }\n            else if (offset % 2 !== 0) {\n                workingHash = hash((leaf.hash ?? '') + (workingHash ?? ''));\n            }\n            else {\n                workingHash = hash((workingHash ?? '') + (leaf.hash ?? ''));\n            }\n        }\n        return workingHash;\n    }\n    /**\n     * Find leaf with `offset` at `height` or compute from level below, recursively.\n     *\n     * Does not add computed leaves to path.\n     *\n     * @param height\n     * @param offset\n     */\n    findOrComputeLeaf(height, offset) {\n        const hash = (m) => (0, utils_js_1.toHex)((0, Hash_js_1.hash256)((0, utils_js_1.toArray)(m, 'hex').reverse()).reverse());\n        let leaf = this.path[height].find((l) => l.offset === offset);\n        if (leaf != null)\n            return leaf;\n        if (height === 0)\n            return undefined;\n        const h = height - 1;\n        const l = offset << 1;\n        const leaf0 = this.findOrComputeLeaf(h, l);\n        if (leaf0 == null || leaf0.hash == null || leaf0.hash === '')\n            return undefined;\n        const leaf1 = this.findOrComputeLeaf(h, l + 1);\n        if (leaf1 == null)\n            return undefined;\n        let workinghash;\n        if (leaf1.duplicate === true) {\n            workinghash = hash(leaf0.hash + leaf0.hash);\n        }\n        else {\n            workinghash = hash((leaf1.hash ?? '') + (leaf0.hash ?? ''));\n        }\n        leaf = {\n            offset,\n            hash: workinghash\n        };\n        return leaf;\n    }\n    /**\n     * Verifies if the given transaction ID is part of the Merkle tree at the specified block height.\n     *\n     * @param {string} txid - The transaction ID to verify.\n     * @param {ChainTracker} chainTracker - The ChainTracker instance used to verify the Merkle root.\n     * @returns {boolean} - True if the transaction ID is valid within the Merkle Path at the specified block height.\n     */\n    async verify(txid, chainTracker) {\n        const root = this.computeRoot(txid);\n        if (this.indexOf(txid) === 0) {\n            // Coinbase transaction outputs can only be spent once they're 100 blocks deep.\n            const height = await chainTracker.currentHeight();\n            if (this.blockHeight + 100 < height) {\n                return false;\n            }\n        }\n        // Use the chain tracker to determine whether this is a valid merkle root at the given block height\n        return await chainTracker.isValidRootForHeight(root, this.blockHeight);\n    }\n    /**\n     * Combines this MerklePath with another to create a compound proof.\n     *\n     * @param {MerklePath} other - Another MerklePath to combine with this path.\n     * @throws {Error} - If the paths have different block heights or roots.\n     */\n    combine(other) {\n        if (this.blockHeight !== other.blockHeight) {\n            throw new Error('You cannot combine paths which do not have the same block height.');\n        }\n        const root1 = this.computeRoot();\n        const root2 = other.computeRoot();\n        if (root1 !== root2) {\n            throw new Error('You cannot combine paths which do not have the same root.');\n        }\n        const combinedPath = [];\n        for (let h = 0; h < this.path.length; h++) {\n            combinedPath.push([]);\n            for (let l = 0; l < this.path[h].length; l++) {\n                combinedPath[h].push(this.path[h][l]);\n            }\n            for (let l = 0; l < other.path[h].length; l++) {\n                if (combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset) === undefined) {\n                    combinedPath[h].push(other.path[h][l]);\n                }\n                else {\n                    // Ensure that any elements which appear in both are not downgraded to a non txid.\n                    if (other.path[h][l]?.txid !== undefined && other.path[h][l]?.txid !== null) {\n                        const target = combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset);\n                        if (target !== null && target !== undefined) {\n                            target.txid = true;\n                        }\n                    }\n                }\n            }\n        }\n        this.path = combinedPath;\n        this.trim();\n    }\n    /**\n     * Remove all internal nodes that are not required by level zero txid nodes.\n     * Assumes that at least all required nodes are present.\n     * Leaves all levels sorted by increasing offset.\n     */\n    trim() {\n        const pushIfNew = (v, a) => {\n            if (a.length === 0 || a.slice(-1)[0] !== v) {\n                a.push(v);\n            }\n        };\n        const dropOffsetsFromLevel = (dropOffsets, level) => {\n            for (let i = dropOffsets.length; i >= 0; i--) {\n                const l = this.path[level].findIndex((n) => n.offset === dropOffsets[i]);\n                if (l >= 0) {\n                    this.path[level].splice(l, 1);\n                }\n            }\n        };\n        const nextComputedOffsets = (cos) => {\n            const ncos = [];\n            for (const o of cos) {\n                pushIfNew(o >> 1, ncos);\n            }\n            return ncos;\n        };\n        let computedOffsets = []; // in next level\n        let dropOffsets = [];\n        for (let h = 0; h < this.path.length; h++) {\n            // Sort each level by increasing offset order\n            this.path[h].sort((a, b) => a.offset - b.offset);\n        }\n        for (let l = 0; l < this.path[0].length; l++) {\n            const n = this.path[0][l];\n            if (n.txid === true) {\n                // level 0 must enable computing level 1 for txid nodes\n                pushIfNew(n.offset >> 1, computedOffsets);\n            }\n            else {\n                const isOdd = n.offset % 2 === 1;\n                const peer = this.path[0][l + (isOdd ? -1 : 1)];\n                if (peer.txid === undefined || peer.txid === null || !peer.txid) {\n                    // drop non-txid level 0 nodes without a txid peer\n                    pushIfNew(peer.offset, dropOffsets);\n                }\n            }\n        }\n        dropOffsetsFromLevel(dropOffsets, 0);\n        for (let h = 1; h < this.path.length; h++) {\n            dropOffsets = computedOffsets;\n            computedOffsets = nextComputedOffsets(computedOffsets);\n            dropOffsetsFromLevel(dropOffsets, h);\n        }\n    }\n}\nexports[\"default\"] = MerklePath;\n//# sourceMappingURL=MerklePath.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/MerklePath.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst UnlockingScript_js_1 = __importDefault(__webpack_require__(/*! ../script/UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/UnlockingScript.js\"));\nconst LockingScript_js_1 = __importDefault(__webpack_require__(/*! ../script/LockingScript.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/LockingScript.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nconst Hash_js_1 = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Hash.js\");\nconst SatoshisPerKilobyte_js_1 = __importDefault(__webpack_require__(/*! ./fee-models/SatoshisPerKilobyte.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/SatoshisPerKilobyte.js\"));\nconst Spend_js_1 = __importDefault(__webpack_require__(/*! ../script/Spend.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/Spend.js\"));\nconst DefaultBroadcaster_js_1 = __webpack_require__(/*! ./broadcasters/DefaultBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/DefaultBroadcaster.js\");\nconst DefaultChainTracker_js_1 = __webpack_require__(/*! ./chaintrackers/DefaultChainTracker.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/DefaultChainTracker.js\");\nconst Beef_js_1 = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js\");\nconst P2PKH_js_1 = __importDefault(__webpack_require__(/*! ../script/templates/P2PKH.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/script/templates/P2PKH.js\"));\n/**\n * Represents a complete Bitcoin transaction. This class encapsulates all the details\n * required for creating, signing, and processing a Bitcoin transaction, including\n * inputs, outputs, and various transaction-related methods.\n *\n * @class Transaction\n * @property {number} version - The version number of the transaction. Used to specify\n *           which set of rules this transaction follows.\n * @property {TransactionInput[]} inputs - An array of TransactionInput objects, representing\n *           the inputs for the transaction. Each input references a previous transaction's output.\n * @property {TransactionOutput[]} outputs - An array of TransactionOutput objects, representing\n *           the outputs for the transaction. Each output specifies the amount of satoshis to be\n *           transferred and the conditions under which they can be spent.\n * @property {number} lockTime - The lock time of the transaction. If non-zero, it specifies the\n *           earliest time or block height at which the transaction can be added to the block chain.\n * @property {Record<string, any>} metadata - A key-value store for attaching additional data to\n *           the transaction object, not included in the transaction itself. Useful for adding descriptions, internal reference numbers, or other information.\n * @property {MerkleProof} [merklePath] - Optional. A merkle proof demonstrating the transaction's\n *           inclusion in a block. Useful for transaction verification using SPV.\n *\n * @example\n * // Creating a new transaction\n * let tx = new Transaction();\n * tx.addInput(...);\n * tx.addOutput(...);\n * await tx.fee();\n * await tx.sign();\n * await tx.broadcast();\n *\n * @description\n * The Transaction class provides comprehensive\n * functionality to handle various aspects of transaction creation, including\n * adding inputs and outputs, computing fees, signing the transaction, and\n * generating its binary or hexadecimal representation.\n */\nclass Transaction {\n    // Recursive function for adding merkle proofs or input transactions\n    static addPathOrInputs(obj, transactions, BUMPs) {\n        if (typeof obj.pathIndex === 'number') {\n            const path = BUMPs[obj.pathIndex];\n            if (typeof path !== 'object') {\n                throw new Error('Invalid merkle path index found in BEEF!');\n            }\n            obj.tx.merklePath = path;\n        }\n        else {\n            for (const input of obj.tx.inputs) {\n                if (input.sourceTXID === undefined) {\n                    throw new Error('Input sourceTXID is undefined');\n                }\n                const sourceObj = transactions[input.sourceTXID];\n                if (typeof sourceObj !== 'object') {\n                    throw new Error(`Reference to unknown TXID in BEEF: ${input.sourceTXID ?? 'undefined'}`);\n                }\n                input.sourceTransaction = sourceObj.tx;\n                this.addPathOrInputs(sourceObj, transactions, BUMPs);\n            }\n        }\n    }\n    /**\n     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF V1, V2 or Atomic.\n     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.\n     * If the TXID is provided but not found in the BEEF data, an error will be thrown.\n     * If no TXID is provided, the last transaction in the BEEF data is returned, or the atomic txid.\n     * @param beef A binary representation of transactions in BEEF format.\n     * @param txid Optional TXID of the transaction to retrieve from the BEEF data.\n     * @returns An anchored transaction, linked to its associated inputs populated with merkle paths.\n     */\n    static fromBEEF(beef, txid) {\n        const { tx } = Transaction.fromAnyBeef(beef, txid);\n        return tx;\n    }\n    /**\n     * Creates a new transaction from an Atomic BEEF (BRC-95) structure.\n     * Extracts the subject transaction and supporting merkle path and source transactions contained in the BEEF data\n     *\n     * @param beef A binary representation of an Atomic BEEF structure.\n     * @returns The subject transaction, linked to its associated inputs populated with merkle paths.\n     */\n    static fromAtomicBEEF(beef) {\n        const { tx, txid, beef: b } = Transaction.fromAnyBeef(beef);\n        if (txid !== b.atomicTxid) {\n            if (b.atomicTxid != null) {\n                throw new Error(`Transaction with TXID ${b.atomicTxid} not found in BEEF data.`);\n            }\n            else {\n                throw new Error('beef must conform to BRC-95 and must contain the subject txid.');\n            }\n        }\n        return tx;\n    }\n    static fromAnyBeef(beef, txid) {\n        const b = Beef_js_1.Beef.fromBinary(beef);\n        if (b.txs.length < 1) {\n            throw new Error('beef must include at least one transaction.');\n        }\n        const target = txid ?? b.atomicTxid ?? b.txs.slice(-1)[0].txid;\n        const tx = b.findAtomicTransaction(target);\n        if (tx == null) {\n            if (txid != null) {\n                throw new Error(`Transaction with TXID ${target} not found in BEEF data.`);\n            }\n            else {\n                throw new Error('beef does not contain transaction for atomic txid.');\n            }\n        }\n        return { tx, beef: b, txid: target };\n    }\n    /**\n     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.\n     * @param ef A binary representation of a transaction in EF format.\n     * @returns An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.\n     */\n    static fromEF(ef) {\n        const br = new utils_js_1.Reader(ef);\n        const version = br.readUInt32LE();\n        if ((0, utils_js_1.toHex)(br.read(6)) !== '0000000000ef') {\n            throw new Error('Invalid EF marker');\n        }\n        const inputsLength = br.readVarIntNum();\n        const inputs = [];\n        for (let i = 0; i < inputsLength; i++) {\n            const sourceTXID = (0, utils_js_1.toHex)(br.readReverse(32));\n            const sourceOutputIndex = br.readUInt32LE();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const unlockingScript = UnlockingScript_js_1.default.fromBinary(scriptBin);\n            const sequence = br.readUInt32LE();\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const lockingScriptLength = br.readVarIntNum();\n            const lockingScriptBin = br.read(lockingScriptLength);\n            const lockingScript = LockingScript_js_1.default.fromBinary(lockingScriptBin);\n            const sourceTransaction = new Transaction(undefined, [], [], undefined);\n            sourceTransaction.outputs = Array(sourceOutputIndex + 1).fill(null);\n            sourceTransaction.outputs[sourceOutputIndex] = {\n                satoshis,\n                lockingScript\n            };\n            inputs.push({\n                sourceTransaction,\n                sourceTXID,\n                sourceOutputIndex,\n                unlockingScript,\n                sequence\n            });\n        }\n        const outputsLength = br.readVarIntNum();\n        const outputs = [];\n        for (let i = 0; i < outputsLength; i++) {\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const lockingScript = LockingScript_js_1.default.fromBinary(scriptBin);\n            outputs.push({\n                satoshis,\n                lockingScript\n            });\n        }\n        const lockTime = br.readUInt32LE();\n        return new Transaction(version, inputs, outputs, lockTime);\n    }\n    /**\n     * Since the validation of blockchain data is atomically transaction data validation,\n     * any application seeking to validate data in output scripts must store the entire transaction as well.\n     * Since the transaction data includes the output script data, saving a second copy of potentially\n     * large scripts can bloat application storage requirements.\n     *\n     * This function efficiently parses binary transaction data to determine the offsets and lengths of each script.\n     * This supports the efficient retreival of script data from transaction data.\n     *\n     * @param bin binary transaction data\n     * @returns {\n     *   inputs: { vin: number, offset: number, length: number }[]\n     *   outputs: { vout: number, offset: number, length: number }[]\n     * }\n     */\n    static parseScriptOffsets(bin) {\n        const br = new utils_js_1.Reader(bin);\n        const inputs = [];\n        const outputs = [];\n        br.pos += 4; // version\n        const inputsLength = br.readVarIntNum();\n        for (let i = 0; i < inputsLength; i++) {\n            br.pos += 36; // txid and vout\n            const scriptLength = br.readVarIntNum();\n            inputs.push({ vin: i, offset: br.pos, length: scriptLength });\n            br.pos += scriptLength + 4; // script and sequence\n        }\n        const outputsLength = br.readVarIntNum();\n        for (let i = 0; i < outputsLength; i++) {\n            br.pos += 8; // satoshis\n            const scriptLength = br.readVarIntNum();\n            outputs.push({ vout: i, offset: br.pos, length: scriptLength });\n            br.pos += scriptLength;\n        }\n        return { inputs, outputs };\n    }\n    static fromReader(br) {\n        const version = br.readUInt32LE();\n        const inputsLength = br.readVarIntNum();\n        const inputs = [];\n        for (let i = 0; i < inputsLength; i++) {\n            const sourceTXID = (0, utils_js_1.toHex)(br.readReverse(32));\n            const sourceOutputIndex = br.readUInt32LE();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const unlockingScript = UnlockingScript_js_1.default.fromBinary(scriptBin);\n            const sequence = br.readUInt32LE();\n            inputs.push({\n                sourceTXID,\n                sourceOutputIndex,\n                unlockingScript,\n                sequence\n            });\n        }\n        const outputsLength = br.readVarIntNum();\n        const outputs = [];\n        for (let i = 0; i < outputsLength; i++) {\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const lockingScript = LockingScript_js_1.default.fromBinary(scriptBin);\n            outputs.push({\n                satoshis,\n                lockingScript\n            });\n        }\n        const lockTime = br.readUInt32LE();\n        return new Transaction(version, inputs, outputs, lockTime);\n    }\n    /**\n     * Creates a Transaction instance from a binary array.\n     *\n     * @static\n     * @param {number[]} bin - The binary array representation of the transaction.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromBinary(bin) {\n        const br = new utils_js_1.Reader(bin);\n        return Transaction.fromReader(br);\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHex(hex) {\n        return Transaction.fromBinary((0, utils_js_1.toArray)(hex, 'hex'));\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string encoded EF.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction EF.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHexEF(hex) {\n        return Transaction.fromEF((0, utils_js_1.toArray)(hex, 'hex'));\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string encoded BEEF.\n     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.\n     * If the TXID is provided but not found in the BEEF data, an error will be thrown.\n     * If no TXID is provided, the last transaction in the BEEF data is returned.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction BEEF.\n     * @param {string} [txid] - Optional TXID of the transaction to retrieve from the BEEF data.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHexBEEF(hex, txid) {\n        return Transaction.fromBEEF((0, utils_js_1.toArray)(hex, 'hex'), txid);\n    }\n    constructor(version = 1, inputs = [], outputs = [], lockTime = 0, metadata = new Map(), merklePath) {\n        this.version = version;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.lockTime = lockTime;\n        this.metadata = metadata;\n        this.merklePath = merklePath;\n    }\n    /**\n     * Adds a new input to the transaction.\n     *\n     * @param {TransactionInput} input - The TransactionInput object to add to the transaction.\n     * @throws {Error} - If the input does not have a sourceTXID or sourceTransaction defined.\n     */\n    addInput(input) {\n        if (typeof input.sourceTXID === 'undefined' &&\n            typeof input.sourceTransaction === 'undefined') {\n            throw new Error('A reference to an an input transaction is required. If the input transaction itself cannot be referenced, its TXID must still be provided.');\n        }\n        // If the input sequence number hasn't been set, the expectation is that it is final.\n        if (typeof input.sequence === 'undefined') {\n            input.sequence = 0xffffffff;\n        }\n        this.cachedHash = undefined;\n        this.inputs.push(input);\n    }\n    /**\n     * Adds a new output to the transaction.\n     *\n     * @param {TransactionOutput} output - The TransactionOutput object to add to the transaction.\n     */\n    addOutput(output) {\n        this.cachedHash = undefined;\n        if (output.change !== true) {\n            if (typeof output.satoshis === 'undefined') {\n                throw new Error('either satoshis must be defined or change must be set to true');\n            }\n            if (output.satoshis < 0) {\n                throw new Error('satoshis must be a positive integer or zero');\n            }\n        }\n        if (output.lockingScript == null)\n            throw new Error('lockingScript must be defined');\n        this.outputs.push(output);\n    }\n    /**\n     * Adds a new P2PKH output to the transaction.\n     *\n     * @param {number[] | string} address - The P2PKH address of the output.\n     * @param {number} [satoshis] - The number of satoshis to send to the address - if not provided, the output is considered a change output.\n     *\n     */\n    addP2PKHOutput(address, satoshis) {\n        const lockingScript = new P2PKH_js_1.default().lock(address);\n        if (typeof satoshis === 'undefined') {\n            return this.addOutput({ lockingScript, change: true });\n        }\n        this.addOutput({\n            lockingScript,\n            satoshis\n        });\n    }\n    /**\n     * Updates the transaction's metadata.\n     *\n     * @param {Record<string, any>} metadata - The metadata object to merge into the existing metadata.\n     */\n    updateMetadata(metadata) {\n        this.metadata = {\n            ...this.metadata,\n            ...metadata\n        };\n    }\n    /**\n     * Computes fees prior to signing.\n     * If no fee model is provided, uses a SatoshisPerKilobyte fee model that pays 1 sat/kb.\n     * If fee is a number, the transaction uses that value as fee.\n     *\n     * @param modelOrFee - The initialized fee model to use or fixed fee for the transaction\n     * @param changeDistribution - Specifies how the change should be distributed\n     * amongst the change outputs\n     *\n     */\n    async fee(modelOrFee = new SatoshisPerKilobyte_js_1.default(1), changeDistribution = 'equal') {\n        this.cachedHash = undefined;\n        if (typeof modelOrFee === 'number') {\n            const sats = modelOrFee;\n            modelOrFee = {\n                computeFee: async () => sats\n            };\n        }\n        const fee = await modelOrFee.computeFee(this);\n        const change = this.calculateChange(fee);\n        if (change <= 0) {\n            this.outputs = this.outputs.filter((output) => output.change !== true);\n            return;\n        }\n        this.distributeChange(change, changeDistribution);\n    }\n    calculateChange(fee) {\n        let change = 0;\n        for (const input of this.inputs) {\n            if (typeof input.sourceTransaction !== 'object') {\n                throw new Error('Source transactions are required for all inputs during fee computation');\n            }\n            change +=\n                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;\n        }\n        change -= fee;\n        for (const out of this.outputs) {\n            if (out.change !== true) {\n                if (out.satoshis !== undefined) {\n                    change -= out.satoshis;\n                }\n            }\n        }\n        return change;\n    }\n    distributeChange(change, changeDistribution) {\n        let distributedChange = 0;\n        const changeOutputs = this.outputs.filter((out) => out.change);\n        if (changeDistribution === 'random') {\n            distributedChange = this.distributeRandomChange(change, changeOutputs);\n        }\n        else if (changeDistribution === 'equal') {\n            distributedChange = this.distributeEqualChange(change, changeOutputs);\n        }\n        if (distributedChange < change) {\n            const lastOutput = this.outputs[this.outputs.length - 1];\n            if (lastOutput.satoshis !== undefined) {\n                lastOutput.satoshis += change - distributedChange;\n            }\n            else {\n                lastOutput.satoshis = change - distributedChange;\n            }\n        }\n    }\n    distributeRandomChange(change, changeOutputs) {\n        let distributedChange = 0;\n        let changeToUse = change;\n        const benfordNumbers = Array(changeOutputs.length).fill(1);\n        changeToUse -= changeOutputs.length;\n        distributedChange += changeOutputs.length;\n        for (let i = 0; i < changeOutputs.length - 1; i++) {\n            const portion = this.benfordNumber(0, changeToUse);\n            benfordNumbers[i] = benfordNumbers[i] + portion;\n            distributedChange += portion;\n            changeToUse -= portion;\n        }\n        for (const output of this.outputs) {\n            if (output.change === true)\n                output.satoshis = benfordNumbers.shift();\n        }\n        return distributedChange;\n    }\n    distributeEqualChange(change, changeOutputs) {\n        let distributedChange = 0;\n        const perOutput = Math.floor(change / changeOutputs.length);\n        for (const out of changeOutputs) {\n            distributedChange += perOutput;\n            out.satoshis = perOutput;\n        }\n        return distributedChange;\n    }\n    benfordNumber(min, max) {\n        const d = Math.floor(Math.random() * 9) + 1;\n        return Math.floor(min + ((max - min) * Math.log10(1 + 1 / d)) / Math.log10(10));\n    }\n    /**\n     * Utility method that returns the current fee based on inputs and outputs\n     *\n     * @returns The current transaction fee\n     */\n    getFee() {\n        let totalIn = 0;\n        for (const input of this.inputs) {\n            if (typeof input.sourceTransaction !== 'object') {\n                throw new Error('Source transactions or sourceSatoshis are required for all inputs to calculate fee');\n            }\n            totalIn +=\n                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;\n        }\n        let totalOut = 0;\n        for (const output of this.outputs) {\n            totalOut += output.satoshis ?? 0;\n        }\n        return totalIn - totalOut;\n    }\n    /**\n     * Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.\n     */\n    async sign() {\n        this.cachedHash = undefined;\n        for (const out of this.outputs) {\n            if (typeof out.satoshis === 'undefined') {\n                if (out.change === true) {\n                    throw new Error('There are still change outputs with uncomputed amounts. Use the fee() method to compute the change amounts and transaction fees prior to signing.');\n                }\n                else {\n                    throw new Error('One or more transaction outputs is missing an amount. Ensure all output amounts are provided before signing.');\n                }\n            }\n        }\n        const unlockingScripts = await Promise.all(this.inputs.map(async (x, i) => {\n            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {\n                return await this.inputs[i]?.unlockingScriptTemplate?.sign(this, i);\n            }\n            else {\n                return await Promise.resolve(undefined);\n            }\n        }));\n        for (let i = 0, l = this.inputs.length; i < l; i++) {\n            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {\n                this.inputs[i].unlockingScript = unlockingScripts[i];\n            }\n        }\n    }\n    /**\n     * Broadcasts a transaction.\n     *\n     * @param broadcaster The Broadcaster instance wwhere the transaction will be sent\n     * @returns A BroadcastResponse or BroadcastFailure from the Broadcaster\n     */\n    async broadcast(broadcaster = (0, DefaultBroadcaster_js_1.defaultBroadcaster)()) {\n        return await broadcaster.broadcast(this);\n    }\n    /**\n     * Converts the transaction to a binary array format.\n     *\n     * @returns {number[]} - The binary array representation of the transaction.\n     */\n    toBinary() {\n        const writer = new utils_js_1.Writer();\n        writer.writeUInt32LE(this.version);\n        writer.writeVarIntNum(this.inputs.length);\n        for (const i of this.inputs) {\n            if (typeof i.sourceTXID === 'undefined') {\n                if (i.sourceTransaction != null) {\n                    writer.write(i.sourceTransaction.hash());\n                }\n                else {\n                    throw new Error('sourceTransaction is undefined');\n                }\n            }\n            else {\n                writer.writeReverse((0, utils_js_1.toArray)(i.sourceTXID, 'hex'));\n            }\n            writer.writeUInt32LE(i.sourceOutputIndex);\n            if (i.unlockingScript == null) {\n                throw new Error('unlockingScript is undefined');\n            }\n            const scriptBin = i.unlockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n            writer.writeUInt32LE(i.sequence ?? 0);\n        }\n        writer.writeVarIntNum(this.outputs.length);\n        for (const o of this.outputs) {\n            writer.writeUInt64LE(o.satoshis ?? 0);\n            const scriptBin = o.lockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n        }\n        writer.writeUInt32LE(this.lockTime);\n        return writer.toArray();\n    }\n    /**\n     * Converts the transaction to a BRC-30 EF format.\n     *\n     * @returns {number[]} - The BRC-30 EF representation of the transaction.\n     */\n    toEF() {\n        const writer = new utils_js_1.Writer();\n        writer.writeUInt32LE(this.version);\n        writer.write([0, 0, 0, 0, 0, 0xef]);\n        writer.writeVarIntNum(this.inputs.length);\n        for (const i of this.inputs) {\n            if (typeof i.sourceTransaction === 'undefined') {\n                throw new Error('All inputs must have source transactions when serializing to EF format');\n            }\n            if (typeof i.sourceTXID === 'undefined') {\n                writer.write(i.sourceTransaction.hash());\n            }\n            else {\n                writer.write((0, utils_js_1.toArray)(i.sourceTXID, 'hex').reverse());\n            }\n            writer.writeUInt32LE(i.sourceOutputIndex);\n            if (i.unlockingScript == null) {\n                throw new Error('unlockingScript is undefined');\n            }\n            const scriptBin = i.unlockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n            writer.writeUInt32LE(i.sequence ?? 0);\n            writer.writeUInt64LE(i.sourceTransaction.outputs[i.sourceOutputIndex].satoshis ?? 0);\n            const lockingScriptBin = i.sourceTransaction.outputs[i.sourceOutputIndex].lockingScript.toBinary();\n            writer.writeVarIntNum(lockingScriptBin.length);\n            writer.write(lockingScriptBin);\n        }\n        writer.writeVarIntNum(this.outputs.length);\n        for (const o of this.outputs) {\n            writer.writeUInt64LE(o.satoshis ?? 0);\n            const scriptBin = o.lockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n        }\n        writer.writeUInt32LE(this.lockTime);\n        return writer.toArray();\n    }\n    /**\n     * Converts the transaction to a hexadecimal string EF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction EF.\n     */\n    toHexEF() {\n        return (0, utils_js_1.toHex)(this.toEF());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string format.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction.\n     */\n    toHex() {\n        return (0, utils_js_1.toHex)(this.toBinary());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string BEEF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction BEEF.\n     */\n    toHexBEEF() {\n        return (0, utils_js_1.toHex)(this.toBEEF());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string Atomic BEEF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction Atomic BEEF.\n     */\n    toHexAtomicBEEF() {\n        return (0, utils_js_1.toHex)(this.toAtomicBEEF());\n    }\n    /**\n     * Calculates the transaction's hash.\n     *\n     * @param {'hex' | undefined} enc - The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.\n     * @returns {string | number[]} - The hash of the transaction in the specified format.\n     */\n    hash(enc) {\n        let hash;\n        if (this.cachedHash != null) {\n            hash = this.cachedHash;\n        }\n        else {\n            hash = (0, Hash_js_1.hash256)(this.toBinary());\n            this.cachedHash = hash;\n        }\n        if (enc === 'hex') {\n            return (0, utils_js_1.toHex)(hash);\n        }\n        return hash;\n    }\n    /**\n     * Calculates the transaction's ID.\n     *\n     * @param {'hex' | undefined} enc - The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.\n     * @returns {string | number[]} - The ID of the transaction in the specified format.\n     */\n    id(enc) {\n        const id = [...this.hash()];\n        id.reverse();\n        if (enc === 'hex') {\n            return (0, utils_js_1.toHex)(id);\n        }\n        return id;\n    }\n    /**\n     * Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.\n     *\n     * @param chainTracker - An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.\n     * @param feeModel - An instance of FeeModel, a fee model to use for fee calculation. If not provided then the default fee model will be used.\n     * @param memoryLimit - The maximum memory in bytes usage allowed for script evaluation. If not provided then the default memory limit will be used.\n     *\n     * @returns Whether the transaction is valid according to the rules of SPV.\n     *\n     * @example tx.verify(new WhatsOnChain(), new SatoshisPerKilobyte(1))\n     */\n    async verify(chainTracker = (0, DefaultChainTracker_js_1.defaultChainTracker)(), feeModel, memoryLimit) {\n        const verifiedTxids = new Set();\n        const txQueue = [this];\n        while (txQueue.length > 0) {\n            const tx = txQueue.shift();\n            const txid = tx?.id('hex') ?? '';\n            if (txid != null && txid !== '' && verifiedTxids.has(txid)) {\n                continue;\n            }\n            // If the transaction has a valid merkle path, verification is complete.\n            if (typeof tx?.merklePath === 'object') {\n                if (chainTracker === 'scripts only') {\n                    if (txid != null) {\n                        verifiedTxids.add(txid);\n                    }\n                    continue;\n                }\n                else {\n                    const proofValid = await tx.merklePath.verify(txid, chainTracker);\n                    // If the proof is valid, no need to verify inputs.\n                    if (proofValid) {\n                        verifiedTxids.add(txid);\n                        continue;\n                    }\n                }\n            }\n            // Verify fee if feeModel is provided\n            if (typeof feeModel !== 'undefined') {\n                if (tx === undefined) {\n                    throw new Error('Transaction is undefined');\n                }\n                const cpTx = Transaction.fromEF(tx.toEF());\n                delete cpTx.outputs[0].satoshis;\n                cpTx.outputs[0].change = true;\n                await cpTx.fee(feeModel);\n                if (tx.getFee() < cpTx.getFee()) {\n                    throw new Error(`Verification failed because the transaction ${txid} has an insufficient fee and has not been mined.`);\n                }\n            }\n            // Verify each input transaction and evaluate the spend events.\n            // Also, keep a total of the input amounts for later.\n            let inputTotal = 0;\n            if (tx === undefined) {\n                throw new Error('Transaction is undefined');\n            }\n            for (let i = 0; i < tx.inputs.length; i++) {\n                const input = tx.inputs[i];\n                if (typeof input.sourceTransaction !== 'object') {\n                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated source transaction. This source transaction is required for transaction verification because there is no merkle proof for the transaction spending a UTXO it contains.`);\n                }\n                if (typeof input.unlockingScript !== 'object') {\n                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated unlocking script. This script is required for transaction verification because there is no merkle proof for the transaction spending the UTXO.`);\n                }\n                const sourceOutput = input.sourceTransaction.outputs[input.sourceOutputIndex];\n                inputTotal += sourceOutput.satoshis ?? 0;\n                const sourceTxid = input.sourceTransaction.id('hex');\n                if (!verifiedTxids.has(sourceTxid)) {\n                    txQueue.push(input.sourceTransaction);\n                }\n                const otherInputs = tx.inputs.filter((_, idx) => idx !== i);\n                if (typeof input.sourceTXID === 'undefined') {\n                    input.sourceTXID = sourceTxid;\n                }\n                const spend = new Spend_js_1.default({\n                    sourceTXID: input.sourceTXID,\n                    sourceOutputIndex: input.sourceOutputIndex,\n                    lockingScript: sourceOutput.lockingScript,\n                    sourceSatoshis: sourceOutput.satoshis ?? 0,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    unlockingScript: input.unlockingScript,\n                    inputSequence: input.sequence ?? 0,\n                    inputIndex: i,\n                    outputs: tx.outputs,\n                    lockTime: tx.lockTime,\n                    memoryLimit\n                });\n                const spendValid = spend.validate();\n                if (!spendValid) {\n                    return false;\n                }\n            }\n            // Total the outputs to ensure they don't amount to more than the inputs\n            let outputTotal = 0;\n            for (const out of tx.outputs) {\n                if (typeof out.satoshis !== 'number') {\n                    throw new Error('Every output must have a defined amount during transaction verification.');\n                }\n                outputTotal += out.satoshis;\n            }\n            if (outputTotal > inputTotal) {\n                return false;\n            }\n            verifiedTxids.add(txid);\n        }\n        return true;\n    }\n    /**\n     * Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.\n     *\n     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.\n     *\n     * @returns The serialized BEEF structure\n     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.\n     */\n    toBEEF(allowPartial) {\n        const writer = new utils_js_1.Writer();\n        writer.writeUInt32LE(Beef_js_1.BEEF_V1);\n        const BUMPs = [];\n        const txs = [];\n        // Recursive function to add paths and input transactions for a TX\n        const addPathsAndInputs = (tx) => {\n            const obj = { tx };\n            const hasProof = typeof tx.merklePath === 'object';\n            if (hasProof) {\n                let added = false;\n                // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.\n                for (let i = 0; i < BUMPs.length; i++) {\n                    if (BUMPs[i] === tx.merklePath) {\n                        // Literally the same\n                        obj.pathIndex = i;\n                        added = true;\n                        break;\n                    }\n                    if (tx.merklePath !== null && tx.merklePath !== undefined && BUMPs[i].blockHeight === tx.merklePath.blockHeight) {\n                        // Probably the same...\n                        const rootA = BUMPs[i].computeRoot();\n                        const rootB = tx.merklePath.computeRoot();\n                        if (rootA === rootB) {\n                            // Definitely the same... combine them to save space\n                            BUMPs[i].combine(tx.merklePath);\n                            obj.pathIndex = i;\n                            added = true;\n                            break;\n                        }\n                    }\n                }\n                // Finally, if the proof is not yet added, add a new path.\n                if (!added) {\n                    obj.pathIndex = BUMPs.length;\n                    if (tx.merklePath !== null && tx.merklePath !== undefined) {\n                        BUMPs.push(tx.merklePath);\n                    }\n                }\n            }\n            const duplicate = txs.some((x) => x.tx.id('hex') === tx.id('hex'));\n            if (!duplicate) {\n                txs.unshift(obj);\n            }\n            if (!hasProof) {\n                for (let i = 0; i < tx.inputs.length; i++) {\n                    const input = tx.inputs[i];\n                    if (typeof input.sourceTransaction === 'object') {\n                        addPathsAndInputs(input.sourceTransaction);\n                    }\n                    else if (allowPartial === false) {\n                        throw new Error('A required source transaction is missing!');\n                    }\n                }\n            }\n        };\n        addPathsAndInputs(this);\n        writer.writeVarIntNum(BUMPs.length);\n        for (const b of BUMPs) {\n            writer.write(b.toBinary());\n        }\n        writer.writeVarIntNum(txs.length);\n        for (const t of txs) {\n            writer.write(t.tx.toBinary());\n            if (typeof t.pathIndex === 'number') {\n                writer.writeUInt8(1);\n                writer.writeVarIntNum(t.pathIndex);\n            }\n            else {\n                writer.writeUInt8(0);\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * Serializes this transaction and its inputs into the Atomic BEEF (BRC-95) format.\n     * The Atomic BEEF format starts with a 4-byte prefix `0x01010101`, followed by the TXID of the subject transaction,\n     * and then the BEEF data containing only the subject transaction and its dependencies.\n     * This format ensures that the BEEF structure is atomic and contains no unrelated transactions.\n     *\n     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.\n     *\n     * @returns {number[]} - The serialized Atomic BEEF structure.\n     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.\n     */\n    toAtomicBEEF(allowPartial) {\n        const writer = new utils_js_1.Writer();\n        // Write the Atomic BEEF prefix\n        writer.writeUInt32LE(0x01010101);\n        // Write the subject TXID (big-endian)\n        writer.write(this.hash());\n        // Append the BEEF data\n        const beefData = this.toBEEF(allowPartial);\n        writer.write(beefData);\n        return writer.toArray();\n    }\n}\nexports[\"default\"] = Transaction;\n//# sourceMappingURL=Transaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/ARC.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/ARC.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst DefaultHttpClient_js_1 = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js\");\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst utils_js_1 = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\");\nfunction defaultDeploymentId() {\n    return `ts-sdk-${(0, utils_js_1.toHex)((0, Random_js_1.default)(16))}`;\n}\n/**\n * Represents an ARC transaction broadcaster.\n */\nclass ARC {\n    constructor(URL, config) {\n        this.URL = URL;\n        if (typeof config === 'string') {\n            this.apiKey = config;\n            this.httpClient = (0, DefaultHttpClient_js_1.defaultHttpClient)();\n            this.deploymentId = defaultDeploymentId();\n            this.callbackToken = undefined;\n            this.callbackUrl = undefined;\n        }\n        else {\n            const configObj = config ?? {};\n            const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = configObj;\n            this.apiKey = apiKey;\n            this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();\n            this.deploymentId = deploymentId ?? defaultDeploymentId();\n            this.callbackToken = callbackToken;\n            this.callbackUrl = callbackUrl;\n            this.headers = headers;\n        }\n    }\n    /**\n     * Constructs a dictionary of the default & supplied request headers.\n     */\n    requestHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'XDeployment-ID': this.deploymentId\n        };\n        if (this.apiKey != null && this.apiKey !== '') {\n            headers.Authorization = `Bearer ${this.apiKey}`;\n        }\n        if (this.callbackUrl != null && this.callbackUrl !== '') {\n            headers['X-CallbackUrl'] = this.callbackUrl;\n        }\n        if (this.callbackToken != null && this.callbackToken !== '') {\n            headers['X-CallbackToken'] = this.callbackToken;\n        }\n        if (this.headers != null) {\n            for (const key in this.headers) {\n                headers[key] = this.headers[key];\n            }\n        }\n        return headers;\n    }\n    /**\n     * Broadcasts a transaction via ARC.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        let rawTx;\n        try {\n            rawTx = tx.toHexEF();\n        }\n        catch (error) {\n            if (error.message ===\n                'All inputs must have source transactions when serializing to EF format') {\n                rawTx = tx.toHex();\n            }\n            else {\n                throw error;\n            }\n        }\n        const requestOptions = {\n            method: 'POST',\n            headers: this.requestHeaders(),\n            data: { rawTx }\n        };\n        try {\n            const response = await this.httpClient.request(`${this.URL}/v1/tx`, requestOptions);\n            if (response.ok) {\n                const { txid, extraInfo, txStatus, competingTxs } = response.data;\n                const broadcastRes = {\n                    status: 'success',\n                    txid,\n                    message: `${txStatus} ${extraInfo}`\n                };\n                if (competingTxs != null) {\n                    broadcastRes.competingTxs = competingTxs;\n                }\n                return broadcastRes;\n            }\n            else {\n                const st = typeof response.status;\n                const r = {\n                    status: 'error',\n                    code: st === 'number' || st === 'string'\n                        ? response.status.toString()\n                        : 'ERR_UNKNOWN',\n                    description: 'Unknown error'\n                };\n                let d = response.data;\n                if (typeof d === 'string') {\n                    try {\n                        d = JSON.parse(response.data);\n                    }\n                    catch {\n                        // Intentionally left empty\n                    }\n                }\n                if (typeof d === 'object') {\n                    if (d !== null) {\n                        r.more = d;\n                    }\n                    if ((d != null) && typeof d.txid === 'string') {\n                        r.txid = d.txid;\n                    }\n                    if ((d != null) && 'detail' in d && typeof d.detail === 'string') {\n                        r.description = d.detail;\n                    }\n                }\n                return r;\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n    /**\n     * Broadcasts multiple transactions via ARC.\n     * Handles mixed responses where some transactions succeed and others fail.\n     *\n     * @param {Transaction[]} txs - Array of transactions to be broadcasted.\n     * @returns {Promise<Array<object>>} A promise that resolves to an array of objects.\n     */\n    async broadcastMany(txs) {\n        const rawTxs = txs.map((tx) => {\n            try {\n                return { rawTx: tx.toHexEF() };\n            }\n            catch (error) {\n                if (error.message ===\n                    'All inputs must have source transactions when serializing to EF format') {\n                    return { rawTx: tx.toHex() };\n                }\n                throw error;\n            }\n        });\n        const requestOptions = {\n            method: 'POST',\n            headers: this.requestHeaders(),\n            data: rawTxs\n        };\n        try {\n            const response = await this.httpClient.request(`${this.URL}/v1/txs`, requestOptions);\n            return response.data;\n        }\n        catch (error) {\n            const errorResponse = {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string' ? error.message : 'Internal Server Error'\n            };\n            return txs.map(() => errorResponse);\n        }\n    }\n}\nexports[\"default\"] = ARC;\n//# sourceMappingURL=ARC.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/ARC.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/DefaultBroadcaster.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/DefaultBroadcaster.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultBroadcaster = void 0;\nconst ARC_js_1 = __importDefault(__webpack_require__(/*! ./ARC.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/ARC.js\"));\nfunction defaultBroadcaster(isTestnet = false, config = {}) {\n    return new ARC_js_1.default(isTestnet ? 'https://testnet.arc.gorillapool.io' : 'https://arc.gorillapool.io', config);\n}\nexports.defaultBroadcaster = defaultBroadcaster;\n//# sourceMappingURL=DefaultBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/DefaultBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/Teranode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/Teranode.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst index_js_1 = __webpack_require__(/*! ../http/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/index.js\");\n/**\n * Represents an Teranode transaction broadcaster.\n */\nclass Teranode {\n    /**\n     * Constructs an instance of the Teranode broadcaster.\n     *\n     * @param {string} URL - The URL endpoint for the Teranode API.\n     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API, binaryHttpClient by default.\n     */\n    constructor(URL, httpClient = (0, index_js_1.binaryHttpClient)()) {\n        this.URL = URL;\n        this.httpClient = httpClient;\n    }\n    /**\n     * Broadcasts a transaction via Teranode.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        const rawTx = tx.toEF();\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/octet-stream'\n            },\n            data: new Blob([new Uint8Array(rawTx)])\n        };\n        try {\n            const response = await this.httpClient.request(this.URL, requestOptions);\n            if (response.ok) {\n                const txid = tx.id('hex');\n                return {\n                    status: 'success',\n                    txid,\n                    message: 'broadcast successful'\n                };\n            }\n            else {\n                return {\n                    status: 'error',\n                    code: response.status.toString() ?? 'ERR_UNKNOWN',\n                    description: response.data ?? 'Unknown error'\n                };\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n}\nexports[\"default\"] = Teranode;\n//# sourceMappingURL=Teranode.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/Teranode.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/WhatsOnChainBroadcaster.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/WhatsOnChainBroadcaster.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst DefaultHttpClient_js_1 = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js\");\n/**\n * Represents an WhatsOnChain transaction broadcaster.\n */\nclass WhatsOnChainBroadcaster {\n    /**\n     * Constructs an instance of the WhatsOnChain broadcaster.\n     *\n     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.\n     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API.\n     */\n    constructor(network = 'main', httpClient = (0, DefaultHttpClient_js_1.defaultHttpClient)()) {\n        this.network = network;\n        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}/tx/raw`;\n        this.httpClient = httpClient;\n    }\n    /**\n     * Broadcasts a transaction via WhatsOnChain.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        const rawTx = tx.toHex();\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Accept: 'text/plain'\n            },\n            data: { txhex: rawTx }\n        };\n        try {\n            const response = await this.httpClient.request(this.URL, requestOptions);\n            if (response.ok) {\n                const txid = response.data;\n                return {\n                    status: 'success',\n                    txid,\n                    message: 'broadcast successful'\n                };\n            }\n            else {\n                return {\n                    status: 'error',\n                    code: response.status.toString() ?? 'ERR_UNKNOWN',\n                    description: response.data ?? 'Unknown error'\n                };\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n}\nexports[\"default\"] = WhatsOnChainBroadcaster;\n//# sourceMappingURL=WhatsOnChainBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/WhatsOnChainBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/index.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultBroadcaster = exports.Teranode = exports.WhatsOnChainBroadcaster = exports.ARC = void 0;\nvar ARC_js_1 = __webpack_require__(/*! ./ARC.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/ARC.js\");\nObject.defineProperty(exports, \"ARC\", ({ enumerable: true, get: function () { return __importDefault(ARC_js_1).default; } }));\nvar WhatsOnChainBroadcaster_js_1 = __webpack_require__(/*! ./WhatsOnChainBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/WhatsOnChainBroadcaster.js\");\nObject.defineProperty(exports, \"WhatsOnChainBroadcaster\", ({ enumerable: true, get: function () { return __importDefault(WhatsOnChainBroadcaster_js_1).default; } }));\nvar Teranode_js_1 = __webpack_require__(/*! ./Teranode.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/Teranode.js\");\nObject.defineProperty(exports, \"Teranode\", ({ enumerable: true, get: function () { return __importDefault(Teranode_js_1).default; } }));\nvar DefaultBroadcaster_js_1 = __webpack_require__(/*! ./DefaultBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/DefaultBroadcaster.js\");\nObject.defineProperty(exports, \"defaultBroadcaster\", ({ enumerable: true, get: function () { return DefaultBroadcaster_js_1.defaultBroadcaster; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/broadcasters/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/BlockHeadersService.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/BlockHeadersService.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BlockHeadersService = void 0;\nconst DefaultHttpClient_js_1 = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js\");\n/**\n * Represents a chain tracker based on a BlockHeadersService API.\n *\n * @example\n * ```typescript\n * const chainTracker = new BlockHeadersService('https://headers.spv.money', {\n *   apiKey: '17JxRHcJerGBEbusx56W8o1m8Js73TFGo'\n * })\n * ```\n */\nclass BlockHeadersService {\n    /**\n     * Constructs an instance of the BlockHeadersService ChainTracker.\n     *\n     * @param {string} baseUrl - The base URL for the BlockHeadersService API (e.g. https://headers.spv.money)\n     * @param {BlockHeadersServiceConfig} config - Configuration options for the BlockHeadersService ChainTracker.\n     */\n    constructor(baseUrl, config = {}) {\n        const { httpClient, apiKey } = config;\n        this.baseUrl = baseUrl;\n        this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();\n        this.apiKey = apiKey ?? '';\n    }\n    /**\n     * Verifies if a given merkle root is valid for a specific block height.\n     *\n     * @param {string} root - The merkle root to verify.\n     * @param {number} height - The block height to check against.\n     * @returns {Promise<boolean>} - A promise that resolves to true if the merkle root is valid for the specified block height, false otherwise.\n     */\n    async isValidRootForHeight(root, height) {\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`\n            },\n            data: [\n                {\n                    blockHeight: height,\n                    merkleRoot: root\n                }\n            ]\n        };\n        try {\n            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/merkleroot/verify`, requestOptions);\n            if (response.ok) {\n                return response.data.confirmationState === 'CONFIRMED';\n            }\n            else {\n                throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Gets the current block height from the BlockHeadersService API.\n     *\n     * @returns {Promise<number>} - A promise that resolves to the current block height.\n     */\n    async currentHeight() {\n        const requestOptions = {\n            method: 'GET',\n            headers: {\n                'Accept': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`\n            }\n        };\n        try {\n            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/tip/longest`, requestOptions);\n            if (response.ok && response.data && typeof response.data.height === 'number') {\n                return response.data.height;\n            }\n            else {\n                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n}\nexports.BlockHeadersService = BlockHeadersService;\n//# sourceMappingURL=BlockHeadersService.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/BlockHeadersService.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/DefaultChainTracker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/DefaultChainTracker.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultChainTracker = void 0;\nconst WhatsOnChain_js_1 = __importDefault(__webpack_require__(/*! ./WhatsOnChain.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/WhatsOnChain.js\"));\nfunction defaultChainTracker() {\n    return new WhatsOnChain_js_1.default();\n}\nexports.defaultChainTracker = defaultChainTracker;\n//# sourceMappingURL=DefaultChainTracker.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/DefaultChainTracker.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/WhatsOnChain.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/WhatsOnChain.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst DefaultHttpClient_js_1 = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js\");\n/**\n * Represents a chain tracker based on What's On Chain .\n */\nclass WhatsOnChain {\n    /**\n     * Constructs an instance of the WhatsOnChain ChainTracker.\n     *\n     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.\n     * @param {WhatsOnChainConfig} config - Configuration options for the WhatsOnChain ChainTracker.\n     */\n    constructor(network = 'main', config = {}) {\n        const { apiKey, httpClient } = config;\n        this.network = network;\n        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}`;\n        this.httpClient = httpClient ?? (0, DefaultHttpClient_js_1.defaultHttpClient)();\n        this.apiKey = apiKey ?? '';\n    }\n    async isValidRootForHeight(root, height) {\n        const requestOptions = {\n            method: 'GET',\n            headers: this.getHttpHeaders()\n        };\n        const response = await this.httpClient.request(`${this.URL}/block/${height}/header`, requestOptions);\n        if (response.ok) {\n            const { merkleroot } = response.data;\n            return merkleroot === root;\n        }\n        else if (response.status === 404) {\n            return false;\n        }\n        else {\n            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)} `);\n        }\n    }\n    async currentHeight() {\n        try {\n            const requestOptions = {\n                method: 'GET',\n                headers: this.getHttpHeaders()\n            };\n            const response = await this.httpClient.request(`${this.URL}/block/headers`, requestOptions);\n            if (response.ok) {\n                return response.data[0].height;\n            }\n            else {\n                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)} `);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    getHttpHeaders() {\n        const headers = {\n            Accept: 'application/json'\n        };\n        if (typeof this.apiKey === 'string' && this.apiKey.trim() !== '') {\n            headers.Authorization = this.apiKey;\n        }\n        return headers;\n    }\n}\nexports[\"default\"] = WhatsOnChain;\n//# sourceMappingURL=WhatsOnChain.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/WhatsOnChain.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/index.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultChainTracker = exports.BlockHeadersService = exports.WhatsOnChain = void 0;\nvar WhatsOnChain_js_1 = __webpack_require__(/*! ./WhatsOnChain.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/WhatsOnChain.js\");\nObject.defineProperty(exports, \"WhatsOnChain\", ({ enumerable: true, get: function () { return __importDefault(WhatsOnChain_js_1).default; } }));\nvar BlockHeadersService_js_1 = __webpack_require__(/*! ./BlockHeadersService.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/BlockHeadersService.js\");\nObject.defineProperty(exports, \"BlockHeadersService\", ({ enumerable: true, get: function () { return BlockHeadersService_js_1.BlockHeadersService; } }));\nvar DefaultChainTracker_js_1 = __webpack_require__(/*! ./DefaultChainTracker.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/DefaultChainTracker.js\");\nObject.defineProperty(exports, \"defaultChainTracker\", ({ enumerable: true, get: function () { return DefaultChainTracker_js_1.defaultChainTracker; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/chaintrackers/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/SatoshisPerKilobyte.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/SatoshisPerKilobyte.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Represents the \"satoshis per kilobyte\" transaction fee model.\n */\nclass SatoshisPerKilobyte {\n    /**\n     * Constructs an instance of the sat/kb fee model.\n     *\n     * @param {number} value - The number of satoshis per kilobyte to charge as a fee.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Computes the fee for a given transaction.\n     *\n     * @param tx The transaction for which a fee is to be computed.\n     * @returns The fee in satoshis for the transaction, as a BigNumber.\n     */\n    async computeFee(tx) {\n        const getVarIntSize = (i) => {\n            if (i > 2 ** 32) {\n                return 9;\n            }\n            else if (i > 2 ** 16) {\n                return 5;\n            }\n            else if (i > 253) {\n                return 3;\n            }\n            else {\n                return 1;\n            }\n        };\n        // Compute the (potentially estimated) size of the transaction\n        let size = 4; // version\n        size += getVarIntSize(tx.inputs.length); // number of inputs\n        for (let i = 0; i < tx.inputs.length; i++) {\n            const input = tx.inputs[i];\n            size += 40; // txid, output index, sequence number\n            let scriptLength;\n            if (typeof input.unlockingScript === 'object') {\n                scriptLength = input.unlockingScript.toBinary().length;\n            }\n            else if (typeof input.unlockingScriptTemplate === 'object') {\n                scriptLength = await input.unlockingScriptTemplate.estimateLength(tx, i);\n            }\n            else {\n                throw new Error('All inputs must have an unlocking script or an unlocking script template for sat/kb fee computation.');\n            }\n            size += getVarIntSize(scriptLength); // unlocking script length\n            size += scriptLength; // unlocking script\n        }\n        size += getVarIntSize(tx.outputs.length); // number of outputs\n        for (const out of tx.outputs) {\n            size += 8; // satoshis\n            const length = out.lockingScript.toBinary().length;\n            size += getVarIntSize(length); // script length\n            size += length; // script\n        }\n        size += 4; // lock time\n        // We'll use Math.ceil to ensure the miners get the extra satoshi.\n        const fee = Math.ceil((size / 1000) * this.value);\n        return fee;\n    }\n}\nexports[\"default\"] = SatoshisPerKilobyte;\n//# sourceMappingURL=SatoshisPerKilobyte.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/SatoshisPerKilobyte.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SatoshisPerKilobyte = void 0;\nvar SatoshisPerKilobyte_js_1 = __webpack_require__(/*! ./SatoshisPerKilobyte.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/SatoshisPerKilobyte.js\");\nObject.defineProperty(exports, \"SatoshisPerKilobyte\", ({ enumerable: true, get: function () { return __importDefault(SatoshisPerKilobyte_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/fee-models/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/BinaryFetchClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/BinaryFetchClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.binaryHttpClient = exports.BinaryFetchClient = exports.BinaryNodejsHttpClient = void 0;\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass BinaryNodejsHttpClient {\n    constructor(https) {\n        this.https = https;\n    }\n    async request(url, requestOptions) {\n        return await new Promise((resolve, reject) => {\n            const req = this.https.request(url, requestOptions, (res) => {\n                let body = '';\n                res.on('data', (chunk) => {\n                    body += chunk;\n                });\n                res.on('end', () => {\n                    const ok = res.statusCode >= 200 && res.statusCode <= 299;\n                    const mediaType = res.headers['content-type'];\n                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')\n                        ? JSON.parse(body)\n                        : body;\n                    resolve({\n                        status: res.statusCode,\n                        statusText: res.statusMessage,\n                        ok,\n                        data\n                    });\n                });\n            });\n            req.on('error', (error) => {\n                reject(error);\n            });\n            if (requestOptions.data !== null && requestOptions.data !== undefined) {\n                req.write(Buffer.from(requestOptions.data));\n            }\n            req.end();\n        });\n    }\n}\nexports.BinaryNodejsHttpClient = BinaryNodejsHttpClient;\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass BinaryFetchClient {\n    constructor(fetch) {\n        this.fetch = fetch;\n    }\n    async request(url, options) {\n        const fetchOptions = {\n            method: options.method,\n            headers: options.headers,\n            body: options.data\n        };\n        const res = await this.fetch(url, fetchOptions);\n        const data = await res.text();\n        return {\n            ok: res.ok,\n            status: res.status,\n            statusText: res.statusText,\n            data: data\n        };\n    }\n}\nexports.BinaryFetchClient = BinaryFetchClient;\nfunction binaryHttpClient() {\n    const noHttpClient = {\n        async request(..._) {\n            throw new Error('No method available to perform HTTP request');\n        }\n    };\n    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {\n        // Use fetch in a browser environment\n        return new BinaryFetchClient(window.fetch.bind(window));\n    }\n    else if (true) {\n        // Use Node https module\n        // eslint-disable-next-line\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const https = __webpack_require__(/*! https */ \"?0693\");\n            return new BinaryNodejsHttpClient(https);\n        }\n        catch (e) {\n            return noHttpClient;\n        }\n    }\n    else // removed by dead control flow\n{}\n}\nexports.binaryHttpClient = binaryHttpClient;\n//# sourceMappingURL=BinaryFetchClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/BinaryFetchClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultHttpClient = void 0;\nconst NodejsHttpClient_js_1 = __webpack_require__(/*! ./NodejsHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/NodejsHttpClient.js\");\nconst FetchHttpClient_js_1 = __webpack_require__(/*! ./FetchHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/FetchHttpClient.js\");\n/**\n * Returns a default HttpClient implementation based on the environment that it is run on.\n * This method will attempt to use `window.fetch` if available (in browser environments).\n * If running in a Node environment, it falls back to using the Node `https` module\n */\nfunction defaultHttpClient() {\n    const noHttpClient = {\n        async request(..._) {\n            throw new Error('No method available to perform HTTP request');\n        }\n    };\n    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {\n        // Use fetch in a browser environment\n        return new FetchHttpClient_js_1.FetchHttpClient(window.fetch.bind(window));\n    }\n    else if (true) {\n        // Use Node https module\n        // eslint-disable-next-line\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const https = __webpack_require__(/*! https */ \"?0693\");\n            return new NodejsHttpClient_js_1.NodejsHttpClient(https);\n        }\n        catch (e) {\n            return noHttpClient;\n        }\n    }\n    else // removed by dead control flow\n{}\n}\nexports.defaultHttpClient = defaultHttpClient;\n//# sourceMappingURL=DefaultHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/FetchHttpClient.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/FetchHttpClient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchHttpClient = void 0;\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass FetchHttpClient {\n    constructor(fetch) {\n        this.fetch = fetch;\n    }\n    async request(url, options) {\n        const fetchOptions = {\n            method: options.method,\n            headers: options.headers,\n            body: JSON.stringify(options.data)\n        };\n        const res = await this.fetch(url, fetchOptions);\n        const mediaType = res.headers.get('Content-Type');\n        const data = mediaType?.startsWith('application/json') ?? false\n            ? await res.json()\n            : await res.text();\n        return {\n            ok: res.ok,\n            status: res.status,\n            statusText: res.statusText,\n            data: data\n        };\n    }\n}\nexports.FetchHttpClient = FetchHttpClient;\n//# sourceMappingURL=FetchHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/FetchHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/NodejsHttpClient.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/NodejsHttpClient.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NodejsHttpClient = void 0;\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass NodejsHttpClient {\n    constructor(https) {\n        this.https = https;\n    }\n    async request(url, requestOptions) {\n        return await new Promise((resolve, reject) => {\n            const req = this.https.request(url, requestOptions, (res) => {\n                let body = '';\n                res.on('data', (chunk) => {\n                    body += chunk;\n                });\n                res.on('end', () => {\n                    const ok = res.statusCode >= 200 && res.statusCode <= 299;\n                    const mediaType = res.headers['content-type'];\n                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')\n                        ? JSON.parse(body)\n                        : body;\n                    resolve({\n                        status: res.statusCode,\n                        statusText: res.statusMessage,\n                        ok,\n                        data\n                    });\n                });\n            });\n            req.on('error', (error) => {\n                reject(error);\n            });\n            if (requestOptions.data !== null && requestOptions.data !== undefined) {\n                req.write(JSON.stringify(requestOptions.data));\n            }\n            req.end();\n        });\n    }\n}\nexports.NodejsHttpClient = NodejsHttpClient;\n//# sourceMappingURL=NodejsHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/NodejsHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FetchHttpClient = exports.NodejsHttpClient = exports.binaryHttpClient = exports.defaultHttpClient = void 0;\nvar DefaultHttpClient_js_1 = __webpack_require__(/*! ./DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/DefaultHttpClient.js\");\nObject.defineProperty(exports, \"defaultHttpClient\", ({ enumerable: true, get: function () { return DefaultHttpClient_js_1.defaultHttpClient; } }));\nvar BinaryFetchClient_js_1 = __webpack_require__(/*! ./BinaryFetchClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/BinaryFetchClient.js\");\nObject.defineProperty(exports, \"binaryHttpClient\", ({ enumerable: true, get: function () { return BinaryFetchClient_js_1.binaryHttpClient; } }));\nvar NodejsHttpClient_js_1 = __webpack_require__(/*! ./NodejsHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/NodejsHttpClient.js\");\nObject.defineProperty(exports, \"NodejsHttpClient\", ({ enumerable: true, get: function () { return NodejsHttpClient_js_1.NodejsHttpClient; } }));\nvar FetchHttpClient_js_1 = __webpack_require__(/*! ./FetchHttpClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/FetchHttpClient.js\");\nObject.defineProperty(exports, \"FetchHttpClient\", ({ enumerable: true, get: function () { return FetchHttpClient_js_1.FetchHttpClient; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/http/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BeefParty = exports.BeefTx = exports.isBroadcastFailure = exports.isBroadcastResponse = exports.MerklePath = exports.Transaction = void 0;\nvar Transaction_js_1 = __webpack_require__(/*! ./Transaction.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Transaction.js\");\nObject.defineProperty(exports, \"Transaction\", ({ enumerable: true, get: function () { return __importDefault(Transaction_js_1).default; } }));\nvar MerklePath_js_1 = __webpack_require__(/*! ./MerklePath.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/MerklePath.js\");\nObject.defineProperty(exports, \"MerklePath\", ({ enumerable: true, get: function () { return __importDefault(MerklePath_js_1).default; } }));\nvar Broadcaster_js_1 = __webpack_require__(/*! ./Broadcaster.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Broadcaster.js\");\nObject.defineProperty(exports, \"isBroadcastResponse\", ({ enumerable: true, get: function () { return Broadcaster_js_1.isBroadcastResponse; } }));\nObject.defineProperty(exports, \"isBroadcastFailure\", ({ enumerable: true, get: function () { return Broadcaster_js_1.isBroadcastFailure; } }));\nvar BeefTx_js_1 = __webpack_require__(/*! ./BeefTx.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefTx.js\");\nObject.defineProperty(exports, \"BeefTx\", ({ enumerable: true, get: function () { return __importDefault(BeefTx_js_1).default; } }));\n__exportStar(__webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/Beef.js\"), exports);\nvar BeefParty_js_1 = __webpack_require__(/*! ./BeefParty.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/transaction/BeefParty.js\");\nObject.defineProperty(exports, \"BeefParty\", ({ enumerable: true, get: function () { return __importDefault(BeefParty_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/transaction/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/CachedKeyDeriver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/CachedKeyDeriver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst index_js_1 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\nconst KeyDeriver_js_1 = __webpack_require__(/*! ./KeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/KeyDeriver.js\");\n/**\n * A cached version of KeyDeriver that caches the results of key derivation methods.\n * This is useful for optimizing performance when the same keys are derived multiple times.\n * It supports configurable cache size with sane defaults and maintains cache entries using LRU (Least Recently Used) eviction policy.\n */\nclass CachedKeyDeriver {\n    /**\n     * Initializes the CachedKeyDeriver instance with a root private key and optional cache settings.\n     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.\n     * @param {Object} [options] - Optional settings for the cache.\n     * @param {number} [options.maxCacheSize=1000] - The maximum number of entries to store in the cache.\n     */\n    constructor(rootKey, options) {\n        if (rootKey === 'anyone') {\n            this.rootKey = new index_js_1.PrivateKey(1);\n        }\n        else {\n            this.rootKey = rootKey;\n        }\n        this.keyDeriver = new KeyDeriver_js_1.KeyDeriver(this.rootKey, (priv, pub, point) => {\n            this.cacheSet(`${priv.toString()}-${pub.toString()}`, point);\n        }, (priv, pub) => {\n            return this.cacheGet(`${priv.toString()}-${pub.toString()}`);\n        });\n        this.identityKey = this.rootKey.toPublicKey().toString();\n        this.cache = new Map();\n        const maxCacheSize = options?.maxCacheSize;\n        this.maxCacheSize = (maxCacheSize != null && !isNaN(maxCacheSize) && maxCacheSize > 0) ? maxCacheSize : 1000;\n    }\n    /**\n     * Derives a public key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {boolean} [forSelf=false] - Whether deriving for self.\n     * @returns {PublicKey} - The derived public key.\n     */\n    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {\n        const cacheKey = this.generateCacheKey('derivePublicKey', protocolID, keyID, counterparty, forSelf);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.derivePublicKey(protocolID, keyID, counterparty, forSelf);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Derives a private key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PrivateKey} - The derived private key.\n     */\n    derivePrivateKey(protocolID, keyID, counterparty) {\n        const cacheKey = this.generateCacheKey('derivePrivateKey', protocolID, keyID, counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.derivePrivateKey(protocolID, keyID, counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Derives a symmetric key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {SymmetricKey} - The derived symmetric key.\n     * @throws {Error} - Throws an error if attempting to derive a symmetric key for 'anyone'.\n     */\n    deriveSymmetricKey(protocolID, keyID, counterparty) {\n        const cacheKey = this.generateCacheKey('deriveSymmetricKey', protocolID, keyID, counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.deriveSymmetricKey(protocolID, keyID, counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Reveals the shared secret between the root key and the counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {number[]} - The shared secret as a number array.\n     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.\n     */\n    revealCounterpartySecret(counterparty) {\n        const cacheKey = this.generateCacheKey('revealCounterpartySecret', counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.revealCounterpartySecret(counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {number[]} - The specific key association as a number array.\n     */\n    revealSpecificSecret(counterparty, protocolID, keyID) {\n        const cacheKey = this.generateCacheKey('revealSpecificSecret', counterparty, protocolID, keyID);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.revealSpecificSecret(counterparty, protocolID, keyID);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Generates a unique cache key based on the method name and input parameters.\n     * @param {string} methodName - The name of the method.\n     * @param {...any} args - The arguments passed to the method.\n     * @returns {string} - The generated cache key.\n     */\n    generateCacheKey(methodName, ...args) {\n        const serializedArgs = args\n            .map((arg) => this.serializeArgument(arg))\n            .join('|');\n        return `${methodName}|${serializedArgs}`;\n    }\n    /**\n     * Serializes an argument to a string for use in a cache key.\n     * @param {any} arg - The argument to serialize.\n     * @returns {string} - The serialized argument.\n     */\n    serializeArgument(arg) {\n        if (arg instanceof index_js_1.PublicKey || arg instanceof index_js_1.PrivateKey) {\n            return arg.toString();\n        }\n        else if (Array.isArray(arg)) {\n            return arg.map((item) => this.serializeArgument(item)).join(',');\n        }\n        else if (typeof arg === 'object' && arg !== null) {\n            return JSON.stringify(arg);\n        }\n        else {\n            return String(arg);\n        }\n    }\n    /**\n     * Retrieves an item from the cache and updates its position to reflect recent use.\n     * @param {string} cacheKey - The key of the cached item.\n     * @returns {any} - The cached value.\n     */\n    cacheGet(cacheKey) {\n        const value = this.cache.get(cacheKey);\n        // Update the entry to reflect recent use\n        this.cache.delete(cacheKey);\n        if (value !== undefined) {\n            this.cache.set(cacheKey, value);\n        }\n        return value;\n    }\n    /**\n     * Adds an item to the cache and evicts the least recently used item if necessary.\n     * @param {string} cacheKey - The key of the item to cache.\n     * @param {any} value - The value to cache.\n     */\n    cacheSet(cacheKey, value) {\n        if (this.cache.size >= this.maxCacheSize) {\n            // Evict the least recently used item (first item in Map)\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(cacheKey, value);\n    }\n}\nexports[\"default\"] = CachedKeyDeriver;\n//# sourceMappingURL=CachedKeyDeriver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/CachedKeyDeriver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/KeyDeriver.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/KeyDeriver.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.KeyDeriver = void 0;\nconst index_js_1 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\n/**\n * Class responsible for deriving various types of keys using a root private key.\n * It supports deriving public and private keys, symmetric keys, and revealing key linkages.\n */\nclass KeyDeriver {\n    /**\n     * Initializes the KeyDeriver instance with a root private key.\n     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.\n     */\n    constructor(rootKey, cacheSharedSecret, retrieveCachedSharedSecret) {\n        this.cacheSharedSecret = cacheSharedSecret;\n        this.retrieveCachedSharedSecret = retrieveCachedSharedSecret;\n        this.anyone = new index_js_1.PrivateKey(1).toPublicKey();\n        if (rootKey === 'anyone') {\n            this.rootKey = new index_js_1.PrivateKey(1);\n        }\n        else {\n            this.rootKey = rootKey;\n        }\n        this.identityKey = this.rootKey.toPublicKey().toString();\n    }\n    /**\n     * Derives a public key based on protocol ID, key ID, and counterparty.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {boolean} [forSelf=false] - Whether deriving for self.\n     * @returns {PublicKey} - The derived public key.\n     */\n    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        if (forSelf) {\n            return this.rootKey\n                .deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret)\n                .toPublicKey();\n        }\n        else {\n            return counterparty.deriveChild(this.rootKey, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);\n        }\n    }\n    /**\n     * Derives a private key based on protocol ID, key ID, and counterparty.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PrivateKey} - The derived private key.\n     */\n    derivePrivateKey(protocolID, keyID, counterparty) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        return this.rootKey.deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);\n    }\n    /**\n     * Derives a symmetric key based on protocol ID, key ID, and counterparty.\n     * Note: Symmetric keys should not be derivable by everyone due to security risks.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {SymmetricKey} - The derived symmetric key.\n     */\n    deriveSymmetricKey(protocolID, keyID, counterparty) {\n        // If counterparty is 'anyone', we use 1*G as the public key.\n        // This is a publicly derivable key and should only be used in scenarios where public disclosure is intended.\n        if (counterparty === 'anyone') {\n            counterparty = this.anyone;\n        }\n        else {\n            counterparty = this.normalizeCounterparty(counterparty);\n        }\n        const derivedPublicKey = this.derivePublicKey(protocolID, keyID, counterparty);\n        const derivedPrivateKey = this.derivePrivateKey(protocolID, keyID, counterparty);\n        return new index_js_1.SymmetricKey(derivedPrivateKey.deriveSharedSecret(derivedPublicKey)?.x?.toArray() ?? []);\n    }\n    /**\n     * Reveals the shared secret between the root key and the counterparty.\n     * Note: This should not be used for 'self'.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {number[]} - The shared secret as a number array.\n     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.\n     */\n    revealCounterpartySecret(counterparty) {\n        if (counterparty === 'self') {\n            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');\n        }\n        counterparty = this.normalizeCounterparty(counterparty);\n        // Double-check to ensure not revealing the secret for 'self'\n        const self = this.rootKey.toPublicKey();\n        const keyDerivedBySelf = this.rootKey.deriveChild(self, 'test').toHex();\n        const keyDerivedByCounterparty = this.rootKey\n            .deriveChild(counterparty, 'test')\n            .toHex();\n        if (keyDerivedBySelf === keyDerivedByCounterparty) {\n            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');\n        }\n        return this.rootKey\n            .deriveSharedSecret(counterparty)\n            .encode(true);\n    }\n    /**\n     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {number[]} - The specific key association as a number array.\n     */\n    revealSpecificSecret(counterparty, protocolID, keyID) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        const sharedSecret = this.rootKey.deriveSharedSecret(counterparty);\n        const invoiceNumberBin = index_js_1.Utils.toArray(this.computeInvoiceNumber(protocolID, keyID), 'utf8');\n        return index_js_1.Hash.sha256hmac(sharedSecret.encode(true), invoiceNumberBin);\n    }\n    /**\n     * Normalizes the counterparty to a public key.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PublicKey} - The normalized counterparty public key.\n     * @throws {Error} - Throws an error if the counterparty is invalid.\n     */\n    normalizeCounterparty(counterparty) {\n        if (counterparty === null || counterparty === undefined) {\n            throw new Error('counterparty must be self, anyone or a public key!');\n        }\n        else if (counterparty === 'self') {\n            return this.rootKey.toPublicKey();\n        }\n        else if (counterparty === 'anyone') {\n            return new index_js_1.PrivateKey(1).toPublicKey();\n        }\n        else if (typeof counterparty === 'string') {\n            return index_js_1.PublicKey.fromString(counterparty);\n        }\n        else {\n            return counterparty;\n        }\n    }\n    /**\n     * Computes the invoice number based on the protocol ID and key ID.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {string} - The computed invoice number.\n     * @throws {Error} - Throws an error if protocol ID or key ID are invalid.\n     */\n    computeInvoiceNumber(protocolID, keyID) {\n        const securityLevel = protocolID[0];\n        if (!Number.isInteger(securityLevel) ||\n            securityLevel < 0 ||\n            securityLevel > 2) {\n            throw new Error('Protocol security level must be 0, 1, or 2');\n        }\n        const protocolName = protocolID[1].toLowerCase().trim();\n        if (keyID.length > 800) {\n            throw new Error('Key IDs must be 800 characters or less');\n        }\n        if (keyID.length < 1) {\n            throw new Error('Key IDs must be 1 character or more');\n        }\n        if (protocolName.length > 400) {\n            // Specific linkage revelation is the only protocol ID that can contain another protocol ID.\n            // Therefore, we allow it to be long enough to encapsulate the target protocol\n            if (protocolName.startsWith('specific linkage revelation ')) {\n                // The format is: 'specific linkage revelation x YYYYY'\n                // Where: x is the security level and YYYYY is the target protocol\n                // Thus, the max acceptable length is 30 + 400 = 430 bytes\n                if (protocolName.length > 430) {\n                    throw new Error('Specific linkage revelation protocol names must be 430 characters or less');\n                }\n            }\n            else {\n                throw new Error('Protocol names must be 400 characters or less');\n            }\n        }\n        if (protocolName.length < 5) {\n            throw new Error('Protocol names must be 5 characters or more');\n        }\n        if (protocolName.includes('  ')) {\n            throw new Error('Protocol names cannot contain multiple consecutive spaces (\"  \")');\n        }\n        if (!/^[a-z0-9 ]+$/g.test(protocolName)) {\n            throw new Error('Protocol names can only contain letters, numbers and spaces');\n        }\n        if (protocolName.endsWith(' protocol')) {\n            throw new Error('No need to end your protocol name with \" protocol\"');\n        }\n        return `${securityLevel}-${protocolName}-${keyID}`;\n    }\n}\nexports.KeyDeriver = KeyDeriver;\nexports[\"default\"] = KeyDeriver;\n//# sourceMappingURL=KeyDeriver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/KeyDeriver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/ProtoWallet.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/ProtoWallet.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProtoWallet = void 0;\nconst CachedKeyDeriver_js_1 = __importDefault(__webpack_require__(/*! ./CachedKeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/CachedKeyDeriver.js\"));\nconst index_js_1 = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/index.js\");\n/**\n * A ProtoWallet is precursor to a full wallet, capable of performing all foundational cryptographic operations.\n * It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages.\n *\n * However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain,\n * enable the management of identity certificates, or store any data. It is also not concerned with privileged keys.\n */\nclass ProtoWallet {\n    constructor(rootKeyOrKeyDeriver) {\n        if (typeof rootKeyOrKeyDeriver.identityKey !== 'string') {\n            rootKeyOrKeyDeriver = new CachedKeyDeriver_js_1.default(rootKeyOrKeyDeriver);\n        }\n        this.keyDeriver = rootKeyOrKeyDeriver;\n    }\n    async getPublicKey(args) {\n        if (args.identityKey) {\n            if (this.keyDeriver == null) {\n                throw new Error('keyDeriver is undefined');\n            }\n            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };\n        }\n        else {\n            if (args.protocolID == null || args.keyID == null || args.keyID === '') {\n                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');\n            }\n            const keyDeriver = this.keyDeriver ??\n                (() => {\n                    throw new Error('keyDeriver is undefined');\n                })();\n            return {\n                publicKey: keyDeriver\n                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf)\n                    .toString()\n            };\n        }\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        const { publicKey: identityKey } = await this.getPublicKey({\n            identityKey: true\n        });\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);\n        const linkageProof = new index_js_1.Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), index_js_1.PublicKey.fromString(args.counterparty), index_js_1.Point.fromDER(linkage));\n        const linkageProofBin = [\n            ...linkageProof.R.encode(true),\n            ...linkageProof.SPrime.encode(true),\n            ...linkageProof.z.toArray()\n        ];\n        const revelationTime = new Date().toISOString();\n        const { ciphertext: encryptedLinkage } = await this.encrypt({\n            plaintext: linkage,\n            protocolID: [2, 'counterparty linkage revelation'],\n            keyID: revelationTime,\n            counterparty: args.verifier\n        });\n        const { ciphertext: encryptedLinkageProof } = await this.encrypt({\n            plaintext: linkageProofBin,\n            protocolID: [2, 'counterparty linkage revelation'],\n            keyID: revelationTime,\n            counterparty: args.verifier\n        });\n        return {\n            prover: identityKey,\n            verifier: args.verifier,\n            counterparty: args.counterparty,\n            revelationTime,\n            encryptedLinkage,\n            encryptedLinkageProof\n        };\n    }\n    async revealSpecificKeyLinkage(args) {\n        const { publicKey: identityKey } = await this.getPublicKey({\n            identityKey: true\n        });\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);\n        const { ciphertext: encryptedLinkage } = await this.encrypt({\n            plaintext: linkage,\n            protocolID: [\n                2,\n                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`\n            ],\n            keyID: args.keyID,\n            counterparty: args.verifier\n        });\n        const { ciphertext: encryptedLinkageProof } = await this.encrypt({\n            plaintext: [0],\n            protocolID: [\n                2,\n                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`\n            ],\n            keyID: args.keyID,\n            counterparty: args.verifier\n        });\n        return {\n            prover: identityKey,\n            verifier: args.verifier,\n            counterparty: args.counterparty,\n            protocolID: args.protocolID,\n            keyID: args.keyID,\n            encryptedLinkage,\n            encryptedLinkageProof,\n            proofType: 0\n        };\n    }\n    async encrypt(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { ciphertext: key.encrypt(args.plaintext) };\n    }\n    async decrypt(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { plaintext: key.decrypt(args.ciphertext) };\n    }\n    async createHmac(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { hmac: index_js_1.Hash.sha256hmac(key.toArray(), args.data) };\n    }\n    async verifyHmac(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        const valid = index_js_1.Hash.sha256hmac(key.toArray(), args.data).toString() ===\n            args.hmac.toString();\n        if (!valid) {\n            const e = new Error('HMAC is not valid');\n            e.code = 'ERR_INVALID_HMAC';\n            throw e;\n        }\n        return { valid };\n    }\n    async createSignature(args) {\n        if ((args.hashToDirectlySign == null) && (args.data == null)) {\n            throw new Error('args.data or args.hashToDirectlySign must be valid');\n        }\n        const hash = args.hashToDirectlySign ?? index_js_1.Hash.sha256(args.data ?? []);\n        const keyDeriver = this.keyDeriver ??\n            (() => {\n                throw new Error('keyDeriver is undefined');\n            })();\n        const key = keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty ?? 'anyone');\n        return {\n            signature: index_js_1.ECDSA.sign(new index_js_1.BigNumber(hash), key, true).toDER()\n        };\n    }\n    async verifySignature(args) {\n        if ((args.hashToDirectlyVerify == null) && (args.data == null)) {\n            throw new Error('args.data or args.hashToDirectlyVerify must be valid');\n        }\n        const hash = args.hashToDirectlyVerify ?? index_js_1.Hash.sha256(args.data ?? []);\n        const keyDeriver = this.keyDeriver ??\n            (() => {\n                throw new Error('keyDeriver is undefined');\n            })();\n        const key = keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf);\n        const valid = index_js_1.ECDSA.verify(new index_js_1.BigNumber(hash), index_js_1.Signature.fromDER(args.signature), key);\n        if (!valid) {\n            const e = new Error('Signature is not valid');\n            e.code = 'ERR_INVALID_SIGNATURE';\n            throw e;\n        }\n        return { valid };\n    }\n}\nexports.ProtoWallet = ProtoWallet;\nexports[\"default\"] = ProtoWallet;\n//# sourceMappingURL=ProtoWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/ProtoWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/WERR_REVIEW_ACTIONS.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/WERR_REVIEW_ACTIONS.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WERR_REVIEW_ACTIONS = void 0;\n/**\n * When a `createAction` or `signAction` is completed in undelayed mode (`acceptDelayedBroadcast`: false),\n * any unsucccessful result will return the results by way of this exception to ensure attention is\n * paid to processing errors.\n */\nclass WERR_REVIEW_ACTIONS extends Error {\n    /**\n     * All parameters correspond to their comparable `createAction` or `signSction` results\n     * with the exception of `reviewActionResults`;\n     * which contains more details, particularly for double spend results.\n     */\n    constructor(reviewActionResults, sendWithResults, txid, tx, noSendChange) {\n        super('Undelayed createAction or signAction results require review.');\n        this.reviewActionResults = reviewActionResults;\n        this.sendWithResults = sendWithResults;\n        this.txid = txid;\n        this.tx = tx;\n        this.noSendChange = noSendChange;\n        this.isError = true;\n        this.code = 5;\n        this.name = this.constructor.name;\n    }\n}\nexports.WERR_REVIEW_ACTIONS = WERR_REVIEW_ACTIONS;\nexports[\"default\"] = WERR_REVIEW_ACTIONS;\n//# sourceMappingURL=WERR_REVIEW_ACTIONS.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/WERR_REVIEW_ACTIONS.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/Wallet.interfaces.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/Wallet.interfaces.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SecurityLevels = void 0;\n/**\n * @enum {number} SecurityLevels\n *\n * Silent = 0 Silently grants the request with no user interation.\n * App = 1 Requires user approval for every application.\n * Counterparty = 2 Requires user approval per counterparty per application.\n */\nvar SecurityLevels;\n(function (SecurityLevels) {\n    SecurityLevels[SecurityLevels[\"Silent\"] = 0] = \"Silent\";\n    SecurityLevels[SecurityLevels[\"App\"] = 1] = \"App\";\n    SecurityLevels[SecurityLevels[\"Counterparty\"] = 2] = \"Counterparty\";\n})(SecurityLevels || (exports.SecurityLevels = SecurityLevels = {}));\n//# sourceMappingURL=Wallet.interfaces.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/Wallet.interfaces.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletClient.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst window_CWI_js_1 = __importDefault(__webpack_require__(/*! ./substrates/window.CWI.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/window.CWI.js\"));\nconst XDM_js_1 = __importDefault(__webpack_require__(/*! ./substrates/XDM.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/XDM.js\"));\nconst WalletWireTransceiver_js_1 = __importDefault(__webpack_require__(/*! ./substrates/WalletWireTransceiver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireTransceiver.js\"));\nconst HTTPWalletWire_js_1 = __importDefault(__webpack_require__(/*! ./substrates/HTTPWalletWire.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletWire.js\"));\nconst HTTPWalletJSON_js_1 = __importDefault(__webpack_require__(/*! ./substrates/HTTPWalletJSON.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletJSON.js\"));\nconst ReactNativeWebView_js_1 = __importDefault(__webpack_require__(/*! ./substrates/ReactNativeWebView.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/ReactNativeWebView.js\"));\nconst MAX_XDM_RESPONSE_WAIT = 200;\n/**\n * The SDK is how applications communicate with wallets over a communications substrate.\n */\nclass WalletClient {\n    constructor(substrate = 'auto', originator) {\n        if (substrate === 'Cicada') {\n            substrate = new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(originator));\n        }\n        if (substrate === 'window.CWI')\n            substrate = new window_CWI_js_1.default();\n        if (substrate === 'XDM')\n            substrate = new XDM_js_1.default();\n        if (substrate === 'json-api')\n            substrate = new HTTPWalletJSON_js_1.default(originator);\n        if (substrate === 'react-native')\n            substrate = new ReactNativeWebView_js_1.default(originator);\n        this.substrate = substrate;\n        this.originator = originator;\n    }\n    async connectToSubstrate() {\n        if (typeof this.substrate === 'object') {\n            return; // substrate is already connected\n        }\n        let sub;\n        const checkSub = async (timeout) => {\n            let result;\n            if (typeof timeout === 'number') {\n                result = await Promise.race([\n                    sub.getVersion({}),\n                    new Promise((_resolve, reject) => setTimeout(() => reject(new Error('Timed out.')), timeout))\n                ]);\n            }\n            else {\n                result = await sub.getVersion({});\n            }\n            if (typeof result !== 'object' || typeof result.version !== 'string') {\n                throw new Error('Failed to use substrate.');\n            }\n        };\n        try {\n            sub = new window_CWI_js_1.default();\n            await checkSub();\n            this.substrate = sub;\n        }\n        catch (e) {\n            // XDM failed, try the next one...\n            try {\n                sub = new XDM_js_1.default();\n                await checkSub(MAX_XDM_RESPONSE_WAIT);\n                this.substrate = sub;\n            }\n            catch (e) {\n                // HTTP wire failed, move on...\n                try {\n                    sub = new WalletWireTransceiver_js_1.default(new HTTPWalletWire_js_1.default(this.originator));\n                    await checkSub();\n                    this.substrate = sub;\n                }\n                catch (e) {\n                    // HTTP Wire failed, attempt the next...\n                    try {\n                        sub = new HTTPWalletJSON_js_1.default(this.originator);\n                        await checkSub();\n                        this.substrate = sub;\n                    }\n                    catch (e) {\n                        // HTTP JSON failed, attempt the next...\n                        try {\n                            sub = new ReactNativeWebView_js_1.default(this.originator);\n                            await checkSub();\n                            this.substrate = sub;\n                        }\n                        catch (e) {\n                            // No comms. Tell the user to install a BSV wallet.\n                            throw new Error('No wallet available over any communication substrate. Install a BSV wallet today!');\n                        }\n                    }\n                }\n            }\n        }\n    }\n    async createAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createAction(args, this.originator);\n    }\n    async signAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.signAction(args, this.originator);\n    }\n    async abortAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.abortAction(args, this.originator);\n    }\n    async listActions(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listActions(args, this.originator);\n    }\n    async internalizeAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.internalizeAction(args, this.originator);\n    }\n    async listOutputs(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listOutputs(args, this.originator);\n    }\n    async relinquishOutput(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.relinquishOutput(args, this.originator);\n    }\n    async getPublicKey(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.getPublicKey(args, this.originator);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.revealCounterpartyKeyLinkage(args, this.originator);\n    }\n    async revealSpecificKeyLinkage(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.revealSpecificKeyLinkage(args, this.originator);\n    }\n    async encrypt(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.encrypt(args, this.originator);\n    }\n    async decrypt(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.decrypt(args, this.originator);\n    }\n    async createHmac(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createHmac(args, this.originator);\n    }\n    async verifyHmac(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.verifyHmac(args, this.originator);\n    }\n    async createSignature(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createSignature(args, this.originator);\n    }\n    async verifySignature(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.verifySignature(args, this.originator);\n    }\n    async acquireCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.acquireCertificate(args, this.originator);\n    }\n    async listCertificates(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listCertificates(args, this.originator);\n    }\n    async proveCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.proveCertificate(args, this.originator);\n    }\n    async relinquishCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.relinquishCertificate(args, this.originator);\n    }\n    async discoverByIdentityKey(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.discoverByIdentityKey(args, this.originator);\n    }\n    async discoverByAttributes(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.discoverByAttributes(args, this.originator);\n    }\n    async isAuthenticated(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.isAuthenticated(args, this.originator);\n    }\n    async waitForAuthentication(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.waitForAuthentication(args, this.originator);\n    }\n    async getHeight(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getHeight(args, this.originator);\n    }\n    async getHeaderForHeight(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.getHeaderForHeight(args, this.originator);\n    }\n    async getNetwork(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getNetwork(args, this.originator);\n    }\n    async getVersion(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getVersion(args, this.originator);\n    }\n}\nexports[\"default\"] = WalletClient;\n//# sourceMappingURL=WalletClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.walletErrors = exports.WalletError = void 0;\nclass WalletError extends Error {\n    constructor(message, code = 1, stack) {\n        super(message);\n        this.isError = true;\n        this.code = code;\n        this.name = this.constructor.name;\n        if (stack !== undefined && stack !== null && stack !== '') {\n            this.stack = stack;\n        }\n        else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\nexports.WalletError = WalletError;\n// NOTE: Enum values must not exceed the UInt8 range (0255)\nvar walletErrors;\n(function (walletErrors) {\n    walletErrors[walletErrors[\"unknownError\"] = 1] = \"unknownError\";\n    walletErrors[walletErrors[\"unsupportedAction\"] = 2] = \"unsupportedAction\";\n    walletErrors[walletErrors[\"invalidHmac\"] = 3] = \"invalidHmac\";\n    walletErrors[walletErrors[\"invalidSignature\"] = 4] = \"invalidSignature\";\n    walletErrors[walletErrors[\"reviewActions\"] = 5] = \"reviewActions\";\n})(walletErrors || (exports.walletErrors = walletErrors = {}));\nexports[\"default\"] = WalletError;\n//# sourceMappingURL=WalletError.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WERR_REVIEW_ACTIONS = exports.WalletErrors = exports.WalletClient = exports.ProtoWallet = exports.CachedKeyDeriver = void 0;\n__exportStar(__webpack_require__(/*! ./Wallet.interfaces.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/Wallet.interfaces.js\"), exports);\n__exportStar(__webpack_require__(/*! ./KeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/KeyDeriver.js\"), exports);\nvar CachedKeyDeriver_js_1 = __webpack_require__(/*! ./CachedKeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/CachedKeyDeriver.js\");\nObject.defineProperty(exports, \"CachedKeyDeriver\", ({ enumerable: true, get: function () { return __importDefault(CachedKeyDeriver_js_1).default; } }));\nvar ProtoWallet_js_1 = __webpack_require__(/*! ./ProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/ProtoWallet.js\");\nObject.defineProperty(exports, \"ProtoWallet\", ({ enumerable: true, get: function () { return __importDefault(ProtoWallet_js_1).default; } }));\nvar WalletClient_js_1 = __webpack_require__(/*! ./WalletClient.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletClient.js\");\nObject.defineProperty(exports, \"WalletClient\", ({ enumerable: true, get: function () { return __importDefault(WalletClient_js_1).default; } }));\n// Is this an error? should it be 'walletErrors', the enum not the class?\nvar WalletError_js_1 = __webpack_require__(/*! ./WalletError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js\");\nObject.defineProperty(exports, \"WalletErrors\", ({ enumerable: true, get: function () { return __importDefault(WalletError_js_1).default; } }));\nvar WERR_REVIEW_ACTIONS_js_1 = __webpack_require__(/*! ./WERR_REVIEW_ACTIONS.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WERR_REVIEW_ACTIONS.js\");\nObject.defineProperty(exports, \"WERR_REVIEW_ACTIONS\", ({ enumerable: true, get: function () { return __importDefault(WERR_REVIEW_ACTIONS_js_1).default; } }));\n__exportStar(__webpack_require__(/*! ./WalletError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js\"), exports);\n__exportStar(__webpack_require__(/*! ./substrates/index.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletJSON.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletJSON.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst WERR_REVIEW_ACTIONS_js_1 = __webpack_require__(/*! ../WERR_REVIEW_ACTIONS.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WERR_REVIEW_ACTIONS.js\");\nconst toOriginHeader_js_1 = __webpack_require__(/*! ./utils/toOriginHeader.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/utils/toOriginHeader.js\");\nclass HTTPWalletJSON {\n    constructor(originator, baseUrl = 'http://localhost:3321', httpClient = fetch) {\n        this.baseUrl = baseUrl;\n        this.originator = originator;\n        this.httpClient = httpClient;\n        // Detect if we're in a browser environment\n        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window?.origin !== 'file://';\n        this.api = async (call, args) => {\n            // In browser environments, let the browser handle Origin header automatically\n            // In Node.js environments, we need to set it manually if originator is provided\n            const origin = !isBrowser && this.originator\n                ? (0, toOriginHeader_js_1.toOriginHeader)(this.originator, 'http')\n                : undefined;\n            if (!isBrowser && origin === undefined) {\n                console.error('Originator is required in Node.js environments');\n            }\n            const res = await (await httpClient(`${this.baseUrl}/${call}`, {\n                method: 'POST',\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Type': 'application/json',\n                    ...(origin ? { Origin: origin } : {}),\n                    ...(origin ? { Originator: origin } : {}),\n                },\n                body: JSON.stringify(args)\n            }));\n            const data = await res.json();\n            // Check the HTTP status on the original response\n            if (!res.ok) {\n                if (res.status === 400 && data.isError && data.code === 5) {\n                    const err = new WERR_REVIEW_ACTIONS_js_1.WERR_REVIEW_ACTIONS(data.reviewActionResults, data.sendWithResults, data.txid, data.tx, data.noSendChange);\n                    throw err;\n                }\n                else {\n                    const err = {\n                        call,\n                        args,\n                        message: data.message ?? `HTTP Client error ${res.status}`\n                    };\n                    throw new Error(JSON.stringify(err));\n                }\n            }\n            return data;\n        };\n    }\n    async createAction(args) {\n        return await this.api('createAction', args);\n    }\n    async signAction(args) {\n        return await this.api('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.api('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.api('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.api('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.api('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.api('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.api('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.api('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.api('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.api('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.api('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.api('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.api('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.api('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.api('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.api('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.api('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.api('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.api('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.api('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.api('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.api('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.api('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.api('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.api('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.api('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.api('getVersion', args);\n    }\n}\nexports[\"default\"] = HTTPWalletJSON;\n//# sourceMappingURL=HTTPWalletJSON.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletJSON.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletWire.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletWire.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst WalletWireCalls_js_1 = __importDefault(__webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nclass HTTPWalletWire {\n    constructor(originator, baseUrl = 'http://localhost:3301', httpClient = fetch) {\n        this.baseUrl = baseUrl;\n        this.httpClient = httpClient;\n        this.originator = originator;\n    }\n    async transmitToWallet(message) {\n        const messageReader = new Utils.Reader(message);\n        // Read call code\n        const callCode = messageReader.readUInt8();\n        // Map call code to call name\n        const callName = WalletWireCalls_js_1.default[callCode]; // calls is enum\n        if (callName === undefined || callName === '') {\n            // Invalid call code\n            throw new Error(`Invalid call code: ${callCode}`);\n        }\n        // Read originator length\n        const originatorLength = messageReader.readUInt8();\n        let originator;\n        if (originatorLength > 0) {\n            const originatorBytes = messageReader.read(originatorLength);\n            originator = Utils.toUTF8(originatorBytes);\n        }\n        const payload = messageReader.read();\n        const response = await fetch(`${this.baseUrl}/${callName}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/octet-stream',\n                Origin: originator ?? '' //  Explicitly handle null/undefined cases\n            },\n            body: new Uint8Array(payload)\n        });\n        const responseBuffer = await response.arrayBuffer();\n        return Array.from(new Uint8Array(responseBuffer));\n    }\n}\nexports[\"default\"] = HTTPWalletWire;\n//# sourceMappingURL=HTTPWalletWire.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletWire.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/ReactNativeWebView.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/ReactNativeWebView.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst WalletError_js_1 = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js\");\n/**\n * Facilitates wallet operations over cross-document messaging.\n */\nclass ReactNativeWebView {\n    constructor(domain = '*') {\n        if (typeof window !== 'object') {\n            throw new Error('The XDM substrate requires a global window object.');\n        }\n        if (!window.hasOwnProperty(\"ReactNativeWebView\")) {\n            throw new Error('The window object does not have a ReactNativeWebView property.');\n        }\n        if (typeof window.ReactNativeWebView.postMessage !== 'function') {\n            throw new Error('The window.ReactNativeWebView property does not seem to support postMessage calls.');\n        }\n        this.domain = domain;\n    }\n    async invoke(call, args) {\n        return await new Promise((resolve, reject) => {\n            const id = Utils.toBase64((0, Random_js_1.default)(12));\n            const listener = (e) => {\n                const data = JSON.parse(e.data);\n                if (data.type !== 'CWI' ||\n                    data.id !== id ||\n                    data.isInvocation === true) {\n                    return;\n                }\n                if (typeof window.removeEventListener === 'function') {\n                    window.removeEventListener('message', listener);\n                }\n                if (data.status === 'error') {\n                    const err = new WalletError_js_1.WalletError(data.description, data.code);\n                    reject(err);\n                }\n                else {\n                    resolve(data.result);\n                }\n            };\n            window.addEventListener('message', listener);\n            window.ReactNativeWebView.postMessage(JSON.stringify({\n                type: 'CWI',\n                isInvocation: true,\n                id,\n                call,\n                args\n            }));\n        });\n    }\n    async createAction(args) {\n        return await this.invoke('createAction', args);\n    }\n    async signAction(args) {\n        return await this.invoke('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.invoke('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.invoke('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.invoke('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.invoke('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.invoke('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.invoke('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.invoke('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.invoke('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.invoke('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.invoke('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.invoke('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.invoke('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.invoke('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.invoke('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.invoke('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.invoke('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.invoke('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.invoke('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.invoke('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.invoke('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.invoke('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.invoke('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.invoke('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.invoke('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.invoke('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.invoke('getVersion', args);\n    }\n}\nexports[\"default\"] = ReactNativeWebView;\n//# sourceMappingURL=ReactNativeWebView.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/ReactNativeWebView.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWire.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWire.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=WalletWire.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWire.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// NOTE: Enum values must not exceed the UInt8 range (0255)\nvar calls;\n(function (calls) {\n    calls[calls[\"createAction\"] = 1] = \"createAction\";\n    calls[calls[\"signAction\"] = 2] = \"signAction\";\n    calls[calls[\"abortAction\"] = 3] = \"abortAction\";\n    calls[calls[\"listActions\"] = 4] = \"listActions\";\n    calls[calls[\"internalizeAction\"] = 5] = \"internalizeAction\";\n    calls[calls[\"listOutputs\"] = 6] = \"listOutputs\";\n    calls[calls[\"relinquishOutput\"] = 7] = \"relinquishOutput\";\n    calls[calls[\"getPublicKey\"] = 8] = \"getPublicKey\";\n    calls[calls[\"revealCounterpartyKeyLinkage\"] = 9] = \"revealCounterpartyKeyLinkage\";\n    calls[calls[\"revealSpecificKeyLinkage\"] = 10] = \"revealSpecificKeyLinkage\";\n    calls[calls[\"encrypt\"] = 11] = \"encrypt\";\n    calls[calls[\"decrypt\"] = 12] = \"decrypt\";\n    calls[calls[\"createHmac\"] = 13] = \"createHmac\";\n    calls[calls[\"verifyHmac\"] = 14] = \"verifyHmac\";\n    calls[calls[\"createSignature\"] = 15] = \"createSignature\";\n    calls[calls[\"verifySignature\"] = 16] = \"verifySignature\";\n    calls[calls[\"acquireCertificate\"] = 17] = \"acquireCertificate\";\n    calls[calls[\"listCertificates\"] = 18] = \"listCertificates\";\n    calls[calls[\"proveCertificate\"] = 19] = \"proveCertificate\";\n    calls[calls[\"relinquishCertificate\"] = 20] = \"relinquishCertificate\";\n    calls[calls[\"discoverByIdentityKey\"] = 21] = \"discoverByIdentityKey\";\n    calls[calls[\"discoverByAttributes\"] = 22] = \"discoverByAttributes\";\n    calls[calls[\"isAuthenticated\"] = 23] = \"isAuthenticated\";\n    calls[calls[\"waitForAuthentication\"] = 24] = \"waitForAuthentication\";\n    calls[calls[\"getHeight\"] = 25] = \"getHeight\";\n    calls[calls[\"getHeaderForHeight\"] = 26] = \"getHeaderForHeight\";\n    calls[calls[\"getNetwork\"] = 27] = \"getNetwork\";\n    calls[calls[\"getVersion\"] = 28] = \"getVersion\";\n})(calls || (calls = {}));\nexports[\"default\"] = calls;\n//# sourceMappingURL=WalletWireCalls.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireProcessor.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireProcessor.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst WalletWireCalls_js_1 = __importDefault(__webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js\"));\nconst Certificate_js_1 = __importDefault(__webpack_require__(/*! ../../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\"));\n/**\n * Processes incoming wallet calls received over a wallet wire, with a given wallet.\n */\nclass WalletWireProcessor {\n    constructor(wallet) {\n        this.wallet = wallet;\n    }\n    decodeOutpoint(reader) {\n        const txidBytes = reader.read(32);\n        const txid = Utils.toHex(txidBytes);\n        const index = reader.readVarIntNum();\n        return `${txid}.${index}`;\n    }\n    encodeOutpoint(outpoint) {\n        const writer = new Utils.Writer();\n        const [txid, index] = outpoint.split('.');\n        writer.write(Utils.toArray(txid, 'hex'));\n        writer.writeVarIntNum(Number(index));\n        return writer.toArray();\n    }\n    async transmitToWallet(message) {\n        const messageReader = new Utils.Reader(message);\n        try {\n            // Read call code\n            const callCode = messageReader.readUInt8();\n            // Map call code to call name\n            const callName = WalletWireCalls_js_1.default[callCode]; // calls is enum\n            if (callName === undefined || callName === '') {\n                // Invalid call code\n                throw new Error(`Invalid call code: ${callCode}`);\n            }\n            // Read originator length\n            const originatorLength = messageReader.readUInt8();\n            const originatorBytes = messageReader.read(originatorLength);\n            const originator = Utils.toUTF8(originatorBytes);\n            // Read parameters\n            const paramsReader = messageReader; // Remaining bytes\n            switch (callName) {\n                case 'createAction': {\n                    // Deserialize parameters from paramsReader\n                    const args = {};\n                    // Read description\n                    const descriptionLength = paramsReader.readVarIntNum();\n                    const descriptionBytes = paramsReader.read(descriptionLength);\n                    args.description = Utils.toUTF8(descriptionBytes);\n                    // tx\n                    const inputBeefLength = paramsReader.readVarIntNum();\n                    if (inputBeefLength >= 0) {\n                        args.inputBEEF = paramsReader.read(inputBeefLength); // BEEF (Byte[])\n                    }\n                    else {\n                        args.inputBEEF = undefined;\n                    }\n                    // Read inputs\n                    const inputsLength = paramsReader.readVarIntNum();\n                    if (inputsLength >= 0) {\n                        args.inputs = [];\n                        for (let i = 0; i < inputsLength; i++) {\n                            const input = {};\n                            // outpoint\n                            input.outpoint = this.decodeOutpoint(paramsReader);\n                            // unlockingScript / unlockingScriptLength\n                            const unlockingScriptLength = paramsReader.readVarIntNum();\n                            if (unlockingScriptLength >= 0) {\n                                const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);\n                                input.unlockingScript = Utils.toHex(unlockingScriptBytes);\n                            }\n                            else {\n                                input.unlockingScript = undefined;\n                                const unlockingScriptLengthValue = paramsReader.readVarIntNum();\n                                input.unlockingScriptLength = unlockingScriptLengthValue;\n                            }\n                            // inputDescription\n                            const inputDescriptionLength = paramsReader.readVarIntNum();\n                            const inputDescriptionBytes = paramsReader.read(inputDescriptionLength);\n                            input.inputDescription = Utils.toUTF8(inputDescriptionBytes);\n                            // sequenceNumber\n                            const sequenceNumber = paramsReader.readVarIntNum();\n                            if (sequenceNumber >= 0) {\n                                input.sequenceNumber = sequenceNumber;\n                            }\n                            else {\n                                input.sequenceNumber = undefined;\n                            }\n                            args.inputs.push(input);\n                        }\n                    }\n                    else {\n                        args.inputs = undefined;\n                    }\n                    // Read outputs\n                    const outputsLength = paramsReader.readVarIntNum();\n                    if (outputsLength >= 0) {\n                        args.outputs = [];\n                        for (let i = 0; i < outputsLength; i++) {\n                            const output = {};\n                            // lockingScript\n                            const lockingScriptLength = paramsReader.readVarIntNum();\n                            const lockingScriptBytes = paramsReader.read(lockingScriptLength);\n                            output.lockingScript = Utils.toHex(lockingScriptBytes);\n                            // satoshis\n                            output.satoshis = paramsReader.readVarIntNum();\n                            // outputDescription\n                            const outputDescriptionLength = paramsReader.readVarIntNum();\n                            const outputDescriptionBytes = paramsReader.read(outputDescriptionLength);\n                            output.outputDescription = Utils.toUTF8(outputDescriptionBytes);\n                            // basket\n                            const basketLength = paramsReader.readVarIntNum();\n                            if (basketLength >= 0) {\n                                const basketBytes = paramsReader.read(basketLength);\n                                output.basket = Utils.toUTF8(basketBytes);\n                            }\n                            else {\n                                output.basket = undefined;\n                            }\n                            // customInstructions\n                            const customInstructionsLength = paramsReader.readVarIntNum();\n                            if (customInstructionsLength >= 0) {\n                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);\n                                output.customInstructions = Utils.toUTF8(customInstructionsBytes);\n                            }\n                            else {\n                                output.customInstructions = undefined;\n                            }\n                            // tags\n                            const tagsLength = paramsReader.readVarIntNum();\n                            if (tagsLength >= 0) {\n                                output.tags = [];\n                                for (let j = 0; j < tagsLength; j++) {\n                                    const tagLength = paramsReader.readVarIntNum();\n                                    const tagBytes = paramsReader.read(tagLength);\n                                    const tag = Utils.toUTF8(tagBytes);\n                                    output.tags.push(tag);\n                                }\n                            }\n                            else {\n                                output.tags = undefined;\n                            }\n                            args.outputs.push(output);\n                        }\n                    }\n                    else {\n                        args.outputs = undefined;\n                    }\n                    // lockTime\n                    const lockTime = paramsReader.readVarIntNum();\n                    if (lockTime >= 0) {\n                        args.lockTime = lockTime;\n                    }\n                    else {\n                        args.lockTime = undefined;\n                    }\n                    // version\n                    const version = paramsReader.readVarIntNum();\n                    if (version >= 0) {\n                        args.version = version;\n                    }\n                    else {\n                        args.version = undefined;\n                    }\n                    // labels\n                    const labelsLength = paramsReader.readVarIntNum();\n                    if (labelsLength >= 0) {\n                        args.labels = [];\n                        for (let i = 0; i < labelsLength; i++) {\n                            const labelLength = paramsReader.readVarIntNum();\n                            const labelBytes = paramsReader.read(labelLength);\n                            const label = Utils.toUTF8(labelBytes);\n                            args.labels.push(label);\n                        }\n                    }\n                    else {\n                        args.labels = undefined;\n                    }\n                    // options\n                    const optionsPresent = paramsReader.readInt8();\n                    if (optionsPresent === 1) {\n                        args.options = {};\n                        // signAndProcess\n                        const signAndProcessFlag = paramsReader.readInt8();\n                        if (signAndProcessFlag === -1) {\n                            args.options.signAndProcess = undefined;\n                        }\n                        else {\n                            args.options.signAndProcess = signAndProcessFlag === 1;\n                        }\n                        // acceptDelayedBroadcast\n                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();\n                        if (acceptDelayedBroadcastFlag === -1) {\n                            args.options.acceptDelayedBroadcast = undefined;\n                        }\n                        else {\n                            args.options.acceptDelayedBroadcast =\n                                acceptDelayedBroadcastFlag === 1;\n                        }\n                        // trustSelf\n                        const trustSelfFlag = paramsReader.readInt8();\n                        if (trustSelfFlag === -1) {\n                            args.options.trustSelf = undefined;\n                        }\n                        else if (trustSelfFlag === 1) {\n                            args.options.trustSelf = 'known';\n                        }\n                        // knownTxids\n                        const knownTxidsLength = paramsReader.readVarIntNum();\n                        if (knownTxidsLength >= 0) {\n                            args.options.knownTxids = [];\n                            for (let i = 0; i < knownTxidsLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = Utils.toHex(txidBytes);\n                                args.options.knownTxids.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.knownTxids = undefined;\n                        }\n                        // returnTXIDOnly\n                        const returnTXIDOnlyFlag = paramsReader.readInt8();\n                        if (returnTXIDOnlyFlag === -1) {\n                            args.options.returnTXIDOnly = undefined;\n                        }\n                        else {\n                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;\n                        }\n                        // noSend\n                        const noSendFlag = paramsReader.readInt8();\n                        if (noSendFlag === -1) {\n                            args.options.noSend = undefined;\n                        }\n                        else {\n                            args.options.noSend = noSendFlag === 1;\n                        }\n                        // noSendChange\n                        const noSendChangeLength = paramsReader.readVarIntNum();\n                        if (noSendChangeLength >= 0) {\n                            args.options.noSendChange = [];\n                            for (let i = 0; i < noSendChangeLength; i++) {\n                                const outpoint = this.decodeOutpoint(paramsReader);\n                                args.options.noSendChange.push(outpoint);\n                            }\n                        }\n                        else {\n                            args.options.noSendChange = undefined;\n                        }\n                        // sendWith\n                        const sendWithLength = paramsReader.readVarIntNum();\n                        if (sendWithLength >= 0) {\n                            args.options.sendWith = [];\n                            for (let i = 0; i < sendWithLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = Utils.toHex(txidBytes);\n                                args.options.sendWith.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.sendWith = undefined;\n                        }\n                        // randomizeOutputs\n                        const randomizeOutputsFlag = paramsReader.readInt8();\n                        if (randomizeOutputsFlag === -1) {\n                            args.options.randomizeOutputs = undefined;\n                        }\n                        else {\n                            args.options.randomizeOutputs = randomizeOutputsFlag === 1;\n                        }\n                    }\n                    else {\n                        args.options = undefined;\n                    }\n                    // Call the method\n                    const createActionResult = await this.wallet.createAction(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // txid\n                    if (createActionResult.txid != null && createActionResult.txid !== '') {\n                        resultWriter.writeInt8(1);\n                        resultWriter.write(Utils.toArray(createActionResult.txid, 'hex'));\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // tx\n                    if (createActionResult.tx != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(createActionResult.tx.length);\n                        resultWriter.write(createActionResult.tx);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // noSendChange\n                    if (createActionResult.noSendChange != null) {\n                        resultWriter.writeVarIntNum(createActionResult.noSendChange.length);\n                        for (const outpoint of createActionResult.noSendChange) {\n                            resultWriter.write(this.encodeOutpoint(outpoint));\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // sendWithResults\n                    if (createActionResult.sendWithResults != null) {\n                        resultWriter.writeVarIntNum(createActionResult.sendWithResults.length);\n                        for (const result of createActionResult.sendWithResults) {\n                            resultWriter.write(Utils.toArray(result.txid, 'hex'));\n                            let statusCode;\n                            if (result.status === 'unproven')\n                                statusCode = 1;\n                            else if (result.status === 'sending')\n                                statusCode = 2;\n                            else if (result.status === 'failed')\n                                statusCode = 3;\n                            resultWriter.writeInt8(statusCode);\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // signableTransaction\n                    if (createActionResult.signableTransaction != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(createActionResult.signableTransaction.tx.length);\n                        resultWriter.write(createActionResult.signableTransaction.tx);\n                        const referenceBytes = Utils.toArray(createActionResult.signableTransaction.reference, 'base64');\n                        resultWriter.writeVarIntNum(referenceBytes.length);\n                        resultWriter.write(referenceBytes);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'signAction': {\n                    const args = {};\n                    // Deserialize spends\n                    const spendCount = paramsReader.readVarIntNum();\n                    args.spends = {};\n                    for (let i = 0; i < spendCount; i++) {\n                        const inputIndex = paramsReader.readVarIntNum();\n                        const spend = {};\n                        // unlockingScript\n                        const unlockingScriptLength = paramsReader.readVarIntNum();\n                        const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);\n                        spend.unlockingScript = Utils.toHex(unlockingScriptBytes);\n                        // sequenceNumber\n                        const sequenceNumber = paramsReader.readVarIntNum();\n                        if (sequenceNumber >= 0) {\n                            spend.sequenceNumber = sequenceNumber;\n                        }\n                        else {\n                            spend.sequenceNumber = undefined;\n                        }\n                        args.spends[inputIndex] = spend;\n                    }\n                    // Deserialize reference\n                    const referenceLength = paramsReader.readVarIntNum();\n                    const referenceBytes = paramsReader.read(referenceLength);\n                    args.reference = Utils.toBase64(referenceBytes);\n                    // Deserialize options\n                    const optionsPresent = paramsReader.readInt8();\n                    if (optionsPresent === 1) {\n                        args.options = {};\n                        // acceptDelayedBroadcast\n                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();\n                        if (acceptDelayedBroadcastFlag === -1) {\n                            args.options.acceptDelayedBroadcast = undefined;\n                        }\n                        else {\n                            args.options.acceptDelayedBroadcast =\n                                acceptDelayedBroadcastFlag === 1;\n                        }\n                        // returnTXIDOnly\n                        const returnTXIDOnlyFlag = paramsReader.readInt8();\n                        if (returnTXIDOnlyFlag === -1) {\n                            args.options.returnTXIDOnly = undefined;\n                        }\n                        else {\n                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;\n                        }\n                        // noSend\n                        const noSendFlag = paramsReader.readInt8();\n                        if (noSendFlag === -1) {\n                            args.options.noSend = undefined;\n                        }\n                        else {\n                            args.options.noSend = noSendFlag === 1;\n                        }\n                        // sendWith\n                        const sendWithLength = paramsReader.readVarIntNum();\n                        if (sendWithLength >= 0) {\n                            args.options.sendWith = [];\n                            for (let i = 0; i < sendWithLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = Utils.toHex(txidBytes);\n                                args.options.sendWith.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.sendWith = undefined;\n                        }\n                    }\n                    else {\n                        args.options = undefined;\n                    }\n                    // Call the method\n                    const signActionResult = await this.wallet.signAction(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // txid\n                    if (signActionResult.txid != null && signActionResult.txid !== '') {\n                        resultWriter.writeInt8(1);\n                        resultWriter.write(Utils.toArray(signActionResult.txid, 'hex'));\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // tx\n                    if (signActionResult.tx != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(signActionResult.tx.length);\n                        resultWriter.write(signActionResult.tx);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // sendWithResults\n                    if (signActionResult.sendWithResults != null) {\n                        resultWriter.writeVarIntNum(signActionResult.sendWithResults.length);\n                        for (const result of signActionResult.sendWithResults) {\n                            resultWriter.write(Utils.toArray(result.txid, 'hex'));\n                            let statusCode;\n                            if (result.status === 'unproven')\n                                statusCode = 1;\n                            else if (result.status === 'sending')\n                                statusCode = 2;\n                            else if (result.status === 'failed')\n                                statusCode = 3;\n                            resultWriter.writeInt8(statusCode);\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'abortAction': {\n                    // Deserialize reference\n                    const referenceBytes = paramsReader.read();\n                    const reference = Utils.toBase64(referenceBytes);\n                    // Call the method\n                    await this.wallet.abortAction({ reference }, originator);\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'listActions': {\n                    const args = {};\n                    // Deserialize labels\n                    const labelsLength = paramsReader.readVarIntNum();\n                    args.labels = [];\n                    for (let i = 0; i < labelsLength; i++) {\n                        const labelLength = paramsReader.readVarIntNum();\n                        const labelBytes = paramsReader.read(labelLength);\n                        args.labels.push(Utils.toUTF8(labelBytes));\n                    }\n                    // Deserialize labelQueryMode\n                    const labelQueryModeFlag = paramsReader.readInt8();\n                    if (labelQueryModeFlag === -1) {\n                        args.labelQueryMode = undefined;\n                    }\n                    else if (labelQueryModeFlag === 1) {\n                        args.labelQueryMode = 'any';\n                    }\n                    else if (labelQueryModeFlag === 2) {\n                        args.labelQueryMode = 'all';\n                    }\n                    // Deserialize include options\n                    const includeOptionsNames = [\n                        'includeLabels',\n                        'includeInputs',\n                        'includeInputSourceLockingScripts',\n                        'includeInputUnlockingScripts',\n                        'includeOutputs',\n                        'includeOutputLockingScripts'\n                    ];\n                    for (const optionName of includeOptionsNames) {\n                        const optionFlag = paramsReader.readInt8();\n                        if (optionFlag === -1) {\n                            args[optionName] = undefined;\n                        }\n                        else {\n                            args[optionName] = optionFlag === 1;\n                        }\n                    }\n                    // Deserialize limit\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    // Deserialize offset\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const listActionsResult = await this.wallet.listActions(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // totalActions\n                    resultWriter.writeVarIntNum(listActionsResult.totalActions);\n                    // actions\n                    for (const action of listActionsResult.actions) {\n                        // txid\n                        resultWriter.write(Utils.toArray(action.txid, 'hex'));\n                        // satoshis\n                        resultWriter.writeVarIntNum(action.satoshis);\n                        // status\n                        let statusCode;\n                        switch (action.status) {\n                            case 'completed':\n                                statusCode = 1;\n                                break;\n                            case 'unprocessed':\n                                statusCode = 2;\n                                break;\n                            case 'sending':\n                                statusCode = 3;\n                                break;\n                            case 'unproven':\n                                statusCode = 4;\n                                break;\n                            case 'unsigned':\n                                statusCode = 5;\n                                break;\n                            case 'nosend':\n                                statusCode = 6;\n                                break;\n                            case 'nonfinal':\n                                statusCode = 7;\n                                break;\n                            case 'failed':\n                                statusCode = 8;\n                                break;\n                            default:\n                                statusCode = -1;\n                                break;\n                        }\n                        resultWriter.writeInt8(statusCode);\n                        // isOutgoing\n                        resultWriter.writeInt8(action.isOutgoing ? 1 : 0);\n                        // description\n                        const descriptionBytes = Utils.toArray(action.description, 'utf8');\n                        resultWriter.writeVarIntNum(descriptionBytes.length);\n                        resultWriter.write(descriptionBytes);\n                        // labels\n                        if (action.labels !== undefined) {\n                            resultWriter.writeVarIntNum(action.labels.length);\n                            for (const label of action.labels) {\n                                const labelBytes = Utils.toArray(label, 'utf8');\n                                resultWriter.writeVarIntNum(labelBytes.length);\n                                resultWriter.write(labelBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // version\n                        resultWriter.writeVarIntNum(action.version);\n                        // lockTime\n                        resultWriter.writeVarIntNum(action.lockTime);\n                        // inputs\n                        if (action.inputs !== undefined) {\n                            resultWriter.writeVarIntNum(action.inputs.length);\n                            for (const input of action.inputs) {\n                                // sourceOutpoint\n                                resultWriter.write(this.encodeOutpoint(input.sourceOutpoint));\n                                // sourceSatoshis\n                                resultWriter.writeVarIntNum(input.sourceSatoshis);\n                                // sourceLockingScript\n                                if (input.sourceLockingScript !== undefined) {\n                                    const sourceLockingScriptBytes = Utils.toArray(input.sourceLockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(sourceLockingScriptBytes.length);\n                                    resultWriter.write(sourceLockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // unlockingScript\n                                if (input.unlockingScript !== undefined) {\n                                    const unlockingScriptBytes = Utils.toArray(input.unlockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(unlockingScriptBytes.length);\n                                    resultWriter.write(unlockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // inputDescription\n                                const inputDescriptionBytes = Utils.toArray(input.inputDescription, 'utf8');\n                                resultWriter.writeVarIntNum(inputDescriptionBytes.length);\n                                resultWriter.write(inputDescriptionBytes);\n                                // sequenceNumber\n                                resultWriter.writeVarIntNum(input.sequenceNumber);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // outputs\n                        if (action.outputs !== undefined) {\n                            resultWriter.writeVarIntNum(action.outputs.length);\n                            for (const output of action.outputs) {\n                                // outputIndex\n                                resultWriter.writeVarIntNum(output.outputIndex);\n                                // satoshis\n                                resultWriter.writeVarIntNum(output.satoshis);\n                                // lockingScript\n                                if (output.lockingScript !== undefined) {\n                                    const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(lockingScriptBytes.length);\n                                    resultWriter.write(lockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // spendable\n                                resultWriter.writeInt8(output.spendable ? 1 : 0);\n                                // outputDescription\n                                const outputDescriptionBytes = Utils.toArray(output.outputDescription, 'utf8');\n                                resultWriter.writeVarIntNum(outputDescriptionBytes.length);\n                                resultWriter.write(outputDescriptionBytes);\n                                // basket\n                                if (output.basket !== undefined) {\n                                    const basketBytes = Utils.toArray(output.basket, 'utf8');\n                                    resultWriter.writeVarIntNum(basketBytes.length);\n                                    resultWriter.write(basketBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // tags\n                                if (output.tags !== undefined) {\n                                    resultWriter.writeVarIntNum(output.tags.length);\n                                    for (const tag of output.tags) {\n                                        const tagBytes = Utils.toArray(tag, 'utf8');\n                                        resultWriter.writeVarIntNum(tagBytes.length);\n                                        resultWriter.write(tagBytes);\n                                    }\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // customInstructions\n                                if (output.customInstructions !== undefined) {\n                                    const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');\n                                    resultWriter.writeVarIntNum(customInstructionsBytes.length);\n                                    resultWriter.write(customInstructionsBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                    }\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'internalizeAction': {\n                    const args = {};\n                    // Read tx\n                    const txLength = paramsReader.readVarIntNum();\n                    args.tx = paramsReader.read(txLength);\n                    // Read outputs\n                    const outputsLength = paramsReader.readVarIntNum();\n                    args.outputs = [];\n                    for (let i = 0; i < outputsLength; i++) {\n                        const output = {};\n                        // outputIndex\n                        output.outputIndex = paramsReader.readVarIntNum();\n                        // protocol\n                        const protocolFlag = paramsReader.readUInt8();\n                        if (protocolFlag === 1) {\n                            output.protocol = 'wallet payment';\n                            output.paymentRemittance = {};\n                            // senderIdentityKey\n                            const senderIdentityKeyBytes = paramsReader.read(33);\n                            output.paymentRemittance.senderIdentityKey = Utils.toHex(senderIdentityKeyBytes);\n                            // derivationPrefix\n                            const derivationPrefixLength = paramsReader.readVarIntNum();\n                            const derivationPrefixBytes = paramsReader.read(derivationPrefixLength);\n                            output.paymentRemittance.derivationPrefix = Utils.toBase64(derivationPrefixBytes);\n                            // derivationSuffix\n                            const derivationSuffixLength = paramsReader.readVarIntNum();\n                            const derivationSuffixBytes = paramsReader.read(derivationSuffixLength);\n                            output.paymentRemittance.derivationSuffix = Utils.toBase64(derivationSuffixBytes);\n                        }\n                        else if (protocolFlag === 2) {\n                            output.protocol = 'basket insertion';\n                            output.insertionRemittance = {};\n                            // basket\n                            const basketLength = paramsReader.readVarIntNum();\n                            const basketBytes = paramsReader.read(basketLength);\n                            output.insertionRemittance.basket = Utils.toUTF8(basketBytes);\n                            // customInstructions\n                            const customInstructionsLength = paramsReader.readVarIntNum();\n                            if (customInstructionsLength >= 0) {\n                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);\n                                output.insertionRemittance.customInstructions = Utils.toUTF8(customInstructionsBytes);\n                            }\n                            // tags\n                            const tagsLength = paramsReader.readVarIntNum();\n                            if (tagsLength > 0) {\n                                output.insertionRemittance.tags = [];\n                                for (let j = 0; j < tagsLength; j++) {\n                                    const tagLength = paramsReader.readVarIntNum();\n                                    const tagBytes = paramsReader.read(tagLength);\n                                    output.insertionRemittance.tags.push(Utils.toUTF8(tagBytes));\n                                }\n                            }\n                            else {\n                                output.insertionRemittance.tags = [];\n                            }\n                        }\n                        args.outputs.push(output);\n                    }\n                    const numberOfLabels = paramsReader.readVarIntNum();\n                    if (numberOfLabels >= 0) {\n                        args.labels = [];\n                        for (let i = 0; i < numberOfLabels; i++) {\n                            const labelLength = paramsReader.readVarIntNum();\n                            args.labels.push(Utils.toUTF8(paramsReader.read(labelLength)));\n                        }\n                    }\n                    const descriptionLength = paramsReader.readVarIntNum();\n                    args.description = Utils.toUTF8(paramsReader.read(descriptionLength));\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.internalizeAction(args, originator);\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'listOutputs': {\n                    const args = {};\n                    // Deserialize basket\n                    const basketLength = paramsReader.readVarIntNum();\n                    const basketBytes = paramsReader.read(basketLength);\n                    args.basket = Utils.toUTF8(basketBytes);\n                    // Deserialize tags\n                    const tagsLength = paramsReader.readVarIntNum();\n                    if (tagsLength > 0) {\n                        args.tags = [];\n                        for (let i = 0; i < tagsLength; i++) {\n                            const tagLength = paramsReader.readVarIntNum();\n                            const tagBytes = paramsReader.read(tagLength);\n                            args.tags.push(Utils.toUTF8(tagBytes));\n                        }\n                    }\n                    else {\n                        args.tags = undefined;\n                    }\n                    // Deserialize tagQueryMode\n                    const tagQueryModeFlag = paramsReader.readInt8();\n                    if (tagQueryModeFlag === 1) {\n                        args.tagQueryMode = 'all';\n                    }\n                    else if (tagQueryModeFlag === 2) {\n                        args.tagQueryMode = 'any';\n                    }\n                    else {\n                        args.tagQueryMode = undefined;\n                    }\n                    // Deserialize include\n                    const includeFlag = paramsReader.readInt8();\n                    if (includeFlag === 1) {\n                        args.include = 'locking scripts';\n                    }\n                    else if (includeFlag === 2) {\n                        args.include = 'entire transactions';\n                    }\n                    else {\n                        args.include = undefined;\n                    }\n                    // Deserialize includeCustomInstructions\n                    const includeCustomInstructionsFlag = paramsReader.readInt8();\n                    if (includeCustomInstructionsFlag === -1) {\n                        args.includeCustomInstructions = undefined;\n                    }\n                    else {\n                        args.includeCustomInstructions =\n                            includeCustomInstructionsFlag === 1;\n                    }\n                    // Deserialize includeTags\n                    const includeTagsFlag = paramsReader.readInt8();\n                    if (includeTagsFlag === -1) {\n                        args.includeTags = undefined;\n                    }\n                    else {\n                        args.includeTags = includeTagsFlag === 1;\n                    }\n                    // Deserialize includeLabels\n                    const includeLabelsFlag = paramsReader.readInt8();\n                    if (includeLabelsFlag === -1) {\n                        args.includeLabels = undefined;\n                    }\n                    else {\n                        args.includeLabels = includeLabelsFlag === 1;\n                    }\n                    // Deserialize limit\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    // Deserialize offset\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const listOutputsResult = await this.wallet.listOutputs(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // totalOutputs\n                    resultWriter.writeVarIntNum(listOutputsResult.totalOutputs);\n                    // BEEF length and BEEF or -1\n                    if (listOutputsResult.BEEF != null) {\n                        resultWriter.writeVarIntNum(listOutputsResult.BEEF.length);\n                        resultWriter.write(listOutputsResult.BEEF);\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // outputs\n                    for (const output of listOutputsResult.outputs) {\n                        // outpoint\n                        resultWriter.write(this.encodeOutpoint(output.outpoint));\n                        // satoshis\n                        resultWriter.writeVarIntNum(output.satoshis);\n                        // lockingScript\n                        if (output.lockingScript !== undefined) {\n                            const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');\n                            resultWriter.writeVarIntNum(lockingScriptBytes.length);\n                            resultWriter.write(lockingScriptBytes);\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // customInstructions\n                        if (output.customInstructions !== undefined) {\n                            const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');\n                            resultWriter.writeVarIntNum(customInstructionsBytes.length);\n                            resultWriter.write(customInstructionsBytes);\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // tags\n                        if (output.tags !== undefined) {\n                            resultWriter.writeVarIntNum(output.tags.length);\n                            for (const tag of output.tags) {\n                                const tagBytes = Utils.toArray(tag, 'utf8');\n                                resultWriter.writeVarIntNum(tagBytes.length);\n                                resultWriter.write(tagBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // labels\n                        if (output.labels !== undefined) {\n                            resultWriter.writeVarIntNum(output.labels.length);\n                            for (const label of output.labels) {\n                                const labelBytes = Utils.toArray(label, 'utf8');\n                                resultWriter.writeVarIntNum(labelBytes.length);\n                                resultWriter.write(labelBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                    }\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'relinquishOutput': {\n                    const args = {};\n                    // Deserialize basket\n                    const basketLength = paramsReader.readVarIntNum();\n                    const basketBytes = paramsReader.read(basketLength);\n                    args.basket = Utils.toUTF8(basketBytes);\n                    // Deserialize outpoint\n                    args.output = this.decodeOutpoint(paramsReader);\n                    // Call the method\n                    await this.wallet.relinquishOutput(args, originator);\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'getPublicKey': {\n                    const args = {};\n                    // Deserialize identityKey flag\n                    const identityKeyFlag = paramsReader.readUInt8();\n                    args.identityKey = identityKeyFlag === 1;\n                    if (args.identityKey !== true) {\n                        // Deserialize protocolID\n                        args.protocolID = this.decodeProtocolID(paramsReader);\n                        // Deserialize keyID\n                        args.keyID = this.decodeString(paramsReader);\n                        // Deserialize counterparty\n                        args.counterparty = this.decodeCounterparty(paramsReader);\n                        // Deserialize privilege parameters\n                        const privilegedFlag = paramsReader.readInt8();\n                        if (privilegedFlag === -1) {\n                            args.privileged = undefined;\n                        }\n                        else {\n                            args.privileged = privilegedFlag === 1;\n                        }\n                        const privilegedReasonLength = paramsReader.readInt8();\n                        if (privilegedReasonLength !== -1) {\n                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                        }\n                        else {\n                            args.privilegedReason = undefined;\n                        }\n                        // Deserialize forSelf\n                        const forSelfFlag = paramsReader.readInt8();\n                        if (forSelfFlag === -1) {\n                            args.forSelf = undefined;\n                        }\n                        else {\n                            args.forSelf = forSelfFlag === 1;\n                        }\n                    }\n                    else {\n                        // Deserialize privilege parameters\n                        const privilegedFlag = paramsReader.readInt8();\n                        if (privilegedFlag === -1) {\n                            args.privileged = undefined;\n                        }\n                        else {\n                            args.privileged = privilegedFlag === 1;\n                        }\n                        const privilegedReasonLength = paramsReader.readInt8();\n                        if (privilegedReasonLength !== -1) {\n                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                        }\n                        else {\n                            args.privilegedReason = undefined;\n                        }\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const getPublicKeyResult = await this.wallet.getPublicKey(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const publicKeyBytes = Utils.toArray(getPublicKeyResult.publicKey, 'hex');\n                    responseWriter.write(publicKeyBytes);\n                    return responseWriter.toArray();\n                }\n                case 'encrypt': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize plaintext\n                    const plaintextLength = paramsReader.readVarIntNum();\n                    args.plaintext = paramsReader.read(plaintextLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const encryptResult = await this.wallet.encrypt(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(encryptResult.ciphertext);\n                    return responseWriter.toArray();\n                }\n                case 'decrypt': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize ciphertext\n                    const ciphertextLength = paramsReader.readVarIntNum();\n                    args.ciphertext = paramsReader.read(ciphertextLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const decryptResult = await this.wallet.decrypt(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(decryptResult.plaintext);\n                    return responseWriter.toArray();\n                }\n                case 'createHmac': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize data\n                    const dataLength = paramsReader.readVarIntNum();\n                    args.data = paramsReader.read(dataLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const createHmacResult = await this.wallet.createHmac(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(createHmacResult.hmac);\n                    return responseWriter.toArray();\n                }\n                case 'verifyHmac': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize hmac\n                    args.hmac = paramsReader.read(32);\n                    // Deserialize data\n                    const dataLength = paramsReader.readVarIntNum();\n                    args.data = paramsReader.read(dataLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.verifyHmac(args, originator);\n                    // Serialize the result (no data to return)\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'createSignature': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize data or hashToDirectlySign\n                    const dataTypeFlag = paramsReader.readUInt8();\n                    if (dataTypeFlag === 1) {\n                        const dataLength = paramsReader.readVarIntNum();\n                        args.data = paramsReader.read(dataLength);\n                    }\n                    else if (dataTypeFlag === 2) {\n                        args.hashToDirectlySign = paramsReader.read(32);\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const createSignatureResult = await this.wallet.createSignature(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(createSignatureResult.signature);\n                    return responseWriter.toArray();\n                }\n                case 'verifySignature': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize forSelf\n                    const forSelfFlag = paramsReader.readInt8();\n                    if (forSelfFlag === -1) {\n                        args.forSelf = undefined;\n                    }\n                    else {\n                        args.forSelf = forSelfFlag === 1;\n                    }\n                    // Deserialize signature\n                    const signatureLength = paramsReader.readVarIntNum();\n                    args.signature = paramsReader.read(signatureLength);\n                    // Deserialize data or hashToDirectlyVerify\n                    const dataTypeFlag = paramsReader.readUInt8();\n                    if (dataTypeFlag === 1) {\n                        const dataLength = paramsReader.readVarIntNum();\n                        args.data = paramsReader.read(dataLength);\n                    }\n                    else if (dataTypeFlag === 2) {\n                        args.hashToDirectlyVerify = paramsReader.read(32);\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.verifySignature(args, originator);\n                    // Serialize the result (no data to return)\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'isAuthenticated': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const isAuthenticatedResult = await this.wallet.isAuthenticated({}, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeUInt8(isAuthenticatedResult.authenticated ? 1 : 0);\n                    return responseWriter.toArray();\n                }\n                case 'waitForAuthentication': {\n                    // No parameters to deserialize\n                    // Call the method\n                    await this.wallet.waitForAuthentication({}, originator);\n                    // Serialize the result (authenticated is always true)\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'getHeight': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getHeightResult = await this.wallet.getHeight({}, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeVarIntNum(getHeightResult.height);\n                    return responseWriter.toArray();\n                }\n                case 'getHeaderForHeight': {\n                    const args = {};\n                    // Deserialize height\n                    args.height = paramsReader.readVarIntNum();\n                    // Call the method\n                    const getHeaderResult = await this.wallet.getHeaderForHeight(args, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const headerBytes = Utils.toArray(getHeaderResult.header, 'hex');\n                    responseWriter.write(headerBytes);\n                    return responseWriter.toArray();\n                }\n                case 'getNetwork': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getNetworkResult = await this.wallet.getNetwork({}, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeUInt8(getNetworkResult.network === 'mainnet' ? 0 : 1);\n                    return responseWriter.toArray();\n                }\n                case 'getVersion': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getVersionResult = await this.wallet.getVersion({}, originator);\n                    // Serialize the result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const versionBytes = Utils.toArray(getVersionResult.version, 'utf8');\n                    responseWriter.write(versionBytes);\n                    return responseWriter.toArray();\n                }\n                case 'revealCounterpartyKeyLinkage': {\n                    const args = {};\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                    }\n                    // Read counterparty public key\n                    const counterpartyBytes = paramsReader.read(33);\n                    args.counterparty = Utils.toHex(counterpartyBytes);\n                    // Read verifier public key\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = Utils.toHex(verifierBytes);\n                    // Call the method\n                    const revealResult = await this.wallet.revealCounterpartyKeyLinkage(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // Write prover\n                    resultWriter.write(Utils.toArray(revealResult.prover, 'hex'));\n                    // Write verifier\n                    resultWriter.write(Utils.toArray(revealResult.verifier, 'hex'));\n                    // Write counterparty\n                    resultWriter.write(Utils.toArray(revealResult.counterparty, 'hex'));\n                    // Write revelationTime\n                    const revelationTimeBytes = Utils.toArray(revealResult.revelationTime, 'utf8');\n                    resultWriter.writeVarIntNum(revelationTimeBytes.length);\n                    resultWriter.write(revelationTimeBytes);\n                    // Write encryptedLinkage\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);\n                    resultWriter.write(revealResult.encryptedLinkage);\n                    // Write encryptedLinkageProof\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);\n                    resultWriter.write(revealResult.encryptedLinkageProof);\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'revealSpecificKeyLinkage': {\n                    // Deserialize key-related parameters and privileged parameters\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Read verifier public key\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = Utils.toHex(verifierBytes);\n                    // Call the method\n                    const revealResult = await this.wallet.revealSpecificKeyLinkage(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // Write prover\n                    resultWriter.write(Utils.toArray(revealResult.prover, 'hex'));\n                    // Write verifier\n                    resultWriter.write(Utils.toArray(revealResult.verifier, 'hex'));\n                    // Write counterparty\n                    resultWriter.write(Utils.toArray(revealResult.counterparty, 'hex'));\n                    // Write securityLevel\n                    resultWriter.writeUInt8(revealResult.protocolID[0]);\n                    // Write protocol string\n                    const protocolBytesOut = Utils.toArray(revealResult.protocolID[1], 'utf8');\n                    resultWriter.writeVarIntNum(protocolBytesOut.length);\n                    resultWriter.write(protocolBytesOut);\n                    // Write keyID\n                    const keyIDBytesOut = Utils.toArray(revealResult.keyID, 'utf8');\n                    resultWriter.writeVarIntNum(keyIDBytesOut.length);\n                    resultWriter.write(keyIDBytesOut);\n                    // Write encryptedLinkage\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);\n                    resultWriter.write(revealResult.encryptedLinkage);\n                    // Write encryptedLinkageProof\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);\n                    resultWriter.write(revealResult.encryptedLinkageProof);\n                    // Write proofType\n                    resultWriter.writeUInt8(revealResult.proofType);\n                    // Return success code and result\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'acquireCertificate': {\n                    const args = {};\n                    // Read args.type\n                    const typeBytes = paramsReader.read(32);\n                    args.type = Utils.toBase64(typeBytes);\n                    // args.certifier\n                    const certifierBytes = paramsReader.read(33);\n                    args.certifier = Utils.toHex(certifierBytes);\n                    // Read fields\n                    const fieldsLength = paramsReader.readVarIntNum();\n                    args.fields = {};\n                    for (let i = 0; i < fieldsLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = Utils.toUTF8(fieldNameBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = Utils.toUTF8(fieldValueBytes);\n                        args.fields[fieldName] = fieldValue;\n                    }\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                    }\n                    // Read acquisitionProtocol\n                    const acquisitionProtocolFlag = paramsReader.readUInt8();\n                    args.acquisitionProtocol =\n                        acquisitionProtocolFlag === 1 ? 'direct' : 'issuance';\n                    if (args.acquisitionProtocol === 'direct') {\n                        // args.serialNumber\n                        const serialNumberBytes = paramsReader.read(32);\n                        args.serialNumber = Utils.toBase64(serialNumberBytes);\n                        // args.revocationOutpoint\n                        args.revocationOutpoint = this.decodeOutpoint(paramsReader);\n                        // args.signature\n                        const signatureLength = paramsReader.readVarIntNum();\n                        const signatureBytes = paramsReader.read(signatureLength);\n                        args.signature = Utils.toHex(signatureBytes);\n                        // args.keyringRevealer\n                        const keyringRevealerIdentifier = paramsReader.readUInt8();\n                        if (keyringRevealerIdentifier === 11) {\n                            args.keyringRevealer = 'certifier';\n                        }\n                        else {\n                            const keyringRevealerBytes = [keyringRevealerIdentifier].concat(paramsReader.read(32));\n                            args.keyringRevealer = Utils.toHex(keyringRevealerBytes);\n                        }\n                        // args.keyringForSubject\n                        const keyringEntriesLength = paramsReader.readVarIntNum();\n                        args.keyringForSubject = {};\n                        for (let i = 0; i < keyringEntriesLength; i++) {\n                            const fieldKeyLength = paramsReader.readVarIntNum();\n                            const fieldKeyBytes = paramsReader.read(fieldKeyLength);\n                            const fieldKey = Utils.toUTF8(fieldKeyBytes);\n                            const fieldValueLength = paramsReader.readVarIntNum();\n                            const fieldValueBytes = paramsReader.read(fieldValueLength);\n                            const fieldValue = Utils.toBase64(fieldValueBytes);\n                            args.keyringForSubject[fieldKey] = fieldValue;\n                        }\n                    }\n                    else {\n                        // args.certifierUrl\n                        const certifierUrlLength = paramsReader.readVarIntNum();\n                        const certifierUrlBytes = paramsReader.read(certifierUrlLength);\n                        args.certifierUrl = Utils.toUTF8(certifierUrlBytes);\n                    }\n                    // Call the method\n                    const acquireResult = await this.wallet.acquireCertificate(args, originator);\n                    // Serialize the certificate (assuming Certificate class is available)\n                    const cert = new Certificate_js_1.default(acquireResult.type, acquireResult.serialNumber, acquireResult.subject, acquireResult.certifier, acquireResult.revocationOutpoint, acquireResult.fields, acquireResult.signature);\n                    const certBin = cert.toBinary();\n                    // Return success code and certificate binary\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(certBin);\n                    return responseWriter.toArray();\n                }\n                case 'listCertificates': {\n                    const args = {};\n                    // Read certifiers\n                    const certifiersLength = paramsReader.readVarIntNum();\n                    args.certifiers = [];\n                    for (let i = 0; i < certifiersLength; i++) {\n                        const certifierBytes = paramsReader.read(33);\n                        args.certifiers.push(Utils.toHex(certifierBytes));\n                    }\n                    // Read types\n                    const typesLength = paramsReader.readVarIntNum();\n                    args.types = [];\n                    for (let i = 0; i < typesLength; i++) {\n                        const typeBytes = paramsReader.read(32);\n                        args.types.push(Utils.toBase64(typeBytes));\n                    }\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                    }\n                    // Call the method\n                    const listResult = await this.wallet.listCertificates(args, originator);\n                    // Serialize the result\n                    const resultWriter = new Utils.Writer();\n                    // totalCertificates\n                    resultWriter.writeVarIntNum(listResult.totalCertificates);\n                    // certificates\n                    for (const cert of listResult.certificates) {\n                        const certificate = new Certificate_js_1.default(cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);\n                        const certBin = certificate.toBinary();\n                        // Write certificate binary length and data\n                        resultWriter.writeVarIntNum(certBin.length);\n                        resultWriter.write(certBin);\n                    }\n                    // Return the response\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'proveCertificate': {\n                    const args = {};\n                    // Read certificate\n                    const cert = {};\n                    // Read type\n                    const typeBytes = paramsReader.read(32);\n                    cert.type = Utils.toBase64(typeBytes);\n                    // Read subject\n                    const subjectBytes = paramsReader.read(33);\n                    cert.subject = Utils.toHex(subjectBytes);\n                    // Read serialNumber\n                    const serialNumberBytes = paramsReader.read(32);\n                    cert.serialNumber = Utils.toBase64(serialNumberBytes);\n                    // Read certifier\n                    const certifierBytes = paramsReader.read(33);\n                    cert.certifier = Utils.toHex(certifierBytes);\n                    // Read revocationOutpoint\n                    cert.revocationOutpoint = this.decodeOutpoint(paramsReader);\n                    // Read signature\n                    const signatureLength = paramsReader.readVarIntNum();\n                    const signatureBytes = paramsReader.read(signatureLength);\n                    cert.signature = Utils.toHex(signatureBytes);\n                    // Read fields\n                    const fieldsLength = paramsReader.readVarIntNum();\n                    cert.fields = {};\n                    for (let i = 0; i < fieldsLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = Utils.toUTF8(fieldNameBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = Utils.toUTF8(fieldValueBytes);\n                        cert.fields[fieldName] = fieldValue;\n                    }\n                    args.certificate = cert;\n                    // Read fields to reveal\n                    const fieldsToRevealLength = paramsReader.readVarIntNum();\n                    args.fieldsToReveal = [];\n                    for (let i = 0; i < fieldsToRevealLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = Utils.toUTF8(fieldNameBytes);\n                        args.fieldsToReveal.push(fieldName);\n                    }\n                    // Read verifier\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = Utils.toHex(verifierBytes);\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n                    }\n                    // Call the method\n                    const proveResult = await this.wallet.proveCertificate(args, originator);\n                    // Serialize keyringForVerifier\n                    const resultWriter = new Utils.Writer();\n                    const keyringEntries = Object.entries(proveResult.keyringForVerifier);\n                    resultWriter.writeVarIntNum(keyringEntries.length);\n                    for (const [fieldName, fieldValue] of keyringEntries) {\n                        const fieldNameBytes = Utils.toArray(fieldName, 'utf8');\n                        resultWriter.writeVarIntNum(fieldNameBytes.length);\n                        resultWriter.write(fieldNameBytes);\n                        const fieldValueBytes = Utils.toArray(fieldValue, 'base64');\n                        resultWriter.writeVarIntNum(fieldValueBytes.length);\n                        resultWriter.write(fieldValueBytes);\n                    }\n                    // Return the response\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'relinquishCertificate': {\n                    const args = {};\n                    // Read type\n                    const typeBytes = paramsReader.read(32);\n                    args.type = Utils.toBase64(typeBytes);\n                    // Read serialNumber\n                    const serialNumberBytes = paramsReader.read(32);\n                    args.serialNumber = Utils.toBase64(serialNumberBytes);\n                    // Read certifier\n                    const certifierBytes = paramsReader.read(33);\n                    args.certifier = Utils.toHex(certifierBytes);\n                    // Call the method\n                    await this.wallet.relinquishCertificate(args, originator);\n                    // Return success code\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'discoverByIdentityKey': {\n                    const args = {};\n                    // Read identityKey\n                    const identityKeyBytes = paramsReader.read(33);\n                    args.identityKey = Utils.toHex(identityKeyBytes);\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const discoverResult = await this.wallet.discoverByIdentityKey(args, originator);\n                    // Serialize the result\n                    const result = this.serializeDiscoveryResult(discoverResult);\n                    // Return the response\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(result);\n                    return responseWriter.toArray();\n                }\n                case 'discoverByAttributes': {\n                    const args = {};\n                    // Read attributes\n                    const attributesLength = paramsReader.readVarIntNum();\n                    args.attributes = {};\n                    for (let i = 0; i < attributesLength; i++) {\n                        const fieldKeyLength = paramsReader.readVarIntNum();\n                        const fieldKeyBytes = paramsReader.read(fieldKeyLength);\n                        const fieldKey = Utils.toUTF8(fieldKeyBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = Utils.toUTF8(fieldValueBytes);\n                        args.attributes[fieldKey] = fieldValue;\n                    }\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const discoverResult = await this.wallet.discoverByAttributes(args, originator);\n                    // Serialize the result\n                    const result = this.serializeDiscoveryResult(discoverResult);\n                    // Return the response\n                    const responseWriter = new Utils.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(result);\n                    return responseWriter.toArray();\n                }\n                default:\n                    throw new Error(`Method ${callName} not implemented`);\n            }\n        }\n        catch (err) {\n            const responseWriter = new Utils.Writer();\n            responseWriter.writeUInt8(typeof err.code === 'number' ? err.code : 1); // errorCode = 1 (generic error)\n            // Serialize the error message\n            const errorMessage = typeof err.message === 'string' ? err.message : 'Unknown error';\n            const errorMessageBytes = Utils.toArray(errorMessage, 'utf8');\n            responseWriter.writeVarIntNum(errorMessageBytes.length);\n            responseWriter.write(errorMessageBytes);\n            // Serialize the stack trace\n            const stackTrace = typeof err.stack === 'string' ? err.stack : '';\n            const stackTraceBytes = Utils.toArray(stackTrace, 'utf8');\n            responseWriter.writeVarIntNum(stackTraceBytes.length);\n            responseWriter.write(stackTraceBytes);\n            return responseWriter.toArray();\n        }\n    }\n    decodeProtocolID(reader) {\n        const securityLevel = reader.readUInt8();\n        const protocolLength = reader.readVarIntNum();\n        const protocolBytes = reader.read(protocolLength);\n        const protocolString = Utils.toUTF8(protocolBytes);\n        return [securityLevel, protocolString];\n    }\n    decodeString(reader) {\n        const length = reader.readVarIntNum();\n        const bytes = reader.read(length);\n        return Utils.toUTF8(bytes);\n    }\n    decodeCounterparty(reader) {\n        const counterpartyFlag = reader.readUInt8();\n        if (counterpartyFlag === 11) {\n            return 'self';\n        }\n        else if (counterpartyFlag === 12) {\n            return 'anyone';\n        }\n        else if (counterpartyFlag === 0) {\n            return undefined;\n        }\n        else {\n            const counterpartyRemainingBytes = reader.read(32);\n            return Utils.toHex([counterpartyFlag, ...counterpartyRemainingBytes]);\n        }\n    }\n    serializeDiscoveryResult(discoverResult) {\n        const resultWriter = new Utils.Writer();\n        // totalCertificates\n        resultWriter.writeVarIntNum(discoverResult.totalCertificates);\n        // certificates\n        for (const cert of discoverResult.certificates) {\n            // Serialize certificate binary\n            const certificate = new Certificate_js_1.default(cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);\n            const certBin = certificate.toBinary();\n            // Write certificate binary length and data\n            resultWriter.writeVarIntNum(certBin.length);\n            resultWriter.write(certBin);\n            // Serialize certifierInfo\n            const nameBytes = Utils.toArray(cert.certifierInfo.name, 'utf8');\n            resultWriter.writeVarIntNum(nameBytes.length);\n            resultWriter.write(nameBytes);\n            const iconUrlBytes = Utils.toArray(cert.certifierInfo.iconUrl, 'utf8');\n            resultWriter.writeVarIntNum(iconUrlBytes.length);\n            resultWriter.write(iconUrlBytes);\n            const descriptionBytes = Utils.toArray(cert.certifierInfo.description, 'utf8');\n            resultWriter.writeVarIntNum(descriptionBytes.length);\n            resultWriter.write(descriptionBytes);\n            resultWriter.writeUInt8(cert.certifierInfo.trust);\n            // Serialize publiclyRevealedKeyring\n            const publicKeyringEntries = Object.entries(cert.publiclyRevealedKeyring);\n            resultWriter.writeVarIntNum(publicKeyringEntries.length);\n            for (const [fieldName, fieldValue] of publicKeyringEntries) {\n                const fieldNameBytes = Utils.toArray(fieldName, 'utf8');\n                resultWriter.writeVarIntNum(fieldNameBytes.length);\n                resultWriter.write(fieldNameBytes);\n                const fieldValueBytes = Utils.toArray(fieldValue, 'base64');\n                resultWriter.writeVarIntNum(fieldValueBytes.length);\n                resultWriter.write(fieldValueBytes);\n            }\n            // Serialize decryptedFields\n            const decryptedFieldEntries = Object.entries(cert.decryptedFields);\n            resultWriter.writeVarIntNum(decryptedFieldEntries.length);\n            for (const [fieldName, fieldValue] of decryptedFieldEntries) {\n                const fieldNameBytes = Utils.toArray(fieldName, 'utf8');\n                resultWriter.writeVarIntNum(fieldNameBytes.length);\n                resultWriter.write(fieldNameBytes);\n                const fieldValueBytes = Utils.toArray(fieldValue, 'utf8');\n                resultWriter.writeVarIntNum(fieldValueBytes.length);\n                resultWriter.write(fieldValueBytes);\n            }\n        }\n        return resultWriter.toArray();\n    }\n    decodeKeyRelatedParams(paramsReader) {\n        const args = {};\n        // Read protocolID\n        args.protocolID = this.decodeProtocolID(paramsReader);\n        // Read keyID\n        const keyIDLength = paramsReader.readVarIntNum();\n        const keyIDBytes = paramsReader.read(keyIDLength);\n        args.keyID = Utils.toUTF8(keyIDBytes);\n        // Read counterparty\n        args.counterparty = this.decodeCounterparty(paramsReader);\n        // Read privileged parameters\n        const privilegedFlag = paramsReader.readInt8();\n        if (privilegedFlag === -1) {\n            args.privileged = undefined;\n        }\n        else {\n            args.privileged = privilegedFlag === 1;\n        }\n        const privilegedReasonLength = paramsReader.readInt8();\n        if (privilegedReasonLength === -1) {\n            args.privilegedReason = undefined;\n        }\n        else {\n            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n            args.privilegedReason = Utils.toUTF8(privilegedReasonBytes);\n        }\n        return args;\n    }\n}\nexports[\"default\"] = WalletWireProcessor;\n//# sourceMappingURL=WalletWireProcessor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireProcessor.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireTransceiver.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireTransceiver.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Wallet_interfaces_js_1 = __webpack_require__(/*! ../Wallet.interfaces.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/Wallet.interfaces.js\");\nconst Certificate_js_1 = __importDefault(__webpack_require__(/*! ../../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/auth/certificates/Certificate.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst WalletWireCalls_js_1 = __importDefault(__webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js\"));\nconst WalletError_js_1 = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js\");\n/**\n * A way to make remote calls to a wallet over a wallet wire.\n */\nclass WalletWireTransceiver {\n    constructor(wire) {\n        this.wire = wire;\n    }\n    async transmit(call, originator = '', params = []) {\n        const frameWriter = new Utils.Writer();\n        frameWriter.writeUInt8(WalletWireCalls_js_1.default[call]);\n        const originatorArray = Utils.toArray(originator, 'utf8');\n        frameWriter.writeUInt8(originatorArray.length);\n        frameWriter.write(originatorArray);\n        if (params.length > 0) {\n            frameWriter.write(params);\n        }\n        const frame = frameWriter.toArray();\n        const result = await this.wire.transmitToWallet(frame);\n        const resultReader = new Utils.Reader(result);\n        const errorByte = resultReader.readUInt8();\n        if (errorByte === 0) {\n            const resultFrame = resultReader.read();\n            return resultFrame;\n        }\n        else {\n            // Deserialize the error message length\n            const errorMessageLength = resultReader.readVarIntNum();\n            const errorMessageBytes = resultReader.read(errorMessageLength);\n            const errorMessage = Utils.toUTF8(errorMessageBytes);\n            // Deserialize the stack trace length\n            const stackTraceLength = resultReader.readVarIntNum();\n            const stackTraceBytes = resultReader.read(stackTraceLength);\n            const stackTrace = Utils.toUTF8(stackTraceBytes);\n            // Construct a custom wallet error\n            const e = new WalletError_js_1.WalletError(errorMessage, errorByte, stackTrace);\n            throw e;\n        }\n    }\n    async createAction(args, originator) {\n        const paramWriter = new Utils.Writer();\n        // Serialize description\n        const descriptionBytes = Utils.toArray(args.description, 'utf8');\n        paramWriter.writeVarIntNum(descriptionBytes.length);\n        paramWriter.write(descriptionBytes);\n        // input BEEF\n        if (args.inputBEEF != null) {\n            paramWriter.writeVarIntNum(args.inputBEEF.length);\n            paramWriter.write(args.inputBEEF);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize inputs\n        if (args.inputs != null) {\n            paramWriter.writeVarIntNum(args.inputs.length);\n            for (const input of args.inputs) {\n                // outpoint\n                paramWriter.write(this.encodeOutpoint(input.outpoint));\n                // unlockingScript / unlockingScriptLength\n                if (input.unlockingScript != null && input.unlockingScript !== '') {\n                    const unlockingScriptBytes = Utils.toArray(input.unlockingScript, 'hex');\n                    paramWriter.writeVarIntNum(unlockingScriptBytes.length);\n                    paramWriter.write(unlockingScriptBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                    paramWriter.writeVarIntNum(input.unlockingScriptLength ?? 0);\n                }\n                // inputDescription\n                const inputDescriptionBytes = Utils.toArray(input.inputDescription, 'utf8');\n                paramWriter.writeVarIntNum(inputDescriptionBytes.length);\n                paramWriter.write(inputDescriptionBytes);\n                // sequenceNumber\n                if (typeof input.sequenceNumber === 'number') {\n                    paramWriter.writeVarIntNum(input.sequenceNumber);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize outputs\n        if (args.outputs != null) {\n            paramWriter.writeVarIntNum(args.outputs.length);\n            for (const output of args.outputs) {\n                // lockingScript\n                const lockingScriptBytes = Utils.toArray(output.lockingScript, 'hex');\n                paramWriter.writeVarIntNum(lockingScriptBytes.length);\n                paramWriter.write(lockingScriptBytes);\n                // satoshis\n                paramWriter.writeVarIntNum(output.satoshis);\n                // outputDescription\n                const outputDescriptionBytes = Utils.toArray(output.outputDescription, 'utf8');\n                paramWriter.writeVarIntNum(outputDescriptionBytes.length);\n                paramWriter.write(outputDescriptionBytes);\n                // basket\n                if (output.basket != null && output.basket !== '') {\n                    const basketBytes = Utils.toArray(output.basket, 'utf8');\n                    paramWriter.writeVarIntNum(basketBytes.length);\n                    paramWriter.write(basketBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                // customInstructions\n                if (output.customInstructions != null && output.customInstructions !== '') {\n                    const customInstructionsBytes = Utils.toArray(output.customInstructions, 'utf8');\n                    paramWriter.writeVarIntNum(customInstructionsBytes.length);\n                    paramWriter.write(customInstructionsBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                // tags\n                if (output.tags != null) {\n                    paramWriter.writeVarIntNum(output.tags.length);\n                    for (const tag of output.tags) {\n                        const tagBytes = Utils.toArray(tag, 'utf8');\n                        paramWriter.writeVarIntNum(tagBytes.length);\n                        paramWriter.write(tagBytes);\n                    }\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize lockTime\n        if (typeof args.lockTime === 'number') {\n            paramWriter.writeVarIntNum(args.lockTime);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize version\n        if (typeof args.version === 'number') {\n            paramWriter.writeVarIntNum(args.version);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize labels\n        if (args.labels != null) {\n            paramWriter.writeVarIntNum(args.labels.length);\n            for (const label of args.labels) {\n                const labelBytes = Utils.toArray(label, 'utf8');\n                paramWriter.writeVarIntNum(labelBytes.length);\n                paramWriter.write(labelBytes);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize options\n        if (args.options != null) {\n            paramWriter.writeInt8(1); // options present\n            // signAndProcess\n            if (typeof args.options.signAndProcess === 'boolean') {\n                paramWriter.writeInt8(args.options.signAndProcess ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // acceptDelayedBroadcast\n            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {\n                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // trustSelf\n            if (args.options.trustSelf === 'known') {\n                paramWriter.writeInt8(1);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // knownTxids\n            if (args.options.knownTxids != null) {\n                paramWriter.writeVarIntNum(args.options.knownTxids.length);\n                for (const txid of args.options.knownTxids) {\n                    const txidBytes = Utils.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // returnTXIDOnly\n            if (typeof args.options.returnTXIDOnly === 'boolean') {\n                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSend\n            if (typeof args.options.noSend === 'boolean') {\n                paramWriter.writeInt8(args.options.noSend ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSendChange\n            if (args.options.noSendChange != null) {\n                paramWriter.writeVarIntNum(args.options.noSendChange.length);\n                for (const outpoint of args.options.noSendChange) {\n                    paramWriter.write(this.encodeOutpoint(outpoint));\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // sendWith\n            if (args.options.sendWith != null) {\n                paramWriter.writeVarIntNum(args.options.sendWith.length);\n                for (const txid of args.options.sendWith) {\n                    const txidBytes = Utils.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // randomizeOutputs\n            if (typeof args.options.randomizeOutputs === 'boolean') {\n                paramWriter.writeInt8(args.options.randomizeOutputs ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        else {\n            paramWriter.writeInt8(0); // options not present\n        }\n        // Transmit and parse response\n        const result = await this.transmit('createAction', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const response = {};\n        // Parse txid\n        const txidFlag = resultReader.readInt8();\n        if (txidFlag === 1) {\n            const txidBytes = resultReader.read(32);\n            response.txid = Utils.toHex(txidBytes);\n        }\n        // Parse tx\n        const txFlag = resultReader.readInt8();\n        if (txFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            response.tx = resultReader.read(txLength);\n        }\n        // Parse noSendChange\n        const noSendChangeLength = resultReader.readVarIntNum();\n        if (noSendChangeLength >= 0) {\n            response.noSendChange = [];\n            for (let i = 0; i < noSendChangeLength; i++) {\n                const outpoint = this.readOutpoint(resultReader);\n                response.noSendChange.push(outpoint);\n            }\n        }\n        // Parse sendWithResults\n        const sendWithResultsLength = resultReader.readVarIntNum();\n        if (sendWithResultsLength >= 0) {\n            response.sendWithResults = [];\n            for (let i = 0; i < sendWithResultsLength; i++) {\n                const txidBytes = resultReader.read(32);\n                const txid = Utils.toHex(txidBytes);\n                const statusCode = resultReader.readInt8();\n                let status = 'unproven';\n                if (statusCode === 1)\n                    status = 'unproven';\n                else if (statusCode === 2)\n                    status = 'sending';\n                else if (statusCode === 3)\n                    status = 'failed';\n                response.sendWithResults.push({ txid, status });\n            }\n        }\n        // Parse signableTransaction\n        const signableTransactionFlag = resultReader.readInt8();\n        if (signableTransactionFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            const tx = resultReader.read(txLength);\n            const referenceLength = resultReader.readVarIntNum();\n            const referenceBytes = resultReader.read(referenceLength);\n            response.signableTransaction = {\n                tx,\n                reference: Utils.toBase64(referenceBytes)\n            };\n        }\n        return response;\n    }\n    async signAction(args, originator) {\n        const paramWriter = new Utils.Writer();\n        // Serialize spends\n        const spendIndexes = Object.keys(args.spends);\n        paramWriter.writeVarIntNum(spendIndexes.length);\n        for (const index of spendIndexes) {\n            paramWriter.writeVarIntNum(Number(index));\n            const spend = args.spends[Number(index)];\n            // unlockingScript\n            const unlockingScriptBytes = Utils.toArray(spend.unlockingScript, 'hex');\n            paramWriter.writeVarIntNum(unlockingScriptBytes.length);\n            paramWriter.write(unlockingScriptBytes);\n            // sequenceNumber\n            if (typeof spend.sequenceNumber === 'number') {\n                paramWriter.writeVarIntNum(spend.sequenceNumber);\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n        }\n        // Serialize reference\n        const referenceBytes = Utils.toArray(args.reference, 'base64');\n        paramWriter.writeVarIntNum(referenceBytes.length);\n        paramWriter.write(referenceBytes);\n        // Serialize options\n        if (args.options != null) {\n            paramWriter.writeInt8(1); // options present\n            // acceptDelayedBroadcast\n            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {\n                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // returnTXIDOnly\n            if (typeof args.options.returnTXIDOnly === 'boolean') {\n                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSend\n            if (typeof args.options.noSend === 'boolean') {\n                paramWriter.writeInt8(args.options.noSend ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // sendWith\n            if (args.options.sendWith != null) {\n                paramWriter.writeVarIntNum(args.options.sendWith.length);\n                for (const txid of args.options.sendWith) {\n                    const txidBytes = Utils.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n        }\n        else {\n            paramWriter.writeInt8(0); // options not present\n        }\n        // Transmit and parse response\n        const result = await this.transmit('signAction', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const response = {};\n        // Parse txid\n        const txidFlag = resultReader.readInt8();\n        if (txidFlag === 1) {\n            const txidBytes = resultReader.read(32);\n            response.txid = Utils.toHex(txidBytes);\n        }\n        // Parse tx\n        const txFlag = resultReader.readInt8();\n        if (txFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            response.tx = resultReader.read(txLength);\n        }\n        // Parse sendWithResults\n        const sendWithResultsLength = resultReader.readVarIntNum();\n        if (sendWithResultsLength >= 0) {\n            response.sendWithResults = [];\n            for (let i = 0; i < sendWithResultsLength; i++) {\n                const txidBytes = resultReader.read(32);\n                const txid = Utils.toHex(txidBytes);\n                const statusCode = resultReader.readInt8();\n                let status = 'unproven';\n                if (statusCode === 1)\n                    status = 'unproven';\n                else if (statusCode === 2)\n                    status = 'sending';\n                else if (statusCode === 3)\n                    status = 'failed';\n                response.sendWithResults.push({ txid, status });\n            }\n        }\n        return response;\n    }\n    async abortAction(args, originator) {\n        await this.transmit('abortAction', originator, Utils.toArray(args.reference, 'base64'));\n        return { aborted: true };\n    }\n    async listActions(args, originator) {\n        const paramWriter = new Utils.Writer();\n        // Serialize labels\n        paramWriter.writeVarIntNum(args.labels.length);\n        for (const label of args.labels) {\n            const labelBytes = Utils.toArray(label, 'utf8');\n            paramWriter.writeVarIntNum(labelBytes.length);\n            paramWriter.write(labelBytes);\n        }\n        // Serialize labelQueryMode\n        if (args.labelQueryMode === 'any') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.labelQueryMode === 'all') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        // Serialize include options\n        const includeOptions = [\n            args.includeLabels,\n            args.includeInputs,\n            args.includeInputSourceLockingScripts,\n            args.includeInputUnlockingScripts,\n            args.includeOutputs,\n            args.includeOutputLockingScripts\n        ];\n        for (const option of includeOptions) {\n            if (typeof option === 'boolean') {\n                paramWriter.writeInt8(option ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        // Serialize limit and offset\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        // Transmit and parse response\n        const result = await this.transmit('listActions', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const totalActions = resultReader.readVarIntNum();\n        const actions = [];\n        for (let i = 0; i < totalActions; i++) {\n            // Parse action fields\n            const txidBytes = resultReader.read(32);\n            const txid = Utils.toHex(txidBytes);\n            const satoshis = resultReader.readVarIntNum();\n            const statusCode = resultReader.readInt8();\n            let status;\n            switch (statusCode) {\n                case 1:\n                    status = 'completed';\n                    break;\n                case 2:\n                    status = 'unprocessed';\n                    break;\n                case 3:\n                    status = 'sending';\n                    break;\n                case 4:\n                    status = 'unproven';\n                    break;\n                case 5:\n                    status = 'unsigned';\n                    break;\n                case 6:\n                    status = 'nosend';\n                    break;\n                case 7:\n                    status = 'nonfinal';\n                    break;\n                case 8:\n                    status = 'failed';\n                    break;\n                default:\n                    throw new Error(`Unknown status code: ${statusCode}`);\n            }\n            const isOutgoing = resultReader.readInt8() === 1;\n            const descriptionLength = resultReader.readVarIntNum();\n            const descriptionBytes = resultReader.read(descriptionLength);\n            const description = Utils.toUTF8(descriptionBytes);\n            const action = {\n                txid,\n                satoshis,\n                status,\n                isOutgoing,\n                description,\n                version: 0,\n                lockTime: 0\n            };\n            // Parse labels\n            const labelsLength = resultReader.readVarIntNum();\n            if (labelsLength >= 0) {\n                action.labels = [];\n                for (let j = 0; j < labelsLength; j++) {\n                    const labelLength = resultReader.readVarIntNum();\n                    const labelBytes = resultReader.read(labelLength);\n                    action.labels.push(Utils.toUTF8(labelBytes));\n                }\n            }\n            // Parse version and lockTime\n            action.version = resultReader.readVarIntNum();\n            action.lockTime = resultReader.readVarIntNum();\n            // Parse inputs\n            const inputsLength = resultReader.readVarIntNum();\n            if (inputsLength >= 0) {\n                action.inputs = [];\n                for (let k = 0; k < inputsLength; k++) {\n                    const sourceOutpoint = this.readOutpoint(resultReader);\n                    const sourceSatoshis = resultReader.readVarIntNum();\n                    // sourceLockingScript\n                    const sourceLockingScriptLength = resultReader.readVarIntNum();\n                    let sourceLockingScript;\n                    if (sourceLockingScriptLength >= 0) {\n                        const sourceLockingScriptBytes = resultReader.read(sourceLockingScriptLength);\n                        sourceLockingScript = Utils.toHex(sourceLockingScriptBytes);\n                    }\n                    // unlockingScript\n                    const unlockingScriptLength = resultReader.readVarIntNum();\n                    let unlockingScript;\n                    if (unlockingScriptLength >= 0) {\n                        const unlockingScriptBytes = resultReader.read(unlockingScriptLength);\n                        unlockingScript = Utils.toHex(unlockingScriptBytes);\n                    }\n                    // inputDescription\n                    const inputDescriptionLength = resultReader.readVarIntNum();\n                    const inputDescriptionBytes = resultReader.read(inputDescriptionLength);\n                    const inputDescription = Utils.toUTF8(inputDescriptionBytes);\n                    // sequenceNumber\n                    const sequenceNumber = resultReader.readVarIntNum();\n                    action.inputs.push({\n                        sourceOutpoint,\n                        sourceSatoshis,\n                        sourceLockingScript,\n                        unlockingScript,\n                        inputDescription,\n                        sequenceNumber\n                    });\n                }\n            }\n            // Parse outputs\n            const outputsLength = resultReader.readVarIntNum();\n            if (outputsLength >= 0) {\n                action.outputs = [];\n                for (let l = 0; l < outputsLength; l++) {\n                    const outputIndex = resultReader.readVarIntNum();\n                    const satoshis = resultReader.readVarIntNum();\n                    // lockingScript\n                    const lockingScriptLength = resultReader.readVarIntNum();\n                    let lockingScript;\n                    if (lockingScriptLength >= 0) {\n                        const lockingScriptBytes = resultReader.read(lockingScriptLength);\n                        lockingScript = Utils.toHex(lockingScriptBytes);\n                    }\n                    const spendable = resultReader.readInt8() === 1;\n                    // outputDescription\n                    const outputDescriptionLength = resultReader.readVarIntNum();\n                    const outputDescriptionBytes = resultReader.read(outputDescriptionLength);\n                    const outputDescription = Utils.toUTF8(outputDescriptionBytes);\n                    // basket\n                    const basketLength = resultReader.readVarIntNum();\n                    let basket;\n                    if (basketLength >= 0) {\n                        const basketBytes = resultReader.read(basketLength);\n                        basket = Utils.toUTF8(basketBytes);\n                    }\n                    // tags\n                    const tagsLength = resultReader.readVarIntNum();\n                    const tags = [];\n                    if (tagsLength >= 0) {\n                        for (let m = 0; m < tagsLength; m++) {\n                            const tagLength = resultReader.readVarIntNum();\n                            const tagBytes = resultReader.read(tagLength);\n                            tags.push(Utils.toUTF8(tagBytes));\n                        }\n                    }\n                    // customInstructions\n                    const customInstructionsLength = resultReader.readVarIntNum();\n                    let customInstructions;\n                    if (customInstructionsLength >= 0) {\n                        const customInstructionsBytes = resultReader.read(customInstructionsLength);\n                        customInstructions = Utils.toUTF8(customInstructionsBytes);\n                    }\n                    action.outputs.push({\n                        outputIndex,\n                        satoshis,\n                        lockingScript,\n                        spendable,\n                        outputDescription,\n                        basket,\n                        tags,\n                        customInstructions\n                    });\n                }\n            }\n            actions.push(action);\n        }\n        return {\n            totalActions,\n            actions\n        };\n    }\n    async internalizeAction(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.writeVarIntNum(args.tx.length);\n        paramWriter.write(args.tx);\n        paramWriter.writeVarIntNum(args.outputs.length);\n        for (const out of args.outputs) {\n            paramWriter.writeVarIntNum(out.outputIndex);\n            if (out.protocol === 'wallet payment') {\n                if (out.paymentRemittance == null) {\n                    throw new Error('Payment remittance is required for wallet payment');\n                }\n                paramWriter.writeUInt8(1);\n                paramWriter.write(Utils.toArray(out.paymentRemittance.senderIdentityKey, 'hex'));\n                const derivationPrefixAsArray = Utils.toArray(out.paymentRemittance.derivationPrefix, 'base64');\n                paramWriter.writeVarIntNum(derivationPrefixAsArray.length);\n                paramWriter.write(derivationPrefixAsArray);\n                const derivationSuffixAsArray = Utils.toArray(out.paymentRemittance.derivationSuffix, 'base64');\n                paramWriter.writeVarIntNum(derivationSuffixAsArray.length);\n                paramWriter.write(derivationSuffixAsArray);\n            }\n            else {\n                paramWriter.writeUInt8(2);\n                const basketAsArray = Utils.toArray(out.insertionRemittance?.basket, 'utf8');\n                paramWriter.writeVarIntNum(basketAsArray.length);\n                paramWriter.write(basketAsArray);\n                if (typeof out.insertionRemittance?.customInstructions === 'string' && out.insertionRemittance.customInstructions !== '') {\n                    const customInstructionsAsArray = Utils.toArray(out.insertionRemittance.customInstructions, 'utf8');\n                    paramWriter.writeVarIntNum(customInstructionsAsArray.length);\n                    paramWriter.write(customInstructionsAsArray);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                if (typeof out.insertionRemittance?.tags === 'object') {\n                    paramWriter.writeVarIntNum(out.insertionRemittance.tags.length);\n                    for (const tag of out.insertionRemittance.tags) {\n                        const tagAsArray = Utils.toArray(tag, 'utf8');\n                        paramWriter.writeVarIntNum(tagAsArray.length);\n                        paramWriter.write(tagAsArray);\n                    }\n                }\n                else {\n                    paramWriter.writeVarIntNum(0);\n                }\n            }\n        }\n        if (typeof args.labels === 'object') {\n            paramWriter.writeVarIntNum(args.labels.length);\n            for (const l of args.labels) {\n                const labelAsArray = Utils.toArray(l, 'utf8');\n                paramWriter.writeVarIntNum(labelAsArray.length);\n                paramWriter.write(labelAsArray);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        const descriptionAsArray = Utils.toArray(args.description);\n        paramWriter.writeVarIntNum(descriptionAsArray.length);\n        paramWriter.write(descriptionAsArray);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('internalizeAction', originator, paramWriter.toArray());\n        return { accepted: true };\n    }\n    async listOutputs(args, originator) {\n        const paramWriter = new Utils.Writer();\n        const basketAsArray = Utils.toArray(args.basket, 'utf8');\n        paramWriter.writeVarIntNum(basketAsArray.length);\n        paramWriter.write(basketAsArray);\n        if (typeof args.tags === 'object') {\n            paramWriter.writeVarIntNum(args.tags.length);\n            for (const tag of args.tags) {\n                const tagAsArray = Utils.toArray(tag, 'utf8');\n                paramWriter.writeVarIntNum(tagAsArray.length);\n                paramWriter.write(tagAsArray);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(0);\n        }\n        if (args.tagQueryMode === 'all') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.tagQueryMode === 'any') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (args.include === 'locking scripts') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.include === 'entire transactions') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeCustomInstructions === 'boolean') {\n            paramWriter.writeInt8(args.includeCustomInstructions ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeTags === 'boolean') {\n            paramWriter.writeInt8(args.includeTags ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeLabels === 'boolean') {\n            paramWriter.writeInt8(args.includeLabels ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('listOutputs', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const totalOutputs = resultReader.readVarIntNum();\n        const beefLength = resultReader.readVarIntNum();\n        let BEEF;\n        if (beefLength >= 0) {\n            BEEF = resultReader.read(beefLength);\n        }\n        const outputs = [];\n        for (let i = 0; i < totalOutputs; i++) {\n            const outpoint = this.readOutpoint(resultReader);\n            const satoshis = resultReader.readVarIntNum();\n            const output = {\n                spendable: true,\n                outpoint,\n                satoshis\n            };\n            const scriptLength = resultReader.readVarIntNum();\n            if (scriptLength >= 0) {\n                output.lockingScript = Utils.toHex(resultReader.read(scriptLength));\n            }\n            const customInstructionsLength = resultReader.readVarIntNum();\n            if (customInstructionsLength >= 0) {\n                output.customInstructions = Utils.toUTF8(resultReader.read(customInstructionsLength));\n            }\n            const tagsLength = resultReader.readVarIntNum();\n            if (tagsLength !== -1) {\n                const tags = [];\n                for (let i = 0; i < tagsLength; i++) {\n                    const tagLength = resultReader.readVarIntNum();\n                    tags.push(Utils.toUTF8(resultReader.read(tagLength)));\n                }\n                output.tags = tags;\n            }\n            const labelsLength = resultReader.readVarIntNum();\n            if (labelsLength !== -1) {\n                const labels = [];\n                for (let i = 0; i < labelsLength; i++) {\n                    const labelLength = resultReader.readVarIntNum();\n                    labels.push(Utils.toUTF8(resultReader.read(labelLength)));\n                }\n                output.labels = labels;\n            }\n            outputs.push(output);\n        }\n        return {\n            totalOutputs,\n            BEEF,\n            outputs\n        };\n    }\n    async relinquishOutput(args, originator) {\n        const paramWriter = new Utils.Writer();\n        const basketAsArray = Utils.toArray(args.basket, 'utf8');\n        paramWriter.writeVarIntNum(basketAsArray.length);\n        paramWriter.write(basketAsArray);\n        paramWriter.write(this.encodeOutpoint(args.output));\n        await this.transmit('relinquishOutput', originator, paramWriter.toArray());\n        return { relinquished: true };\n    }\n    encodeOutpoint(outpoint) {\n        const writer = new Utils.Writer();\n        const [txid, index] = outpoint.split('.');\n        writer.write(Utils.toArray(txid, 'hex'));\n        writer.writeVarIntNum(Number(index));\n        return writer.toArray();\n    }\n    readOutpoint(reader) {\n        const txid = Utils.toHex(reader.read(32));\n        const index = reader.readVarIntNum();\n        return `${txid}.${index}`;\n    }\n    async getPublicKey(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.writeUInt8(args.identityKey ? 1 : 0);\n        if (!args.identityKey) {\n            paramWriter.write(this.encodeKeyRelatedParams(args.protocolID ?? (args.protocolID = [Wallet_interfaces_js_1.SecurityLevels.Silent, 'default']), args.keyID ?? (args.keyID = ''), args.counterparty, args.privileged, args.privilegedReason));\n            if (typeof args.forSelf === 'boolean') {\n                paramWriter.writeInt8(args.forSelf ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        else {\n            paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('getPublicKey', originator, paramWriter.toArray());\n        return {\n            publicKey: Utils.toHex(result)\n        };\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        paramWriter.write(Utils.toArray(args.counterparty, 'hex'));\n        paramWriter.write(Utils.toArray(args.verifier, 'hex'));\n        const result = await this.transmit('revealCounterpartyKeyLinkage', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const prover = Utils.toHex(resultReader.read(33));\n        const verifier = Utils.toHex(resultReader.read(33));\n        const counterparty = Utils.toHex(resultReader.read(33));\n        const revelationTimeLength = resultReader.readVarIntNum();\n        const revelationTime = Utils.toUTF8(resultReader.read(revelationTimeLength));\n        const encryptedLinkageLength = resultReader.readVarIntNum();\n        const encryptedLinkage = resultReader.read(encryptedLinkageLength);\n        const encryptedLinkageProofLength = resultReader.readVarIntNum();\n        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);\n        return {\n            prover,\n            verifier,\n            counterparty,\n            revelationTime,\n            encryptedLinkage,\n            encryptedLinkageProof\n        };\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.write(Utils.toArray(args.verifier, 'hex'));\n        const result = await this.transmit('revealSpecificKeyLinkage', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const prover = Utils.toHex(resultReader.read(33));\n        const verifier = Utils.toHex(resultReader.read(33));\n        const counterparty = Utils.toHex(resultReader.read(33));\n        const securityLevel = resultReader.readUInt8();\n        const protocolLength = resultReader.readVarIntNum();\n        const protocol = Utils.toUTF8(resultReader.read(protocolLength));\n        const keyIDLength = resultReader.readVarIntNum();\n        const keyID = Utils.toUTF8(resultReader.read(keyIDLength));\n        const encryptedLinkageLength = resultReader.readVarIntNum();\n        const encryptedLinkage = resultReader.read(encryptedLinkageLength);\n        const encryptedLinkageProofLength = resultReader.readVarIntNum();\n        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);\n        const proofType = resultReader.readUInt8();\n        return {\n            prover,\n            verifier,\n            counterparty,\n            protocolID: [securityLevel, protocol],\n            keyID,\n            encryptedLinkage,\n            encryptedLinkageProof,\n            proofType\n        };\n    }\n    async encrypt(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.plaintext.length);\n        paramWriter.write(args.plaintext);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            ciphertext: await this.transmit('encrypt', originator, paramWriter.toArray())\n        };\n    }\n    async decrypt(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.ciphertext.length);\n        paramWriter.write(args.ciphertext);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            plaintext: await this.transmit('decrypt', originator, paramWriter.toArray())\n        };\n    }\n    async createHmac(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.data.length);\n        paramWriter.write(args.data);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            hmac: await this.transmit('createHmac', originator, paramWriter.toArray())\n        };\n    }\n    async verifyHmac(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.write(args.hmac);\n        paramWriter.writeVarIntNum(args.data.length);\n        paramWriter.write(args.data);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('verifyHmac', originator, paramWriter.toArray());\n        return { valid: true };\n    }\n    async createSignature(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        if (typeof args.data === 'object') {\n            paramWriter.writeUInt8(1);\n            paramWriter.writeVarIntNum(args.data.length);\n            paramWriter.write(args.data);\n        }\n        else {\n            paramWriter.writeUInt8(2);\n            paramWriter.write(args.hashToDirectlySign ?? (args.hashToDirectlySign = []));\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            signature: await this.transmit('createSignature', originator, paramWriter.toArray())\n        };\n    }\n    async verifySignature(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        if (typeof args.forSelf === 'boolean') {\n            paramWriter.writeInt8(args.forSelf ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        paramWriter.writeVarIntNum(args.signature.length);\n        paramWriter.write(args.signature);\n        if (typeof args.data === 'object') {\n            paramWriter.writeUInt8(1);\n            paramWriter.writeVarIntNum(args.data.length);\n            paramWriter.write(args.data);\n        }\n        else {\n            paramWriter.writeUInt8(2);\n            paramWriter.write(args.hashToDirectlyVerify ?? []);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('verifySignature', originator, paramWriter.toArray());\n        return { valid: true };\n    }\n    encodeKeyRelatedParams(protocolID, keyID, counterparty, privileged, privilegedReason) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.writeUInt8(protocolID[0]);\n        const protocolAsArray = Utils.toArray(protocolID[1], 'utf8');\n        paramWriter.writeVarIntNum(protocolAsArray.length);\n        paramWriter.write(protocolAsArray);\n        const keyIDAsArray = Utils.toArray(keyID, 'utf8');\n        paramWriter.writeVarIntNum(keyIDAsArray.length);\n        paramWriter.write(keyIDAsArray);\n        if (typeof counterparty !== 'string') {\n            paramWriter.writeUInt8(0);\n        }\n        else if (counterparty === 'self') {\n            paramWriter.writeUInt8(11);\n        }\n        else if (counterparty === 'anyone') {\n            paramWriter.writeUInt8(12);\n        }\n        else {\n            paramWriter.write(Utils.toArray(counterparty, 'hex'));\n        }\n        paramWriter.write(this.encodePrivilegedParams(privileged, privilegedReason));\n        return paramWriter.toArray();\n    }\n    async acquireCertificate(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(Utils.toArray(args.type, 'base64'));\n        paramWriter.write(Utils.toArray(args.certifier, 'hex'));\n        const fieldEntries = Object.entries(args.fields);\n        paramWriter.writeVarIntNum(fieldEntries.length);\n        for (const [key, value] of fieldEntries) {\n            const keyAsArray = Utils.toArray(key, 'utf8');\n            const valueAsArray = Utils.toArray(value, 'utf8');\n            paramWriter.writeVarIntNum(keyAsArray.length);\n            paramWriter.write(keyAsArray);\n            paramWriter.writeVarIntNum(valueAsArray.length);\n            paramWriter.write(valueAsArray);\n        }\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        paramWriter.writeUInt8(args.acquisitionProtocol === 'direct' ? 1 : 2);\n        if (args.acquisitionProtocol === 'direct') {\n            paramWriter.write(Utils.toArray(args.serialNumber, 'base64'));\n            paramWriter.write(this.encodeOutpoint(args.revocationOutpoint ?? ''));\n            const signatureAsArray = Utils.toArray(args.signature, 'hex');\n            paramWriter.writeVarIntNum(signatureAsArray.length);\n            paramWriter.write(signatureAsArray);\n            const keyringRevealerAsArray = args.keyringRevealer !== 'certifier'\n                ? Utils.toArray(args.keyringRevealer, 'hex')\n                : [11];\n            paramWriter.write(keyringRevealerAsArray);\n            const keyringKeys = Object.keys(args.keyringForSubject ?? {});\n            paramWriter.writeVarIntNum(keyringKeys.length);\n            for (let i = 0; i < keyringKeys.length; i++) {\n                const keyringKeysAsArray = Utils.toArray(keyringKeys[i], 'utf8');\n                paramWriter.writeVarIntNum(keyringKeysAsArray.length);\n                paramWriter.write(keyringKeysAsArray);\n                const keyringForSubjectAsArray = Utils.toArray(args.keyringForSubject?.[keyringKeys[i]], 'base64');\n                paramWriter.writeVarIntNum(keyringForSubjectAsArray.length);\n                paramWriter.write(keyringForSubjectAsArray);\n            }\n        }\n        else {\n            const certifierUrlAsArray = Utils.toArray(args.certifierUrl, 'utf8');\n            paramWriter.writeVarIntNum(certifierUrlAsArray.length);\n            paramWriter.write(certifierUrlAsArray);\n        }\n        const result = await this.transmit('acquireCertificate', originator, paramWriter.toArray());\n        const cert = Certificate_js_1.default.fromBinary(result);\n        return {\n            ...cert,\n            signature: cert.signature\n        };\n    }\n    encodePrivilegedParams(privileged, privilegedReason) {\n        const paramWriter = new Utils.Writer();\n        if (typeof privileged === 'boolean') {\n            paramWriter.writeInt8(privileged ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof privilegedReason === 'string') {\n            const privilegedReasonAsArray = Utils.toArray(privilegedReason, 'utf8');\n            paramWriter.writeInt8(privilegedReasonAsArray.length);\n            paramWriter.write(privilegedReasonAsArray);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        return paramWriter.toArray();\n    }\n    async listCertificates(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.writeVarIntNum(args.certifiers.length);\n        for (let i = 0; i < args.certifiers.length; i++) {\n            paramWriter.write(Utils.toArray(args.certifiers[i], 'hex'));\n        }\n        paramWriter.writeVarIntNum(args.types.length);\n        for (let i = 0; i < args.types.length; i++) {\n            paramWriter.write(Utils.toArray(args.types[i], 'base64'));\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        const result = await this.transmit('listCertificates', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const totalCertificates = resultReader.readVarIntNum();\n        const certificates = [];\n        for (let i = 0; i < totalCertificates; i++) {\n            const certificateLength = resultReader.readVarIntNum();\n            const certificateBin = resultReader.read(certificateLength);\n            const cert = Certificate_js_1.default.fromBinary(certificateBin);\n            certificates.push({\n                ...cert,\n                signature: cert.signature\n            });\n        }\n        return {\n            totalCertificates,\n            certificates\n        };\n    }\n    async proveCertificate(args, originator) {\n        const paramWriter = new Utils.Writer();\n        const typeAsArray = Utils.toArray(args.certificate.type, 'base64');\n        paramWriter.write(typeAsArray);\n        const subjectAsArray = Utils.toArray(args.certificate.subject, 'hex');\n        paramWriter.write(subjectAsArray);\n        const serialNumberAsArray = Utils.toArray(args.certificate.serialNumber, 'base64');\n        paramWriter.write(serialNumberAsArray);\n        const certifierAsArray = Utils.toArray(args.certificate.certifier, 'hex');\n        paramWriter.write(certifierAsArray);\n        const revocationOutpointAsArray = this.encodeOutpoint(args.certificate.revocationOutpoint ?? '');\n        paramWriter.write(revocationOutpointAsArray);\n        const signatureAsArray = Utils.toArray(args.certificate.signature, 'hex');\n        paramWriter.writeVarIntNum(signatureAsArray.length);\n        paramWriter.write(signatureAsArray);\n        const fieldEntries = Object.entries(args.certificate.fields ?? {});\n        paramWriter.writeVarIntNum(fieldEntries.length);\n        for (const [key, value] of fieldEntries) {\n            const keyAsArray = Utils.toArray(key, 'utf8');\n            const valueAsArray = Utils.toArray(value, 'utf8');\n            paramWriter.writeVarIntNum(keyAsArray.length);\n            paramWriter.write(keyAsArray);\n            paramWriter.writeVarIntNum(valueAsArray.length);\n            paramWriter.write(valueAsArray);\n        }\n        paramWriter.writeVarIntNum(args.fieldsToReveal.length);\n        for (const field of args.fieldsToReveal) {\n            const fieldAsArray = Utils.toArray(field, 'utf8');\n            paramWriter.writeVarIntNum(fieldAsArray.length);\n            paramWriter.write(fieldAsArray);\n        }\n        paramWriter.write(Utils.toArray(args.verifier, 'hex'));\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        const result = await this.transmit('proveCertificate', originator, paramWriter.toArray());\n        const resultReader = new Utils.Reader(result);\n        const numFields = resultReader.readVarIntNum();\n        const keyringForVerifier = {};\n        for (let i = 0; i < numFields; i++) {\n            const fieldKeyLength = resultReader.readVarIntNum();\n            const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLength));\n            const fieldValueLength = resultReader.readVarIntNum();\n            keyringForVerifier[fieldKey] = Utils.toBase64(resultReader.read(fieldValueLength));\n        }\n        return {\n            keyringForVerifier\n        };\n    }\n    async relinquishCertificate(args, originator) {\n        const paramWriter = new Utils.Writer();\n        const typeAsArray = Utils.toArray(args.type, 'base64');\n        paramWriter.write(typeAsArray);\n        const serialNumberAsArray = Utils.toArray(args.serialNumber, 'base64');\n        paramWriter.write(serialNumberAsArray);\n        const certifierAsArray = Utils.toArray(args.certifier, 'hex');\n        paramWriter.write(certifierAsArray);\n        await this.transmit('relinquishCertificate', originator, paramWriter.toArray());\n        return { relinquished: true };\n    }\n    parseDiscoveryResult(result) {\n        const resultReader = new Utils.Reader(result);\n        const totalCertificates = resultReader.readVarIntNum();\n        const certificates = [];\n        for (let i = 0; i < totalCertificates; i++) {\n            const certBinLen = resultReader.readVarIntNum();\n            const certBin = resultReader.read(certBinLen);\n            const cert = Certificate_js_1.default.fromBinary(certBin);\n            const nameLength = resultReader.readVarIntNum();\n            const name = Utils.toUTF8(resultReader.read(nameLength));\n            const iconUrlLength = resultReader.readVarIntNum();\n            const iconUrl = Utils.toUTF8(resultReader.read(iconUrlLength));\n            const descriptionLength = resultReader.readVarIntNum();\n            const description = Utils.toUTF8(resultReader.read(descriptionLength));\n            const trust = resultReader.readUInt8();\n            const publiclyRevealedKeyring = {};\n            const numPublicKeyringEntries = resultReader.readVarIntNum();\n            for (let j = 0; j < numPublicKeyringEntries; j++) {\n                const fieldKeyLen = resultReader.readVarIntNum();\n                const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLen));\n                const fieldValueLen = resultReader.readVarIntNum();\n                publiclyRevealedKeyring[fieldKey] = resultReader.read(fieldValueLen);\n            }\n            const decryptedFields = {};\n            const numDecryptedFields = resultReader.readVarIntNum();\n            for (let k = 0; k < numDecryptedFields; k++) {\n                const fieldKeyLen = resultReader.readVarIntNum();\n                const fieldKey = Utils.toUTF8(resultReader.read(fieldKeyLen));\n                const fieldValueLen = resultReader.readVarIntNum();\n                decryptedFields[fieldKey] = Utils.toUTF8(resultReader.read(fieldValueLen));\n            }\n            certificates.push({\n                ...cert,\n                signature: cert.signature,\n                certifierInfo: { iconUrl, name, description, trust },\n                publiclyRevealedKeyring,\n                decryptedFields\n            });\n        }\n        return {\n            totalCertificates,\n            certificates\n        };\n    }\n    async discoverByIdentityKey(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.write(Utils.toArray(args.identityKey, 'hex'));\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('discoverByIdentityKey', originator, paramWriter.toArray());\n        return this.parseDiscoveryResult(result);\n    }\n    async discoverByAttributes(args, originator) {\n        const paramWriter = new Utils.Writer();\n        const attributeKeys = Object.keys(args.attributes);\n        paramWriter.writeVarIntNum(attributeKeys.length);\n        for (let i = 0; i < attributeKeys.length; i++) {\n            paramWriter.writeVarIntNum(attributeKeys[i].length);\n            paramWriter.write(Utils.toArray(attributeKeys[i], 'utf8'));\n            paramWriter.writeVarIntNum(args.attributes[attributeKeys[i]].length);\n            paramWriter.write(Utils.toArray(args.attributes[attributeKeys[i]], 'utf8'));\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('discoverByAttributes', originator, paramWriter.toArray());\n        return this.parseDiscoveryResult(result);\n    }\n    async isAuthenticated(args, originator) {\n        const result = await this.transmit('isAuthenticated', originator);\n        // @ts-expect-error\n        return { authenticated: result[0] === 1 };\n    }\n    async waitForAuthentication(args, originator) {\n        await this.transmit('waitForAuthentication', originator);\n        return { authenticated: true };\n    }\n    async getHeight(args, originator) {\n        const result = await this.transmit('getHeight', originator);\n        const resultReader = new Utils.Reader(result);\n        return {\n            height: resultReader.readVarIntNum()\n        };\n    }\n    async getHeaderForHeight(args, originator) {\n        const paramWriter = new Utils.Writer();\n        paramWriter.writeVarIntNum(args.height);\n        const header = await this.transmit('getHeaderForHeight', originator, paramWriter.toArray());\n        return {\n            header: Utils.toHex(header)\n        };\n    }\n    async getNetwork(args, originator) {\n        const net = await this.transmit('getNetwork', originator);\n        return {\n            network: net[0] === 0 ? 'mainnet' : 'testnet'\n        };\n    }\n    async getVersion(args, originator) {\n        const version = await this.transmit('getVersion', originator);\n        return {\n            version: Utils.toUTF8(version)\n        };\n    }\n}\nexports[\"default\"] = WalletWireTransceiver;\n//# sourceMappingURL=WalletWireTransceiver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/XDM.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/XDM.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Random_js_1 = __importDefault(__webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/Random.js\"));\nconst Utils = __importStar(__webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/primitives/utils.js\"));\nconst WalletError_js_1 = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/WalletError.js\");\n/**\n * Facilitates wallet operations over cross-document messaging.\n */\nclass XDMSubstrate {\n    constructor(domain = '*') {\n        if (typeof window !== 'object') {\n            throw new Error('The XDM substrate requires a global window object.');\n        }\n        if (typeof window.postMessage !== 'function') {\n            throw new Error('The window object does not seem to support postMessage calls.');\n        }\n        this.domain = domain;\n    }\n    async invoke(call, args) {\n        return await new Promise((resolve, reject) => {\n            const id = Utils.toBase64((0, Random_js_1.default)(12));\n            const listener = (e) => {\n                if (e.data.type !== 'CWI' ||\n                    !e.isTrusted ||\n                    e.data.id !== id ||\n                    e.data.isInvocation === true) {\n                    return;\n                }\n                if (typeof window.removeEventListener === 'function') {\n                    window.removeEventListener('message', listener);\n                }\n                if (e.data.status === 'error') {\n                    const err = new WalletError_js_1.WalletError(e.data.description, e.data.code);\n                    reject(err);\n                }\n                else {\n                    resolve(e.data.result);\n                }\n            };\n            window.addEventListener('message', listener);\n            window.parent.postMessage({\n                type: 'CWI',\n                isInvocation: true,\n                id,\n                call,\n                args\n            }, this.domain);\n        });\n    }\n    async createAction(args) {\n        return await this.invoke('createAction', args);\n    }\n    async signAction(args) {\n        return await this.invoke('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.invoke('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.invoke('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.invoke('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.invoke('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.invoke('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.invoke('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.invoke('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.invoke('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.invoke('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.invoke('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.invoke('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.invoke('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.invoke('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.invoke('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.invoke('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.invoke('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.invoke('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.invoke('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.invoke('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.invoke('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.invoke('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.invoke('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.invoke('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.invoke('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.invoke('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.invoke('getVersion', args);\n    }\n}\nexports[\"default\"] = XDMSubstrate;\n//# sourceMappingURL=XDM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/XDM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/index.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ReactNativeWebView = exports.HTTPWalletJSON = exports.HTTPWalletWire = exports.WalletWireProcessor = exports.WalletWireTransceiver = exports.XDM = exports.WindowCWISubstrate = void 0;\nvar window_CWI_js_1 = __webpack_require__(/*! ./window.CWI.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/window.CWI.js\");\nObject.defineProperty(exports, \"WindowCWISubstrate\", ({ enumerable: true, get: function () { return __importDefault(window_CWI_js_1).default; } }));\nvar XDM_js_1 = __webpack_require__(/*! ./XDM.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/XDM.js\");\nObject.defineProperty(exports, \"XDM\", ({ enumerable: true, get: function () { return __importDefault(XDM_js_1).default; } }));\n__exportStar(__webpack_require__(/*! ./WalletWire.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWire.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireCalls.js\"), exports);\nvar WalletWireTransceiver_js_1 = __webpack_require__(/*! ./WalletWireTransceiver.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireTransceiver.js\");\nObject.defineProperty(exports, \"WalletWireTransceiver\", ({ enumerable: true, get: function () { return __importDefault(WalletWireTransceiver_js_1).default; } }));\nvar WalletWireProcessor_js_1 = __webpack_require__(/*! ./WalletWireProcessor.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/WalletWireProcessor.js\");\nObject.defineProperty(exports, \"WalletWireProcessor\", ({ enumerable: true, get: function () { return __importDefault(WalletWireProcessor_js_1).default; } }));\nvar HTTPWalletWire_js_1 = __webpack_require__(/*! ./HTTPWalletWire.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletWire.js\");\nObject.defineProperty(exports, \"HTTPWalletWire\", ({ enumerable: true, get: function () { return __importDefault(HTTPWalletWire_js_1).default; } }));\nvar HTTPWalletJSON_js_1 = __webpack_require__(/*! ./HTTPWalletJSON.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/HTTPWalletJSON.js\");\nObject.defineProperty(exports, \"HTTPWalletJSON\", ({ enumerable: true, get: function () { return __importDefault(HTTPWalletJSON_js_1).default; } }));\nvar ReactNativeWebView_js_1 = __webpack_require__(/*! ./ReactNativeWebView.js */ \"./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/ReactNativeWebView.js\");\nObject.defineProperty(exports, \"ReactNativeWebView\", ({ enumerable: true, get: function () { return __importDefault(ReactNativeWebView_js_1).default; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/utils/toOriginHeader.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/utils/toOriginHeader.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toOriginHeader = void 0;\nfunction toOriginHeader(originator, fallbackScheme = 'http') {\n    // If the caller already gave us a scheme, assume its fine\n    if (/^[a-z][a-z0-9+.-]*:\\/\\//i.test(originator)) {\n        try {\n            return new URL(originator).origin; // trims any path/query\n        }\n        catch { /* fall through to fix-up */ }\n    }\n    // Otherwise, prepend the fallback scheme and validate\n    try {\n        return new URL(`${fallbackScheme}://${originator}`).origin;\n    }\n    catch {\n        throw new Error(`Invalid originator value: ${originator}`);\n    }\n}\nexports.toOriginHeader = toOriginHeader;\n//# sourceMappingURL=toOriginHeader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/utils/toOriginHeader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/window.CWI.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/window.CWI.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Facilitates wallet operations over the window.CWI interface.\n */\nclass WindowCWISubstrate {\n    constructor() {\n        if (typeof window !== 'object') {\n            throw new Error('The window.CWI substrate requires a global window object.');\n        }\n        if (typeof window.CWI !== 'object') {\n            throw new Error('The window.CWI interface does not appear to be bound to the window object.');\n        }\n        this.CWI = window.CWI; // Binding CWI to prevent changes\n    }\n    async createAction(args, originator) {\n        return await this.CWI.createAction(args, originator);\n    }\n    async signAction(args, originator) {\n        return await this.CWI.signAction(args, originator);\n    }\n    async abortAction(args, originator) {\n        return await this.CWI.abortAction(args, originator);\n    }\n    async listActions(args, originator) {\n        return await this.CWI.listActions(args, originator);\n    }\n    async internalizeAction(args, originator) {\n        return await this.CWI.internalizeAction(args, originator);\n    }\n    async listOutputs(args, originator) {\n        return await this.CWI.listOutputs(args, originator);\n    }\n    async relinquishOutput(args, originator) {\n        return await this.CWI.relinquishOutput(args, originator);\n    }\n    async getPublicKey(args, originator) {\n        return await this.CWI.getPublicKey(args, originator);\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        return await this.CWI.revealCounterpartyKeyLinkage(args, originator);\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        return await this.CWI.revealSpecificKeyLinkage(args, originator);\n    }\n    async encrypt(args, originator) {\n        return await this.CWI.encrypt(args, originator);\n    }\n    async decrypt(args, originator) {\n        return await this.CWI.decrypt(args, originator);\n    }\n    async createHmac(args, originator) {\n        return await this.CWI.createHmac(args, originator);\n    }\n    async verifyHmac(args, originator) {\n        return await this.CWI.verifyHmac(args, originator);\n    }\n    async createSignature(args, originator) {\n        return await this.CWI.createSignature(args, originator);\n    }\n    async verifySignature(args, originator) {\n        return await this.CWI.verifySignature(args, originator);\n    }\n    async acquireCertificate(args, originator) {\n        return await this.CWI.acquireCertificate(args, originator);\n    }\n    async listCertificates(args, originator) {\n        return await this.CWI.listCertificates(args, originator);\n    }\n    async proveCertificate(args, originator) {\n        return await this.CWI.proveCertificate(args, originator);\n    }\n    async relinquishCertificate(args, originator) {\n        return await this.CWI.relinquishCertificate(args, originator);\n    }\n    async discoverByIdentityKey(args, originator) {\n        return await this.CWI.discoverByIdentityKey(args, originator);\n    }\n    async discoverByAttributes(args, originator) {\n        return await this.CWI.discoverByAttributes(args, originator);\n    }\n    async isAuthenticated(args, originator) {\n        return await this.CWI.isAuthenticated(args, originator);\n    }\n    async waitForAuthentication(args, originator) {\n        return await this.CWI.waitForAuthentication(args, originator);\n    }\n    async getHeight(args, originator) {\n        return await this.CWI.getHeight(args, originator);\n    }\n    async getHeaderForHeight(args, originator) {\n        return await this.CWI.getHeaderForHeight(args, originator);\n    }\n    async getNetwork(args, originator) {\n        return await this.CWI.getNetwork(args, originator);\n    }\n    async getVersion(args, originator) {\n        return await this.CWI.getVersion(args, originator);\n    }\n}\nexports[\"default\"] = WindowCWISubstrate;\n//# sourceMappingURL=window.CWI.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/cjs/src/wallet/substrates/window.CWI.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/mod.js":
/*!***********************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/mod.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARC: () => (/* reexport safe */ _src_transaction_broadcasters_index_js__WEBPACK_IMPORTED_MODULE_5__.ARC),\n/* harmony export */   ATOMIC_BEEF: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.ATOMIC_BEEF),\n/* harmony export */   AuthFetch: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.AuthFetch),\n/* harmony export */   BEEF_V1: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.BEEF_V1),\n/* harmony export */   BEEF_V2: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.BEEF_V2),\n/* harmony export */   BSM: () => (/* reexport safe */ _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__.BSM),\n/* harmony export */   Beef: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.Beef),\n/* harmony export */   BeefParty: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.BeefParty),\n/* harmony export */   BeefTx: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.BeefTx),\n/* harmony export */   BigNumber: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.BigNumber),\n/* harmony export */   BlockHeadersService: () => (/* reexport safe */ _src_transaction_chaintrackers_index_js__WEBPACK_IMPORTED_MODULE_6__.BlockHeadersService),\n/* harmony export */   CachedKeyDeriver: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.CachedKeyDeriver),\n/* harmony export */   Certificate: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.Certificate),\n/* harmony export */   CompletedProtoWallet: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.CompletedProtoWallet),\n/* harmony export */   Curve: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Curve),\n/* harmony export */   DEFAULT_IDENTITY_CLIENT_OPTIONS: () => (/* reexport safe */ _src_identity_index_js__WEBPACK_IMPORTED_MODULE_16__.DEFAULT_IDENTITY_CLIENT_OPTIONS),\n/* harmony export */   DEFAULT_SLAP_TRACKERS: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_SLAP_TRACKERS),\n/* harmony export */   DEFAULT_TESTNET_SLAP_TRACKERS: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.DEFAULT_TESTNET_SLAP_TRACKERS),\n/* harmony export */   DRBG: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.DRBG),\n/* harmony export */   ECDSA: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.ECDSA),\n/* harmony export */   ECIES: () => (/* reexport safe */ _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__.ECIES),\n/* harmony export */   EncryptedMessage: () => (/* reexport safe */ _src_messages_index_js__WEBPACK_IMPORTED_MODULE_8__.EncryptedMessage),\n/* harmony export */   FetchHttpClient: () => (/* reexport safe */ _src_transaction_http_index_js__WEBPACK_IMPORTED_MODULE_7__.FetchHttpClient),\n/* harmony export */   HD: () => (/* reexport safe */ _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__.HD),\n/* harmony export */   HTTPSOverlayBroadcastFacilitator: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.HTTPSOverlayBroadcastFacilitator),\n/* harmony export */   HTTPSOverlayLookupFacilitator: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.HTTPSOverlayLookupFacilitator),\n/* harmony export */   HTTPWalletJSON: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.HTTPWalletJSON),\n/* harmony export */   HTTPWalletWire: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.HTTPWalletWire),\n/* harmony export */   Hash: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Hash),\n/* harmony export */   IdentityClient: () => (/* reexport safe */ _src_identity_index_js__WEBPACK_IMPORTED_MODULE_16__.IdentityClient),\n/* harmony export */   KNOWN_IDENTITY_TYPES: () => (/* reexport safe */ _src_identity_index_js__WEBPACK_IMPORTED_MODULE_16__.KNOWN_IDENTITY_TYPES),\n/* harmony export */   KeyDeriver: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.KeyDeriver),\n/* harmony export */   KeyShares: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.KeyShares),\n/* harmony export */   LocalKVStore: () => (/* reexport safe */ _src_kvstore_index_js__WEBPACK_IMPORTED_MODULE_18__.LocalKVStore),\n/* harmony export */   LockingScript: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.LockingScript),\n/* harmony export */   LookupResolver: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.LookupResolver),\n/* harmony export */   MasterCertificate: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.MasterCertificate),\n/* harmony export */   MerklePath: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.MerklePath),\n/* harmony export */   Mnemonic: () => (/* reexport safe */ _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__.Mnemonic),\n/* harmony export */   NodejsHttpClient: () => (/* reexport safe */ _src_transaction_http_index_js__WEBPACK_IMPORTED_MODULE_7__.NodejsHttpClient),\n/* harmony export */   OP: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.OP),\n/* harmony export */   OverlayAdminTokenTemplate: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.OverlayAdminTokenTemplate),\n/* harmony export */   P2PKH: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.P2PKH),\n/* harmony export */   Peer: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.Peer),\n/* harmony export */   Point: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Point),\n/* harmony export */   PointInFiniteField: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PointInFiniteField),\n/* harmony export */   Polynomial: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Polynomial),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey),\n/* harmony export */   ProtoWallet: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.ProtoWallet),\n/* harmony export */   PublicKey: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey),\n/* harmony export */   PushDrop: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.PushDrop),\n/* harmony export */   RPuzzle: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.RPuzzle),\n/* harmony export */   Random: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Random),\n/* harmony export */   ReactNativeWebView: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.ReactNativeWebView),\n/* harmony export */   RegistryClient: () => (/* reexport safe */ _src_registry_index_js__WEBPACK_IMPORTED_MODULE_17__.RegistryClient),\n/* harmony export */   SHIPBroadcaster: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.SHIPBroadcaster),\n/* harmony export */   SHIPCast: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.SHIPCast),\n/* harmony export */   SatoshisPerKilobyte: () => (/* reexport safe */ _src_transaction_fee_models_index_js__WEBPACK_IMPORTED_MODULE_4__.SatoshisPerKilobyte),\n/* harmony export */   Schnorr: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Schnorr),\n/* harmony export */   Script: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.Script),\n/* harmony export */   ScriptEvaluationError: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.ScriptEvaluationError),\n/* harmony export */   SecurityLevels: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.SecurityLevels),\n/* harmony export */   SessionManager: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.SessionManager),\n/* harmony export */   Signature: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Signature),\n/* harmony export */   SignedMessage: () => (/* reexport safe */ _src_messages_index_js__WEBPACK_IMPORTED_MODULE_8__.SignedMessage),\n/* harmony export */   SimplifiedFetchTransport: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.SimplifiedFetchTransport),\n/* harmony export */   Spend: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.Spend),\n/* harmony export */   StorageDownloader: () => (/* reexport safe */ _src_storage_index_js__WEBPACK_IMPORTED_MODULE_15__.StorageDownloader),\n/* harmony export */   StorageUploader: () => (/* reexport safe */ _src_storage_index_js__WEBPACK_IMPORTED_MODULE_15__.StorageUploader),\n/* harmony export */   StorageUtils: () => (/* reexport safe */ _src_storage_index_js__WEBPACK_IMPORTED_MODULE_15__.StorageUtils),\n/* harmony export */   SymmetricKey: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.SymmetricKey),\n/* harmony export */   TOTP: () => (/* reexport safe */ _src_totp_index_js__WEBPACK_IMPORTED_MODULE_10__.TOTP),\n/* harmony export */   TX_DATA_FORMAT: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT),\n/* harmony export */   Teranode: () => (/* reexport safe */ _src_transaction_broadcasters_index_js__WEBPACK_IMPORTED_MODULE_5__.Teranode),\n/* harmony export */   TopicBroadcaster: () => (/* reexport safe */ _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__.TopicBroadcaster),\n/* harmony export */   Transaction: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.Transaction),\n/* harmony export */   TransactionSignature: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.TransactionSignature),\n/* harmony export */   UnlockingScript: () => (/* reexport safe */ _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__.UnlockingScript),\n/* harmony export */   Utils: () => (/* reexport safe */ _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Utils),\n/* harmony export */   VerifiableCertificate: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.VerifiableCertificate),\n/* harmony export */   WERR_REVIEW_ACTIONS: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WERR_REVIEW_ACTIONS),\n/* harmony export */   WalletClient: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WalletClient),\n/* harmony export */   WalletError: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WalletError),\n/* harmony export */   WalletErrors: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WalletErrors),\n/* harmony export */   WalletWireProcessor: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WalletWireProcessor),\n/* harmony export */   WalletWireTransceiver: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WalletWireTransceiver),\n/* harmony export */   WhatsOnChain: () => (/* reexport safe */ _src_transaction_chaintrackers_index_js__WEBPACK_IMPORTED_MODULE_6__.WhatsOnChain),\n/* harmony export */   WhatsOnChainBroadcaster: () => (/* reexport safe */ _src_transaction_broadcasters_index_js__WEBPACK_IMPORTED_MODULE_5__.WhatsOnChainBroadcaster),\n/* harmony export */   WindowCWISubstrate: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.WindowCWISubstrate),\n/* harmony export */   XDM: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.XDM),\n/* harmony export */   binaryHttpClient: () => (/* reexport safe */ _src_transaction_http_index_js__WEBPACK_IMPORTED_MODULE_7__.binaryHttpClient),\n/* harmony export */   createNonce: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.createNonce),\n/* harmony export */   defaultBroadcaster: () => (/* reexport safe */ _src_transaction_broadcasters_index_js__WEBPACK_IMPORTED_MODULE_5__.defaultBroadcaster),\n/* harmony export */   defaultChainTracker: () => (/* reexport safe */ _src_transaction_chaintrackers_index_js__WEBPACK_IMPORTED_MODULE_6__.defaultChainTracker),\n/* harmony export */   defaultHttpClient: () => (/* reexport safe */ _src_transaction_http_index_js__WEBPACK_IMPORTED_MODULE_7__.defaultHttpClient),\n/* harmony export */   defaultIdentity: () => (/* reexport safe */ _src_identity_index_js__WEBPACK_IMPORTED_MODULE_16__.defaultIdentity),\n/* harmony export */   deserializeWalletProtocol: () => (/* reexport safe */ _src_registry_index_js__WEBPACK_IMPORTED_MODULE_17__.deserializeWalletProtocol),\n/* harmony export */   fromUtxo: () => (/* reexport safe */ _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__.fromUtxo),\n/* harmony export */   getVerifiableCertificates: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.getVerifiableCertificates),\n/* harmony export */   isBroadcastFailure: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.isBroadcastFailure),\n/* harmony export */   isBroadcastResponse: () => (/* reexport safe */ _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.isBroadcastResponse),\n/* harmony export */   validateCertificates: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.validateCertificates),\n/* harmony export */   verifyNonce: () => (/* reexport safe */ _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__.verifyNonce),\n/* harmony export */   walletErrors: () => (/* reexport safe */ _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__.walletErrors)\n/* harmony export */ });\n/* harmony import */ var _src_primitives_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n/* harmony import */ var _src_script_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/script/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/index.js\");\n/* harmony import */ var _src_script_templates_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/script/templates/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/index.js\");\n/* harmony import */ var _src_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/transaction/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js\");\n/* harmony import */ var _src_transaction_fee_models_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/transaction/fee-models/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/index.js\");\n/* harmony import */ var _src_transaction_broadcasters_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/transaction/broadcasters/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/index.js\");\n/* harmony import */ var _src_transaction_chaintrackers_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/transaction/chaintrackers/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/index.js\");\n/* harmony import */ var _src_transaction_http_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/transaction/http/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/index.js\");\n/* harmony import */ var _src_messages_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/messages/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/messages/index.js\");\n/* harmony import */ var _src_compat_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/compat/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/index.js\");\n/* harmony import */ var _src_totp_index_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/totp/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/totp/index.js\");\n/* harmony import */ var _src_wallet_index_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/wallet/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js\");\n/* harmony import */ var _src_wallet_substrates_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/wallet/substrates/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/index.js\");\n/* harmony import */ var _src_auth_index_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/auth/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/index.js\");\n/* harmony import */ var _src_overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js\");\n/* harmony import */ var _src_storage_index_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/storage/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/index.js\");\n/* harmony import */ var _src_identity_index_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/identity/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/identity/index.js\");\n/* harmony import */ var _src_registry_index_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/registry/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/registry/index.js\");\n/* harmony import */ var _src_kvstore_index_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/kvstore/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/kvstore/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=mod.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/mod.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/Peer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/Peer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Peer: () => (/* binding */ Peer)\n/* harmony export */ });\n/* harmony import */ var _SessionManager_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SessionManager.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\nconst AUTH_VERSION = '0.1';\n/**\n * Represents a peer capable of performing mutual authentication.\n * Manages sessions, handles authentication handshakes, certificate requests and responses,\n * and sending and receiving general messages over a transport layer.\n *\n * This version supports multiple concurrent sessions per peer identityKey.\n */\nclass Peer {\n    sessionManager;\n    transport;\n    wallet;\n    certificatesToRequest;\n    onGeneralMessageReceivedCallbacks = new Map();\n    onCertificatesReceivedCallbacks = new Map();\n    onCertificateRequestReceivedCallbacks = new Map();\n    onInitialResponseReceivedCallbacks = new Map();\n    // Single shared counter for all callback types\n    callbackIdCounter = 0;\n    // Whether to auto-persist the session with the last-interacted-with peer\n    autoPersistLastSession = true;\n    // Last-interacted-with peer identity key (if the user calls toPeer with no identityKey)\n    lastInteractedWithPeer;\n    /**\n     * Creates a new Peer instance\n     *\n     * @param {WalletInterface} wallet - The wallet instance used for cryptographic operations.\n     * @param {Transport} transport - The transport mechanism used for sending and receiving messages.\n     * @param {RequestedCertificateSet} [certificatesToRequest] - Optional set of certificates to request from a peer during the initial handshake.\n     * @param {SessionManager} [sessionManager] - Optional SessionManager to be used for managing peer sessions.\n     * @param {boolean} [autoPersistLastSession] - Whether to auto-persist the session with the last-interacted-with peer. Defaults to true.\n     */\n    constructor(wallet, transport, certificatesToRequest, sessionManager, autoPersistLastSession) {\n        this.wallet = wallet;\n        this.transport = transport;\n        this.certificatesToRequest = certificatesToRequest ?? {\n            certifiers: [],\n            types: {}\n        };\n        this.transport.onData(this.handleIncomingMessage.bind(this)).catch(e => {\n            throw e;\n        });\n        this.sessionManager =\n            sessionManager != null ? sessionManager : new _SessionManager_js__WEBPACK_IMPORTED_MODULE_0__.SessionManager();\n        if (autoPersistLastSession === false) {\n            this.autoPersistLastSession = false;\n        }\n        else {\n            this.autoPersistLastSession = true;\n        }\n    }\n    /**\n     * Sends a general message to a peer, and initiates a handshake if necessary.\n     *\n     * @param {number[]} message - The message payload to send.\n     * @param {string} [identityKey] - The identity public key of the peer. If not provided, uses lastInteractedWithPeer (if any).\n     * @param {number} [maxWaitTime] - optional max wait time in ms\n     * @returns {Promise<void>}\n     * @throws Will throw an error if the message fails to send.\n     */\n    async toPeer(message, identityKey, maxWaitTime) {\n        if (this.autoPersistLastSession &&\n            typeof this.lastInteractedWithPeer === 'string' &&\n            typeof identityKey !== 'string') {\n            identityKey = this.lastInteractedWithPeer;\n        }\n        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);\n        // Prepare the general message\n        const requestNonce = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32));\n        const { signature } = await this.wallet.createSignature({\n            data: message,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const generalMessage = {\n            version: AUTH_VERSION,\n            messageType: 'general',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            yourNonce: peerSession.peerNonce,\n            payload: message,\n            signature\n        };\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(generalMessage);\n        }\n        catch (error) {\n            const e = new Error(`Failed to send message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);\n            e.stack = error.stack;\n            throw e;\n        }\n    }\n    /**\n     * Sends a request for certificates to a peer.\n     * This method allows a peer to dynamically request specific certificates after\n     * an initial handshake or message has been exchanged.\n     *\n     * @param {RequestedCertificateSet} certificatesToRequest - Specifies the certifiers and types of certificates required from the peer.\n     * @param {string} [identityKey] - The identity public key of the peer. If not provided, the current or last session identity is used.\n     * @param {number} [maxWaitTime=10000] - Maximum time in milliseconds to wait for the peer session to be authenticated.\n     * @returns {Promise<void>} Resolves if the certificate request message is successfully sent.\n     * @throws Will throw an error if the peer session is not authenticated or if sending the request fails.\n     */\n    async requestCertificates(certificatesToRequest, identityKey, maxWaitTime = 10000) {\n        if (this.autoPersistLastSession &&\n            typeof this.lastInteractedWithPeer === 'string' &&\n            typeof identityKey !== 'string') {\n            identityKey = this.lastInteractedWithPeer;\n        }\n        const peerSession = await this.getAuthenticatedSession(identityKey, maxWaitTime);\n        // Prepare the message\n        const requestNonce = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32));\n        const { signature } = await this.wallet.createSignature({\n            data: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray(JSON.stringify(certificatesToRequest), 'utf8'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const certRequestMessage = {\n            version: AUTH_VERSION,\n            messageType: 'certificateRequest',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            initialNonce: peerSession.sessionNonce,\n            yourNonce: peerSession.peerNonce,\n            requestedCertificates: certificatesToRequest,\n            signature\n        };\n        // Update last-used timestamp\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(certRequestMessage);\n        }\n        catch (error) {\n            throw new Error(`Failed to send certificate request message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${String(error.message)}`);\n        }\n    }\n    /**\n     * Retrieves an authenticated session for a given peer identity. If no session exists\n     * or the session is not authenticated, initiates a handshake to create or authenticate the session.\n     *\n     * - If `identityKey` is provided, we look up any existing session for that identity key.\n     * - If none is found or not authenticated, we do a new handshake.\n     * - If `identityKey` is not provided, but we have a `lastInteractedWithPeer`, we try that key.\n     *\n     * @param {string} [identityKey] - The identity public key of the peer.\n     * @param {number} [maxWaitTime] - The maximum time in milliseconds to wait for the handshake.\n     * @returns {Promise<PeerSession>} - A promise that resolves with an authenticated `PeerSession`.\n     */\n    async getAuthenticatedSession(identityKey, maxWaitTime) {\n        if (this.transport === undefined) {\n            throw new Error('Peer transport is not connected!');\n        }\n        let peerSession;\n        if (typeof identityKey === 'string') {\n            peerSession = this.sessionManager.getSession(identityKey);\n        }\n        // If that session doesn't exist or isn't authenticated, initiate handshake\n        if ((peerSession == null) || !peerSession.isAuthenticated) {\n            // This will create a brand-new session\n            const sessionNonce = await this.initiateHandshake(identityKey, maxWaitTime);\n            // Now retrieve it by the sessionNonce\n            peerSession = this.sessionManager.getSession(sessionNonce);\n            if ((peerSession == null) || !peerSession.isAuthenticated) {\n                throw new Error('Unable to establish mutual authentication with peer!');\n            }\n        }\n        return peerSession;\n    }\n    /**\n     * Registers a callback to listen for general messages from peers.\n     *\n     * @param {(senderPublicKey: string, payload: number[]) => void} callback - The function to call when a general message is received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForGeneralMessages(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onGeneralMessageReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Removes a general message listener.\n     *\n     * @param {number} callbackID - The ID of the callback to remove.\n     */\n    stopListeningForGeneralMessages(callbackID) {\n        this.onGeneralMessageReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Registers a callback to listen for certificates received from peers.\n     *\n     * @param {(senderPublicKey: string, certs: VerifiableCertificate[]) => void} callback - The function to call when certificates are received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForCertificatesReceived(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onCertificatesReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Cancels and unsubscribes a certificatesReceived listener.\n     *\n     * @param {number} callbackID - The ID of the certificates received callback to cancel.\n     */\n    stopListeningForCertificatesReceived(callbackID) {\n        this.onCertificatesReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Registers a callback to listen for certificates requested from peers.\n     *\n     * @param {(requestedCertificates: RequestedCertificateSet) => void} callback - The function to call when a certificate request is received\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForCertificatesRequested(callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onCertificateRequestReceivedCallbacks.set(callbackID, callback);\n        return callbackID;\n    }\n    /**\n     * Cancels and unsubscribes a certificatesRequested listener.\n     *\n     * @param {number} callbackID - The ID of the requested certificates callback to cancel.\n     */\n    stopListeningForCertificatesRequested(callbackID) {\n        this.onCertificateRequestReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Initiates the mutual authentication handshake with a peer.\n     *\n     * @private\n     * @param {string} [identityKey] - The identity public key of the peer.\n     * @param {number} [maxWaitTime=10000] - how long to wait for handshake\n     * @returns {Promise<string>} A promise that resolves to the session nonce.\n     */\n    async initiateHandshake(identityKey, maxWaitTime = 10000) {\n        const sessionNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.createNonce)(this.wallet); // Initial request nonce\n        // Create the preliminary session (not yet authenticated)\n        const now = Date.now();\n        this.sessionManager.addSession({\n            isAuthenticated: false,\n            sessionNonce,\n            peerIdentityKey: identityKey,\n            lastUpdate: now\n        });\n        const initialRequest = {\n            version: AUTH_VERSION,\n            messageType: 'initialRequest',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            initialNonce: sessionNonce,\n            requestedCertificates: this.certificatesToRequest\n        };\n        await this.transport.send(initialRequest);\n        return await this.waitForInitialResponse(sessionNonce, maxWaitTime);\n    }\n    /**\n     * Waits for the initial response from the peer after sending an initial handshake request message.\n     *\n     * @param {string} sessionNonce - The session nonce created in the initial request.\n     * @returns {Promise<string>} A promise that resolves with the session nonce when the initial response is received.\n     */\n    async waitForInitialResponse(sessionNonce, maxWaitTime = 10000) {\n        return await new Promise((resolve, reject) => {\n            const callbackID = this.listenForInitialResponse(sessionNonce, nonce => {\n                clearTimeout(timeoutHandle);\n                this.stopListeningForInitialResponses(callbackID);\n                resolve(nonce);\n            });\n            const timeoutHandle = setTimeout(() => {\n                this.stopListeningForInitialResponses(callbackID);\n                reject(new Error('Initial response timed out.'));\n            }, maxWaitTime);\n        });\n    }\n    /**\n     * Adds a listener for an initial response message matching a specific initial nonce.\n     *\n     * @private\n     * @param {string} sessionNonce - The session nonce to match.\n     * @param {(sessionNonce: string) => void} callback - The callback to invoke when the initial response is received.\n     * @returns {number} The ID of the callback listener.\n     */\n    listenForInitialResponse(sessionNonce, callback) {\n        const callbackID = this.callbackIdCounter++;\n        this.onInitialResponseReceivedCallbacks.set(callbackID, {\n            callback,\n            sessionNonce\n        });\n        return callbackID;\n    }\n    /**\n     * Removes a listener for initial responses.\n     *\n     * @private\n     * @param {number} callbackID - The ID of the callback to remove.\n     */\n    stopListeningForInitialResponses(callbackID) {\n        this.onInitialResponseReceivedCallbacks.delete(callbackID);\n    }\n    /**\n     * Handles incoming messages from the transport.\n     *\n     * @param {AuthMessage} message - The incoming message to process.\n     * @returns {Promise<void>}\n     */\n    async handleIncomingMessage(message) {\n        if (typeof message.version !== 'string' || message.version !== AUTH_VERSION) {\n            throw new Error(`Invalid or unsupported message auth version! Received: ${message.version}, expected: ${AUTH_VERSION}`);\n        }\n        switch (message.messageType) {\n            case 'initialRequest':\n                await this.processInitialRequest(message);\n                break;\n            case 'initialResponse':\n                await this.processInitialResponse(message);\n                break;\n            case 'certificateRequest':\n                await this.processCertificateRequest(message);\n                break;\n            case 'certificateResponse':\n                await this.processCertificateResponse(message);\n                break;\n            case 'general':\n                await this.processGeneralMessage(message);\n                break;\n            default:\n                throw new Error(`Unknown message type of ${String(message.messageType)} from ${String(message.identityKey)}`);\n        }\n    }\n    /**\n     * Processes an initial request message from a peer.\n     *\n     * @param {AuthMessage} message - The incoming initial request message.\n     */\n    async processInitialRequest(message) {\n        if (typeof message.identityKey !== 'string' ||\n            typeof message.initialNonce !== 'string' ||\n            message.initialNonce === '') {\n            throw new Error('Missing required fields in initialRequest message.');\n        }\n        // Create a new sessionNonce for our side\n        const sessionNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.createNonce)(this.wallet);\n        const now = Date.now();\n        // We'll treat this as fully authenticated from *our* perspective (the responding side).\n        this.sessionManager.addSession({\n            isAuthenticated: true,\n            sessionNonce,\n            peerNonce: message.initialNonce,\n            peerIdentityKey: message.identityKey,\n            lastUpdate: now\n        });\n        // Possibly handle the peer's requested certs\n        let certificatesToInclude;\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt to find automatically\n                certificatesToInclude = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n            }\n        }\n        // Create signature\n        const { signature } = await this.wallet.createSignature({\n            data: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray(message.initialNonce + sessionNonce, 'base64'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.initialNonce} ${sessionNonce}`,\n            counterparty: message.identityKey\n        });\n        const initialResponseMessage = {\n            version: AUTH_VERSION,\n            messageType: 'initialResponse',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            initialNonce: sessionNonce,\n            yourNonce: message.initialNonce,\n            certificates: certificatesToInclude,\n            requestedCertificates: this.certificatesToRequest,\n            signature\n        };\n        // If we haven't interacted with a peer yet, store this identity as \"lastInteracted\"\n        if (this.lastInteractedWithPeer === undefined) {\n            this.lastInteractedWithPeer = message.identityKey;\n        }\n        // Send the response\n        await this.transport.send(initialResponseMessage);\n    }\n    /**\n     * Processes an initial response message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming initial response message.\n     * @throws Will throw an error if nonce or signature verification fails.\n     */\n    async processInitialResponse(message) {\n        const validNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Initial response nonce verification failed from peer: ${message.identityKey}`);\n        }\n        // This is the session we previously created by calling initiateHandshake\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Peer session not found for peer: ${message.identityKey}`);\n        }\n        // Validate message signature\n        const dataToVerify = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray((peerSession.sessionNonce ?? '') + (message.initialNonce ?? ''), 'base64');\n        const { valid } = await this.wallet.verifySignature({\n            data: dataToVerify,\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${peerSession.sessionNonce ?? ''} ${message.initialNonce ?? ''}`,\n            counterparty: message.identityKey\n        });\n        if (!valid) {\n            throw new Error(`Unable to verify initial response signature for peer: ${message.identityKey}`);\n        }\n        // Now mark the session as authenticated\n        peerSession.peerNonce = message.initialNonce;\n        peerSession.peerIdentityKey = message.identityKey;\n        peerSession.isAuthenticated = true;\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        // If the handshake had requested certificates, validate them\n        if (this.certificatesToRequest?.certifiers?.length > 0 &&\n            message.certificates?.length > 0) {\n            await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.validateCertificates)(this.wallet, message, this.certificatesToRequest);\n            // Notify listeners\n            this.onCertificatesReceivedCallbacks.forEach(cb => cb(message.identityKey, message.certificates));\n        }\n        // Update lastInteractedWithPeer\n        this.lastInteractedWithPeer = message.identityKey;\n        // Let the handshake wait-latch know we got our response\n        this.onInitialResponseReceivedCallbacks.forEach(entry => {\n            if (entry.sessionNonce === peerSession.sessionNonce) {\n                entry.callback(peerSession.sessionNonce);\n            }\n        });\n        // The peer might also request certificates from us\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt auto\n                const verifiableCertificates = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);\n            }\n        }\n    }\n    /**\n     * Processes an incoming certificate request message from a peer.\n     * Verifies nonce/signature and then possibly sends a certificateResponse.\n     *\n     * @param {AuthMessage} message - The certificate request message received from the peer.\n     * @throws {Error} if nonce or signature is invalid.\n     */\n    async processCertificateRequest(message) {\n        const validNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for certificate request message from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        const { valid } = await this.wallet.verifySignature({\n            data: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray(JSON.stringify(message.requestedCertificates), 'utf8'),\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        if (!valid) {\n            throw new Error(`Invalid signature in certificate request message from ${peerSession.peerIdentityKey}`);\n        }\n        // Update usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        if ((message.requestedCertificates != null) &&\n            Array.isArray(message.requestedCertificates.certifiers) &&\n            message.requestedCertificates.certifiers.length > 0) {\n            if (this.onCertificateRequestReceivedCallbacks.size > 0) {\n                // Let the application handle it\n                this.onCertificateRequestReceivedCallbacks.forEach(cb => {\n                    cb(message.identityKey, message.requestedCertificates);\n                });\n            }\n            else {\n                // Attempt auto\n                const verifiableCertificates = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.getVerifiableCertificates)(this.wallet, message.requestedCertificates, message.identityKey);\n                await this.sendCertificateResponse(message.identityKey, verifiableCertificates);\n            }\n        }\n    }\n    /**\n     * Sends a certificate response message containing the specified certificates to a peer.\n     *\n     * @param {string} verifierIdentityKey - The identity key of the peer requesting the certificates.\n     * @param {VerifiableCertificate[]} certificates - The list of certificates to include in the response.\n     * @throws Will throw an error if the transport fails to send the message.\n     */\n    async sendCertificateResponse(verifierIdentityKey, certificates) {\n        const peerSession = await this.getAuthenticatedSession(verifierIdentityKey);\n        const requestNonce = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32));\n        const { signature } = await this.wallet.createSignature({\n            data: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray(JSON.stringify(certificates), 'utf8'),\n            protocolID: [2, 'auth message signature'],\n            keyID: `${requestNonce} ${peerSession.peerNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        const certificateResponse = {\n            version: AUTH_VERSION,\n            messageType: 'certificateResponse',\n            identityKey: (await this.wallet.getPublicKey({ identityKey: true }))\n                .publicKey,\n            nonce: requestNonce,\n            initialNonce: peerSession.sessionNonce,\n            yourNonce: peerSession.peerNonce,\n            certificates,\n            signature\n        };\n        // Update usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        try {\n            await this.transport.send(certificateResponse);\n        }\n        catch (error) {\n            const errorMessage = error instanceof Error ? error.message : String(error);\n            throw new Error(`Failed to send certificate response message to peer ${peerSession.peerIdentityKey ?? 'unknown'}: ${errorMessage}`);\n        }\n    }\n    /**\n     * Processes a certificate response message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming certificate response message.\n     * @throws Will throw an error if nonce verification or signature verification fails.\n     */\n    async processCertificateResponse(message) {\n        const validNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for certificate response from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        // Validate message signature\n        const { valid } = await this.wallet.verifySignature({\n            data: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray(JSON.stringify(message.certificates), 'utf8'),\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: message.identityKey\n        });\n        if (!valid) {\n            throw new Error(`Unable to verify certificate response signature for peer: ${message.identityKey}`);\n        }\n        // We also handle optional validation if there's a requestedCertificates field\n        await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.validateCertificates)(this.wallet, message, message.requestedCertificates);\n        // Notify any listeners\n        this.onCertificatesReceivedCallbacks.forEach(cb => {\n            cb(message.identityKey, message.certificates ?? []);\n        });\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n    }\n    /**\n     * Processes a general message from a peer.\n     *\n     * @private\n     * @param {AuthMessage} message - The incoming general message.\n     * @throws Will throw an error if nonce or signature verification fails.\n     */\n    async processGeneralMessage(message) {\n        const validNonce = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_1__.verifyNonce)(message.yourNonce, this.wallet);\n        if (!validNonce) {\n            throw new Error(`Unable to verify nonce for general message from: ${message.identityKey}`);\n        }\n        const peerSession = this.sessionManager.getSession(message.yourNonce);\n        if (peerSession == null) {\n            throw new Error(`Session not found for nonce: ${message.yourNonce}`);\n        }\n        const { valid } = await this.wallet.verifySignature({\n            data: message.payload,\n            signature: message.signature,\n            protocolID: [2, 'auth message signature'],\n            keyID: `${message.nonce ?? ''} ${peerSession.sessionNonce ?? ''}`,\n            counterparty: peerSession.peerIdentityKey\n        });\n        if (!valid) {\n            throw new Error(`Invalid signature in generalMessage from ${peerSession.peerIdentityKey}`);\n        }\n        // Mark last usage\n        peerSession.lastUpdate = Date.now();\n        this.sessionManager.updateSession(peerSession);\n        // Update lastInteractedWithPeer\n        this.lastInteractedWithPeer = message.identityKey;\n        // Dispatch callbacks\n        this.onGeneralMessageReceivedCallbacks.forEach(cb => {\n            cb(message.identityKey, message.payload ?? []);\n        });\n    }\n}\n//# sourceMappingURL=Peer.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/Peer.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionManager: () => (/* binding */ SessionManager)\n/* harmony export */ });\n/**\n * Manages sessions for peers, allowing multiple concurrent sessions\n * per identity key. Primary lookup is always by `sessionNonce`.\n */\nclass SessionManager {\n    /**\n     * Maps sessionNonce -> PeerSession\n     */\n    sessionNonceToSession;\n    /**\n     * Maps identityKey -> Set of sessionNonces\n     */\n    identityKeyToNonces;\n    constructor() {\n        this.sessionNonceToSession = new Map();\n        this.identityKeyToNonces = new Map();\n    }\n    /**\n     * Adds a session to the manager, associating it with its sessionNonce,\n     * and also with its peerIdentityKey (if any).\n     *\n     * This does NOT overwrite existing sessions for the same peerIdentityKey,\n     * allowing multiple concurrent sessions for the same peer.\n     *\n     * @param {PeerSession} session - The peer session to add.\n     */\n    addSession(session) {\n        if (typeof session.sessionNonce !== 'string') {\n            throw new Error('Invalid session: sessionNonce is required to add a session.');\n        }\n        // Use the sessionNonce as the primary key\n        this.sessionNonceToSession.set(session.sessionNonce, session);\n        // Also track it by identity key if present\n        if (typeof session.peerIdentityKey === 'string') {\n            let nonces = this.identityKeyToNonces.get(session.peerIdentityKey);\n            if (nonces == null) {\n                nonces = new Set();\n                this.identityKeyToNonces.set(session.peerIdentityKey, nonces);\n            }\n            nonces.add(session.sessionNonce);\n        }\n    }\n    /**\n     * Updates a session in the manager (primarily by re-adding it),\n     * ensuring we record the latest data (e.g., isAuthenticated, lastUpdate, etc.).\n     *\n     * @param {PeerSession} session - The peer session to update.\n     */\n    updateSession(session) {\n        // Remove the old references (if any) and re-add\n        this.removeSession(session);\n        this.addSession(session);\n    }\n    /**\n     * Retrieves a session based on a given identifier, which can be:\n     *  - A sessionNonce, or\n     *  - A peerIdentityKey.\n     *\n     * If it is a `sessionNonce`, returns that exact session.\n     * If it is a `peerIdentityKey`, returns the \"best\" (e.g. most recently updated,\n     * authenticated) session associated with that peer, if any.\n     *\n     * @param {string} identifier - The identifier for the session (sessionNonce or peerIdentityKey).\n     * @returns {PeerSession | undefined} - The matching peer session, or undefined if not found.\n     */\n    getSession(identifier) {\n        // Check if this identifier is directly a sessionNonce\n        const direct = this.sessionNonceToSession.get(identifier);\n        if (direct != null) {\n            return direct;\n        }\n        // Otherwise, interpret the identifier as an identity key\n        const nonces = this.identityKeyToNonces.get(identifier);\n        if ((nonces == null) || nonces.size === 0) {\n            return undefined;\n        }\n        // Pick the \"best\" session. One sensible approach:\n        // - Choose an authenticated session if available\n        // - Among them, pick the most recently updated\n        let best;\n        for (const nonce of nonces) {\n            const s = this.sessionNonceToSession.get(nonce);\n            if (s == null)\n                continue;\n            // We can prefer authenticated sessions\n            if (best == null) {\n                best = s;\n            }\n            else {\n                // If we want the \"most recently updated\" AND isAuthenticated\n                if ((s.lastUpdate ?? 0) > (best.lastUpdate ?? 0)) {\n                    best = s;\n                }\n            }\n        }\n        // Optionally, you could also filter out isAuthenticated===false if you only want\n        // an authenticated session. But for our usage, let's return the latest any session.\n        return best;\n    }\n    /**\n     * Removes a session from the manager by clearing all associated identifiers.\n     *\n     * @param {PeerSession} session - The peer session to remove.\n     */\n    removeSession(session) {\n        if (typeof session.sessionNonce === 'string') {\n            this.sessionNonceToSession.delete(session.sessionNonce);\n        }\n        if (typeof session.peerIdentityKey === 'string') {\n            const nonces = this.identityKeyToNonces.get(session.peerIdentityKey);\n            if (nonces != null) {\n                nonces.delete(session.sessionNonce ?? '');\n                if (nonces.size === 0) {\n                    this.identityKeyToNonces.delete(session.peerIdentityKey);\n                }\n            }\n        }\n    }\n    /**\n     * Checks if a session exists for a given identifier (either sessionNonce or identityKey).\n     *\n     * @param {string} identifier - The identifier to check.\n     * @returns {boolean} - True if the session exists, false otherwise.\n     */\n    hasSession(identifier) {\n        const direct = this.sessionNonceToSession.has(identifier);\n        if (direct)\n            return true;\n        // if not directly a nonce, interpret as identityKey\n        const nonces = this.identityKeyToNonces.get(identifier);\n        return !(nonces == null) && nonces.size > 0;\n    }\n}\n//# sourceMappingURL=SessionManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Certificate)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _wallet_ProtoWallet_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../wallet/ProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/ProtoWallet.js\");\n/* harmony import */ var _primitives_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../primitives/Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n\n\n\n/**\n * Represents an Identity Certificate as per the Wallet interface specifications.\n *\n * This class provides methods to serialize and deserialize certificates, as well as signing and verifying the certificate's signature.\n */\nclass Certificate {\n    /**\n     * Type identifier for the certificate, base64 encoded string, 32 bytes.\n     */\n    type;\n    /**\n     * Unique serial number of the certificate, base64 encoded string, 32 bytes.\n     */\n    serialNumber;\n    /**\n     * The public key belonging to the certificate's subject, compressed public key hex string.\n     */\n    subject;\n    /**\n     * Public key of the certifier who issued the certificate, compressed public key hex string.\n     */\n    certifier;\n    /**\n     * The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.\n     */\n    revocationOutpoint;\n    /**\n     * All the fields present in the certificate, with field names as keys and encrypted field values as Base64 strings.\n     */\n    fields;\n    /**\n     * Certificate signature by the certifier's private key, DER encoded hex string.\n     */\n    signature;\n    /**\n     * Constructs a new Certificate.\n     *\n     * @param {Base64String} type - Type identifier for the certificate, base64 encoded string, 32 bytes.\n     * @param {Base64String} serialNumber - Unique serial number of the certificate, base64 encoded string, 32 bytes.\n     * @param {PubKeyHex} subject - The public key belonging to the certificate's subject, compressed public key hex string.\n     * @param {PubKeyHex} certifier - Public key of the certifier who issued the certificate, compressed public key hex string.\n     * @param {OutpointString} revocationOutpoint - The outpoint used to confirm that the certificate has not been revoked (TXID.OutputIndex), as a string.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - All the fields present in the certificate.\n     * @param {HexString} signature - Certificate signature by the certifier's private key, DER encoded hex string.\n     */\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature) {\n        this.type = type;\n        this.serialNumber = serialNumber;\n        this.subject = subject;\n        this.certifier = certifier;\n        this.revocationOutpoint = revocationOutpoint;\n        this.fields = fields;\n        this.signature = signature;\n    }\n    /**\n     * Serializes the certificate into binary format, with or without a signature.\n     *\n     * @param {boolean} [includeSignature=true] - Whether to include the signature in the serialization.\n     * @returns {number[]} - The serialized certificate in binary format.\n     */\n    toBinary(includeSignature = true) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n        // Write type (Base64String, 32 bytes)\n        const typeBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(this.type, 'base64');\n        writer.write(typeBytes);\n        // Write serialNumber (Base64String, 32 bytes)\n        const serialNumberBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(this.serialNumber, 'base64');\n        writer.write(serialNumberBytes);\n        // Write subject (33 bytes compressed PubKeyHex)\n        const subjectBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(this.subject, 'hex');\n        writer.write(subjectBytes);\n        // Write certifier (33 bytes compressed PubKeyHex)\n        const certifierBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(this.certifier, 'hex');\n        writer.write(certifierBytes);\n        // Write revocationOutpoint (TXID + OutputIndex)\n        const [txid, outputIndex] = this.revocationOutpoint.split('.');\n        const txidBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(txid, 'hex');\n        writer.write(txidBytes);\n        writer.writeVarIntNum(Number(outputIndex));\n        // Write fields\n        // Sort field names lexicographically\n        const fieldNames = Object.keys(this.fields).sort();\n        writer.writeVarIntNum(fieldNames.length);\n        for (const fieldName of fieldNames) {\n            const fieldValue = this.fields[fieldName];\n            // Field name\n            const fieldNameBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldName, 'utf8');\n            writer.writeVarIntNum(fieldNameBytes.length);\n            writer.write(fieldNameBytes);\n            // Field value\n            const fieldValueBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldValue, 'utf8');\n            writer.writeVarIntNum(fieldValueBytes.length);\n            writer.write(fieldValueBytes);\n        }\n        // Write signature if included\n        if (includeSignature && (this.signature ?? '').length > 0) { //  Explicitly handle nullish signature\n            const signatureBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(this.signature, 'hex'); //  Type assertion ensures it's a string\n            writer.write(signatureBytes);\n        }\n        return writer.toArray();\n    }\n    /**\n     * Deserializes a certificate from binary format.\n     *\n     * @param {number[]} bin - The binary data representing the certificate.\n     * @returns {Certificate} - The deserialized Certificate object.\n     */\n    static fromBinary(bin) {\n        const reader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(bin);\n        // Read type\n        const typeBytes = reader.read(32);\n        const type = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(typeBytes);\n        // Read serialNumber\n        const serialNumberBytes = reader.read(32);\n        const serialNumber = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(serialNumberBytes);\n        // Read subject (33 bytes)\n        const subjectBytes = reader.read(33);\n        const subject = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(subjectBytes);\n        // Read certifier (33 bytes)\n        const certifierBytes = reader.read(33);\n        const certifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(certifierBytes);\n        // Read revocationOutpoint\n        const txidBytes = reader.read(32);\n        const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(txidBytes);\n        const outputIndex = reader.readVarIntNum();\n        const revocationOutpoint = `${txid}.${outputIndex}`;\n        // Read fields\n        const numFields = reader.readVarIntNum();\n        const fields = {};\n        for (let i = 0; i < numFields; i++) {\n            // Field name\n            const fieldNameLength = reader.readVarIntNum();\n            const fieldNameBytes = reader.read(fieldNameLength);\n            const fieldName = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldNameBytes);\n            // Field value\n            const fieldValueLength = reader.readVarIntNum();\n            const fieldValueBytes = reader.read(fieldValueLength);\n            const fieldValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldValueBytes);\n            fields[fieldName] = fieldValue;\n        }\n        // Read signature if present\n        let signature;\n        if (!reader.eof()) {\n            const signatureBytes = reader.read();\n            const sig = _primitives_Signature_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromDER(signatureBytes);\n            signature = sig.toString('hex');\n        }\n        return new Certificate(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n    }\n    /**\n     * Verifies the certificate's signature.\n     *\n     * @returns {Promise<boolean>} - A promise that resolves to true if the signature is valid.\n     */\n    async verify() {\n        // A verifier can be any wallet capable of verifying signatures\n        const verifier = new _wallet_ProtoWallet_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('anyone');\n        const verificationData = this.toBinary(false); // Exclude the signature from the verification data\n        const signatureHex = this.signature ?? ''; // Provide a fallback value (empty string)\n        const { valid } = await verifier.verifySignature({\n            signature: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(signatureHex, 'hex'),\n            data: verificationData,\n            protocolID: [2, 'certificate signature'],\n            keyID: `${this.type} ${this.serialNumber}`,\n            counterparty: this.certifier // The certifier is the one who signed the certificate\n        });\n        return valid;\n    }\n    /**\n   * Signs the certificate using the provided certifier wallet.\n   *\n   * @param {Wallet} certifierWallet - The wallet representing the certifier.\n   * @returns {Promise<void>}\n   */\n    async sign(certifierWallet) {\n        if (this.signature != null && this.signature.length > 0) { //  Explicitly checking for null/undefined\n            throw new Error(`Certificate has already been signed! Signature present: ${this.signature}`);\n        }\n        // Ensure the certifier declared is the one actually signing\n        this.certifier = (await certifierWallet.getPublicKey({ identityKey: true })).publicKey;\n        const preimage = this.toBinary(false); // Exclude the signature when signing\n        const { signature } = await certifierWallet.createSignature({\n            data: preimage,\n            protocolID: [2, 'certificate signature'],\n            keyID: `${this.type} ${this.serialNumber}`\n        });\n        this.signature = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(signature);\n    }\n    /**\n     * Helper function which retrieves the protocol ID and key ID for certificate field encryption.\n     *\n     * For master certificate creation, no serial number is provided because entropy is required\n     * from both the client and the certifier. In this case, the `keyID` is simply the `fieldName`.\n     *\n     * For VerifiableCertificates verifier keyring creation, both the serial number and field name are available,\n     * so the `keyID` is formed by concatenating the `serialNumber` and `fieldName`.\n     *\n     * @param fieldName - The name of the field within the certificate to be encrypted.\n     * @param serialNumber - (Optional) The serial number of the certificate.\n     * @returns An object containing:\n     *   - `protocolID` (WalletProtocol): The protocol ID for certificate field encryption.\n     *   - `keyID` (string): A unique key identifier. It is the `fieldName` if `serialNumber` is undefined,\n     *     otherwise it is a combination of `serialNumber` and `fieldName`.\n     */\n    static getCertificateFieldEncryptionDetails(fieldName, serialNumber) {\n        return {\n            protocolID: [2, 'certificate field encryption'],\n            keyID: serialNumber ? `${serialNumber} ${fieldName}` : fieldName\n        };\n    }\n}\n//# sourceMappingURL=Certificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/MasterCertificate.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/MasterCertificate.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MasterCertificate: () => (/* binding */ MasterCertificate)\n/* harmony export */ });\n/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n\n\n\n\n/**\n * MasterCertificate extends the base Certificate class to manage a master keyring, enabling the creation of verifiable certificates.\n *\n * It allows for the selective disclosure of certificate fields by creating a `VerifiableCertificate` for a specific verifier.\n * The `MasterCertificate` can securely decrypt each master key and re-encrypt it for a verifier, creating a customized\n * keyring containing only the keys necessary for the verifier to access designated fields.\n *\n */\nclass MasterCertificate extends _Certificate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    masterKeyring;\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, masterKeyring, signature) {\n        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n        // Ensure every field in `fields` is a string and has a corresponding key in `masterKeyring`\n        for (const fieldName of Object.keys(fields)) {\n            if (masterKeyring[fieldName] === undefined || masterKeyring[fieldName] === '') {\n                throw new Error(`Master keyring must contain a value for every field. Missing or empty key for field: \"${fieldName}\".`);\n            }\n        }\n        this.masterKeyring = masterKeyring;\n    }\n    /**\n     * Encrypts certificate fields for a subject and generates a master keyring.\n     * This method returns a master keyring tied to a specific certifier or subject who will validate\n     * and sign off on the fields, along with the encrypted certificate fields.\n     *\n     * @param {ProtoWallet} creatorWallet - The wallet of the creator responsible for encrypting the fields.\n     * @param {WalletCounterparty} certifierOrSubject - The certifier or subject who will validate the certificate fields.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - A record of certificate field names (under 50 bytes) mapped to their values.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *\n     * @returns {Promise<CreateCertificateFieldsResult>} A promise resolving to an object containing:\n     *   - `certificateFields` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:\n     *     The encrypted certificate fields.\n     *   - `masterKeyring` {Record<CertificateFieldNameUnder50Bytes, Base64String>}:\n     *     The master keyring containing encrypted revelation keys for each field.\n     */\n    static async createCertificateFields(creatorWallet, certifierOrSubject, fields, privileged, privilegedReason) {\n        const certificateFields = {};\n        const masterKeyring = {};\n        for (const [fieldName, fieldValue] of Object.entries(fields)) {\n            const fieldSymmetricKey = _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromRandom();\n            const encryptedFieldValue = fieldSymmetricKey.encrypt(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(fieldValue, 'utf8'));\n            certificateFields[fieldName] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(encryptedFieldValue);\n            const { ciphertext: encryptedFieldRevelationKey } = await creatorWallet.encrypt({\n                plaintext: fieldSymmetricKey.toArray(),\n                ..._Certificate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getCertificateFieldEncryptionDetails(fieldName),\n                counterparty: certifierOrSubject,\n                privileged,\n                privilegedReason\n            });\n            masterKeyring[fieldName] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(encryptedFieldRevelationKey);\n        }\n        return {\n            certificateFields,\n            masterKeyring\n        };\n    }\n    /**\n     * Creates a keyring for a verifier, enabling them to decrypt specific certificate fields.\n     * This method decrypts the master field keys for the specified fields and re-encrypts them\n     * for the verifier's identity key. The result is a keyring containing the keys necessary\n     * for the verifier to access the designated fields.\n     *\n     * @param {ProtoWallet} subjectWallet - The wallet instance of the subject, used to decrypt and re-encrypt field keys.\n     * @param {WalletCounterparty} verifier - The verifier who will receive access to the selectively revealed fields. Can be an identity key as hex, 'anyone', or 'self'.\n     * @param {string[]} fieldsToReveal - An array of field names to be revealed to the verifier. Must be a subset of the certificate's fields.\n     * @param {string} [originator] - Optional originator identifier, used if additional context is needed for decryption and encryption operations.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A keyring mapping field names to encrypted field revelation keys, allowing the verifier to decrypt specified fields.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.   *\n     * @throws {Error} Throws an error if:\n     *   - fieldsToReveal is not an array of strings.\n     *   - A field in `fieldsToReveal` does not exist in the certificate.\n     *   - The decrypted master field key fails to decrypt the corresponding field (indicating an invalid key).\n     */\n    static async createKeyringForVerifier(subjectWallet, certifier, verifier, fields, fieldsToReveal, masterKeyring, serialNumber, privileged, privilegedReason) {\n        if (!Array.isArray(fieldsToReveal)) {\n            throw new Error('fieldsToReveal must be an array of strings');\n        }\n        const fieldRevelationKeyring = {};\n        for (const fieldName of fieldsToReveal) {\n            // Make sure that fields to reveal is a subset of the certificate fields\n            if (fields[fieldName] === undefined || fields[fieldName] === null || fields[fieldName] === '') {\n                throw new Error(`Fields to reveal must be a subset of the certificate fields. Missing the \"${fieldName}\" field.`);\n            }\n            // Decrypt the master field key and verify that derived key actually decrypts requested field\n            const masterFieldKey = (await this.decryptField(subjectWallet, masterKeyring, fieldName, fields[fieldName], certifier, privileged, privilegedReason)).fieldRevelationKey;\n            // Encrypt derived fieldRevelationKey for verifier\n            const { ciphertext: encryptedFieldRevelationKey } = await subjectWallet.encrypt({\n                plaintext: masterFieldKey,\n                ..._Certificate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getCertificateFieldEncryptionDetails(fieldName, serialNumber),\n                counterparty: verifier,\n                privileged,\n                privilegedReason\n            });\n            // Add encryptedFieldRevelationKey to fieldRevelationKeyring\n            fieldRevelationKeyring[fieldName] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64(encryptedFieldRevelationKey);\n        }\n        // Return the field revelation keyring which can be used to create a verifiable certificate for a verifier.\n        return fieldRevelationKeyring;\n    }\n    /**\n     * Issues a new MasterCertificate for a specified subject.\n     *\n     * This method generates a certificate containing encrypted fields and a keyring\n     * for the subject to decrypt all fields. Each field is encrypted with a randomly\n     * generated symmetric key, which is then encrypted for the subject. The certificate\n     * can also includes a revocation outpoint to manage potential revocation.\n     *\n     * @param {ProtoWallet} certifierWallet - The wallet of the certifier, used to sign the certificate and encrypt field keys.\n     * @param {WalletCounterparty} subject - The subject for whom the certificate is issued.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} fields - Unencrypted certificate fields to include, with their names and values.\n     * @param {string} certificateType - The type of certificate being issued.\n     * @param {function(string, Record<CertificateFieldNameUnder50Bytes, string>?): Promise<string>} getRevocationOutpoint -\n     *   Optional function to obtain a revocation outpoint for the certificate. Defaults to a placeholder.\n     * @param {function(string): Promise<void>} updateProgress - Optional callback for reporting progress updates during the operation. Defaults to a no-op.\n     * @returns {Promise<MasterCertificate>} - A signed MasterCertificate instance containing the encrypted fields and subject specific keyring.\n     *\n     * @throws {Error} Throws an error if any operation (e.g., encryption, signing) fails during certificate issuance.\n     */\n    static async issueCertificateForSubject(certifierWallet, subject, fields, certificateType, getRevocationOutpoint = async (_serial) => {\n        void _serial; // Explicitly acknowledge unused parameter\n        return 'Certificate revocation not tracked.';\n    }, serialNumber) {\n        // 1. Generate a random serialNumber if not provided\n        const finalSerialNumber = serialNumber ?? _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(32));\n        // 2. Create encrypted certificate fields and associated master keyring\n        const { certificateFields, masterKeyring } = await this.createCertificateFields(certifierWallet, subject, fields);\n        // 3. Obtain a revocation outpoint\n        const revocationOutpoint = await getRevocationOutpoint(finalSerialNumber);\n        // 4. Create new MasterCertificate instance\n        const certificate = new MasterCertificate(certificateType, finalSerialNumber, subject, (await certifierWallet.getPublicKey({ identityKey: true })).publicKey, revocationOutpoint, certificateFields, masterKeyring);\n        // 5. Sign and return the new MasterCertificate certifying the subject.\n        await certificate.sign(certifierWallet);\n        return certificate;\n    }\n    /**\n     * Decrypts all fields in the MasterCertificate using the subject's or certifier's wallet.\n     *\n     * This method allows the subject or certifier to decrypt the `masterKeyring` and retrieve\n     * the encryption keys for each field, which are then used to decrypt the corresponding field values.\n     * The counterparty used for decryption depends on how the certificate fields were created:\n     * - If the certificate is self-signed, the counterparty should be set to 'self'.\n     * - Otherwise, the counterparty should always be the other party involved in the certificate issuance process (the subject or certifier).\n     *\n     * @param {ProtoWallet} subjectOrCertifierWallet - The wallet of the subject or certifier, used to decrypt the master keyring and field values.\n     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} masterKeyring - A record containing encrypted keys for each field.\n     * @param {Record<CertificateFieldNameUnder50Bytes, Base64String>} fields - A record of encrypted field names and their values.\n     * @param {WalletCounterparty} counterparty - The counterparty responsible for creating or signing the certificate. For self-signed certificates, use 'self'.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} A promise resolving to a record of field names and their decrypted values in plaintext.\n     *\n     * @throws {Error} Throws an error if the `masterKeyring` is invalid or if decryption fails for any field.\n     */\n    static async decryptFields(subjectOrCertifierWallet, masterKeyring, fields, counterparty, privileged, privilegedReason) {\n        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {\n            throw new Error('A MasterCertificate must have a valid masterKeyring!');\n        }\n        try {\n            const decryptedFields = {};\n            // Note: we want to iterate through all fields, not just masterKeyring keys/value pairs.\n            for (const fieldName of Object.keys(fields)) {\n                decryptedFields[fieldName] = (await this.decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fields[fieldName], counterparty, privileged, privilegedReason)).decryptedFieldValue;\n            }\n            return decryptedFields;\n        }\n        catch {\n            throw new Error('Failed to decrypt all master certificate fields.');\n        }\n    }\n    static async decryptField(subjectOrCertifierWallet, masterKeyring, fieldName, fieldValue, counterparty, privileged, privilegedReason) {\n        if (masterKeyring == null || Object.keys(masterKeyring).length === 0) {\n            throw new Error('A MasterCertificate must have a valid masterKeyring!');\n        }\n        try {\n            const { plaintext: fieldRevelationKey } = await subjectOrCertifierWallet.decrypt({\n                ciphertext: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(masterKeyring[fieldName], 'base64'),\n                ..._Certificate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getCertificateFieldEncryptionDetails(fieldName),\n                counterparty,\n                privileged,\n                privilegedReason\n            });\n            const decryptedFieldValue = new _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](fieldRevelationKey).decrypt(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(fieldValue, 'base64'));\n            return {\n                fieldRevelationKey,\n                decryptedFieldValue: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toUTF8(decryptedFieldValue)\n            };\n        }\n        catch {\n            throw new Error('Failed to decrypt certificate field!');\n        }\n    }\n}\n//# sourceMappingURL=MasterCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/MasterCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   VerifiableCertificate: () => (/* binding */ VerifiableCertificate)\n/* harmony export */ });\n/* harmony import */ var _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n\n\n\n/**\n * VerifiableCertificate extends the Certificate class, adding functionality to manage a verifier-specific keyring.\n * This keyring allows selective decryption of certificate fields for authorized verifiers.\n */\nclass VerifiableCertificate extends _Certificate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"] {\n    keyring;\n    decryptedFields;\n    constructor(type, serialNumber, subject, certifier, revocationOutpoint, fields, keyring, signature, decryptedFields) {\n        super(type, serialNumber, subject, certifier, revocationOutpoint, fields, signature);\n        this.keyring = keyring;\n        this.decryptedFields = decryptedFields;\n    }\n    /**\n     *\n     * @param {WalletCertificate} certificate  The source certificate that was issued and signed by the certifier.\n     * @param {Record<CertificateFieldNameUnder50Bytes, string>} keyring  A allows the verifier to decrypt selected certificate fields.\n     * @returns {VerifiableCertificate}  A fully-formed instance containing the\n     *   original certificate data plus the supplied keyring.\n     */\n    static fromCertificate(certificate, keyring) {\n        return new VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyring, certificate.signature);\n    }\n    /**\n     * Decrypts selectively revealed certificate fields using the provided keyring and verifier wallet\n     * @param {ProtoWallet} verifierWallet - The wallet instance of the certificate's verifier, used to decrypt field keys.\n     * @returns {Promise<Record<CertificateFieldNameUnder50Bytes, string>>} - A promise that resolves to an object where each key is a field name and each value is the decrypted field value as a string.\n     * @param {BooleanDefaultFalse} [privileged] - Whether this is a privileged request.\n     * @param {DescriptionString5to50Bytes} [privilegedReason] - Reason provided for privileged access, required if this is a privileged operation.\n     * @throws {Error} Throws an error if any of the decryption operations fail, with a message indicating the failure context.\n     */\n    async decryptFields(verifierWallet, privileged, privilegedReason) {\n        if (this.keyring == null || Object.keys(this.keyring).length === 0) { //  Explicitly check null and empty object\n            throw new Error('A keyring is required to decrypt certificate fields for the verifier.');\n        }\n        try {\n            const decryptedFields = {};\n            for (const fieldName in this.keyring) {\n                const { plaintext: fieldRevelationKey } = await verifierWallet.decrypt({\n                    ciphertext: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(this.keyring[fieldName], 'base64'),\n                    ..._Certificate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getCertificateFieldEncryptionDetails(fieldName, this.serialNumber),\n                    counterparty: this.subject,\n                    privileged,\n                    privilegedReason\n                });\n                const fieldValue = new _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](fieldRevelationKey).decrypt(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(this.fields[fieldName], 'base64'));\n                decryptedFields[fieldName] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toUTF8(fieldValue);\n            }\n            return decryptedFields;\n        }\n        catch (error) {\n            throw new Error(`Failed to decrypt selectively revealed certificate fields using keyring: ${String(error instanceof Error ? error.message : error)}`);\n        }\n    }\n}\n//# sourceMappingURL=VerifiableCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/__tests/CompletedProtoWallet.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/__tests/CompletedProtoWallet.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CompletedProtoWallet: () => (/* binding */ CompletedProtoWallet)\n/* harmony export */ });\n/* harmony import */ var _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _wallet_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js\");\n//@ts-nocheck\n\n\n// Test Mock wallet which extends ProtoWallet but still implements Wallet interface\n// Unsupported methods throw\nclass CompletedProtoWallet extends _wallet_index_js__WEBPACK_IMPORTED_MODULE_1__.ProtoWallet {\n    keyDeriver;\n    constructor(rootKeyOrKeyDeriver) {\n        super(rootKeyOrKeyDeriver);\n        if (rootKeyOrKeyDeriver instanceof _wallet_index_js__WEBPACK_IMPORTED_MODULE_1__.KeyDeriver) {\n            this.keyDeriver = rootKeyOrKeyDeriver;\n        }\n        else if (typeof rootKeyOrKeyDeriver === 'string' ||\n            rootKeyOrKeyDeriver instanceof _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            this.keyDeriver = new _wallet_index_js__WEBPACK_IMPORTED_MODULE_1__.CachedKeyDeriver(rootKeyOrKeyDeriver);\n        }\n        else {\n            throw new Error('Invalid key deriver provided');\n        }\n    }\n    async isAuthenticated() {\n        throw new Error('not implemented');\n    }\n    async waitForAuthentication() {\n        throw new Error('not implemented');\n    }\n    async getNetwork() {\n        throw new Error('not implemented');\n    }\n    async getVersion() {\n        throw new Error('not implemented');\n    }\n    async getPublicKey(args) {\n        if (args.privileged === true) {\n            throw new Error('no privilege support');\n        }\n        if (args.identityKey === true) {\n            if (this.keyDeriver === null || this.keyDeriver === undefined) {\n                throw new Error('keyDeriver is not initialized');\n            }\n            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };\n        }\n        else {\n            if (args.protocolID == null || typeof args.keyID !== 'string' || args.keyID.trim() === '') {\n                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');\n            }\n            if (this.keyDeriver === null || this.keyDeriver === undefined) {\n                throw new Error('keyDeriver is not initialized');\n            }\n            return {\n                publicKey: this.keyDeriver\n                    .derivePublicKey(args.protocolID, args.keyID, typeof args.counterparty === 'string' && args.counterparty.trim() !== ''\n                    ? args.counterparty\n                    : 'self', Boolean(args.forSelf))\n                    .toString()\n            };\n        }\n    }\n    async createAction() {\n        throw new Error('not implemented');\n    }\n    async signAction() {\n        throw new Error('not implemented');\n    }\n    async abortAction() {\n        throw new Error('not implemented');\n    }\n    async listActions() {\n        throw new Error('not implemented');\n    }\n    async internalizeAction() {\n        throw new Error('not implemented');\n    }\n    async listOutputs() {\n        throw new Error('not implemented');\n    }\n    async relinquishOutput() {\n        throw new Error('not implemented');\n    }\n    async acquireCertificate() {\n        throw new Error('not implemented');\n    }\n    async listCertificates() {\n        throw new Error('not implemented');\n    }\n    async proveCertificate() {\n        throw new Error('not implemented');\n    }\n    async relinquishCertificate() {\n        throw new Error('not implemented');\n    }\n    async discoverByIdentityKey() {\n        throw new Error('not implemented');\n    }\n    async discoverByAttributes() {\n        throw new Error('not implemented');\n    }\n    async getHeight() {\n        throw new Error('not implemented');\n    }\n    async getHeaderForHeight() {\n        throw new Error('not implemented');\n    }\n}\n//# sourceMappingURL=CompletedProtoWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/__tests/CompletedProtoWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Certificate: () => (/* reexport safe */ _Certificate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   CompletedProtoWallet: () => (/* reexport safe */ _tests_CompletedProtoWallet_js__WEBPACK_IMPORTED_MODULE_3__.CompletedProtoWallet),\n/* harmony export */   MasterCertificate: () => (/* reexport safe */ _MasterCertificate_js__WEBPACK_IMPORTED_MODULE_1__.MasterCertificate),\n/* harmony export */   VerifiableCertificate: () => (/* reexport safe */ _VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_2__.VerifiableCertificate)\n/* harmony export */ });\n/* harmony import */ var _Certificate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n/* harmony import */ var _MasterCertificate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MasterCertificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/MasterCertificate.js\");\n/* harmony import */ var _VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js\");\n/* harmony import */ var _tests_CompletedProtoWallet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./__tests/CompletedProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/__tests/CompletedProtoWallet.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/clients/AuthFetch.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/clients/AuthFetch.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthFetch: () => (/* binding */ AuthFetch)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _script_templates_P2PKH_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../script/templates/P2PKH.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js\");\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _utils_createNonce_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/createNonce.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/createNonce.js\");\n/* harmony import */ var _Peer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Peer.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/Peer.js\");\n/* harmony import */ var _transports_SimplifiedFetchTransport_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../transports/SimplifiedFetchTransport.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/transports/SimplifiedFetchTransport.js\");\n/* harmony import */ var _SessionManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../SessionManager.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js\");\n// @ts-nocheck\n\n\n\n\n\n\n\n\n\nconst PAYMENT_VERSION = '1.0';\n/**\n * AuthFetch provides a lightweight fetch client for interacting with servers\n * over a simplified HTTP transport mechanism. It integrates session management, peer communication,\n * and certificate handling to enable secure and mutually-authenticated requests.\n *\n * Additionally, it automatically handles 402 Payment Required responses by creating\n * and sending BSV payment transactions when necessary.\n */\nclass AuthFetch {\n    sessionManager;\n    wallet;\n    callbacks = {};\n    certificatesReceived = [];\n    requestedCertificates;\n    peers = {};\n    /**\n    * Constructs a new AuthFetch instance.\n    * @param wallet - The wallet instance for signing and authentication.\n    * @param requestedCertificates - Optional set of certificates to request from peers.\n    */\n    constructor(wallet, requestedCertificates, sessionManager) {\n        this.wallet = wallet;\n        this.requestedCertificates = requestedCertificates;\n        this.sessionManager = sessionManager || new _SessionManager_js__WEBPACK_IMPORTED_MODULE_7__.SessionManager();\n    }\n    /**\n     * Mutually authenticates and sends a HTTP request to a server.\n     *\n     * 1) Attempt the request.\n     * 2) If 402 Payment Required, automatically create and send payment.\n     * 3) Return the final response.\n     *\n     * @param url - The URL to send the request to.\n     * @param config - Configuration options for the request, including method, headers, and body.\n     * @returns A promise that resolves with the server's response, structured as a Response-like object.\n     *\n     * @throws Will throw an error if unsupported headers are used or other validation fails.\n     */\n    async fetch(url, config = {}) {\n        if (typeof config.retryCounter === 'number') {\n            if (config.retryCounter <= 0) {\n                throw new Error('Request failed after maximum number of retries.');\n            }\n            config.retryCounter--;\n        }\n        const response = await new Promise((async (resolve, reject) => {\n            try {\n                // Apply defaults\n                const { method = 'GET', headers = {}, body } = config;\n                // Extract a base url\n                const parsedUrl = new URL(url);\n                const baseURL = parsedUrl.origin;\n                // Create a new transport for this base url if needed\n                let peerToUse;\n                if (typeof this.peers[baseURL] === 'undefined') {\n                    // Create a peer for the request\n                    const newTransport = new _transports_SimplifiedFetchTransport_js__WEBPACK_IMPORTED_MODULE_6__.SimplifiedFetchTransport(baseURL);\n                    peerToUse = {\n                        peer: new _Peer_js__WEBPACK_IMPORTED_MODULE_5__.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager),\n                        pendingCertificateRequests: []\n                    };\n                    this.peers[baseURL] = peerToUse;\n                    this.peers[baseURL].peer.listenForCertificatesReceived((senderPublicKey, certs) => {\n                        this.certificatesReceived.push(...certs);\n                    });\n                    this.peers[baseURL].peer.listenForCertificatesRequested((async (verifier, requestedCertificates) => {\n                        try {\n                            this.peers[baseURL].pendingCertificateRequests.push(true);\n                            const certificatesToInclude = await (0,_utils_index_js__WEBPACK_IMPORTED_MODULE_8__.getVerifiableCertificates)(this.wallet, requestedCertificates, verifier);\n                            await this.peers[baseURL].peer.sendCertificateResponse(verifier, certificatesToInclude);\n                        }\n                        finally {\n                            // Give the backend 500 ms to process the certificates we just sent, before releasing the queue entry\n                            await new Promise(resolve => setTimeout(resolve, 500));\n                            this.peers[baseURL].pendingCertificateRequests.shift();\n                        }\n                    }));\n                }\n                else {\n                    // Check if there's a session associated with this baseURL\n                    if (this.peers[baseURL].supportsMutualAuth === false) {\n                        // Use standard fetch if mutual authentication is not supported\n                        try {\n                            const response = await this.handleFetchAndValidate(url, config, this.peers[baseURL]);\n                            resolve(response);\n                        }\n                        catch (error) {\n                            reject(error);\n                        }\n                        return;\n                    }\n                    peerToUse = this.peers[baseURL];\n                }\n                // Serialize the simplified fetch request.\n                const requestNonce = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(32);\n                const requestNonceAsBase64 = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(requestNonce);\n                const writer = await this.serializeRequest(method, headers, body, parsedUrl, requestNonce);\n                // Setup general message listener to resolve requests once a response is received\n                this.callbacks[requestNonceAsBase64] = { resolve, reject };\n                const listenerId = peerToUse.peer.listenForGeneralMessages((senderPublicKey, payload) => {\n                    // Create a reader\n                    const responseReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(payload);\n                    // Deserialize first 32 bytes of payload\n                    const responseNonceAsBase64 = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(responseReader.read(32));\n                    if (responseNonceAsBase64 !== requestNonceAsBase64) {\n                        return;\n                    }\n                    peerToUse.peer.stopListeningForGeneralMessages(listenerId);\n                    // Save the identity key for the peer for future requests, since we have it here.\n                    this.peers[baseURL].identityKey = senderPublicKey;\n                    this.peers[baseURL].supportsMutualAuth = true;\n                    // Status code\n                    const statusCode = responseReader.readVarIntNum();\n                    // Headers\n                    const responseHeaders = {};\n                    const nHeaders = responseReader.readVarIntNum();\n                    if (nHeaders > 0) {\n                        for (let i = 0; i < nHeaders; i++) {\n                            const nHeaderKeyBytes = responseReader.readVarIntNum();\n                            const headerKeyBytes = responseReader.read(nHeaderKeyBytes);\n                            const headerKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(headerKeyBytes);\n                            const nHeaderValueBytes = responseReader.readVarIntNum();\n                            const headerValueBytes = responseReader.read(nHeaderValueBytes);\n                            const headerValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(headerValueBytes);\n                            responseHeaders[headerKey] = headerValue;\n                        }\n                    }\n                    // Add back the server identity key header\n                    responseHeaders['x-bsv-auth-identity-key'] = senderPublicKey;\n                    // Body\n                    let responseBody;\n                    const responseBodyBytes = responseReader.readVarIntNum();\n                    if (responseBodyBytes > 0) {\n                        responseBody = responseReader.read(responseBodyBytes);\n                    }\n                    // Create the Response object\n                    const responseValue = new Response(responseBody ? new Uint8Array(responseBody) : null, {\n                        status: statusCode,\n                        statusText: `${statusCode}`,\n                        headers: new Headers(responseHeaders)\n                    });\n                    // Resolve or reject the correct request with the response data\n                    this.callbacks[requestNonceAsBase64].resolve(responseValue);\n                    // Clean up\n                    delete this.callbacks[requestNonceAsBase64];\n                });\n                // Before sending general messages to the peer, ensure that no certificate requests are pending.\n                // This way, the user would need to choose to either allow or reject the certificate request first.\n                // If the server has a resource that requires certificates to be sent before access would be granted,\n                // this makes sure the user has a chance to send the certificates before the resource is requested.\n                if (peerToUse.pendingCertificateRequests.length > 0) {\n                    await new Promise(resolve => {\n                        setInterval(() => {\n                            if (peerToUse.pendingCertificateRequests.length === 0) {\n                                resolve();\n                            }\n                        }, 100); // Check every 100 ms for the user to finish responding\n                    });\n                }\n                // Send the request, now that all listeners are set up\n                await peerToUse.peer.toPeer(writer.toArray(), peerToUse.identityKey).catch(async (error) => {\n                    if (error.message.includes('Session not found for nonce')) {\n                        delete this.peers[baseURL];\n                        config.retryCounter ??= 3;\n                        const response = await this.fetch(url, config);\n                        resolve(response);\n                        return;\n                    }\n                    if (error.message.includes('HTTP server failed to authenticate')) {\n                        try {\n                            const response = await this.handleFetchAndValidate(url, config, peerToUse);\n                            resolve(response);\n                            return;\n                        }\n                        catch (fetchError) {\n                            reject(fetchError);\n                        }\n                    }\n                    else {\n                        reject(error);\n                    }\n                });\n            }\n            catch (e) {\n                reject(e);\n            }\n        }));\n        // Check if server requires payment to access the requested route\n        if (response.status === 402) {\n            // Create and attach a payment, then retry\n            return await this.handlePaymentAndRetry(url, config, response);\n        }\n        return response;\n    }\n    /**\n     * Request Certificates from a Peer\n     * @param baseUrl\n     * @param certificatesToRequest\n     */\n    async sendCertificateRequest(baseUrl, certificatesToRequest) {\n        const parsedUrl = new URL(baseUrl);\n        const baseURL = parsedUrl.origin;\n        let peerToUse;\n        if (typeof this.peers[baseURL] !== 'undefined') {\n            peerToUse = { peer: this.peers[baseURL].peer };\n        }\n        else {\n            const newTransport = new _transports_SimplifiedFetchTransport_js__WEBPACK_IMPORTED_MODULE_6__.SimplifiedFetchTransport(baseURL);\n            peerToUse = {\n                peer: new _Peer_js__WEBPACK_IMPORTED_MODULE_5__.Peer(this.wallet, newTransport, this.requestedCertificates, this.sessionManager)\n            };\n            this.peers[baseURL] = peerToUse;\n        }\n        // Return a promise that resolves when certificates are received\n        return await new Promise((async (resolve, reject) => {\n            // Set up the listener before making the request\n            const callbackId = peerToUse.peer.listenForCertificatesReceived((_senderPublicKey, certs) => {\n                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);\n                this.certificatesReceived.push(...certs);\n                resolve(certs);\n            });\n            try {\n                // Initiate the certificate request\n                await peerToUse.peer.requestCertificates(certificatesToRequest, peerToUse.identityKey);\n            }\n            catch (err) {\n                peerToUse.peer.stopListeningForCertificatesReceived(callbackId);\n                reject(err);\n            }\n        }));\n    }\n    /**\n     * Return any certificates we've collected thus far, then clear them out.\n     */\n    consumeReceivedCertificates() {\n        return this.certificatesReceived.splice(0);\n    }\n    /**\n     * Serializes the HTTP request to be sent over the Transport.\n     *\n     * @param method - The HTTP method (e.g., 'GET', 'POST') for the request.\n     * @param headers - A record of HTTP headers to include in the request.\n     * @param body - The body of the request, if applicable (e.g., for POST/PUT requests).\n     * @param parsedUrl - The parsed URL object containing the full request URL.\n     * @param requestNonce - A unique random nonce to ensure request integrity.\n     * @returns A promise that resolves to a `Writer` containing the serialized request.\n     *\n     * @throws Will throw an error if unsupported headers are used or serialization fails.\n     */\n    async serializeRequest(method, headers, body, parsedUrl, requestNonce) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n        // Write request nonce\n        writer.write(requestNonce);\n        // Method length\n        writer.writeVarIntNum(method.length);\n        // Method\n        writer.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(method));\n        // Handle pathname (e.g. /path/to/resource)\n        if (parsedUrl.pathname.length > 0) {\n            // Pathname length\n            const pathnameAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(parsedUrl.pathname);\n            writer.writeVarIntNum(pathnameAsArray.length);\n            // Pathname\n            writer.write(pathnameAsArray);\n        }\n        else {\n            writer.writeVarIntNum(-1);\n        }\n        // Handle search params (e.g. ?q=hello)\n        if (parsedUrl.search.length > 0) {\n            // search length\n            const searchAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(parsedUrl.search);\n            writer.writeVarIntNum(searchAsArray.length);\n            // search\n            writer.write(searchAsArray);\n        }\n        else {\n            writer.writeVarIntNum(-1);\n        }\n        // Construct headers to send / sign:\n        // Ensures clients only provided supported HTTP request headers\n        // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)\n        // - Include a normalized version of the content-type header\n        // - Include the authorization header\n        const includedHeaders = [];\n        for (let [k, v] of Object.entries(headers)) {\n            k = k.toLowerCase(); // We will always sign lower-case header keys\n            if (k.startsWith('x-bsv-') || k === 'authorization') {\n                if (k.startsWith('x-bsv-auth')) {\n                    throw new Error('No BSV auth headers allowed here!');\n                }\n                includedHeaders.push([k, v]);\n            }\n            else if (k.startsWith('content-type')) {\n                // Normalize the Content-Type header by removing any parameters (e.g., \"; charset=utf-8\")\n                v = v.split(';')[0].trim();\n                includedHeaders.push([k, v]);\n            }\n            else {\n                throw new Error('Unsupported header in the simplified fetch implementation. Only content-type, authorization, and x-bsv-* headers are supported.');\n            }\n        }\n        // Sort the headers by key to ensure a consistent order for signing and verification.\n        includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n        // nHeaders\n        writer.writeVarIntNum(includedHeaders.length);\n        for (let i = 0; i < includedHeaders.length; i++) {\n            // headerKeyLength\n            const headerKeyAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(includedHeaders[i][0], 'utf8');\n            writer.writeVarIntNum(headerKeyAsArray.length);\n            // headerKey\n            writer.write(headerKeyAsArray);\n            // headerValueLength\n            const headerValueAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(includedHeaders[i][1], 'utf8');\n            writer.writeVarIntNum(headerValueAsArray.length);\n            // headerValue\n            writer.write(headerValueAsArray);\n        }\n        // If method typically carries a body and body is undefined, default it\n        // This prevents signature verification errors due to mismatch default body types with express\n        const methodsThatTypicallyHaveBody = ['POST', 'PUT', 'PATCH', 'DELETE'];\n        if (methodsThatTypicallyHaveBody.includes(method.toUpperCase()) && body === undefined) {\n            // Check if content-type is application/json\n            const contentTypeHeader = includedHeaders.find(([k]) => k === 'content-type');\n            if (contentTypeHeader && contentTypeHeader[1].includes('application/json')) {\n                body = '{}';\n            }\n            else {\n                body = '';\n            }\n        }\n        // Handle body\n        if (body) {\n            const reqBody = await this.normalizeBodyToNumberArray(body); // Use the utility function\n            writer.writeVarIntNum(reqBody.length);\n            writer.write(reqBody);\n        }\n        else {\n            writer.writeVarIntNum(-1); // No body\n        }\n        return writer;\n    }\n    /**\n     * Handles a non-authenticated fetch requests and validates that the server is not claiming to be authenticated.\n     */\n    async handleFetchAndValidate(url, config, peerToUse) {\n        const response = await fetch(url, config);\n        response.headers.forEach(header => {\n            if (header.toLocaleLowerCase().startsWith('x-bsv')) {\n                throw new Error('The server is trying to claim it has been authenticated when it has not!');\n            }\n        });\n        if (response.ok) {\n            peerToUse.supportsMutualAuth = false;\n            return response;\n        }\n        else {\n            throw new Error(`Request failed with status: ${response.status}`);\n        }\n    }\n    /**\n     * If we get 402 Payment Required, we build a transaction via wallet.createAction()\n     * and re-attempt the request with an x-bsv-payment header.\n     */\n    async handlePaymentAndRetry(url, config = {}, originalResponse) {\n        // Make sure the server is using the correct payment version\n        const paymentVersion = originalResponse.headers.get('x-bsv-payment-version');\n        if (!paymentVersion || paymentVersion !== PAYMENT_VERSION) {\n            throw new Error(`Unsupported x-bsv-payment-version response header. Client version: ${PAYMENT_VERSION}, Server version: ${paymentVersion}`);\n        }\n        // Get required headers from the 402 response\n        const satoshisRequiredHeader = originalResponse.headers.get('x-bsv-payment-satoshis-required');\n        if (!satoshisRequiredHeader) {\n            throw new Error('Missing x-bsv-payment-satoshis-required response header.');\n        }\n        const satoshisRequired = parseInt(satoshisRequiredHeader);\n        if (isNaN(satoshisRequired) || satoshisRequired <= 0) {\n            throw new Error('Invalid x-bsv-payment-satoshis-required response header value.');\n        }\n        const serverIdentityKey = originalResponse.headers.get('x-bsv-auth-identity-key');\n        if (!serverIdentityKey) {\n            throw new Error('Missing x-bsv-auth-identity-key response header.');\n        }\n        const derivationPrefix = originalResponse.headers.get('x-bsv-payment-derivation-prefix');\n        if (typeof derivationPrefix !== 'string' || derivationPrefix.length < 1) {\n            throw new Error('Missing x-bsv-payment-derivation-prefix response header.');\n        }\n        // Create a random suffix for the derivation path\n        const derivationSuffix = await (0,_utils_createNonce_js__WEBPACK_IMPORTED_MODULE_4__.createNonce)(this.wallet);\n        // Derive the script hex from the server identity key\n        const { publicKey: derivedPublicKey } = await this.wallet.getPublicKey({\n            protocolID: [2, '3241645161d8'],\n            keyID: `${derivationPrefix} ${derivationSuffix}`,\n            counterparty: serverIdentityKey\n        });\n        const lockingScript = new _script_templates_P2PKH_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]().lock(_primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromString(derivedPublicKey).toAddress()).toHex();\n        // Create the payment transaction using createAction\n        const { tx } = await this.wallet.createAction({\n            description: `Payment for request to ${new URL(url).origin}`,\n            outputs: [{\n                    satoshis: satoshisRequired,\n                    lockingScript,\n                    customInstructions: JSON.stringify({ derivationPrefix, derivationSuffix, payee: serverIdentityKey }),\n                    outputDescription: 'HTTP request payment'\n                }],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        // Attach the payment to the request headers\n        config.headers = config.headers || {};\n        config.headers['x-bsv-payment'] = JSON.stringify({\n            derivationPrefix,\n            derivationSuffix,\n            transaction: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(tx)\n        });\n        config.retryCounter ??= 3;\n        // Re-attempt request with payment attached\n        return this.fetch(url, config);\n    }\n    async normalizeBodyToNumberArray(body) {\n        // 0. Null / undefined\n        if (body == null) {\n            return [];\n        }\n        // 1. object\n        if (typeof body === 'object') {\n            return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(JSON.stringify(body, 'utf8'));\n        }\n        // 2. number[]\n        if (Array.isArray(body) && body.every((item) => typeof item === 'number')) {\n            return body; // Return the array as is\n        }\n        // 3. string\n        if (typeof body === 'string') {\n            return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(body, 'utf8');\n        }\n        // 4. ArrayBuffer / TypedArrays\n        if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n            const typedArray = body instanceof ArrayBuffer ? new Uint8Array(body) : new Uint8Array(body.buffer);\n            return Array.from(typedArray);\n        }\n        // 5. Blob\n        if (body instanceof Blob) {\n            const arrayBuffer = await body.arrayBuffer();\n            return Array.from(new Uint8Array(arrayBuffer));\n        }\n        // 6. FormData\n        if (body instanceof FormData) {\n            const entries = [];\n            body.forEach((value, key) => {\n                entries.push([key, value.toString()]);\n            });\n            const urlEncoded = new URLSearchParams(entries).toString();\n            return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(urlEncoded, 'utf8');\n        }\n        // 7. URLSearchParams\n        if (body instanceof URLSearchParams) {\n            return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(body.toString(), 'utf8');\n        }\n        // 8. ReadableStream\n        if (body instanceof ReadableStream) {\n            throw new Error('ReadableStream cannot be directly converted to number[].');\n        }\n        // 9. Fallback\n        throw new Error('Unsupported body type in this SimplifiedFetch implementation.');\n    }\n}\n//# sourceMappingURL=AuthFetch.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/clients/AuthFetch.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/clients/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/clients/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthFetch: () => (/* reexport safe */ _AuthFetch_js__WEBPACK_IMPORTED_MODULE_0__.AuthFetch)\n/* harmony export */ });\n/* harmony import */ var _AuthFetch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AuthFetch.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/clients/AuthFetch.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/clients/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthFetch: () => (/* reexport safe */ _clients_index_js__WEBPACK_IMPORTED_MODULE_5__.AuthFetch),\n/* harmony export */   Certificate: () => (/* reexport safe */ _certificates_index_js__WEBPACK_IMPORTED_MODULE_0__.Certificate),\n/* harmony export */   CompletedProtoWallet: () => (/* reexport safe */ _certificates_index_js__WEBPACK_IMPORTED_MODULE_0__.CompletedProtoWallet),\n/* harmony export */   MasterCertificate: () => (/* reexport safe */ _certificates_index_js__WEBPACK_IMPORTED_MODULE_0__.MasterCertificate),\n/* harmony export */   Peer: () => (/* reexport safe */ _Peer_js__WEBPACK_IMPORTED_MODULE_1__.Peer),\n/* harmony export */   SessionManager: () => (/* reexport safe */ _SessionManager_js__WEBPACK_IMPORTED_MODULE_2__.SessionManager),\n/* harmony export */   SimplifiedFetchTransport: () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_6__.SimplifiedFetchTransport),\n/* harmony export */   VerifiableCertificate: () => (/* reexport safe */ _certificates_index_js__WEBPACK_IMPORTED_MODULE_0__.VerifiableCertificate),\n/* harmony export */   createNonce: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_4__.createNonce),\n/* harmony export */   getVerifiableCertificates: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_4__.getVerifiableCertificates),\n/* harmony export */   validateCertificates: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_4__.validateCertificates),\n/* harmony export */   verifyNonce: () => (/* reexport safe */ _utils_index_js__WEBPACK_IMPORTED_MODULE_4__.verifyNonce)\n/* harmony export */ });\n/* harmony import */ var _certificates_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./certificates/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/index.js\");\n/* harmony import */ var _Peer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Peer.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/Peer.js\");\n/* harmony import */ var _SessionManager_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SessionManager.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/SessionManager.js\");\n/* harmony import */ var _types_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/types.js\");\n/* harmony import */ var _utils_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js\");\n/* harmony import */ var _clients_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./clients/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/clients/index.js\");\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transports/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/transports/index.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/transports/SimplifiedFetchTransport.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/transports/SimplifiedFetchTransport.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimplifiedFetchTransport: () => (/* binding */ SimplifiedFetchTransport)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n// Only bind window.fetch in the browser\nconst defaultFetch = typeof window !== 'undefined' ? fetch.bind(window) : fetch;\n/**\n * Implements an HTTP-specific transport for handling Peer mutual authentication messages.\n * This class integrates with fetch to send and receive authenticated messages between peers.\n */\nclass SimplifiedFetchTransport {\n    onDataCallback;\n    fetchClient;\n    baseUrl;\n    /**\n     * Constructs a new instance of SimplifiedFetchTransport.\n     * @param baseUrl - The base URL for all HTTP requests made by this transport.\n     * @param fetchClient - A fetch implementation to use for HTTP requests (default: global fetch).\n     */\n    constructor(baseUrl, fetchClient = defaultFetch) {\n        this.fetchClient = fetchClient;\n        this.baseUrl = baseUrl;\n    }\n    /**\n     * Sends a message to an HTTP server using the transport mechanism.\n     * Handles both general and authenticated message types. For general messages,\n     * the payload is deserialized and sent as an HTTP request. For other message types,\n     * the message is sent as a POST request to the `/auth` endpoint.\n     *\n     * @param message - The AuthMessage to send.\n     * @returns A promise that resolves when the message is successfully sent.\n     *\n     * @throws Will throw an error if no listener has been registered via `onData`.\n     */\n    async send(message) {\n        if (this.onDataCallback == null) {\n            throw new Error('Listen before you start speaking. God gave you two ears and one mouth for a reason.');\n        }\n        if (message.messageType !== 'general') {\n            return await new Promise((resolve, reject) => {\n                void (async () => {\n                    try {\n                        const responsePromise = this.fetchClient(`${this.baseUrl}/.well-known/auth`, {\n                            method: 'POST',\n                            headers: {\n                                'Content-Type': 'application/json'\n                            },\n                            body: JSON.stringify(message)\n                        });\n                        // For initialRequest message, mark connection as established and start pool.\n                        if (message.messageType !== 'initialRequest') {\n                            resolve();\n                        }\n                        const response = await responsePromise;\n                        // Handle the response if data is received and callback is set\n                        if (response.ok && (this.onDataCallback != null)) {\n                            const responseMessage = await response.json();\n                            this.onDataCallback(responseMessage);\n                        }\n                        else {\n                            // Server may be a non authenticated server\n                            throw new Error('HTTP server failed to authenticate');\n                        }\n                        if (message.messageType === 'initialRequest') {\n                            resolve();\n                        }\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                })();\n            });\n        }\n        else {\n            // Parse message payload\n            const httpRequest = this.deserializeRequestPayload(message.payload);\n            // Send the byte array as the HTTP payload\n            const url = `${this.baseUrl}${httpRequest.urlPostfix}`;\n            const httpRequestWithAuthHeaders = httpRequest;\n            if (typeof httpRequest.headers !== 'object') {\n                httpRequestWithAuthHeaders.headers = {};\n            }\n            // Append auth headers in request to server\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-version'] = message.version;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-identity-key'] = message.identityKey;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-nonce'] = message.nonce;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-your-nonce'] = message.yourNonce;\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-signature'] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(message.signature);\n            httpRequestWithAuthHeaders.headers['x-bsv-auth-request-id'] = httpRequest.requestId;\n            // Ensure Content-Type is set for requests with a body\n            if (httpRequestWithAuthHeaders.body != null) {\n                const headers = httpRequestWithAuthHeaders.headers;\n                if (headers['content-type'] == null) {\n                    throw new Error('Content-Type header is required for requests with a body.');\n                }\n                const contentType = String(headers['content-type'] ?? '');\n                // Transform body based on Content-Type\n                if (contentType.includes('application/json')) {\n                    // Convert byte array to JSON string\n                    httpRequestWithAuthHeaders.body = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else if (contentType.includes('application/x-www-form-urlencoded')) {\n                    // Convert byte array to URL-encoded string\n                    httpRequestWithAuthHeaders.body = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else if (contentType.includes('text/plain')) {\n                    // Convert byte array to plain UTF-8 string\n                    httpRequestWithAuthHeaders.body = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(httpRequestWithAuthHeaders.body);\n                }\n                else {\n                    // For all other content types, treat as binary data\n                    httpRequestWithAuthHeaders.body = new Uint8Array(httpRequestWithAuthHeaders.body);\n                }\n            }\n            // Send the actual fetch request to the server\n            const response = await this.fetchClient(url, {\n                method: httpRequestWithAuthHeaders.method,\n                headers: httpRequestWithAuthHeaders.headers,\n                body: httpRequestWithAuthHeaders.body\n            });\n            // Check for an acceptable status\n            if (response.status === 500 && (response.headers.get('x-bsv-auth-request-id') == null &&\n                response.headers.get('x-bsv-auth-requested-certificates') == null)) {\n                // Try parsing JSON error\n                const errorInfo = await response.json();\n                // Otherwise just throw whatever we got\n                throw new Error(`HTTP ${response.status} - ${JSON.stringify(errorInfo)}`);\n            }\n            const parsedBody = await response.arrayBuffer();\n            const payloadWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n            if (response.headers.get('x-bsv-auth-request-id') != null) {\n                payloadWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(response.headers.get('x-bsv-auth-request-id'), 'base64'));\n            }\n            payloadWriter.writeVarIntNum(response.status);\n            // PARSE RESPONSE HEADERS FROM SERVER --------------------------------\n            // Parse response headers from the server and include only the signed headers:\n            // - Include custom headers prefixed with x-bsv (excluding those starting with x-bsv-auth)\n            // - Include the authorization header\n            const includedHeaders = [];\n            response.headers.forEach((value, key) => {\n                const lowerKey = key.toLowerCase();\n                if ((lowerKey.startsWith('x-bsv-') || lowerKey === 'authorization') && !lowerKey.startsWith('x-bsv-auth')) {\n                    includedHeaders.push([lowerKey, value]);\n                }\n            });\n            // Sort the headers by key to ensure a consistent order for signing and verification.\n            includedHeaders.sort(([keyA], [keyB]) => keyA.localeCompare(keyB));\n            // nHeaders\n            payloadWriter.writeVarIntNum(includedHeaders.length);\n            for (let i = 0; i < includedHeaders.length; i++) {\n                // headerKeyLength\n                const headerKeyAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(includedHeaders[i][0], 'utf8');\n                payloadWriter.writeVarIntNum(headerKeyAsArray.length);\n                // headerKey\n                payloadWriter.write(headerKeyAsArray);\n                // headerValueLength\n                const headerValueAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(includedHeaders[i][1], 'utf8');\n                payloadWriter.writeVarIntNum(headerValueAsArray.length);\n                // headerValue\n                payloadWriter.write(headerValueAsArray);\n            }\n            // Handle body\n            if (parsedBody != null) {\n                const bodyAsArray = Array.from(new Uint8Array(parsedBody));\n                payloadWriter.writeVarIntNum(bodyAsArray.length);\n                payloadWriter.write(bodyAsArray);\n            }\n            else {\n                payloadWriter.writeVarIntNum(-1);\n            }\n            // Build the correct AuthMessage for the response\n            const responseMessage = {\n                version: response.headers.get('x-bsv-auth-version'),\n                messageType: response.headers.get('x-bsv-auth-message-type') === 'certificateRequest' ? 'certificateRequest' : 'general',\n                identityKey: response.headers.get('x-bsv-auth-identity-key'),\n                nonce: response.headers.get('x-bsv-auth-nonce'),\n                yourNonce: response.headers.get('x-bsv-auth-your-nonce'),\n                requestedCertificates: JSON.parse(response.headers.get('x-bsv-auth-requested-certificates')),\n                payload: payloadWriter.toArray(),\n                signature: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(response.headers.get('x-bsv-auth-signature'), 'hex')\n            };\n            // If the server didn't provide the correct authentication headers, throw an error\n            if (responseMessage.version == null) {\n                throw new Error('HTTP server failed to authenticate');\n            }\n            // Handle the response if data is received and callback is set\n            this.onDataCallback(responseMessage);\n        }\n    }\n    /**\n     * Registers a callback to handle incoming messages.\n     * This must be called before sending any messages to ensure responses can be processed.\n     *\n     * @param callback - A function to invoke when an incoming AuthMessage is received.\n     * @returns A promise that resolves once the callback is set.\n     */\n    async onData(callback) {\n        this.onDataCallback = (m) => {\n            void callback(m);\n        };\n    }\n    /**\n     * Deserializes a request payload from a byte array into an HTTP request-like structure.\n     *\n     * @param payload - The serialized payload to deserialize.\n     * @returns An object representing the deserialized request, including the method,\n     *          URL postfix (path and query string), headers, body, and request ID.\n     */\n    deserializeRequestPayload(payload) {\n        // Create a reader\n        const requestReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(payload);\n        // The first 32 bytes is the requestId\n        const requestId = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(requestReader.read(32));\n        // Method\n        const methodLength = requestReader.readVarIntNum();\n        let method = 'GET';\n        if (methodLength > 0) {\n            method = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(requestReader.read(methodLength));\n        }\n        // Path\n        const pathLength = requestReader.readVarIntNum();\n        let path = '';\n        if (pathLength > 0) {\n            path = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(requestReader.read(pathLength));\n        }\n        // Search\n        const searchLength = requestReader.readVarIntNum();\n        let search = '';\n        if (searchLength > 0) {\n            search = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(requestReader.read(searchLength));\n        }\n        // Read headers\n        const requestHeaders = {};\n        const nHeaders = requestReader.readVarIntNum();\n        if (nHeaders > 0) {\n            for (let i = 0; i < nHeaders; i++) {\n                const nHeaderKeyBytes = requestReader.readVarIntNum();\n                const headerKeyBytes = requestReader.read(nHeaderKeyBytes);\n                const headerKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(headerKeyBytes);\n                const nHeaderValueBytes = requestReader.readVarIntNum();\n                const headerValueBytes = requestReader.read(nHeaderValueBytes);\n                const headerValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(headerValueBytes);\n                requestHeaders[headerKey] = headerValue;\n            }\n        }\n        // Read body\n        let requestBody;\n        const requestBodyBytes = requestReader.readVarIntNum();\n        if (requestBodyBytes > 0) {\n            requestBody = requestReader.read(requestBodyBytes);\n        }\n        // Return the deserialized RequestInit\n        return {\n            urlPostfix: path + search,\n            method,\n            headers: requestHeaders,\n            body: requestBody,\n            requestId\n        };\n    }\n}\n//# sourceMappingURL=SimplifiedFetchTransport.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/transports/SimplifiedFetchTransport.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/transports/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/transports/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SimplifiedFetchTransport: () => (/* reexport safe */ _SimplifiedFetchTransport_js__WEBPACK_IMPORTED_MODULE_0__.SimplifiedFetchTransport)\n/* harmony export */ });\n/* harmony import */ var _SimplifiedFetchTransport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SimplifiedFetchTransport.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/transports/SimplifiedFetchTransport.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/transports/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/types.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/types.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/utils/createNonce.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/utils/createNonce.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNonce: () => (/* binding */ createNonce)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n\n\n/**\n * Creates a nonce derived from a wallet\n * @param wallet\n * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.\n * @returns A random nonce derived with a wallet\n */\nasync function createNonce(wallet, counterparty = 'self') {\n    // Generate 16 random bytes for the first half of the data\n    const firstHalf = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(16);\n    // Create an sha256 HMAC\n    const { hmac } = await wallet.createHmac({\n        protocolID: [2, 'server hmac'],\n        keyID: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(firstHalf),\n        data: firstHalf,\n        counterparty\n    });\n    // Concatenate firstHalf and secondHalf as the nonce bytes\n    const nonceBytes = [...firstHalf, ...hmac];\n    return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(nonceBytes);\n}\n//# sourceMappingURL=createNonce.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/utils/createNonce.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/utils/getVerifiableCertificates.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/utils/getVerifiableCertificates.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getVerifiableCertificates: () => (/* binding */ getVerifiableCertificates)\n/* harmony export */ });\n/* harmony import */ var _certificates_VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../certificates/VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js\");\n\n/**\n * Retrieves an array of verifiable certificates based on the request.\n *\n * @private\n * @param {RequestedCertificateSet} requestedCertificates - The set of certificates requested by the peer.\n * @param {string} verifierIdentityKey - The public key of the verifier requesting the certificates.\n * @returns {Promise<VerifiableCertificate[]>} An array of verifiable certificates.\n */\nconst getVerifiableCertificates = async (wallet, requestedCertificates, verifierIdentityKey) => {\n    // Find matching certificates we have\n    // Note: This may return multiple certificates that match the correct type.\n    const matchingCertificates = await wallet.listCertificates({\n        certifiers: requestedCertificates.certifiers,\n        types: Object.keys(requestedCertificates.types)\n    });\n    // For each certificate requested, create a verifiable cert with selectively revealed fields\n    return await Promise.all(matchingCertificates.certificates.map(async (certificate) => {\n        const { keyringForVerifier } = await wallet.proveCertificate({\n            certificate,\n            fieldsToReveal: requestedCertificates.types[certificate.type],\n            verifier: verifierIdentityKey\n        });\n        return new _certificates_VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_0__.VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, keyringForVerifier, certificate.signature);\n    }));\n};\n//# sourceMappingURL=getVerifiableCertificates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/utils/getVerifiableCertificates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createNonce: () => (/* reexport safe */ _createNonce_js__WEBPACK_IMPORTED_MODULE_1__.createNonce),\n/* harmony export */   getVerifiableCertificates: () => (/* reexport safe */ _getVerifiableCertificates_js__WEBPACK_IMPORTED_MODULE_2__.getVerifiableCertificates),\n/* harmony export */   validateCertificates: () => (/* reexport safe */ _validateCertificates_js__WEBPACK_IMPORTED_MODULE_3__.validateCertificates),\n/* harmony export */   verifyNonce: () => (/* reexport safe */ _verifyNonce_js__WEBPACK_IMPORTED_MODULE_0__.verifyNonce)\n/* harmony export */ });\n/* harmony import */ var _verifyNonce_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./verifyNonce.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/verifyNonce.js\");\n/* harmony import */ var _createNonce_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createNonce.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/createNonce.js\");\n/* harmony import */ var _getVerifiableCertificates_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getVerifiableCertificates.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/getVerifiableCertificates.js\");\n/* harmony import */ var _validateCertificates_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validateCertificates.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/utils/validateCertificates.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/utils/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/utils/validateCertificates.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/utils/validateCertificates.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateCertificates: () => (/* binding */ validateCertificates)\n/* harmony export */ });\n/* harmony import */ var _certificates_VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../certificates/VerifiableCertificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/VerifiableCertificate.js\");\n\n/**\n * Validates and processes the certificates received from a peer.\n *\n * @private\n * @param {AuthMessage} message - The message containing the certificates to validate.\n * @returns {Promise<void>}\n * @throws Will throw an error if certificate validation or field decryption fails.\n */\nconst validateCertificates = async (verifierWallet, message, certificatesRequested) => {\n    if ((message.certificates == null) || message.certificates.length === 0) {\n        throw new Error('No certificates were provided in the AuthMessage.');\n    }\n    await Promise.all(message.certificates.map(async (incomingCert) => {\n        if (incomingCert.subject !== message.identityKey) {\n            throw new Error(`The subject of one of your certificates (\"${incomingCert.subject}\") is not the same as the request sender (\"${message.identityKey}\").`);\n        }\n        // Verify Certificate structure and signature\n        const certToVerify = new _certificates_VerifiableCertificate_js__WEBPACK_IMPORTED_MODULE_0__.VerifiableCertificate(incomingCert.type, incomingCert.serialNumber, incomingCert.subject, incomingCert.certifier, incomingCert.revocationOutpoint, incomingCert.fields, incomingCert.keyring, incomingCert.signature);\n        const isValidCert = await certToVerify.verify();\n        if (!isValidCert) {\n            throw new Error(`The signature for the certificate with serial number ${certToVerify.serialNumber} is invalid!`);\n        }\n        // Check if the certificate matches requested certifiers, types, and fields\n        if (certificatesRequested != null) {\n            const { certifiers, types } = certificatesRequested;\n            // Check certifier matches\n            if (!certifiers.includes(certToVerify.certifier)) {\n                throw new Error(`Certificate with serial number ${certToVerify.serialNumber} has an unrequested certifier: ${certToVerify.certifier}`);\n            }\n            // Check type and fields match requested\n            const requestedFields = types[certToVerify.type];\n            if (requestedFields == null) { //  Explicitly check for null or undefined\n                throw new Error(`Certificate with type ${certToVerify.type} was not requested`);\n            }\n        }\n        // Attempt to decrypt fields\n        await certToVerify.decryptFields(verifierWallet);\n    }));\n};\n//# sourceMappingURL=validateCertificates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/utils/validateCertificates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/auth/utils/verifyNonce.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/auth/utils/verifyNonce.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyNonce: () => (/* binding */ verifyNonce)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n/**\n * Verifies a nonce derived from a wallet\n * @param nonce - A nonce to verify as a base64 string.\n * @param wallet\n * @param counterparty - The counterparty to the nonce creation. Defaults to 'self'.\n * @returns The status of the validation\n */\nasync function verifyNonce(nonce, wallet, counterparty = 'self') {\n    // Convert nonce from base64 string to Uint8Array\n    const buffer = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(nonce, 'base64');\n    // Split the nonce buffer\n    const data = buffer.slice(0, 16);\n    const hmac = buffer.slice(16);\n    // Calculate the HMAC\n    const { valid } = await wallet.verifyHmac({\n        data,\n        hmac,\n        protocolID: [2, 'server hmac'],\n        keyID: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(data),\n        counterparty\n    });\n    return valid;\n}\n//# sourceMappingURL=verifyNonce.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/auth/utils/verifyNonce.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/BSM.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/BSM.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   magicHash: () => (/* binding */ magicHash),\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_ECDSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n\n\n\n\nconst prefix = 'Bitcoin Signed Message:\\n';\n/**\n * Generates a SHA256 double-hash of the prefixed message.\n * @deprecated Replaced by BRC-77 which uses a more secure and private method for message signing.\n * @param messageBuf The message buffer to be hashed.\n * @returns The double-hash of the prefixed message as a number array.\n */\nconst magicHash = (messageBuf) => {\n    const bw = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n    bw.writeVarIntNum(prefix.length);\n    bw.write((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(prefix, 'utf8'));\n    bw.writeVarIntNum(messageBuf.length);\n    bw.write(messageBuf);\n    const buf = bw.toArray();\n    const hashBuf = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash256(buf);\n    return hashBuf;\n};\n/**\n * Signs a BSM message using the given private key.\n * @deprecated Replaced by BRC-77 which employs BRC-42 key derivation and BRC-43 invoice numbers for enhanced security and privacy.\n * @param message The message to be signed as a number array.\n * @param privateKey The private key used for signing the message.\n * @param mode The mode of operation. When \"base64\", the BSM format signature is returned. When \"raw\", a Signature object is returned. Default: \"base64\".\n * @returns The signature object when in raw mode, or the BSM base64 string when in base64 mode.\n */\nconst sign = (message, privateKey, mode = 'base64') => {\n    const hashBuf = magicHash(message);\n    const sig = _primitives_ECDSA_js__WEBPACK_IMPORTED_MODULE_2__.sign(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](hashBuf), privateKey, true);\n    if (mode === 'raw') {\n        return sig;\n    }\n    const h = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](hashBuf);\n    const r = sig.CalculateRecoveryFactor(privateKey.toPublicKey(), h);\n    return sig.toCompact(r, true, 'base64');\n};\n/**\n * Verifies a BSM signed message using the given public key.\n * @deprecated Replaced by BRC-77 which provides privately-verifiable signatures and avoids key reuse.\n * @param message The message to be verified as a number array.\n * @param sig The signature object.\n * @param pubKey The public key for verification.\n * @returns True if the signature is valid, false otherwise.\n */\nconst verify = (message, sig, pubKey) => {\n    const hashBuf = magicHash(message);\n    return _primitives_ECDSA_js__WEBPACK_IMPORTED_MODULE_2__.verify(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](hashBuf), sig, pubKey);\n};\n//# sourceMappingURL=BSM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/BSM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/ECIES.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/ECIES.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ECIES)\n/* harmony export */ });\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _primitives_Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n// import { AESWrappercbc } from './aescbc'\n\n\n\n\n\n\nfunction AES(key) {\n    if (this._tables[0][0][0] === 0)\n        this._precompute();\n    let tmp, encKey, decKey;\n    const sbox = this._tables[0][4];\n    const decTable = this._tables[1];\n    const keyLen = key.length;\n    let rcon = 1;\n    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n        throw new Error('invalid aes key size');\n    }\n    this._key = [(encKey = key.slice(0)), (decKey = [])];\n    // schedule encryption keys\n    let i;\n    for (i = keyLen; i < 4 * keyLen + 28; i++) {\n        tmp = encKey[i - 1];\n        // apply sbox\n        if (i % keyLen === 0 || (keyLen === 8 && i % keyLen === 4)) {\n            tmp =\n                (sbox[tmp >>> 24] << 24) ^\n                    (sbox[(tmp >> 16) & 255] << 16) ^\n                    (sbox[(tmp >> 8) & 255] << 8) ^\n                    sbox[tmp & 255];\n            // shift rows and add rcon\n            if (i % keyLen === 0) {\n                tmp = (tmp << 8) ^ (tmp >>> 24) ^ (rcon << 24);\n                rcon = (rcon << 1) ^ ((rcon >> 7) * 283);\n            }\n        }\n        encKey[i] = encKey[i - keyLen] ^ tmp;\n    }\n    // schedule decryption keys\n    for (let j = 0; i > 0; j++, i--) {\n        tmp = encKey[(j & 3) !== 0 ? i : i - 4];\n        if (i <= 4 || j < 4) {\n            decKey[j] = tmp;\n        }\n        else {\n            decKey[j] =\n                decTable[0][sbox[tmp >>> 24]] ^\n                    decTable[1][sbox[(tmp >> 16) & 255]] ^\n                    decTable[2][sbox[(tmp >> 8) & 255]] ^\n                    decTable[3][sbox[tmp & 255]];\n        }\n    }\n}\nAES.prototype = {\n    /**\n     * Encrypt an array of 4 big-endian words.\n     * @param {Array} data The plaintext.\n     * @return {Array} The ciphertext.\n     */\n    encrypt: function (data) {\n        return this._crypt(data, 0);\n    },\n    /**\n     * Decrypt an array of 4 big-endian words.\n     * @param {Array} data The ciphertext.\n     * @return {Array} The plaintext.\n     */\n    decrypt: function (data) {\n        return this._crypt(data, 1);\n    },\n    /**\n     * The expanded S-box and inverse S-box tables.  These will be computed\n     * on the client so that we don't have to send them down the wire.\n     *\n     * There are two tables, _tables[0] is for encryption and\n     * _tables[1] is for decryption.\n     *\n     * The first 4 sub-tables are the expanded S-box with MixColumns.  The\n     * last (_tables[01][4]) is the S-box itself.\n     *\n     * @private\n     */\n    _tables: [\n        [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ],\n        [\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256),\n            new Uint32Array(256)\n        ]\n    ],\n    // Expand the S-box tables.\n    _precompute: function () {\n        const encTable = this._tables[0];\n        const decTable = this._tables[1];\n        const sbox = encTable[4];\n        const sboxInv = decTable[4];\n        let i;\n        let x;\n        let xInv;\n        const d = new Uint8Array(256);\n        const th = new Uint8Array(256);\n        let x2;\n        let x4;\n        let x8;\n        let s;\n        let tEnc;\n        let tDec;\n        // Compute double and third tables\n        for (i = 0; i < 256; i++) {\n            th[(d[i] = (i << 1) ^ ((i >> 7) * 283)) ^ i] = i;\n        }\n        for (x = xInv = 0; sbox[x] === 0; x ^= (x2 !== 0 ? x2 : 1), xInv = th[xInv] !== 0 ? th[xInv] : 1) {\n            // Compute sbox\n            s = xInv ^ (xInv << 1) ^ (xInv << 2) ^ (xInv << 3) ^ (xInv << 4);\n            s = (s >> 8) ^ (s & 255) ^ 99;\n            sbox[x] = s;\n            sboxInv[s] = x;\n            // Compute MixColumns\n            x8 = d[(x4 = d[(x2 = d[x])])];\n            tDec = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n            tEnc = (d[s] * 0x101) ^ (s * 0x1010100);\n            for (i = 0; i < 4; i++) {\n                encTable[i][x] = tEnc = (tEnc << 24) ^ (tEnc >>> 8);\n                decTable[i][s] = tDec = (tDec << 24) ^ (tDec >>> 8);\n            }\n        }\n    },\n    /**\n     * Encryption and decryption core.\n     * @param {Array} input Four words to be encrypted or decrypted.\n     * @param dir The direction, 0 for encrypt and 1 for decrypt.\n     * @return {Array} The four encrypted or decrypted words.\n     * @private\n     */\n    _crypt: function (input, dir) {\n        if (input.length !== 4) {\n            throw new Error('invalid aes block size');\n        }\n        const key = this._key[dir];\n        // state variables a,b,c,d are loaded with pre-whitened data\n        let a = input[0] ^ key[0];\n        let b = input[dir === 1 ? 3 : 1] ^ key[1];\n        let c = input[2] ^ key[2];\n        let d = input[dir === 1 ? 1 : 3] ^ key[3];\n        let a2;\n        let b2;\n        let c2;\n        const nInnerRounds = key.length / 4 - 2;\n        let i;\n        let kIndex = 4;\n        const out = new Uint32Array(4);\n        const // <--- this is slower in Node, about the same in Chrome */\n        table = this._tables[dir];\n        // load up the tables\n        const t0 = table[0];\n        const t1 = table[1];\n        const t2 = table[2];\n        const t3 = table[3];\n        const sbox = table[4];\n        // Inner rounds.  Cribbed from OpenSSL.\n        for (i = 0; i < nInnerRounds; i++) {\n            a2 =\n                t0[a >>> 24] ^\n                    t1[(b >> 16) & 255] ^\n                    t2[(c >> 8) & 255] ^\n                    t3[d & 255] ^\n                    key[kIndex];\n            b2 =\n                t0[b >>> 24] ^\n                    t1[(c >> 16) & 255] ^\n                    t2[(d >> 8) & 255] ^\n                    t3[a & 255] ^\n                    key[kIndex + 1];\n            c2 =\n                t0[c >>> 24] ^\n                    t1[(d >> 16) & 255] ^\n                    t2[(a >> 8) & 255] ^\n                    t3[b & 255] ^\n                    key[kIndex + 2];\n            d =\n                t0[d >>> 24] ^\n                    t1[(a >> 16) & 255] ^\n                    t2[(b >> 8) & 255] ^\n                    t3[c & 255] ^\n                    key[kIndex + 3];\n            kIndex += 4;\n            a = a2;\n            b = b2;\n            c = c2;\n        }\n        // Last round.\n        for (i = 0; i < 4; i++) {\n            out[dir === 1 ? 3 & -i : i] =\n                (sbox[a >>> 24] << 24) ^\n                    (sbox[(b >> 16) & 255] << 16) ^\n                    (sbox[(c >> 8) & 255] << 8) ^\n                    sbox[d & 255] ^\n                    key[kIndex++];\n            a2 = a;\n            a = b;\n            b = c;\n            c = d;\n            d = a2;\n        }\n        return out;\n    }\n};\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass AESWrapper {\n    static encrypt(messageBuf, keyBuf) {\n        const key = AESWrapper.buf2Words(keyBuf);\n        const message = AESWrapper.buf2Words(messageBuf);\n        const a = new AES(key);\n        const enc = a.encrypt(message);\n        const encBuf = AESWrapper.words2Buf(enc);\n        return encBuf;\n    }\n    static decrypt(encBuf, keyBuf) {\n        const enc = AESWrapper.buf2Words(encBuf);\n        const key = AESWrapper.buf2Words(keyBuf);\n        const a = new AES(key);\n        const message = a.decrypt(enc);\n        const messageBuf = AESWrapper.words2Buf(message);\n        return messageBuf;\n    }\n    static buf2Words(buf) {\n        if (buf.length % 4 !== 0) {\n            throw new Error('buf length must be a multiple of 4');\n        }\n        const words = [];\n        for (let i = 0; i < buf.length / 4; i++) {\n            const val = buf[i * 4] * 0x1000000 + // Shift the first byte by 24 bits\n                ((buf[i * 4 + 1] << 16) | // Shift the second byte by 16 bits\n                    (buf[i * 4 + 2] << 8) | // Shift the third byte by 8 bits\n                    buf[i * 4 + 3]); // The fourth byte\n            words.push(val);\n        }\n        return words;\n    }\n    static words2Buf(words) {\n        const buf = new Array(words.length * 4);\n        for (let i = 0; i < words.length; i++) {\n            const word = words[i];\n            buf[i * 4] = (word >>> 24) & 0xff;\n            buf[i * 4 + 1] = (word >>> 16) & 0xff;\n            buf[i * 4 + 2] = (word >>> 8) & 0xff;\n            buf[i * 4 + 3] = word & 0xff;\n        }\n        return buf;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass CBC {\n    static buf2BlocksBuf(buf, blockSize) {\n        const bytesize = blockSize / 8;\n        const blockBufs = [];\n        for (let i = 0; i <= buf.length / bytesize; i++) {\n            let blockBuf = buf.slice(i * bytesize, i * bytesize + bytesize);\n            if (blockBuf.length < blockSize) {\n                blockBuf = CBC.pkcs7Pad(blockBuf, blockSize);\n            }\n            blockBufs.push(blockBuf);\n        }\n        return blockBufs;\n    }\n    static blockBufs2Buf(blockBufs) {\n        let last = blockBufs[blockBufs.length - 1];\n        last = CBC.pkcs7Unpad(last);\n        blockBufs[blockBufs.length - 1] = last;\n        const buf = blockBufs.flat();\n        return buf;\n    }\n    static encrypt(messageBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const blockSize = ivBuf.length * 8;\n        const blockBufs = CBC.buf2BlocksBuf(messageBuf, blockSize);\n        const encBufs = CBC.encryptBlocks(blockBufs, ivBuf, blockCipher, cipherKeyBuf);\n        const encBuf = encBufs.flat();\n        return encBuf;\n    }\n    static decrypt(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const bytesize = ivBuf.length;\n        const encBufs = [];\n        for (let i = 0; i < encBuf.length / bytesize; i++) {\n            encBufs.push(encBuf.slice(i * bytesize, i * bytesize + bytesize));\n        }\n        const blockBufs = CBC.decryptBlocks(encBufs, ivBuf, blockCipher, cipherKeyBuf);\n        const buf = CBC.blockBufs2Buf(blockBufs);\n        return buf;\n    }\n    static encryptBlock(blockBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const xorbuf = CBC.xorBufs(blockBuf, ivBuf);\n        const encBuf = blockCipher.encrypt(xorbuf, cipherKeyBuf);\n        return encBuf;\n    }\n    static decryptBlock(encBuf, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const xorbuf = blockCipher.decrypt(encBuf, cipherKeyBuf);\n        const blockBuf = CBC.xorBufs(xorbuf, ivBuf);\n        return blockBuf;\n    }\n    static encryptBlocks(blockBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const encBufs = [];\n        for (let i = 0; i < blockBufs.length; i++) {\n            const blockBuf = blockBufs[i];\n            const encBuf = CBC.encryptBlock(blockBuf, ivBuf, blockCipher, cipherKeyBuf);\n            encBufs.push(encBuf);\n            ivBuf = encBuf;\n        }\n        return encBufs;\n    }\n    static decryptBlocks(encBufs, ivBuf, blockCipher /* TODO: type */, cipherKeyBuf) {\n        const blockBufs = [];\n        for (let i = 0; i < encBufs.length; i++) {\n            const encBuf = encBufs[i];\n            const blockBuf = CBC.decryptBlock(encBuf, ivBuf, blockCipher, cipherKeyBuf);\n            blockBufs.push(blockBuf);\n            ivBuf = encBuf;\n        }\n        return blockBufs;\n    }\n    static pkcs7Pad(buf, blockSize) {\n        const bytesize = blockSize / 8;\n        const padbytesize = bytesize - buf.length;\n        const pad = new Array(padbytesize);\n        pad.fill(padbytesize);\n        const paddedbuf = [...buf, ...pad];\n        return paddedbuf;\n    }\n    static pkcs7Unpad(paddedbuf) {\n        const padlength = paddedbuf[paddedbuf.length - 1];\n        const padbuf = paddedbuf.slice(paddedbuf.length - padlength, paddedbuf.length);\n        const padbuf2 = new Array(padlength);\n        padbuf2.fill(padlength);\n        if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(padbuf) !== (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(padbuf2)) {\n            throw new Error('invalid padding');\n        }\n        return paddedbuf.slice(0, paddedbuf.length - padlength);\n    }\n    static xorBufs(buf1, buf2) {\n        if (buf1.length !== buf2.length) {\n            throw new Error('bufs must have the same length');\n        }\n        const buf = new Array(buf1.length);\n        for (let i = 0; i < buf1.length; i++) {\n            buf[i] = buf1[i] ^ buf2[i];\n        }\n        return buf;\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass AESCBC {\n    static encrypt(messageBuf, cipherKeyBuf, ivBuf, concatIvBuf = true) {\n        ivBuf = ivBuf ?? (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(128 / 8);\n        const ctBuf = CBC.encrypt(messageBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        if (concatIvBuf) {\n            return [...ivBuf, ...ctBuf];\n        }\n        else {\n            return [...ctBuf];\n        }\n    }\n    static decrypt(encBuf, cipherKeyBuf, ivBuf) {\n        if (ivBuf == null) {\n            ivBuf = encBuf.slice(0, 128 / 8);\n            const ctBuf = encBuf.slice(128 / 8);\n            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        }\n        else {\n            const ctBuf = encBuf;\n            return CBC.decrypt(ctBuf, ivBuf, AESWrapper, cipherKeyBuf);\n        }\n    }\n}\n/**\n * @class ECIES\n * Implements the Electrum ECIES protocol for encrypted communication.\n *\n * @prprecated This class is deprecated in favor of the BRC-78 standard for portable encrypted messages,\n * which provides a more comprehensive and secure solution by integrating with BRC-42 and BRC-43 standards.\n */\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass ECIES {\n    /**\n     * Generates the initialization vector (iv), encryption key (kE), and MAC key (kM)\n     * using the sender's private key and receiver's public key.\n     *\n     * @param {PrivateKey} privKey - The sender's private key.\n     * @param {PublicKey} pubKey - The receiver's public key.\n     * @returns {Object} An object containing the iv, kE, and kM as number arrays.\n     */\n    static ivkEkM(privKey, pubKey) {\n        const r = privKey;\n        const KB = pubKey;\n        const P = KB.mul(r);\n        const S = new _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](P.x, P.y);\n        const Sbuf = S.encode(true);\n        const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha512(Sbuf);\n        return {\n            iv: hash.slice(0, 16),\n            kE: hash.slice(16, 32),\n            kM: hash.slice(32, 64)\n        };\n    }\n    /**\n     * Encrypts a given message using the Electrum ECIES method.\n     *\n     * @param {number[]} messageBuf - The message to be encrypted, in number array format.\n     * @param {PublicKey} toPublicKey - The public key of the recipient.\n     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.\n     * @param {boolean} [noKey=false] - If true, does not include the sender's public key in the encrypted message.\n     * @returns {number[]} The encrypted message as a number array.\n     */\n    static electrumEncrypt(messageBuf, toPublicKey, fromPrivateKey, noKey = false) {\n        let Rbuf = null;\n        if (fromPrivateKey == null) {\n            fromPrivateKey = _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromRandom();\n        }\n        if (!noKey) {\n            Rbuf = fromPrivateKey.toPublicKey().encode(true);\n        }\n        const { iv, kE, kM } = ECIES.ivkEkM(fromPrivateKey, toPublicKey);\n        const ciphertext = AESCBC.encrypt(messageBuf, kE, iv, false);\n        const BIE1 = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toArray)('BIE1', 'utf8');\n        let encBuf;\n        if (Rbuf !== undefined && Rbuf !== null && Rbuf.length > 0) {\n            encBuf = [...BIE1, ...Rbuf, ...ciphertext];\n        }\n        else {\n            encBuf = [...BIE1, ...ciphertext];\n        }\n        const hmac = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac(kM, encBuf);\n        return [...encBuf, ...hmac];\n    }\n    /**\n     * Decrypts a message encrypted using the Electrum ECIES method.\n     *\n     * @param {number[]} encBuf - The encrypted message buffer.\n     * @param {PrivateKey} toPrivateKey - The private key of the recipient.\n     * @param {PublicKey} [fromPublicKey=null] - The public key of the sender. If not provided, it is extracted from the message.\n     * @returns {number[]} The decrypted message as a number array.\n     */\n    static electrumDecrypt(encBuf, toPrivateKey, fromPublicKey) {\n        const tagLength = 32;\n        const magic = encBuf.slice(0, 4);\n        if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.encode)(magic, 'utf8') !== 'BIE1') {\n            throw new Error('Invalid Magic');\n        }\n        let offset = 4;\n        // Determine if the sender's public key is included in encBuf\n        let Rbuf = null;\n        if (encBuf.length - offset - tagLength >= 33) {\n            const firstByte = encBuf[offset];\n            if (firstByte === 0x02 || firstByte === 0x03) {\n                // Compressed public key\n                Rbuf = encBuf.slice(offset, offset + 33);\n                offset += 33;\n            }\n            else if (firstByte === 0x04) {\n                // Uncompressed public key\n                Rbuf = encBuf.slice(offset, offset + 65);\n                offset += 65;\n            }\n        }\n        if (Rbuf !== null) {\n            if (fromPublicKey == null) {\n                fromPublicKey = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromString((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(Rbuf));\n            }\n        }\n        else {\n            if (fromPublicKey == null) {\n                throw new Error('Sender public key is required');\n            }\n        }\n        const { iv, kE, kM } = ECIES.ivkEkM(toPrivateKey, fromPublicKey);\n        const ciphertext = encBuf.slice(offset, encBuf.length - tagLength);\n        const hmac = encBuf.slice(encBuf.length - tagLength, encBuf.length);\n        const hmac2 = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac(kM, encBuf.slice(0, encBuf.length - tagLength));\n        if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(hmac) !== (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(hmac2)) {\n            throw new Error('Invalid checksum');\n        }\n        return AESCBC.decrypt(ciphertext, kE, iv);\n    }\n    /**\n     * Encrypts a given message using the Bitcore variant of ECIES.\n     *\n     * @param {number[]} messageBuf - The message to be encrypted, in number array format.\n     * @param {PublicKey} toPublicKey - The public key of the recipient.\n     * @param {PrivateKey} [fromPrivateKey] - The private key of the sender. If not provided, a random private key is used.\n     * @param {number[]} [ivBuf] - The initialization vector for encryption. If not provided, a random IV is used.\n     * @returns {number[]} The encrypted message as a number array.\n     */\n    static bitcoreEncrypt(messageBuf, toPublicKey, fromPrivateKey, ivBuf) {\n        if (fromPrivateKey == null) {\n            fromPrivateKey = _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromRandom();\n        }\n        if (ivBuf == null) {\n            ivBuf = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(16);\n        }\n        const r = fromPrivateKey;\n        const RPublicKey = fromPrivateKey.toPublicKey();\n        const RBuf = RPublicKey.encode(true);\n        const KB = toPublicKey;\n        const P = KB.mul(r);\n        const S = P.getX();\n        const Sbuf = S.toArray('be', 32);\n        const kEkM = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha512(Sbuf);\n        const kE = kEkM.slice(0, 32);\n        const kM = kEkM.slice(32, 64);\n        const c = AESCBC.encrypt(messageBuf, kE, ivBuf);\n        const d = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac(kM, [...c]);\n        const encBuf = [...RBuf, ...c, ...d];\n        return encBuf;\n    }\n    /**\n     * Decrypts a message encrypted using the Bitcore variant of ECIES.\n     *\n     * @param {number[]} encBuf - The encrypted message buffer.\n     * @param {PrivateKey} toPrivateKey - The private key of the recipient.\n     * @returns {number[]} The decrypted message as a number array.\n     */\n    static bitcoreDecrypt(encBuf, toPrivateKey) {\n        const kB = toPrivateKey;\n        const fromPublicKey = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromString((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(encBuf.slice(0, 33)));\n        const R = fromPublicKey;\n        const P = R.mul(kB);\n        if (P.eq(new _primitives_Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](0, 0))) {\n            throw new Error('P equals 0');\n        }\n        const S = P.getX();\n        const Sbuf = S.toArray('be', 32);\n        const kEkM = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha512(Sbuf);\n        const kE = kEkM.slice(0, 32);\n        const kM = kEkM.slice(32, 64);\n        const c = encBuf.slice(33, encBuf.length - 32);\n        const d = encBuf.slice(encBuf.length - 32, encBuf.length);\n        const d2 = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac(kM, c);\n        if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(d) !== (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(d2)) {\n            throw new Error('Invalid checksum');\n        }\n        const messageBuf = AESCBC.decrypt(c, kE);\n        return [...messageBuf];\n    }\n}\n//# sourceMappingURL=ECIES.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/ECIES.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/HD.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/HD.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HD)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_Curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n// @ts-nocheck\n\n\n\n\n\n\n\n/**\n * @deprecated\n * The HD class implements the Bitcoin Improvement Proposal 32 (BIP32) hierarchical deterministic wallets.\n * It allows the generation of child keys from a master key, ensuring a tree-like structure of keys and addresses.\n * This class is deprecated due to the introduction of BRC-42, which offers an enhanced key derivation scheme.\n * BRC-42 uses invoice numbers for key derivation, improving privacy and scalability compared to BIP32.\n *\n * @class HD\n * @deprecated Replaced by BRC-42 which uses invoice numbers and supports private derivation.\n */\nclass HD {\n    versionBytesNum;\n    depth;\n    parentFingerPrint;\n    childIndex;\n    chainCode;\n    privKey;\n    pubKey;\n    constants = {\n        pubKey: 0x0488b21e,\n        privKey: 0x0488ade4\n    };\n    /**\n     * Constructor for the BIP32 HD wallet.\n     * Initializes an HD wallet with optional parameters for version bytes, depth, parent fingerprint, child index, chain code, private key, and public key.\n     * @param versionBytesNum - Version bytes number for the wallet.\n     * @param depth - Depth of the key in the hierarchy.\n     * @param parentFingerPrint - Fingerprint of the parent key.\n     * @param childIndex - Index of the child key.\n     * @param chainCode - Chain code for key derivation.\n     * @param privKey - Private key of the wallet.\n     * @param pubKey - Public key of the wallet.\n     */\n    constructor(versionBytesNum, depth, parentFingerPrint, childIndex, chainCode, privKey, pubKey) {\n        this.versionBytesNum = versionBytesNum;\n        this.depth = depth;\n        this.parentFingerPrint = parentFingerPrint;\n        this.childIndex = childIndex;\n        this.chainCode = chainCode;\n        this.privKey = privKey;\n        this.pubKey = pubKey;\n    }\n    /**\n     * Generates a new HD wallet with random keys.\n     * This method creates a root HD wallet with randomly generated private and public keys.\n     * @returns {HD} The current HD instance with generated keys.\n     */\n    fromRandom() {\n        this.versionBytesNum = this.constants.privKey;\n        this.depth = 0x00;\n        this.parentFingerPrint = [0, 0, 0, 0];\n        this.childIndex = 0;\n        this.chainCode = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(32);\n        this.privKey = _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromRandom();\n        this.pubKey = this.privKey.toPublicKey();\n        return this;\n    }\n    /**\n     * Generates a new HD wallet with random keys.\n     * This method creates a root HD wallet with randomly generated private and public keys.\n     * @returns {HD} A new HD instance with generated keys.\n     * @static\n     */\n    static fromRandom() {\n        return new this().fromRandom();\n    }\n    /**\n     * Initializes the HD wallet from a given base58 encoded string.\n     * This method decodes a provided string to set up the HD wallet's properties.\n     * @param str - A base58 encoded string representing the wallet.\n     * @returns {HD} The new instance with properties set from the string.\n     */\n    static fromString(str) {\n        return new this().fromString(str);\n    }\n    /**\n     * Initializes the HD wallet from a given base58 encoded string.\n     * This method decodes a provided string to set up the HD wallet's properties.\n     * @param str - A base58 encoded string representing the wallet.\n     * @returns {HD} The current instance with properties set from the string.\n     */\n    fromString(str) {\n        const decoded = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.fromBase58Check)(str);\n        return this.fromBinary([...decoded.prefix, ...decoded.data]);\n    }\n    /**\n     * Initializes the HD wallet from a seed.\n     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.\n     * @param bytes - An array of bytes representing the seed.\n     * @returns {HD} The current instance with properties set from the seed.\n     */\n    static fromSeed(bytes) {\n        return new this().fromSeed(bytes);\n    }\n    /**\n     * Initializes the HD wallet from a seed.\n     * This method generates keys and other properties from a given seed, conforming to the BIP32 specification.\n     * @param bytes - An array of bytes representing the seed.\n     * @returns {HD} The current instance with properties set from the seed.\n     */\n    fromSeed(bytes) {\n        if (bytes.length < 128 / 8) {\n            throw new Error('Need more than 128 bits of entropy');\n        }\n        if (bytes.length > 512 / 8) {\n            throw new Error('More than 512 bits of entropy is nonstandard');\n        }\n        const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha512hmac((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)('Bitcoin seed', 'utf8'), bytes);\n        this.depth = 0x00;\n        this.parentFingerPrint = [0, 0, 0, 0];\n        this.childIndex = 0;\n        this.chainCode = hash.slice(32, 64);\n        this.versionBytesNum = this.constants.privKey;\n        this.privKey = new _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](hash.slice(0, 32));\n        this.pubKey = this.privKey.toPublicKey();\n        return this;\n    }\n    /**\n     * Initializes the HD wallet from a binary buffer.\n     * Parses a binary buffer to set up the wallet's properties.\n     * @param buf - A buffer containing the wallet data.\n     * @returns {HD} The new instance with properties set from the buffer.\n     */\n    static fromBinary(buf) {\n        return new this().fromBinary(buf);\n    }\n    /**\n     * Initializes the HD wallet from a binary buffer.\n     * Parses a binary buffer to set up the wallet's properties.\n     * @param buf - A buffer containing the wallet data.\n     * @returns {HD} The current instance with properties set from the buffer.\n     */\n    fromBinary(buf) {\n        // Both pub and private extended keys are 78 buf\n        if (buf.length !== 78) {\n            throw new Error('incorrect bip32 data length');\n        }\n        const reader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(buf);\n        this.versionBytesNum = reader.readUInt32BE();\n        this.depth = reader.readUInt8();\n        this.parentFingerPrint = reader.read(4);\n        this.childIndex = reader.readUInt32BE();\n        this.chainCode = reader.read(32);\n        const keyBytes = reader.read(33);\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        const isPublic = this.versionBytesNum === this.constants.pubKey;\n        if (isPrivate && keyBytes[0] === 0) {\n            this.privKey = new _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](keyBytes.slice(1, 33));\n            this.pubKey = this.privKey.toPublicKey();\n        }\n        else if (isPublic && (keyBytes[0] === 0x02 || keyBytes[0] === 0x03)) {\n            this.pubKey = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fromString((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)(keyBytes));\n        }\n        else {\n            throw new Error('Invalid key');\n        }\n        return this;\n    }\n    /**\n     * Converts the HD wallet to a base58 encoded string.\n     * This method provides a string representation of the HD wallet's current state.\n     * @returns {string} A base58 encoded string of the HD wallet.\n     */\n    toString() {\n        const bin = this.toBinary();\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase58Check)(bin, []);\n    }\n    /**\n     * Derives a child HD wallet based on a given path.\n     * The path specifies the hierarchy of the child key to be derived.\n     * @param path - A string representing the derivation path (e.g., 'm/0'/1).\n     * @returns {HD} A new HD instance representing the derived child wallet.\n     */\n    derive(path) {\n        if (path === 'm') {\n            return this;\n        }\n        const e = path.split('/');\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let bip32 = this;\n        for (const [i, c] of e.entries()) {\n            if (i === 0) { // Since `i` is now a number, compare it to 0\n                if (c !== 'm') {\n                    throw new Error('invalid path');\n                }\n                continue;\n            }\n            if (parseInt(c.replace(\"'\", ''), 10).toString() !== c.replace(\"'\", '')) {\n                throw new Error('invalid path');\n            }\n            const usePrivate = c.length > 1 && c[c.length - 1] === \"'\";\n            let childIndex = parseInt(usePrivate ? c.slice(0, c.length - 1) : c, 10) & 0x7fffffff;\n            if (usePrivate) {\n                childIndex += 0x80000000;\n            }\n            bip32 = bip32.deriveChild(childIndex);\n        }\n        return bip32;\n    }\n    /**\n     * Derives a child HD wallet from the current wallet based on an index.\n     * This method generates either a private or public child key depending on the current wallet's state.\n     * @param i - The index of the child key to derive.\n     * @returns {HD} A new HD instance representing the derived child wallet.\n     */\n    deriveChild(i) {\n        if (typeof i !== 'number') {\n            throw new Error('i must be a number');\n        }\n        const ibc = [];\n        ibc.push((i >> 24) & 0xff);\n        ibc.push((i >> 16) & 0xff);\n        ibc.push((i >> 8) & 0xff);\n        ibc.push(i & 0xff);\n        const ib = [...ibc];\n        const usePrivate = (i & 0x80000000) !== 0;\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        if (usePrivate && (this.privKey === null || this.privKey === undefined || !isPrivate)) {\n            throw new Error('Cannot do private key derivation without private key');\n        }\n        let ret = null;\n        if (this.privKey !== null && this.privKey !== undefined) {\n            let data = null;\n            if (usePrivate) {\n                data = [0, ...this.privKey.toArray('be', 32), ...ib];\n            }\n            else {\n                data = [...this.pubKey.encode(true), ...ib];\n            }\n            const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha512hmac(this.chainCode, data);\n            const il = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](hash.slice(0, 32));\n            const ir = hash.slice(32, 64);\n            // ki = IL + kpar (mod n).\n            const k = il.add(this.privKey).mod(new _primitives_Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]().n);\n            ret = new HD();\n            ret.chainCode = ir;\n            ret.privKey = new _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](k.toArray());\n            ret.pubKey = ret.privKey.toPublicKey();\n        }\n        else {\n            const data = [...this.pubKey.encode(true), ...ib];\n            const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.sha512hmac(this.chainCode, data);\n            const il = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](hash.slice(0, 32));\n            const ir = hash.slice(32, 64);\n            // Ki = (IL + kpar)*G = IL*G + Kpar\n            const ilG = new _primitives_Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]().g.mul(il);\n            const Kpar = this.pubKey;\n            const Ki = ilG.add(Kpar);\n            const newpub = new _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](Ki.x, Ki.y);\n            ret = new HD();\n            ret.chainCode = ir;\n            ret.pubKey = newpub;\n        }\n        ret.childIndex = i;\n        const pubKeyhash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.hash160(this.pubKey.encode(true));\n        ret.parentFingerPrint = pubKeyhash.slice(0, 4);\n        ret.versionBytesNum = this.versionBytesNum;\n        ret.depth = this.depth + 1;\n        return ret;\n    }\n    /**\n     * Converts the current HD wallet to a public-only wallet.\n     * This method strips away the private key information, leaving only the public part.\n     * @returns {HD} A new HD instance representing the public-only wallet.\n     */\n    toPublic() {\n        const bip32 = new HD(this.versionBytesNum, this.depth, this.parentFingerPrint, this.childIndex, this.chainCode, this.privKey, this.pubKey);\n        bip32.versionBytesNum = this.constants.pubKey;\n        bip32.privKey = undefined;\n        return bip32;\n    }\n    /**\n     * Converts the HD wallet into a binary representation.\n     * This method serializes the wallet's properties into a binary format.\n     * @returns {number[]} An array of numbers representing the binary data of the wallet.\n     */\n    toBinary() {\n        const isPrivate = this.versionBytesNum === this.constants.privKey;\n        const isPublic = this.versionBytesNum === this.constants.pubKey;\n        if (isPrivate) {\n            return new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer()\n                .writeUInt32BE(this.versionBytesNum)\n                .writeUInt8(this.depth)\n                .write(this.parentFingerPrint)\n                .writeUInt32BE(this.childIndex)\n                .write(this.chainCode)\n                .writeUInt8(0)\n                .write(this.privKey.toArray('be', 32))\n                .toArray();\n        }\n        else if (isPublic) {\n            return new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer()\n                .writeUInt32BE(this.versionBytesNum)\n                .writeUInt8(this.depth)\n                .write(this.parentFingerPrint)\n                .writeUInt32BE(this.childIndex)\n                .write(this.chainCode)\n                .write(this.pubKey.encode(true))\n                .toArray();\n        }\n        else {\n            throw new Error('bip32: invalid versionBytesNum byte');\n        }\n    }\n    /**\n     * Checks if the HD wallet contains a private key.\n     * This method determines whether the wallet is a private key wallet or a public key only wallet.\n     * @returns {boolean} A boolean value indicating whether the wallet has a private key (true) or not (false).\n     */\n    isPrivate() {\n        return this.versionBytesNum === this.constants.privKey;\n    }\n}\n//# sourceMappingURL=HD.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/HD.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/Mnemonic.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/Mnemonic.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mnemonic)\n/* harmony export */ });\n/* harmony import */ var _bip_39_wordlist_en_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bip-39-wordlist-en.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/bip-39-wordlist-en.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n\n\n\n\n/**\n * @class Mnemonic\n *\n * @description\n * Class representing Mnemonic functionality.\n * This class provides methods for generating, converting, and validating mnemonic phrases\n * according to the BIP39 standard. It supports creating mnemonics from random entropy,\n * converting mnemonics to seeds, and validating mnemonic phrases.\n */\nclass Mnemonic {\n    mnemonic;\n    seed;\n    Wordlist;\n    /**\n     * Constructs a Mnemonic object.\n     * @param {string} [mnemonic] - An optional mnemonic phrase.\n     * @param {number[]} [seed] - An optional seed derived from the mnemonic.\n     * @param {object} [wordlist=wordList] - An object containing a list of words and space character used in the mnemonic.\n     */\n    constructor(mnemonic, seed, wordlist = _bip_39_wordlist_en_js__WEBPACK_IMPORTED_MODULE_0__.wordList) {\n        this.mnemonic = mnemonic ?? ''; // Default to empty string if undefined\n        this.seed = seed ?? []; // Default to empty array if undefined\n        this.Wordlist = wordlist;\n    }\n    /**\n     * Converts the mnemonic and seed into a binary representation.\n     * @returns {number[]} The binary representation of the mnemonic and seed.\n     */\n    toBinary() {\n        const bw = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n        if (this.mnemonic !== '') {\n            const buf = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(this.mnemonic, 'utf8');\n            bw.writeVarIntNum(buf.length);\n            bw.write(buf);\n        }\n        else {\n            bw.writeVarIntNum(0);\n        }\n        if (this.seed.length > 0) {\n            bw.writeVarIntNum(this.seed.length);\n            bw.write(this.seed);\n        }\n        else {\n            bw.writeVarIntNum(0);\n        }\n        return bw.toArray();\n    }\n    /**\n     * Loads a mnemonic and seed from a binary representation.\n     * @param {number[]} bin - The binary representation of a mnemonic and seed.\n     * @returns {this} The Mnemonic instance with loaded mnemonic and seed.\n     */\n    fromBinary(bin) {\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Reader(bin);\n        const mnemoniclen = br.readVarIntNum();\n        if (mnemoniclen > 0) {\n            this.mnemonic = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.encode)(br.read(mnemoniclen), 'utf8');\n        }\n        const seedlen = br.readVarIntNum();\n        if (seedlen > 0) {\n            this.seed = br.read(seedlen);\n        }\n        return this;\n    }\n    /**\n     * Generates a random mnemonic from a given bit length.\n     * @param {number} [bits=128] - The bit length for the random mnemonic (must be a multiple of 32 and at least 128).\n     * @returns {this} The Mnemonic instance with the new random mnemonic.\n     * @throws {Error} If the bit length is not a multiple of 32 or is less than 128.\n     */\n    fromRandom(bits) {\n        if (bits === undefined || bits === null || isNaN(bits) || bits === 0) {\n            bits = 128;\n        }\n        if (bits % 32 !== 0) {\n            throw new Error('bits must be multiple of 32');\n        }\n        if (bits < 128) {\n            throw new Error('bits must be at least 128');\n        }\n        const buf = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(bits / 8);\n        this.entropy2Mnemonic(buf);\n        this.mnemonic2Seed();\n        return this;\n    }\n    /**\n     * Static method to generate a Mnemonic instance with a random mnemonic.\n     * @param {number} [bits=128] - The bit length for the random mnemonic.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromRandom(bits) {\n        return new this().fromRandom(bits);\n    }\n    /**\n     * Converts given entropy into a mnemonic phrase.\n     * This method is used to generate a mnemonic from a specific entropy source.\n     * @param {number[]} buf - The entropy buffer, must be at least 128 bits.\n     * @returns {this} The Mnemonic instance with the mnemonic set from the given entropy.\n     * @throws {Error} If the entropy is less than 128 bits.\n     */\n    fromEntropy(buf) {\n        this.entropy2Mnemonic(buf);\n        return this;\n    }\n    /**\n     * Static method to create a Mnemonic instance from a given entropy.\n     * @param {number[]} buf - The entropy buffer.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromEntropy(buf) {\n        return new this().fromEntropy(buf);\n    }\n    /**\n     * Sets the mnemonic for the instance from a string.\n     * @param {string} mnemonic - The mnemonic phrase as a string.\n     * @returns {this} The Mnemonic instance with the set mnemonic.\n     */\n    fromString(mnemonic) {\n        this.mnemonic = mnemonic;\n        return this;\n    }\n    /**\n     * Static method to create a Mnemonic instance from a mnemonic string.\n     * @param {string} str - The mnemonic phrase.\n     * @returns {Mnemonic} A new Mnemonic instance.\n     */\n    static fromString(str) {\n        return new this().fromString(str);\n    }\n    /**\n     * Converts the instance's mnemonic to a string representation.\n     * @returns {string} The mnemonic phrase as a string.\n     */\n    toString() {\n        return this.mnemonic;\n    }\n    /**\n     * Converts the mnemonic to a seed.\n     * The mnemonic must pass the validity check before conversion.\n     * @param {string} [passphrase=''] - An optional passphrase for additional security.\n     * @returns {number[]} The generated seed.\n     * @throws {Error} If the mnemonic is invalid.\n     */\n    toSeed(passphrase) {\n        this.mnemonic2Seed(passphrase);\n        return this.seed;\n    }\n    /**\n     * Converts entropy to a mnemonic phrase.\n     * This method takes a buffer of entropy and converts it into a corresponding\n     * mnemonic phrase based on the Mnemonic wordlist. The entropy should be at least 128 bits.\n     * The method applies a checksum and maps the entropy to words in the wordlist.\n     * @param {number[]} buf - The entropy buffer to convert. Must be at least 128 bits.\n     * @returns {this} The Mnemonic instance with the mnemonic set from the entropy.\n     * @throws {Error} If the entropy is less than 128 bits or if it's not an even multiple of 11 bits.\n     */\n    entropy2Mnemonic(buf) {\n        if (buf.length < 128 / 8) {\n            throw new Error('Entropy is less than 128 bits. It must be 128 bits or more.');\n        }\n        const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_2__.sha256(buf);\n        let bin = '';\n        const bits = buf.length * 8;\n        for (let i = 0; i < buf.length; i++) {\n            bin = bin + ('00000000' + buf[i].toString(2)).slice(-8);\n        }\n        let hashbits = hash[0].toString(2);\n        hashbits = ('00000000' + hashbits).slice(-8).slice(0, bits / 32);\n        bin = bin + hashbits;\n        if (bin.length % 11 !== 0) {\n            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +\n                bin.length.toString());\n        }\n        let mnemonic = '';\n        for (let i = 0; i < bin.length / 11; i++) {\n            if (mnemonic !== '') {\n                mnemonic = mnemonic + this.Wordlist.space;\n            }\n            const wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n            mnemonic = mnemonic + this.Wordlist.value[wi];\n        }\n        this.mnemonic = mnemonic;\n        return this;\n    }\n    /**\n     * Validates the mnemonic phrase.\n     * Checks for correct length, absence of invalid words, and proper checksum.\n     * @returns {boolean} True if the mnemonic is valid, false otherwise.\n     * @throws {Error} If the mnemonic is not an even multiple of 11 bits.\n     */\n    check() {\n        const mnemonic = this.mnemonic;\n        // confirm no invalid words\n        const words = mnemonic.split(this.Wordlist.space);\n        let bin = '';\n        for (let i = 0; i < words.length; i++) {\n            const ind = this.Wordlist.value.indexOf(words[i]);\n            if (ind < 0) {\n                return false;\n            }\n            bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n        }\n        if (bin.length % 11 !== 0) {\n            throw new Error('internal error - entropy not an even multiple of 11 bits - ' +\n                bin.length.toString());\n        }\n        // confirm checksum\n        const cs = bin.length / 33;\n        const hashBits = bin.slice(-cs);\n        const nonhashBits = bin.slice(0, bin.length - cs);\n        const buf = [];\n        for (let i = 0; i < nonhashBits.length / 8; i++) {\n            buf.push(parseInt(bin.slice(i * 8, (i + 1) * 8), 2));\n        }\n        const hash = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_2__.sha256(buf.slice(0, nonhashBits.length / 8));\n        let expectedHashBits = hash[0].toString(2);\n        expectedHashBits = ('00000000' + expectedHashBits).slice(-8).slice(0, cs);\n        return expectedHashBits === hashBits;\n    }\n    /**\n     * Converts a mnemonic to a seed.\n     * This method takes the instance's mnemonic phrase, combines it with a passphrase (if provided),\n     * and uses PBKDF2 to generate a seed. It also validates the mnemonic before conversion.\n     * This seed can then be used for generating deterministic keys.\n     * @param {string} [passphrase=''] - An optional passphrase for added security.\n     * @returns {this} The Mnemonic instance with the seed generated from the mnemonic.\n     * @throws {Error} If the mnemonic does not pass validation or if the passphrase is not a string.\n     */\n    mnemonic2Seed(passphrase = '') {\n        let mnemonic = this.mnemonic;\n        if (!this.check()) {\n            throw new Error('Mnemonic does not pass the check - was the mnemonic typed incorrectly? Are there extra spaces?');\n        }\n        if (typeof passphrase !== 'string') {\n            throw new Error('passphrase must be a string or undefined');\n        }\n        mnemonic = mnemonic.normalize('NFKD');\n        passphrase = passphrase.normalize('NFKD');\n        const mbuf = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(mnemonic, 'utf8');\n        const pbuf = [\n            ...(0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)('mnemonic', 'utf8'),\n            ...(0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(passphrase, 'utf8')\n        ];\n        this.seed = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_2__.pbkdf2(mbuf, pbuf, 2048, 64, 'sha512');\n        return this;\n    }\n    /**\n     * Determines the validity of a given passphrase with the mnemonic.\n     * This method is useful for checking if a passphrase matches with the mnemonic.\n     * @param {string} [passphrase=''] - The passphrase to validate.\n     * @returns {boolean} True if the mnemonic and passphrase combination is valid, false otherwise.\n     */\n    isValid(passphrase = '') {\n        let isValid;\n        try {\n            this.mnemonic2Seed(passphrase);\n            isValid = true;\n        }\n        catch {\n            isValid = false;\n        }\n        return isValid;\n    }\n    /**\n     * Static method to check the validity of a given mnemonic and passphrase combination.\n     * @param {string} mnemonic - The mnemonic phrase.\n     * @param {string} [passphrase=''] - The passphrase to validate.\n     * @returns {boolean} True if the combination is valid, false otherwise.\n     */\n    static isValid(mnemonic, passphrase = '') {\n        return new Mnemonic(mnemonic).isValid(passphrase);\n    }\n}\n//# sourceMappingURL=Mnemonic.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/Mnemonic.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/Utxo.js":
/*!***********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/Utxo.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ fromUtxo)\n/* harmony export */ });\n/* harmony import */ var _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js\");\n/* harmony import */ var _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../script/LockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js\");\n\n\n/**\n * @method fromUtxo\n *\n * @description\n * This function creates a transaction input from a utxo json object\n * The idea being old code that uses utxos rather than sourceTranactions can convert using this.\n *\n * @deprecated\n * This approach is made available for compatibility only. It is deprecated in favor of using sourceTransactions\n * directly. It's recommended that wallets general keep transactions which store unspent outputs in their entirety,\n * along with corresonding Merkle paths. The reason you would keep the whole transaction is such that you can prove\n * the txid, and therefore its inclusion within a specific block.\n *\n * @example\n * const i = fromUtxo({\n *   txid: '434555433eaca96dff6e71a4d02febd0dd3832e5ca4e5734623ca914522e17d5',\n *   vout: 0,\n *   script: '51',\n *   satoshis: 1234\n * }, new P2PKH().unlock(p))\n *\n * tx.addInput(i)\n *\n * @param utxo: jsonUtxo\n * @param unlockingScriptTemplate: { sign: (tx: Transaction, inputIndex: number) => Promise<UnlockingScript>, estimateLength: (tx: Transaction, inputIndex: number) => Promise<number> }\n * @returns\n */\nfunction fromUtxo(utxo, unlockingScriptTemplate) {\n    const sourceTransaction = new _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, [], [], 0);\n    sourceTransaction.outputs = Array(utxo.vout + 1).fill(null);\n    sourceTransaction.outputs[utxo.vout] = {\n        satoshis: utxo.satoshis,\n        lockingScript: _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromHex(utxo.script)\n    };\n    return {\n        sourceTransaction,\n        sourceTXID: utxo.txid,\n        sourceOutputIndex: utxo.vout,\n        unlockingScriptTemplate,\n        sequence: 0xffffffff\n    };\n}\n//# sourceMappingURL=Utxo.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/Utxo.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/bip-39-wordlist-en.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/bip-39-wordlist-en.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   wordList: () => (/* binding */ wordList)\n/* harmony export */ });\nconst wordList = {\n    value: [\n        'abandon',\n        'ability',\n        'able',\n        'about',\n        'above',\n        'absent',\n        'absorb',\n        'abstract',\n        'absurd',\n        'abuse',\n        'access',\n        'accident',\n        'account',\n        'accuse',\n        'achieve',\n        'acid',\n        'acoustic',\n        'acquire',\n        'across',\n        'act',\n        'action',\n        'actor',\n        'actress',\n        'actual',\n        'adapt',\n        'add',\n        'addict',\n        'address',\n        'adjust',\n        'admit',\n        'adult',\n        'advance',\n        'advice',\n        'aerobic',\n        'affair',\n        'afford',\n        'afraid',\n        'again',\n        'age',\n        'agent',\n        'agree',\n        'ahead',\n        'aim',\n        'air',\n        'airport',\n        'aisle',\n        'alarm',\n        'album',\n        'alcohol',\n        'alert',\n        'alien',\n        'all',\n        'alley',\n        'allow',\n        'almost',\n        'alone',\n        'alpha',\n        'already',\n        'also',\n        'alter',\n        'always',\n        'amateur',\n        'amazing',\n        'among',\n        'amount',\n        'amused',\n        'analyst',\n        'anchor',\n        'ancient',\n        'anger',\n        'angle',\n        'angry',\n        'animal',\n        'ankle',\n        'announce',\n        'annual',\n        'another',\n        'answer',\n        'antenna',\n        'antique',\n        'anxiety',\n        'any',\n        'apart',\n        'apology',\n        'appear',\n        'apple',\n        'approve',\n        'april',\n        'arch',\n        'arctic',\n        'area',\n        'arena',\n        'argue',\n        'arm',\n        'armed',\n        'armor',\n        'army',\n        'around',\n        'arrange',\n        'arrest',\n        'arrive',\n        'arrow',\n        'art',\n        'artefact',\n        'artist',\n        'artwork',\n        'ask',\n        'aspect',\n        'assault',\n        'asset',\n        'assist',\n        'assume',\n        'asthma',\n        'athlete',\n        'atom',\n        'attack',\n        'attend',\n        'attitude',\n        'attract',\n        'auction',\n        'audit',\n        'august',\n        'aunt',\n        'author',\n        'auto',\n        'autumn',\n        'average',\n        'avocado',\n        'avoid',\n        'awake',\n        'aware',\n        'away',\n        'awesome',\n        'awful',\n        'awkward',\n        'axis',\n        'baby',\n        'bachelor',\n        'bacon',\n        'badge',\n        'bag',\n        'balance',\n        'balcony',\n        'ball',\n        'bamboo',\n        'banana',\n        'banner',\n        'bar',\n        'barely',\n        'bargain',\n        'barrel',\n        'base',\n        'basic',\n        'basket',\n        'battle',\n        'beach',\n        'bean',\n        'beauty',\n        'because',\n        'become',\n        'beef',\n        'before',\n        'begin',\n        'behave',\n        'behind',\n        'believe',\n        'below',\n        'belt',\n        'bench',\n        'benefit',\n        'best',\n        'betray',\n        'better',\n        'between',\n        'beyond',\n        'bicycle',\n        'bid',\n        'bike',\n        'bind',\n        'biology',\n        'bird',\n        'birth',\n        'bitter',\n        'black',\n        'blade',\n        'blame',\n        'blanket',\n        'blast',\n        'bleak',\n        'bless',\n        'blind',\n        'blood',\n        'blossom',\n        'blouse',\n        'blue',\n        'blur',\n        'blush',\n        'board',\n        'boat',\n        'body',\n        'boil',\n        'bomb',\n        'bone',\n        'bonus',\n        'book',\n        'boost',\n        'border',\n        'boring',\n        'borrow',\n        'boss',\n        'bottom',\n        'bounce',\n        'box',\n        'boy',\n        'bracket',\n        'brain',\n        'brand',\n        'brass',\n        'brave',\n        'bread',\n        'breeze',\n        'brick',\n        'bridge',\n        'brief',\n        'bright',\n        'bring',\n        'brisk',\n        'broccoli',\n        'broken',\n        'bronze',\n        'broom',\n        'brother',\n        'brown',\n        'brush',\n        'bubble',\n        'buddy',\n        'budget',\n        'buffalo',\n        'build',\n        'bulb',\n        'bulk',\n        'bullet',\n        'bundle',\n        'bunker',\n        'burden',\n        'burger',\n        'burst',\n        'bus',\n        'business',\n        'busy',\n        'butter',\n        'buyer',\n        'buzz',\n        'cabbage',\n        'cabin',\n        'cable',\n        'cactus',\n        'cage',\n        'cake',\n        'call',\n        'calm',\n        'camera',\n        'camp',\n        'can',\n        'canal',\n        'cancel',\n        'candy',\n        'cannon',\n        'canoe',\n        'canvas',\n        'canyon',\n        'capable',\n        'capital',\n        'captain',\n        'car',\n        'carbon',\n        'card',\n        'cargo',\n        'carpet',\n        'carry',\n        'cart',\n        'case',\n        'cash',\n        'casino',\n        'castle',\n        'casual',\n        'cat',\n        'catalog',\n        'catch',\n        'category',\n        'cattle',\n        'caught',\n        'cause',\n        'caution',\n        'cave',\n        'ceiling',\n        'celery',\n        'cement',\n        'census',\n        'century',\n        'cereal',\n        'certain',\n        'chair',\n        'chalk',\n        'champion',\n        'change',\n        'chaos',\n        'chapter',\n        'charge',\n        'chase',\n        'chat',\n        'cheap',\n        'check',\n        'cheese',\n        'chef',\n        'cherry',\n        'chest',\n        'chicken',\n        'chief',\n        'child',\n        'chimney',\n        'choice',\n        'choose',\n        'chronic',\n        'chuckle',\n        'chunk',\n        'churn',\n        'cigar',\n        'cinnamon',\n        'circle',\n        'citizen',\n        'city',\n        'civil',\n        'claim',\n        'clap',\n        'clarify',\n        'claw',\n        'clay',\n        'clean',\n        'clerk',\n        'clever',\n        'click',\n        'client',\n        'cliff',\n        'climb',\n        'clinic',\n        'clip',\n        'clock',\n        'clog',\n        'close',\n        'cloth',\n        'cloud',\n        'clown',\n        'club',\n        'clump',\n        'cluster',\n        'clutch',\n        'coach',\n        'coast',\n        'coconut',\n        'code',\n        'coffee',\n        'coil',\n        'coin',\n        'collect',\n        'color',\n        'column',\n        'combine',\n        'come',\n        'comfort',\n        'comic',\n        'common',\n        'company',\n        'concert',\n        'conduct',\n        'confirm',\n        'congress',\n        'connect',\n        'consider',\n        'control',\n        'convince',\n        'cook',\n        'cool',\n        'copper',\n        'copy',\n        'coral',\n        'core',\n        'corn',\n        'correct',\n        'cost',\n        'cotton',\n        'couch',\n        'country',\n        'couple',\n        'course',\n        'cousin',\n        'cover',\n        'coyote',\n        'crack',\n        'cradle',\n        'craft',\n        'cram',\n        'crane',\n        'crash',\n        'crater',\n        'crawl',\n        'crazy',\n        'cream',\n        'credit',\n        'creek',\n        'crew',\n        'cricket',\n        'crime',\n        'crisp',\n        'critic',\n        'crop',\n        'cross',\n        'crouch',\n        'crowd',\n        'crucial',\n        'cruel',\n        'cruise',\n        'crumble',\n        'crunch',\n        'crush',\n        'cry',\n        'crystal',\n        'cube',\n        'culture',\n        'cup',\n        'cupboard',\n        'curious',\n        'current',\n        'curtain',\n        'curve',\n        'cushion',\n        'custom',\n        'cute',\n        'cycle',\n        'dad',\n        'damage',\n        'damp',\n        'dance',\n        'danger',\n        'daring',\n        'dash',\n        'daughter',\n        'dawn',\n        'day',\n        'deal',\n        'debate',\n        'debris',\n        'decade',\n        'december',\n        'decide',\n        'decline',\n        'decorate',\n        'decrease',\n        'deer',\n        'defense',\n        'define',\n        'defy',\n        'degree',\n        'delay',\n        'deliver',\n        'demand',\n        'demise',\n        'denial',\n        'dentist',\n        'deny',\n        'depart',\n        'depend',\n        'deposit',\n        'depth',\n        'deputy',\n        'derive',\n        'describe',\n        'desert',\n        'design',\n        'desk',\n        'despair',\n        'destroy',\n        'detail',\n        'detect',\n        'develop',\n        'device',\n        'devote',\n        'diagram',\n        'dial',\n        'diamond',\n        'diary',\n        'dice',\n        'diesel',\n        'diet',\n        'differ',\n        'digital',\n        'dignity',\n        'dilemma',\n        'dinner',\n        'dinosaur',\n        'direct',\n        'dirt',\n        'disagree',\n        'discover',\n        'disease',\n        'dish',\n        'dismiss',\n        'disorder',\n        'display',\n        'distance',\n        'divert',\n        'divide',\n        'divorce',\n        'dizzy',\n        'doctor',\n        'document',\n        'dog',\n        'doll',\n        'dolphin',\n        'domain',\n        'donate',\n        'donkey',\n        'donor',\n        'door',\n        'dose',\n        'double',\n        'dove',\n        'draft',\n        'dragon',\n        'drama',\n        'drastic',\n        'draw',\n        'dream',\n        'dress',\n        'drift',\n        'drill',\n        'drink',\n        'drip',\n        'drive',\n        'drop',\n        'drum',\n        'dry',\n        'duck',\n        'dumb',\n        'dune',\n        'during',\n        'dust',\n        'dutch',\n        'duty',\n        'dwarf',\n        'dynamic',\n        'eager',\n        'eagle',\n        'early',\n        'earn',\n        'earth',\n        'easily',\n        'east',\n        'easy',\n        'echo',\n        'ecology',\n        'economy',\n        'edge',\n        'edit',\n        'educate',\n        'effort',\n        'egg',\n        'eight',\n        'either',\n        'elbow',\n        'elder',\n        'electric',\n        'elegant',\n        'element',\n        'elephant',\n        'elevator',\n        'elite',\n        'else',\n        'embark',\n        'embody',\n        'embrace',\n        'emerge',\n        'emotion',\n        'employ',\n        'empower',\n        'empty',\n        'enable',\n        'enact',\n        'end',\n        'endless',\n        'endorse',\n        'enemy',\n        'energy',\n        'enforce',\n        'engage',\n        'engine',\n        'enhance',\n        'enjoy',\n        'enlist',\n        'enough',\n        'enrich',\n        'enroll',\n        'ensure',\n        'enter',\n        'entire',\n        'entry',\n        'envelope',\n        'episode',\n        'equal',\n        'equip',\n        'era',\n        'erase',\n        'erode',\n        'erosion',\n        'error',\n        'erupt',\n        'escape',\n        'essay',\n        'essence',\n        'estate',\n        'eternal',\n        'ethics',\n        'evidence',\n        'evil',\n        'evoke',\n        'evolve',\n        'exact',\n        'example',\n        'excess',\n        'exchange',\n        'excite',\n        'exclude',\n        'excuse',\n        'execute',\n        'exercise',\n        'exhaust',\n        'exhibit',\n        'exile',\n        'exist',\n        'exit',\n        'exotic',\n        'expand',\n        'expect',\n        'expire',\n        'explain',\n        'expose',\n        'express',\n        'extend',\n        'extra',\n        'eye',\n        'eyebrow',\n        'fabric',\n        'face',\n        'faculty',\n        'fade',\n        'faint',\n        'faith',\n        'fall',\n        'false',\n        'fame',\n        'family',\n        'famous',\n        'fan',\n        'fancy',\n        'fantasy',\n        'farm',\n        'fashion',\n        'fat',\n        'fatal',\n        'father',\n        'fatigue',\n        'fault',\n        'favorite',\n        'feature',\n        'february',\n        'federal',\n        'fee',\n        'feed',\n        'feel',\n        'female',\n        'fence',\n        'festival',\n        'fetch',\n        'fever',\n        'few',\n        'fiber',\n        'fiction',\n        'field',\n        'figure',\n        'file',\n        'film',\n        'filter',\n        'final',\n        'find',\n        'fine',\n        'finger',\n        'finish',\n        'fire',\n        'firm',\n        'first',\n        'fiscal',\n        'fish',\n        'fit',\n        'fitness',\n        'fix',\n        'flag',\n        'flame',\n        'flash',\n        'flat',\n        'flavor',\n        'flee',\n        'flight',\n        'flip',\n        'float',\n        'flock',\n        'floor',\n        'flower',\n        'fluid',\n        'flush',\n        'fly',\n        'foam',\n        'focus',\n        'fog',\n        'foil',\n        'fold',\n        'follow',\n        'food',\n        'foot',\n        'force',\n        'forest',\n        'forget',\n        'fork',\n        'fortune',\n        'forum',\n        'forward',\n        'fossil',\n        'foster',\n        'found',\n        'fox',\n        'fragile',\n        'frame',\n        'frequent',\n        'fresh',\n        'friend',\n        'fringe',\n        'frog',\n        'front',\n        'frost',\n        'frown',\n        'frozen',\n        'fruit',\n        'fuel',\n        'fun',\n        'funny',\n        'furnace',\n        'fury',\n        'future',\n        'gadget',\n        'gain',\n        'galaxy',\n        'gallery',\n        'game',\n        'gap',\n        'garage',\n        'garbage',\n        'garden',\n        'garlic',\n        'garment',\n        'gas',\n        'gasp',\n        'gate',\n        'gather',\n        'gauge',\n        'gaze',\n        'general',\n        'genius',\n        'genre',\n        'gentle',\n        'genuine',\n        'gesture',\n        'ghost',\n        'giant',\n        'gift',\n        'giggle',\n        'ginger',\n        'giraffe',\n        'girl',\n        'give',\n        'glad',\n        'glance',\n        'glare',\n        'glass',\n        'glide',\n        'glimpse',\n        'globe',\n        'gloom',\n        'glory',\n        'glove',\n        'glow',\n        'glue',\n        'goat',\n        'goddess',\n        'gold',\n        'good',\n        'goose',\n        'gorilla',\n        'gospel',\n        'gossip',\n        'govern',\n        'gown',\n        'grab',\n        'grace',\n        'grain',\n        'grant',\n        'grape',\n        'grass',\n        'gravity',\n        'great',\n        'green',\n        'grid',\n        'grief',\n        'grit',\n        'grocery',\n        'group',\n        'grow',\n        'grunt',\n        'guard',\n        'guess',\n        'guide',\n        'guilt',\n        'guitar',\n        'gun',\n        'gym',\n        'habit',\n        'hair',\n        'half',\n        'hammer',\n        'hamster',\n        'hand',\n        'happy',\n        'harbor',\n        'hard',\n        'harsh',\n        'harvest',\n        'hat',\n        'have',\n        'hawk',\n        'hazard',\n        'head',\n        'health',\n        'heart',\n        'heavy',\n        'hedgehog',\n        'height',\n        'hello',\n        'helmet',\n        'help',\n        'hen',\n        'hero',\n        'hidden',\n        'high',\n        'hill',\n        'hint',\n        'hip',\n        'hire',\n        'history',\n        'hobby',\n        'hockey',\n        'hold',\n        'hole',\n        'holiday',\n        'hollow',\n        'home',\n        'honey',\n        'hood',\n        'hope',\n        'horn',\n        'horror',\n        'horse',\n        'hospital',\n        'host',\n        'hotel',\n        'hour',\n        'hover',\n        'hub',\n        'huge',\n        'human',\n        'humble',\n        'humor',\n        'hundred',\n        'hungry',\n        'hunt',\n        'hurdle',\n        'hurry',\n        'hurt',\n        'husband',\n        'hybrid',\n        'ice',\n        'icon',\n        'idea',\n        'identify',\n        'idle',\n        'ignore',\n        'ill',\n        'illegal',\n        'illness',\n        'image',\n        'imitate',\n        'immense',\n        'immune',\n        'impact',\n        'impose',\n        'improve',\n        'impulse',\n        'inch',\n        'include',\n        'income',\n        'increase',\n        'index',\n        'indicate',\n        'indoor',\n        'industry',\n        'infant',\n        'inflict',\n        'inform',\n        'inhale',\n        'inherit',\n        'initial',\n        'inject',\n        'injury',\n        'inmate',\n        'inner',\n        'innocent',\n        'input',\n        'inquiry',\n        'insane',\n        'insect',\n        'inside',\n        'inspire',\n        'install',\n        'intact',\n        'interest',\n        'into',\n        'invest',\n        'invite',\n        'involve',\n        'iron',\n        'island',\n        'isolate',\n        'issue',\n        'item',\n        'ivory',\n        'jacket',\n        'jaguar',\n        'jar',\n        'jazz',\n        'jealous',\n        'jeans',\n        'jelly',\n        'jewel',\n        'job',\n        'join',\n        'joke',\n        'journey',\n        'joy',\n        'judge',\n        'juice',\n        'jump',\n        'jungle',\n        'junior',\n        'junk',\n        'just',\n        'kangaroo',\n        'keen',\n        'keep',\n        'ketchup',\n        'key',\n        'kick',\n        'kid',\n        'kidney',\n        'kind',\n        'kingdom',\n        'kiss',\n        'kit',\n        'kitchen',\n        'kite',\n        'kitten',\n        'kiwi',\n        'knee',\n        'knife',\n        'knock',\n        'know',\n        'lab',\n        'label',\n        'labor',\n        'ladder',\n        'lady',\n        'lake',\n        'lamp',\n        'language',\n        'laptop',\n        'large',\n        'later',\n        'latin',\n        'laugh',\n        'laundry',\n        'lava',\n        'law',\n        'lawn',\n        'lawsuit',\n        'layer',\n        'lazy',\n        'leader',\n        'leaf',\n        'learn',\n        'leave',\n        'lecture',\n        'left',\n        'leg',\n        'legal',\n        'legend',\n        'leisure',\n        'lemon',\n        'lend',\n        'length',\n        'lens',\n        'leopard',\n        'lesson',\n        'letter',\n        'level',\n        'liar',\n        'liberty',\n        'library',\n        'license',\n        'life',\n        'lift',\n        'light',\n        'like',\n        'limb',\n        'limit',\n        'link',\n        'lion',\n        'liquid',\n        'list',\n        'little',\n        'live',\n        'lizard',\n        'load',\n        'loan',\n        'lobster',\n        'local',\n        'lock',\n        'logic',\n        'lonely',\n        'long',\n        'loop',\n        'lottery',\n        'loud',\n        'lounge',\n        'love',\n        'loyal',\n        'lucky',\n        'luggage',\n        'lumber',\n        'lunar',\n        'lunch',\n        'luxury',\n        'lyrics',\n        'machine',\n        'mad',\n        'magic',\n        'magnet',\n        'maid',\n        'mail',\n        'main',\n        'major',\n        'make',\n        'mammal',\n        'man',\n        'manage',\n        'mandate',\n        'mango',\n        'mansion',\n        'manual',\n        'maple',\n        'marble',\n        'march',\n        'margin',\n        'marine',\n        'market',\n        'marriage',\n        'mask',\n        'mass',\n        'master',\n        'match',\n        'material',\n        'math',\n        'matrix',\n        'matter',\n        'maximum',\n        'maze',\n        'meadow',\n        'mean',\n        'measure',\n        'meat',\n        'mechanic',\n        'medal',\n        'media',\n        'melody',\n        'melt',\n        'member',\n        'memory',\n        'mention',\n        'menu',\n        'mercy',\n        'merge',\n        'merit',\n        'merry',\n        'mesh',\n        'message',\n        'metal',\n        'method',\n        'middle',\n        'midnight',\n        'milk',\n        'million',\n        'mimic',\n        'mind',\n        'minimum',\n        'minor',\n        'minute',\n        'miracle',\n        'mirror',\n        'misery',\n        'miss',\n        'mistake',\n        'mix',\n        'mixed',\n        'mixture',\n        'mobile',\n        'model',\n        'modify',\n        'mom',\n        'moment',\n        'monitor',\n        'monkey',\n        'monster',\n        'month',\n        'moon',\n        'moral',\n        'more',\n        'morning',\n        'mosquito',\n        'mother',\n        'motion',\n        'motor',\n        'mountain',\n        'mouse',\n        'move',\n        'movie',\n        'much',\n        'muffin',\n        'mule',\n        'multiply',\n        'muscle',\n        'museum',\n        'mushroom',\n        'music',\n        'must',\n        'mutual',\n        'myself',\n        'mystery',\n        'myth',\n        'naive',\n        'name',\n        'napkin',\n        'narrow',\n        'nasty',\n        'nation',\n        'nature',\n        'near',\n        'neck',\n        'need',\n        'negative',\n        'neglect',\n        'neither',\n        'nephew',\n        'nerve',\n        'nest',\n        'net',\n        'network',\n        'neutral',\n        'never',\n        'news',\n        'next',\n        'nice',\n        'night',\n        'noble',\n        'noise',\n        'nominee',\n        'noodle',\n        'normal',\n        'north',\n        'nose',\n        'notable',\n        'note',\n        'nothing',\n        'notice',\n        'novel',\n        'now',\n        'nuclear',\n        'number',\n        'nurse',\n        'nut',\n        'oak',\n        'obey',\n        'object',\n        'oblige',\n        'obscure',\n        'observe',\n        'obtain',\n        'obvious',\n        'occur',\n        'ocean',\n        'october',\n        'odor',\n        'off',\n        'offer',\n        'office',\n        'often',\n        'oil',\n        'okay',\n        'old',\n        'olive',\n        'olympic',\n        'omit',\n        'once',\n        'one',\n        'onion',\n        'online',\n        'only',\n        'open',\n        'opera',\n        'opinion',\n        'oppose',\n        'option',\n        'orange',\n        'orbit',\n        'orchard',\n        'order',\n        'ordinary',\n        'organ',\n        'orient',\n        'original',\n        'orphan',\n        'ostrich',\n        'other',\n        'outdoor',\n        'outer',\n        'output',\n        'outside',\n        'oval',\n        'oven',\n        'over',\n        'own',\n        'owner',\n        'oxygen',\n        'oyster',\n        'ozone',\n        'pact',\n        'paddle',\n        'page',\n        'pair',\n        'palace',\n        'palm',\n        'panda',\n        'panel',\n        'panic',\n        'panther',\n        'paper',\n        'parade',\n        'parent',\n        'park',\n        'parrot',\n        'party',\n        'pass',\n        'patch',\n        'path',\n        'patient',\n        'patrol',\n        'pattern',\n        'pause',\n        'pave',\n        'payment',\n        'peace',\n        'peanut',\n        'pear',\n        'peasant',\n        'pelican',\n        'pen',\n        'penalty',\n        'pencil',\n        'people',\n        'pepper',\n        'perfect',\n        'permit',\n        'person',\n        'pet',\n        'phone',\n        'photo',\n        'phrase',\n        'physical',\n        'piano',\n        'picnic',\n        'picture',\n        'piece',\n        'pig',\n        'pigeon',\n        'pill',\n        'pilot',\n        'pink',\n        'pioneer',\n        'pipe',\n        'pistol',\n        'pitch',\n        'pizza',\n        'place',\n        'planet',\n        'plastic',\n        'plate',\n        'play',\n        'please',\n        'pledge',\n        'pluck',\n        'plug',\n        'plunge',\n        'poem',\n        'poet',\n        'point',\n        'polar',\n        'pole',\n        'police',\n        'pond',\n        'pony',\n        'pool',\n        'popular',\n        'portion',\n        'position',\n        'possible',\n        'post',\n        'potato',\n        'pottery',\n        'poverty',\n        'powder',\n        'power',\n        'practice',\n        'praise',\n        'predict',\n        'prefer',\n        'prepare',\n        'present',\n        'pretty',\n        'prevent',\n        'price',\n        'pride',\n        'primary',\n        'print',\n        'priority',\n        'prison',\n        'private',\n        'prize',\n        'problem',\n        'process',\n        'produce',\n        'profit',\n        'program',\n        'project',\n        'promote',\n        'proof',\n        'property',\n        'prosper',\n        'protect',\n        'proud',\n        'provide',\n        'public',\n        'pudding',\n        'pull',\n        'pulp',\n        'pulse',\n        'pumpkin',\n        'punch',\n        'pupil',\n        'puppy',\n        'purchase',\n        'purity',\n        'purpose',\n        'purse',\n        'push',\n        'put',\n        'puzzle',\n        'pyramid',\n        'quality',\n        'quantum',\n        'quarter',\n        'question',\n        'quick',\n        'quit',\n        'quiz',\n        'quote',\n        'rabbit',\n        'raccoon',\n        'race',\n        'rack',\n        'radar',\n        'radio',\n        'rail',\n        'rain',\n        'raise',\n        'rally',\n        'ramp',\n        'ranch',\n        'random',\n        'range',\n        'rapid',\n        'rare',\n        'rate',\n        'rather',\n        'raven',\n        'raw',\n        'razor',\n        'ready',\n        'real',\n        'reason',\n        'rebel',\n        'rebuild',\n        'recall',\n        'receive',\n        'recipe',\n        'record',\n        'recycle',\n        'reduce',\n        'reflect',\n        'reform',\n        'refuse',\n        'region',\n        'regret',\n        'regular',\n        'reject',\n        'relax',\n        'release',\n        'relief',\n        'rely',\n        'remain',\n        'remember',\n        'remind',\n        'remove',\n        'render',\n        'renew',\n        'rent',\n        'reopen',\n        'repair',\n        'repeat',\n        'replace',\n        'report',\n        'require',\n        'rescue',\n        'resemble',\n        'resist',\n        'resource',\n        'response',\n        'result',\n        'retire',\n        'retreat',\n        'return',\n        'reunion',\n        'reveal',\n        'review',\n        'reward',\n        'rhythm',\n        'rib',\n        'ribbon',\n        'rice',\n        'rich',\n        'ride',\n        'ridge',\n        'rifle',\n        'right',\n        'rigid',\n        'ring',\n        'riot',\n        'ripple',\n        'risk',\n        'ritual',\n        'rival',\n        'river',\n        'road',\n        'roast',\n        'robot',\n        'robust',\n        'rocket',\n        'romance',\n        'roof',\n        'rookie',\n        'room',\n        'rose',\n        'rotate',\n        'rough',\n        'round',\n        'route',\n        'royal',\n        'rubber',\n        'rude',\n        'rug',\n        'rule',\n        'run',\n        'runway',\n        'rural',\n        'sad',\n        'saddle',\n        'sadness',\n        'safe',\n        'sail',\n        'salad',\n        'salmon',\n        'salon',\n        'salt',\n        'salute',\n        'same',\n        'sample',\n        'sand',\n        'satisfy',\n        'satoshi',\n        'sauce',\n        'sausage',\n        'save',\n        'say',\n        'scale',\n        'scan',\n        'scare',\n        'scatter',\n        'scene',\n        'scheme',\n        'school',\n        'science',\n        'scissors',\n        'scorpion',\n        'scout',\n        'scrap',\n        'screen',\n        'script',\n        'scrub',\n        'sea',\n        'search',\n        'season',\n        'seat',\n        'second',\n        'secret',\n        'section',\n        'security',\n        'seed',\n        'seek',\n        'segment',\n        'select',\n        'sell',\n        'seminar',\n        'senior',\n        'sense',\n        'sentence',\n        'series',\n        'service',\n        'session',\n        'settle',\n        'setup',\n        'seven',\n        'shadow',\n        'shaft',\n        'shallow',\n        'share',\n        'shed',\n        'shell',\n        'sheriff',\n        'shield',\n        'shift',\n        'shine',\n        'ship',\n        'shiver',\n        'shock',\n        'shoe',\n        'shoot',\n        'shop',\n        'short',\n        'shoulder',\n        'shove',\n        'shrimp',\n        'shrug',\n        'shuffle',\n        'shy',\n        'sibling',\n        'sick',\n        'side',\n        'siege',\n        'sight',\n        'sign',\n        'silent',\n        'silk',\n        'silly',\n        'silver',\n        'similar',\n        'simple',\n        'since',\n        'sing',\n        'siren',\n        'sister',\n        'situate',\n        'six',\n        'size',\n        'skate',\n        'sketch',\n        'ski',\n        'skill',\n        'skin',\n        'skirt',\n        'skull',\n        'slab',\n        'slam',\n        'sleep',\n        'slender',\n        'slice',\n        'slide',\n        'slight',\n        'slim',\n        'slogan',\n        'slot',\n        'slow',\n        'slush',\n        'small',\n        'smart',\n        'smile',\n        'smoke',\n        'smooth',\n        'snack',\n        'snake',\n        'snap',\n        'sniff',\n        'snow',\n        'soap',\n        'soccer',\n        'social',\n        'sock',\n        'soda',\n        'soft',\n        'solar',\n        'soldier',\n        'solid',\n        'solution',\n        'solve',\n        'someone',\n        'song',\n        'soon',\n        'sorry',\n        'sort',\n        'soul',\n        'sound',\n        'soup',\n        'source',\n        'south',\n        'space',\n        'spare',\n        'spatial',\n        'spawn',\n        'speak',\n        'special',\n        'speed',\n        'spell',\n        'spend',\n        'sphere',\n        'spice',\n        'spider',\n        'spike',\n        'spin',\n        'spirit',\n        'split',\n        'spoil',\n        'sponsor',\n        'spoon',\n        'sport',\n        'spot',\n        'spray',\n        'spread',\n        'spring',\n        'spy',\n        'square',\n        'squeeze',\n        'squirrel',\n        'stable',\n        'stadium',\n        'staff',\n        'stage',\n        'stairs',\n        'stamp',\n        'stand',\n        'start',\n        'state',\n        'stay',\n        'steak',\n        'steel',\n        'stem',\n        'step',\n        'stereo',\n        'stick',\n        'still',\n        'sting',\n        'stock',\n        'stomach',\n        'stone',\n        'stool',\n        'story',\n        'stove',\n        'strategy',\n        'street',\n        'strike',\n        'strong',\n        'struggle',\n        'student',\n        'stuff',\n        'stumble',\n        'style',\n        'subject',\n        'submit',\n        'subway',\n        'success',\n        'such',\n        'sudden',\n        'suffer',\n        'sugar',\n        'suggest',\n        'suit',\n        'summer',\n        'sun',\n        'sunny',\n        'sunset',\n        'super',\n        'supply',\n        'supreme',\n        'sure',\n        'surface',\n        'surge',\n        'surprise',\n        'surround',\n        'survey',\n        'suspect',\n        'sustain',\n        'swallow',\n        'swamp',\n        'swap',\n        'swarm',\n        'swear',\n        'sweet',\n        'swift',\n        'swim',\n        'swing',\n        'switch',\n        'sword',\n        'symbol',\n        'symptom',\n        'syrup',\n        'system',\n        'table',\n        'tackle',\n        'tag',\n        'tail',\n        'talent',\n        'talk',\n        'tank',\n        'tape',\n        'target',\n        'task',\n        'taste',\n        'tattoo',\n        'taxi',\n        'teach',\n        'team',\n        'tell',\n        'ten',\n        'tenant',\n        'tennis',\n        'tent',\n        'term',\n        'test',\n        'text',\n        'thank',\n        'that',\n        'theme',\n        'then',\n        'theory',\n        'there',\n        'they',\n        'thing',\n        'this',\n        'thought',\n        'three',\n        'thrive',\n        'throw',\n        'thumb',\n        'thunder',\n        'ticket',\n        'tide',\n        'tiger',\n        'tilt',\n        'timber',\n        'time',\n        'tiny',\n        'tip',\n        'tired',\n        'tissue',\n        'title',\n        'toast',\n        'tobacco',\n        'today',\n        'toddler',\n        'toe',\n        'together',\n        'toilet',\n        'token',\n        'tomato',\n        'tomorrow',\n        'tone',\n        'tongue',\n        'tonight',\n        'tool',\n        'tooth',\n        'top',\n        'topic',\n        'topple',\n        'torch',\n        'tornado',\n        'tortoise',\n        'toss',\n        'total',\n        'tourist',\n        'toward',\n        'tower',\n        'town',\n        'toy',\n        'track',\n        'trade',\n        'traffic',\n        'tragic',\n        'train',\n        'transfer',\n        'trap',\n        'trash',\n        'travel',\n        'tray',\n        'treat',\n        'tree',\n        'trend',\n        'trial',\n        'tribe',\n        'trick',\n        'trigger',\n        'trim',\n        'trip',\n        'trophy',\n        'trouble',\n        'truck',\n        'true',\n        'truly',\n        'trumpet',\n        'trust',\n        'truth',\n        'try',\n        'tube',\n        'tuition',\n        'tumble',\n        'tuna',\n        'tunnel',\n        'turkey',\n        'turn',\n        'turtle',\n        'twelve',\n        'twenty',\n        'twice',\n        'twin',\n        'twist',\n        'two',\n        'type',\n        'typical',\n        'ugly',\n        'umbrella',\n        'unable',\n        'unaware',\n        'uncle',\n        'uncover',\n        'under',\n        'undo',\n        'unfair',\n        'unfold',\n        'unhappy',\n        'uniform',\n        'unique',\n        'unit',\n        'universe',\n        'unknown',\n        'unlock',\n        'until',\n        'unusual',\n        'unveil',\n        'update',\n        'upgrade',\n        'uphold',\n        'upon',\n        'upper',\n        'upset',\n        'urban',\n        'urge',\n        'usage',\n        'use',\n        'used',\n        'useful',\n        'useless',\n        'usual',\n        'utility',\n        'vacant',\n        'vacuum',\n        'vague',\n        'valid',\n        'valley',\n        'valve',\n        'van',\n        'vanish',\n        'vapor',\n        'various',\n        'vast',\n        'vault',\n        'vehicle',\n        'velvet',\n        'vendor',\n        'venture',\n        'venue',\n        'verb',\n        'verify',\n        'version',\n        'very',\n        'vessel',\n        'veteran',\n        'viable',\n        'vibrant',\n        'vicious',\n        'victory',\n        'video',\n        'view',\n        'village',\n        'vintage',\n        'violin',\n        'virtual',\n        'virus',\n        'visa',\n        'visit',\n        'visual',\n        'vital',\n        'vivid',\n        'vocal',\n        'voice',\n        'void',\n        'volcano',\n        'volume',\n        'vote',\n        'voyage',\n        'wage',\n        'wagon',\n        'wait',\n        'walk',\n        'wall',\n        'walnut',\n        'want',\n        'warfare',\n        'warm',\n        'warrior',\n        'wash',\n        'wasp',\n        'waste',\n        'water',\n        'wave',\n        'way',\n        'wealth',\n        'weapon',\n        'wear',\n        'weasel',\n        'weather',\n        'web',\n        'wedding',\n        'weekend',\n        'weird',\n        'welcome',\n        'west',\n        'wet',\n        'whale',\n        'what',\n        'wheat',\n        'wheel',\n        'when',\n        'where',\n        'whip',\n        'whisper',\n        'wide',\n        'width',\n        'wife',\n        'wild',\n        'will',\n        'win',\n        'window',\n        'wine',\n        'wing',\n        'wink',\n        'winner',\n        'winter',\n        'wire',\n        'wisdom',\n        'wise',\n        'wish',\n        'witness',\n        'wolf',\n        'woman',\n        'wonder',\n        'wood',\n        'wool',\n        'word',\n        'work',\n        'world',\n        'worry',\n        'worth',\n        'wrap',\n        'wreck',\n        'wrestle',\n        'wrist',\n        'write',\n        'wrong',\n        'yard',\n        'year',\n        'yellow',\n        'you',\n        'young',\n        'youth',\n        'zebra',\n        'zero',\n        'zone',\n        'zoo'\n    ],\n    space: ' '\n};\n//# sourceMappingURL=bip-39-wordlist-en.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/bip-39-wordlist-en.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/compat/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/compat/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BSM: () => (/* reexport module object */ _BSM_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   ECIES: () => (/* reexport safe */ _ECIES_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   HD: () => (/* reexport safe */ _HD_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   Mnemonic: () => (/* reexport safe */ _Mnemonic_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   fromUtxo: () => (/* reexport safe */ _Utxo_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _BSM_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BSM.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/BSM.js\");\n/* harmony import */ var _HD_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HD.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/HD.js\");\n/* harmony import */ var _Mnemonic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mnemonic.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/Mnemonic.js\");\n/* harmony import */ var _ECIES_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ECIES.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/ECIES.js\");\n/* harmony import */ var _Utxo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utxo.js */ \"./node_modules/@bsv/sdk/dist/esm/src/compat/Utxo.js\");\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/compat/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/identity/IdentityClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/identity/IdentityClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IdentityClient: () => (/* binding */ IdentityClient)\n/* harmony export */ });\n/* harmony import */ var _auth_clients_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../auth/clients/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/clients/index.js\");\n/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/identity/types/index.js\");\n/* harmony import */ var _wallet_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js\");\n/* harmony import */ var _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n/* harmony import */ var _script_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../script/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/index.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n/* harmony import */ var _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js\");\n\n\n\n\n\n\n\n\n/**\n * IdentityClient lets you discover who others are, and let the world know who you are.\n */\nclass IdentityClient {\n    options;\n    originator;\n    authClient;\n    wallet;\n    constructor(wallet, options = _types_index_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_IDENTITY_CLIENT_OPTIONS, originator) {\n        this.options = options;\n        this.originator = originator;\n        this.wallet = wallet ?? new _wallet_index_js__WEBPACK_IMPORTED_MODULE_2__.WalletClient();\n        this.authClient = new _auth_clients_index_js__WEBPACK_IMPORTED_MODULE_0__.AuthFetch(this.wallet);\n    }\n    /**\n     * Publicly reveals selected fields from a given certificate by creating a publicly verifiable certificate.\n     * The publicly revealed certificate is included in a blockchain transaction and broadcast to a federated overlay node.\n     *\n     * @param {Certificate} certificate - The master certificate to selectively reveal.\n     * @param {CertificateFieldNameUnder50Bytes[]} fieldsToReveal - An array of certificate field names to reveal. Only these fields will be included in the public certificate.\n     *\n     * @returns {Promise<object>} A promise that resolves with the broadcast result from the overlay network.\n     * @throws {Error} Throws an error if the certificate is invalid, the fields cannot be revealed, or if the broadcast fails.\n     */\n    async publiclyRevealAttributes(certificate, fieldsToReveal) {\n        if (Object.keys(certificate.fields).length === 0) {\n            throw new Error('Public reveal failed: Certificate has no fields to reveal!');\n        }\n        if (fieldsToReveal.length === 0) {\n            throw new Error('Public reveal failed: You must reveal at least one field!');\n        }\n        try {\n            const masterCert = new _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.signature);\n            await masterCert.verify();\n        }\n        catch (error) {\n            throw new Error('Public reveal failed: Certificate verification failed!');\n        }\n        // Given we already have a master certificate from a certifier,\n        // create an anyone verifiable certificate with selectively revealed fields\n        const { keyringForVerifier } = await this.wallet.proveCertificate({\n            certificate,\n            fieldsToReveal,\n            verifier: new _primitives_index_js__WEBPACK_IMPORTED_MODULE_6__.PrivateKey(1).toPublicKey().toString()\n        });\n        // Build the lockingScript with pushdrop.create() and the transaction with createAction()\n        const lockingScript = await new _script_index_js__WEBPACK_IMPORTED_MODULE_5__.PushDrop(this.wallet).lock([_primitives_index_js__WEBPACK_IMPORTED_MODULE_6__.Utils.toArray(JSON.stringify({ ...certificate, keyring: keyringForVerifier }))], this.options.protocolID, this.options.keyID, 'anyone', true, true);\n        // TODO: Consider verification and if this is necessary\n        // counterpartyCanVerifyMyOwnership: true\n        const { tx } = await this.wallet.createAction({\n            description: 'Create a new Identity Token',\n            outputs: [{\n                    satoshis: this.options.tokenAmount,\n                    lockingScript: lockingScript.toHex(),\n                    outputDescription: 'Identity Token'\n                }],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        if (tx !== undefined) {\n            // Submit the transaction to an overlay\n            const broadcaster = new _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_7__.TopicBroadcaster(['tm_identity'], {\n                networkPreset: (await (this.wallet.getNetwork({}))).network\n            });\n            return await broadcaster.broadcast(_transaction_index_js__WEBPACK_IMPORTED_MODULE_3__.Transaction.fromAtomicBEEF(tx));\n        }\n        throw new Error('Public reveal failed: failed to create action!');\n    }\n    /**\n    * Resolves displayable identity certificates, issued to a given identity key by a trusted certifier.\n    *\n    * @param {DiscoverByIdentityKeyArgs} args - Arguments for requesting the discovery based on the identity key.\n    * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.\n    */\n    async resolveByIdentityKey(args) {\n        const { certificates } = await this.wallet.discoverByIdentityKey(args, this.originator);\n        return certificates.map(cert => {\n            return IdentityClient.parseIdentity(cert);\n        });\n    }\n    /**\n     * Resolves displayable identity certificates by specific identity attributes, issued by a trusted entity.\n     *\n     * @param {DiscoverByAttributesArgs} args - Attributes and optional parameters used to discover certificates.\n     * @returns {Promise<DisplayableIdentity[]>} The promise resolves to displayable identities.\n     */\n    async resolveByAttributes(args) {\n        const { certificates } = await this.wallet.discoverByAttributes(args, this.originator);\n        return certificates.map(cert => {\n            return IdentityClient.parseIdentity(cert);\n        });\n    }\n    /**\n     * TODO: Implement once revocation overlay is created\n     * Remove public certificate revelation from overlay services by spending the identity token\n     * @param serialNumber - Unique serial number of the certificate to revoke revelation\n     */\n    // async revokeCertificateRevelation(\n    //   serialNumber: Base64String\n    // ): Promise<BroadcastResponse | BroadcastFailure> {\n    //   // 1. Find existing UTXO\n    //   const lookupResolver = new LookupResolver()\n    //   const result = await lookupResolver.query({\n    //     service: 'ls_identity',\n    //     query: {\n    //       serialNumber\n    //     }\n    //   })\n    //   let outpoint: string\n    //   let lockingScript: LockingScript | undefined\n    //   if (result.type === 'output-list') {\n    //     const tx = Transaction.fromAtomicBEEF(result.outputs[this.options.outputIndex].beef)\n    //     outpoint = `${tx.id('hex')}.${this.options.outputIndex}` // Consider better way\n    //     lockingScript = tx.outputs[this.options.outputIndex].lockingScript\n    //   }\n    //   if (lockingScript === undefined) {\n    //     throw new Error('Failed to get locking script for revelation output!')\n    //   }\n    //   // 2. Parse results\n    //   const { signableTransaction } = await this.wallet.createAction({\n    //     description: '',\n    //     inputs: [{\n    //       inputDescription: 'Spend certificate revelation token',\n    //       outpoint,\n    //       unlockingScriptLength: 73\n    //     }],\n    //     options: {\n    //       randomizeOutputs: false\n    //     }\n    //   })\n    //   if (signableTransaction === undefined) {\n    //     throw new Error('Failed to create signable transaction')\n    //   }\n    //   const partialTx = Transaction.fromBEEF(signableTransaction.tx)\n    //   const unlocker = new PushDrop(this.wallet).unlock(\n    //     this.options.protocolID,\n    //     this.options.keyID,\n    //     'self',\n    //     'all',\n    //     false,\n    //     1,\n    //     lockingScript\n    //   )\n    //   const unlockingScript = await unlocker.sign(partialTx, this.options.outputIndex)\n    //   const { tx: signedTx } = await this.wallet.signAction({\n    //     reference: signableTransaction.reference,\n    //     spends: {\n    //       [this.options.outputIndex]: {\n    //         unlockingScript: unlockingScript.toHex()\n    //       }\n    //     }\n    //   })\n    //   // 4. Return broadcast status\n    //   // Submit the transaction to an overlay\n    //   const broadcaster = new SHIPBroadcaster(['tm_identity'])\n    //   return await broadcaster.broadcast(Transaction.fromAtomicBEEF(signedTx as number[]))\n    // }\n    /**\n     * Parse out identity and certifier attributes to display from an IdentityCertificate\n     * @param identityToParse - The Identity Certificate to parse\n     * @returns - IdentityToDisplay\n     */\n    static parseIdentity(identityToParse) {\n        const { type, decryptedFields, certifierInfo } = identityToParse;\n        let name, avatarURL, badgeLabel, badgeIconURL, badgeClickURL;\n        // Parse out the name to display based on the specific certificate type which has clearly defined fields.\n        switch (type) {\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.xCert:\n                name = decryptedFields.userName;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `X account certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.discordCert:\n                name = decryptedFields.userName;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `Discord account certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.emailCert:\n                name = decryptedFields.email;\n                avatarURL = 'XUTZxep7BBghAJbSBwTjNfmcsDdRFs5EaGEgkESGSgjJVYgMEizu';\n                badgeLabel = `Email certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.phoneCert:\n                name = decryptedFields.phoneNumber;\n                avatarURL = 'XUTLxtX3ELNUwRhLwL7kWNGbdnFM8WG2eSLv84J7654oH8HaJWrU';\n                badgeLabel = `Phone certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://socialcert.net'; // TODO Make a specific page for this.\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.identiCert:\n                name = `${decryptedFields.firstName} ${decryptedFields.lastName}`;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = `Government ID certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://identicert.me'; // TODO Make a specific page for this.\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.registrant:\n                name = decryptedFields.name;\n                avatarURL = decryptedFields.icon;\n                badgeLabel = `Entity certified by ${certifierInfo.name}`;\n                badgeIconURL = certifierInfo.iconUrl;\n                badgeClickURL = 'https://projectbabbage.com/docs/registrant'; // TODO: Make this doc page exist\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.coolCert:\n                name = decryptedFields.cool === 'true' ? 'Cool Person!' : 'Not cool!';\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.anyone:\n                name = 'Anyone';\n                avatarURL = 'XUT4bpQ6cpBaXi1oMzZsXfpkWGbtp2JTUYAoN7PzhStFJ6wLfoeR';\n                badgeLabel = 'Represents the ability for anyone to access this information.';\n                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';\n                badgeClickURL = 'https://projectbabbage.com/docs/anyone-identity'; // TODO: Make this doc page exist\n                break;\n            case _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES.self:\n                name = 'You';\n                avatarURL = 'XUT9jHGk2qace148jeCX5rDsMftkSGYKmigLwU2PLLBc7Hm63VYR';\n                badgeLabel = 'Represents your ability to access this information.';\n                badgeIconURL = 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG';\n                badgeClickURL = 'https://projectbabbage.com/docs/self-identity'; // TODO: Make this doc page exist\n                break;\n            default:\n                name = _types_index_js__WEBPACK_IMPORTED_MODULE_1__.defaultIdentity.name;\n                avatarURL = decryptedFields.profilePhoto;\n                badgeLabel = _types_index_js__WEBPACK_IMPORTED_MODULE_1__.defaultIdentity.badgeLabel;\n                badgeIconURL = _types_index_js__WEBPACK_IMPORTED_MODULE_1__.defaultIdentity.badgeIconURL;\n                badgeClickURL = _types_index_js__WEBPACK_IMPORTED_MODULE_1__.defaultIdentity.badgeClickURL; // TODO: Make this doc page exist\n                break;\n        }\n        return {\n            name,\n            avatarURL,\n            abbreviatedKey: identityToParse.subject.length > 0 ? `${identityToParse.subject.substring(0, 10)}...` : '',\n            identityKey: identityToParse.subject,\n            badgeIconURL,\n            badgeLabel,\n            badgeClickURL\n        };\n    }\n}\n//# sourceMappingURL=IdentityClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/identity/IdentityClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/identity/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/identity/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_IDENTITY_CLIENT_OPTIONS: () => (/* reexport safe */ _types_index_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_IDENTITY_CLIENT_OPTIONS),\n/* harmony export */   IdentityClient: () => (/* reexport safe */ _IdentityClient_js__WEBPACK_IMPORTED_MODULE_0__.IdentityClient),\n/* harmony export */   KNOWN_IDENTITY_TYPES: () => (/* reexport safe */ _types_index_js__WEBPACK_IMPORTED_MODULE_1__.KNOWN_IDENTITY_TYPES),\n/* harmony export */   defaultIdentity: () => (/* reexport safe */ _types_index_js__WEBPACK_IMPORTED_MODULE_1__.defaultIdentity)\n/* harmony export */ });\n/* harmony import */ var _IdentityClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./IdentityClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/identity/IdentityClient.js\");\n/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/identity/types/index.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/identity/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/identity/types/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/identity/types/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_IDENTITY_CLIENT_OPTIONS: () => (/* binding */ DEFAULT_IDENTITY_CLIENT_OPTIONS),\n/* harmony export */   KNOWN_IDENTITY_TYPES: () => (/* binding */ KNOWN_IDENTITY_TYPES),\n/* harmony export */   defaultIdentity: () => (/* binding */ defaultIdentity)\n/* harmony export */ });\nconst defaultIdentity = {\n    name: 'Unknown Identity',\n    avatarURL: 'XUUB8bbn9fEthk15Ge3zTQXypUShfC94vFjp65v7u5CQ8qkpxzst',\n    identityKey: '',\n    abbreviatedKey: '',\n    badgeIconURL: 'XUUV39HVPkpmMzYNTx7rpKzJvXfeiVyQWg2vfSpjBAuhunTCA9uG',\n    badgeLabel: 'Not verified by anyone you trust.',\n    badgeClickURL: 'https://projectbabbage.com/docs/unknown-identity'\n};\nconst DEFAULT_IDENTITY_CLIENT_OPTIONS = {\n    protocolID: [1, 'identity'],\n    keyID: '1',\n    tokenAmount: 1,\n    outputIndex: 0\n};\nconst KNOWN_IDENTITY_TYPES = {\n    identiCert: 'z40BOInXkI8m7f/wBrv4MJ09bZfzZbTj2fJqCtONqCY=',\n    discordCert: '2TgqRC35B1zehGmB21xveZNc7i5iqHc0uxMb+1NMPW4=',\n    phoneCert: 'mffUklUzxbHr65xLohn0hRL0Tq2GjW1GYF/OPfzqJ6A=',\n    xCert: 'vdDWvftf1H+5+ZprUw123kjHlywH+v20aPQTuXgMpNc=',\n    registrant: 'YoPsbfR6YQczjzPdHCoGC7nJsOdPQR50+SYqcWpJ0y0=',\n    emailCert: 'exOl3KM0dIJ04EW5pZgbZmPag6MdJXd3/a1enmUU/BA=',\n    anyone: 'mfkOMfLDQmrr3SBxBQ5WeE+6Hy3VJRFq6w4A5Ljtlis=',\n    self: 'Hkge6X5JRxt1cWXtHLCrSTg6dCVTxjQJJ48iOYd7n3g=',\n    coolCert: 'AGfk/WrT1eBDXpz3mcw386Zww2HmqcIn3uY6x4Af1eo='\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/identity/types/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/kvstore/LocalKVStore.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/kvstore/LocalKVStore.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LocalKVStore)\n/* harmony export */ });\n/* harmony import */ var _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _wallet_WalletClient_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wallet/WalletClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletClient.js\");\n/* harmony import */ var _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js\");\n/* harmony import */ var _transaction_Beef_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../transaction/Beef.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js\");\n\n\n\n\n\n/**\n * Implements a key-value storage system backed by transaction outputs managed by a wallet.\n * Each key-value pair is represented by a PushDrop token output in a specific context (basket).\n * Allows setting, getting, and removing key-value pairs, with optional encryption.\n */\nclass LocalKVStore {\n    /**\n     * The wallet interface used to manage outputs and perform cryptographic operations.\n     * @private\n     * @readonly\n     */\n    wallet;\n    /**\n     * The context (basket name) used to namespace the key-value pairs within the wallet.\n     * @private\n     * @readonly\n     */\n    context;\n    /**\n     * Flag indicating whether values should be encrypted before storing.\n     * @private\n     * @readonly\n     */\n    encrypt;\n    /**\n     * An originator to use with PushDrop and the wallet.\n     * @private\n     * @readonly\n     */\n    originator;\n    acceptDelayedBroadcast = false;\n    /**\n     * A map to store locks for each key to ensure atomic updates.\n     * @private\n     */\n    keyLocks = new Map();\n    /**\n     * Creates an instance of the localKVStore.\n     *\n     * @param {WalletInterface} [wallet=new WalletClient()] - The wallet interface to use. Defaults to a new WalletClient instance.\n     * @param {string} [context='kvstoredefault'] - The context (basket) for namespacing keys. Defaults to 'kvstore default'.\n     * @param {boolean} [encrypt=true] - Whether to encrypt values. Defaults to true.\n     * @param {string} [originator]  An originator to use with PushDrop and the wallet, if provided.\n     * @throws {Error} If the context is missing or empty.\n     */\n    constructor(wallet = new _wallet_WalletClient_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](), context = 'kvstore default', encrypt = true, originator, acceptDelayedBroadcast = false) {\n        if (typeof context !== 'string' || context.length < 1) {\n            throw new Error('A context in which to operate is required.');\n        }\n        this.wallet = wallet;\n        this.context = context;\n        this.encrypt = encrypt;\n        this.originator = originator;\n        this.acceptDelayedBroadcast = acceptDelayedBroadcast;\n    }\n    async queueOperationOnKey(key) {\n        // Check if a lock exists for this key and wait for it to resolve\n        let lockQueue = this.keyLocks.get(key);\n        if (lockQueue == null) {\n            lockQueue = [];\n            this.keyLocks.set(key, lockQueue);\n        }\n        let resolveNewLock = () => { };\n        const newLock = new Promise((resolve) => {\n            resolveNewLock = resolve;\n            if (lockQueue != null) {\n                lockQueue.push(resolve);\n            }\n        });\n        // If we are the only request, resolve the lock immediately, queue remains at 1 item until request ends.\n        if (lockQueue.length === 1) {\n            resolveNewLock();\n        }\n        await newLock;\n        return lockQueue;\n    }\n    finishOperationOnKey(key, lockQueue) {\n        lockQueue.shift(); // Remove the current lock from the queue\n        if (lockQueue.length > 0) {\n            // If there are more locks waiting, resolve the next one\n            lockQueue[0]();\n        }\n    }\n    getProtocol(key) {\n        return { protocolID: [2, this.context], keyID: key };\n    }\n    async getOutputs(key, limit) {\n        const results = await this.wallet.listOutputs({\n            basket: this.context,\n            tags: [key],\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit\n        });\n        return results;\n    }\n    /**\n     * Retrieves the value associated with a given key.\n     *\n     * @param {string} key - The key to retrieve the value for.\n     * @param {string | undefined} [defaultValue=undefined] - The value to return if the key is not found.\n     * @returns {Promise<string | undefined>} A promise that resolves to the value as a string,\n     *   the defaultValue if the key is not found, or undefined if no defaultValue is provided.\n     * @throws {Error} If too many outputs are found for the key (ambiguous state).\n     * @throws {Error} If the found output's locking script cannot be decoded or represents an invalid token format.\n     */\n    async get(key, defaultValue = undefined) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const r = await this.lookupValue(key, defaultValue, 5);\n            return r.value;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n    getLockingScript(output, beef) {\n        const [txid, vout] = output.outpoint.split('.');\n        const tx = beef.findTxid(txid)?.tx;\n        if (tx == null) {\n            throw new Error(`beef must contain txid ${txid}`);\n        }\n        const lockingScript = tx.outputs[Number(vout)].lockingScript;\n        return lockingScript;\n    }\n    async lookupValue(key, defaultValue, limit) {\n        const lor = await this.getOutputs(key, limit);\n        const r = { value: defaultValue, outpoint: undefined, lor };\n        const { outputs } = lor;\n        if (outputs.length === 0) {\n            return r;\n        }\n        const output = outputs.slice(-1)[0];\n        r.outpoint = output.outpoint;\n        let field;\n        try {\n            if (lor.BEEF === undefined) {\n                throw new Error('entire transactions listOutputs option must return valid BEEF');\n            }\n            const lockingScript = this.getLockingScript(output, _transaction_Beef_js__WEBPACK_IMPORTED_MODULE_4__.Beef.fromBinary(lor.BEEF));\n            const decoded = _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(lockingScript);\n            if (decoded.fields.length < 1 || decoded.fields.length > 2) {\n                throw new Error('Invalid token.');\n            }\n            field = decoded.fields[0];\n        }\n        catch (_) {\n            throw new Error(`Invalid value found. You need to call set to collapse the corrupted state (or relinquish the corrupted ${outputs[0].outpoint} output from the ${this.context} basket) before you can get this value again.`);\n        }\n        if (!this.encrypt) {\n            r.value = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toUTF8(field);\n        }\n        else {\n            const { plaintext } = await this.wallet.decrypt({\n                ...this.getProtocol(key),\n                ciphertext: field\n            });\n            r.value = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toUTF8(plaintext);\n        }\n        return r;\n    }\n    getInputs(outputs) {\n        const inputs = [];\n        for (let i = 0; i < outputs.length; i++) {\n            inputs.push({\n                outpoint: outputs[i].outpoint,\n                unlockingScriptLength: 74,\n                inputDescription: 'Previous key-value token'\n            });\n        }\n        return inputs;\n    }\n    async getSpends(key, outputs, pushdrop, atomicBEEF) {\n        const p = this.getProtocol(key);\n        const tx = _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromAtomicBEEF(atomicBEEF);\n        const spends = {};\n        for (let i = 0; i < outputs.length; i++) {\n            const unlocker = pushdrop.unlock(p.protocolID, p.keyID, 'self');\n            const unlockingScript = await unlocker.sign(tx, i);\n            spends[i] = {\n                unlockingScript: unlockingScript.toHex()\n            };\n        }\n        return spends;\n    }\n    /**\n     * Sets or updates the value associated with a given key atomically.\n     * If the key already exists (one or more outputs found), it spends the existing output(s)\n     * and creates a new one with the updated value. If multiple outputs exist for the key,\n     * they are collapsed into a single new output.\n     * If the key does not exist, it creates a new output.\n     * Handles encryption if enabled.\n     * If signing the update/collapse transaction fails, it relinquishes the original outputs and starts over with a new chain.\n     * Ensures atomicity by locking the key during the operation, preventing concurrent updates\n     * to the same key from missing earlier changes.\n     *\n     * @param {string} key - The key to set or update.\n     * @param {string} value - The value to associate with the key.\n     * @returns {Promise<OutpointString>} A promise that resolves to the outpoint string (txid.vout) of the new or updated token output.\n     */\n    async set(key, value) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const current = await this.lookupValue(key, undefined, 10);\n            if (current.value === value) {\n                if (current.outpoint === undefined) {\n                    throw new Error('outpoint must be valid when value is valid and unchanged');\n                }\n                // Don't create a new transaction if the value doesn't need to change\n                return current.outpoint;\n            }\n            const protocol = this.getProtocol(key);\n            let valueAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray(value, 'utf8');\n            if (this.encrypt) {\n                const { ciphertext } = await this.wallet.encrypt({\n                    ...protocol,\n                    plaintext: valueAsArray\n                });\n                valueAsArray = ciphertext;\n            }\n            const pushdrop = new _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.wallet, this.originator);\n            const lockingScript = await pushdrop.lock([valueAsArray], protocol.protocolID, protocol.keyID, 'self');\n            const { outputs, BEEF: inputBEEF } = current.lor;\n            let outpoint;\n            try {\n                const inputs = this.getInputs(outputs);\n                const { txid, signableTransaction } = await this.wallet.createAction({\n                    description: `Update ${key} in ${this.context}`,\n                    inputBEEF,\n                    inputs,\n                    outputs: [{\n                            basket: this.context,\n                            tags: [key],\n                            lockingScript: lockingScript.toHex(),\n                            satoshis: 1,\n                            outputDescription: 'Key-value token'\n                        }],\n                    options: {\n                        acceptDelayedBroadcast: this.acceptDelayedBroadcast,\n                        randomizeOutputs: false\n                    }\n                });\n                if (outputs.length > 0 && typeof signableTransaction !== 'object') {\n                    throw new Error('Wallet did not return a signable transaction when expected.');\n                }\n                if (signableTransaction == null) {\n                    outpoint = `${txid}.0`;\n                }\n                else {\n                    const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);\n                    const { txid } = await this.wallet.signAction({\n                        reference: signableTransaction.reference,\n                        spends\n                    });\n                    outpoint = `${txid}.0`;\n                }\n            }\n            catch (_) {\n                throw new Error(`There are ${outputs.length} outputs with tag ${key} that cannot be unlocked.`);\n            }\n            return outpoint;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n    /**\n     * Removes the key-value pair associated with the given key.\n     * It finds the existing output(s) for the key and spends them without creating a new output.\n     * If multiple outputs exist, they are all spent in the same transaction.\n     * If the key does not exist, it does nothing.\n     * If signing the removal transaction fails, it relinquishes the original outputs instead of spending.\n     *\n     * @param {string} key - The key to remove.\n     * @returns {Promise<string[]>} A promise that resolves to the txids of the removal transactions if successful.\n     */\n    async remove(key) {\n        const lockQueue = await this.queueOperationOnKey(key);\n        try {\n            const txids = [];\n            for (;;) {\n                const { outputs, BEEF: inputBEEF, totalOutputs } = await this.getOutputs(key);\n                if (outputs.length > 0) {\n                    const pushdrop = new _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.wallet, this.originator);\n                    try {\n                        const inputs = this.getInputs(outputs);\n                        const { signableTransaction } = await this.wallet.createAction({\n                            description: `Remove ${key} in ${this.context}`,\n                            inputBEEF,\n                            inputs,\n                            options: {\n                                acceptDelayedBroadcast: this.acceptDelayedBroadcast\n                            }\n                        });\n                        if (typeof signableTransaction !== 'object') {\n                            throw new Error('Wallet did not return a signable transaction when expected.');\n                        }\n                        const spends = await this.getSpends(key, outputs, pushdrop, signableTransaction.tx);\n                        const { txid } = await this.wallet.signAction({\n                            reference: signableTransaction.reference,\n                            spends\n                        });\n                        if (txid === undefined) {\n                            throw new Error('signAction must return a valid txid');\n                        }\n                        txids.push(txid);\n                    }\n                    catch (_) {\n                        throw new Error(`There are ${totalOutputs} outputs with tag ${key} that cannot be unlocked.`);\n                    }\n                }\n                if (outputs.length === totalOutputs) {\n                    break;\n                }\n            }\n            return txids;\n        }\n        finally {\n            this.finishOperationOnKey(key, lockQueue);\n        }\n    }\n}\n//# sourceMappingURL=LocalKVStore.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/kvstore/LocalKVStore.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/kvstore/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/kvstore/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LocalKVStore: () => (/* reexport safe */ _LocalKVStore_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _LocalKVStore_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LocalKVStore.js */ \"./node_modules/@bsv/sdk/dist/esm/src/kvstore/LocalKVStore.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/kvstore/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/messages/EncryptedMessage.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/messages/EncryptedMessage.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decrypt: () => (/* binding */ decrypt),\n/* harmony export */   encrypt: () => (/* binding */ encrypt)\n/* harmony export */ });\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\nconst VERSION = '42421033';\n/**\n * Encrypts a message from one party to another using the BRC-78 message encryption protocol.\n * @param message The message to encrypt\n * @param sender The private key of the sender\n * @param recipient The public key of the recipient\n *\n * @returns The encrypted message\n */\nconst encrypt = (message, sender, recipient) => {\n    const keyID = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32);\n    const keyIDBase64 = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase64)(keyID);\n    const invoiceNumber = `2-message encryption-${keyIDBase64}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](sharedSecret.encode(true).slice(1));\n    const encrypted = symmetricKey.encrypt(message);\n    const senderPublicKey = sender.toPublicKey().encode(true);\n    const version = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(VERSION, 'hex');\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...recipient.encode(true),\n        ...keyID,\n        ...encrypted\n    ];\n};\n/**\n * Decrypts a message from one party to another using the BRC-78 message encryption protocol.\n * @param message The message to decrypt\n * @param sender The private key of the recipient\n *\n * @returns The decrypted message\n */\nconst decrypt = (message, recipient) => {\n    const reader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.Reader(message);\n    const messageVersion = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const sender = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromString((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(reader.read(33)));\n    const expectedRecipientDER = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(reader.read(33));\n    const actualRecipientDER = recipient\n        .toPublicKey()\n        .encode(true, 'hex');\n    if (expectedRecipientDER !== actualRecipientDER) {\n        throw new Error(`The encrypted message expects a recipient public key of ${expectedRecipientDER}, but the provided key is ${actualRecipientDER}`);\n    }\n    const keyID = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase64)(reader.read(32));\n    const encrypted = reader.read(reader.bin.length - reader.pos);\n    const invoiceNumber = `2-message encryption-${keyID}`;\n    const signingPriv = sender.deriveChild(recipient, invoiceNumber);\n    const recipientPub = recipient.deriveChild(sender, invoiceNumber);\n    const sharedSecret = signingPriv.deriveSharedSecret(recipientPub);\n    const symmetricKey = new _primitives_SymmetricKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](sharedSecret.encode(true).slice(1));\n    return symmetricKey.decrypt(encrypted);\n};\n//# sourceMappingURL=EncryptedMessage.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/messages/EncryptedMessage.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/messages/SignedMessage.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/messages/SignedMessage.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _primitives_Signature_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n/* harmony import */ var _primitives_Curve_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n// @ts-nocheck\n\n\n\n\n\n\nconst VERSION = '42423301';\n/**\n * Signs a message from one party to be verified by another, or for verification by anyone, using the BRC-77 message signing protocol.\n * @param message The message to sign\n * @param signer The private key of the message signer\n * @param [verifier] The public key of the person who can verify the message. If not provided, anyone will be able to verify the message signature.\n *\n * @returns The message signature.\n */\nconst sign = (message, signer, verifier) => {\n    const recipientAnyone = typeof verifier !== 'object';\n    if (recipientAnyone) {\n        const curve = new _primitives_Curve_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n        const anyone = new _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1);\n        const anyonePoint = curve.g.mul(anyone);\n        verifier = new _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](anyonePoint.x, anyonePoint.y);\n    }\n    const keyID = (0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(32);\n    const keyIDBase64 = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toBase64)(keyID);\n    const invoiceNumber = `2-message signing-${keyIDBase64}`;\n    const signingKey = signer.deriveChild(verifier, invoiceNumber);\n    const signature = signingKey.sign(message).toDER();\n    const senderPublicKey = signer.toPublicKey().encode(true);\n    const version = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toArray)(VERSION, 'hex');\n    return [\n        ...version,\n        ...senderPublicKey,\n        ...(recipientAnyone ? [0] : verifier.encode(true)),\n        ...keyID,\n        ...signature\n    ];\n};\n/**\n * Verifies a message using the BRC-77 message signing protocol.\n * @param message The message to verify.\n * @param sig The message signature to be verified.\n * @param [recipient] The private key of the message verifier. This can be omitted if the message is verifiable by anyone.\n *\n * @returns True if the message is verified.\n */\nconst verify = (message, sig, recipient) => {\n    const reader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.Reader(sig);\n    const messageVersion = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(reader.read(4));\n    if (messageVersion !== VERSION) {\n        throw new Error(`Message version mismatch: Expected ${VERSION}, received ${messageVersion}`);\n    }\n    const signer = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromString((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(reader.read(33)));\n    const [verifierFirst] = reader.read(1);\n    if (verifierFirst === 0) {\n        recipient = new _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1);\n    }\n    else {\n        const verifierRest = reader.read(32);\n        const verifierDER = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)([verifierFirst, ...verifierRest]);\n        if (typeof recipient !== 'object') {\n            throw new Error(`This signature can only be verified with knowledge of a specific private key. The associated public key is: ${verifierDER}`);\n        }\n        const recipientDER = recipient.toPublicKey().encode(true, 'hex');\n        if (verifierDER !== recipientDER) {\n            throw new Error(`The recipient public key is ${recipientDER} but the signature requres the recipient to have public key ${verifierDER}`);\n        }\n    }\n    const keyID = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toBase64)(reader.read(32));\n    const signatureDER = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_5__.toHex)(reader.read(reader.bin.length - reader.pos));\n    const signature = _primitives_Signature_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromDER(signatureDER, 'hex');\n    const invoiceNumber = `2-message signing-${keyID}`;\n    const signingKey = signer.deriveChild(recipient, invoiceNumber);\n    const verified = signingKey.verify(message, signature);\n    return verified;\n};\n//# sourceMappingURL=SignedMessage.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/messages/SignedMessage.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/messages/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/messages/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EncryptedMessage: () => (/* reexport module object */ _EncryptedMessage_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   SignedMessage: () => (/* reexport module object */ _SignedMessage_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _SignedMessage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SignedMessage.js */ \"./node_modules/@bsv/sdk/dist/esm/src/messages/SignedMessage.js\");\n/* harmony import */ var _EncryptedMessage_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EncryptedMessage.js */ \"./node_modules/@bsv/sdk/dist/esm/src/messages/EncryptedMessage.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/messages/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/LookupResolver.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/LookupResolver.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SLAP_TRACKERS: () => (/* binding */ DEFAULT_SLAP_TRACKERS),\n/* harmony export */   DEFAULT_TESTNET_SLAP_TRACKERS: () => (/* binding */ DEFAULT_TESTNET_SLAP_TRACKERS),\n/* harmony export */   HTTPSOverlayLookupFacilitator: () => (/* binding */ HTTPSOverlayLookupFacilitator),\n/* harmony export */   \"default\": () => (/* binding */ LookupResolver)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js\");\n/* harmony import */ var _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js\");\n\n\n/** Default SLAP trackers */\nconst DEFAULT_SLAP_TRACKERS = [\n    // BSVA clusters\n    'https://overlay-us-1.bsvb.tech',\n    'https://overlay-eu-1.bsvb.tech',\n    'https://overlay-ap-1.bsvb.tech',\n    // Babbage primary overlay service\n    'https://users.bapp.dev'\n    // NOTE: Other entities may submit pull requests to the library if they maintain SLAP overlay services.\n    // Additional trackers run by different entities contribute to greater network resiliency.\n    // It also generally doesn't hurt to have more trackers in this list.\n    // DISCLAIMER:\n    // Trackers known to host invalid or illegal records will be removed at the discretion of the BSV Association.\n];\n/** Default testnet SLAP trackers */\nconst DEFAULT_TESTNET_SLAP_TRACKERS = [\n    // Babbage primary testnet overlay service\n    'https://testnet-users.bapp.dev'\n];\nconst MAX_TRACKER_WAIT_TIME = 5000;\nclass HTTPSOverlayLookupFacilitator {\n    fetchClient;\n    allowHTTP;\n    constructor(httpClient = fetch, allowHTTP = false) {\n        this.fetchClient = httpClient;\n        this.allowHTTP = allowHTTP;\n    }\n    async lookup(url, question, timeout = 5000) {\n        if (!url.startsWith('https:') && !this.allowHTTP) {\n            throw new Error('HTTPS facilitator can only use URLs that start with \"https:\"');\n        }\n        const timeoutPromise = new Promise((resolve, reject) => setTimeout(() => reject(new Error('Request timed out')), timeout));\n        const fetchPromise = fetch(`${url}/lookup`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                service: question.service,\n                query: question.query\n            })\n        });\n        const response = (await Promise.race([\n            fetchPromise,\n            timeoutPromise\n        ]));\n        if (response.ok) {\n            return await response.json();\n        }\n        else {\n            throw new Error('Failed to facilitate lookup');\n        }\n    }\n}\n/**\n * Represents an SHIP transaction broadcaster.\n */\nclass LookupResolver {\n    facilitator;\n    slapTrackers;\n    hostOverrides;\n    additionalHosts;\n    networkPreset;\n    constructor(config = {}) {\n        this.networkPreset = config.networkPreset ?? 'mainnet';\n        this.facilitator = config.facilitator ?? new HTTPSOverlayLookupFacilitator(undefined, this.networkPreset === 'local');\n        this.slapTrackers = config.slapTrackers ?? (this.networkPreset === 'mainnet' ? DEFAULT_SLAP_TRACKERS : DEFAULT_TESTNET_SLAP_TRACKERS);\n        this.hostOverrides = config.hostOverrides ?? {};\n        this.additionalHosts = config.additionalHosts ?? {};\n    }\n    /**\n     * Given a LookupQuestion, returns a LookupAnswer. Aggregates across multiple services and supports resiliency.\n     */\n    async query(question, timeout) {\n        let competentHosts = [];\n        if (question.service === 'ls_slap') {\n            competentHosts = this.networkPreset === 'local' ? ['http://localhost:8080'] : this.slapTrackers;\n        }\n        else if (this.hostOverrides[question.service] != null) {\n            competentHosts = this.hostOverrides[question.service];\n        }\n        else if (this.networkPreset === 'local') {\n            competentHosts = ['http://localhost:8080'];\n        }\n        else {\n            competentHosts = await this.findCompetentHosts(question.service);\n        }\n        if (this.additionalHosts[question.service]?.length > 0) {\n            competentHosts = [\n                ...competentHosts,\n                ...this.additionalHosts[question.service]\n            ];\n        }\n        if (competentHosts.length < 1) {\n            throw new Error(`No competent ${this.networkPreset} hosts found by the SLAP trackers for lookup service: ${question.service}`);\n        }\n        // Use Promise.allSettled to handle individual host failures\n        const hostResponses = await Promise.allSettled(competentHosts.map(async (host) => await this.facilitator.lookup(host, question, timeout)));\n        const successfulResponses = hostResponses\n            .filter((result) => result.status === 'fulfilled')\n            .map((result) => result.value);\n        if (successfulResponses.length === 0) {\n            throw new Error('No successful responses from any hosts');\n        }\n        // Process the successful responses\n        // Aggregate outputs from all successful responses\n        const outputs = new Map();\n        for (const response of successfulResponses) {\n            if (response.type !== 'output-list') {\n                continue;\n            }\n            try {\n                for (const output of response.outputs) {\n                    try {\n                        const txId = _transaction_index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.fromBEEF(output.beef).id('hex'); // !! This is STUPIDLY inefficient.\n                        const key = `${txId}.${output.outputIndex}`;\n                        outputs.set(key, output);\n                    }\n                    catch {\n                        continue;\n                    }\n                }\n            }\n            catch (_) {\n                // Error processing output, proceed.\n            }\n        }\n        return {\n            type: 'output-list',\n            outputs: Array.from(outputs.values())\n        };\n    }\n    /**\n     * Returns a list of competent hosts for a given lookup service.\n     * @param service Service for which competent hosts are to be returned\n     * @returns Array of hosts competent for resolving queries\n     */\n    async findCompetentHosts(service) {\n        const query = {\n            service: 'ls_slap',\n            query: {\n                service\n            }\n        };\n        // Use Promise.allSettled to handle individual SLAP tracker failures\n        const trackerResponses = await Promise.allSettled(this.slapTrackers.map(async (tracker) => await this.facilitator.lookup(tracker, query, MAX_TRACKER_WAIT_TIME)));\n        const hosts = new Set();\n        for (const result of trackerResponses) {\n            if (result.status === 'fulfilled') {\n                const answer = result.value;\n                if (answer.type !== 'output-list') {\n                    // Log invalid response and continue\n                    continue;\n                }\n                for (const output of answer.outputs) {\n                    try {\n                        const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.fromBEEF(output.beef);\n                        const script = tx.outputs[output.outputIndex].lockingScript;\n                        const parsed = _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].decode(script);\n                        if (parsed.topicOrService !== service ||\n                            parsed.protocol !== 'SLAP') {\n                            // Invalid advertisement, skip\n                            continue;\n                        }\n                        hosts.add(parsed.domain);\n                    }\n                    catch {\n                        // Invalid output, skip\n                        continue;\n                    }\n                }\n            }\n            else {\n                // Log tracker failure and continue\n                continue;\n            }\n        }\n        return [...hosts];\n    }\n}\n//# sourceMappingURL=LookupResolver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/LookupResolver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OverlayAdminTokenTemplate)\n/* harmony export */ });\n/* harmony import */ var _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n\n/**\n * Script template enabling the creation, unlocking, and decoding of SHIP and SLAP advertisements.\n */\nclass OverlayAdminTokenTemplate {\n    pushDrop;\n    /**\n     * Decodes a SHIP or SLAP advertisement from a given locking script.\n     * @param script Locking script comprising a SHIP or SLAP token to decode\n     * @returns Decoded SHIP or SLAP advertisement\n     */\n    static decode(script) {\n        const result = _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].decode(script);\n        if (result.fields.length < 4) {\n            throw new Error('Invalid SHIP/SLAP advertisement!');\n        }\n        const protocol = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(result.fields[0]);\n        if (protocol !== 'SHIP' && protocol !== 'SLAP') {\n            throw new Error('Invalid protocol type!');\n        }\n        const identityKey = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toHex(result.fields[1]);\n        const domain = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(result.fields[2]);\n        const topicOrService = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(result.fields[3]);\n        return {\n            protocol,\n            identityKey,\n            domain,\n            topicOrService\n        };\n    }\n    /**\n     * Constructs a new Overlay Admin template instance\n     * @param wallet Wallet to use for locking and unlocking\n     */\n    constructor(wallet) {\n        this.pushDrop = new _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wallet);\n    }\n    /**\n     * Creates a new advertisement locking script\n     * @param protocol SHIP or SLAP\n     * @param domain Domain where the topic or service is available\n     * @param topicOrService Topic or service to advertise\n     * @returns Locking script comprising the advertisement token\n     */\n    async lock(protocol, domain, topicOrService) {\n        const { publicKey: identityKey } = await this.pushDrop.wallet.getPublicKey({\n            identityKey: true\n        });\n        return await this.pushDrop.lock([\n            _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(protocol, 'utf8'),\n            _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(identityKey, 'hex'),\n            _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(domain, 'utf8'),\n            _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(topicOrService, 'utf8')\n        ], [\n            2,\n            protocol === 'SHIP'\n                ? 'Service Host Interconnect'\n                : 'Service Lookup Availability'\n        ], '1', 'self');\n    }\n    /**\n     * Unlocks an advertisement token as part of a transaction.\n     * @param protocol SHIP or SLAP, depending on the token to unlock\n     * @returns Script unlocker capable of unlocking the advertisement token\n     */\n    unlock(protocol) {\n        return this.pushDrop.unlock([\n            2,\n            protocol === 'SHIP'\n                ? 'Service Host Interconnect'\n                : 'Service Lookup Availability'\n        ], '1', 'self');\n    }\n}\n//# sourceMappingURL=OverlayAdminTokenTemplate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/SHIPBroadcaster.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/SHIPBroadcaster.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTPSOverlayBroadcastFacilitator: () => (/* binding */ HTTPSOverlayBroadcastFacilitator),\n/* harmony export */   \"default\": () => (/* binding */ TopicBroadcaster)\n/* harmony export */ });\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _LookupResolver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LookupResolver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/LookupResolver.js\");\n/* harmony import */ var _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js\");\n\n\n\n\nconst MAX_SHIP_QUERY_TIMEOUT = 5000;\nclass HTTPSOverlayBroadcastFacilitator {\n    httpClient;\n    allowHTTP;\n    constructor(httpClient = fetch, allowHTTP = false) {\n        this.httpClient = httpClient;\n        this.allowHTTP = allowHTTP;\n    }\n    async send(url, taggedBEEF) {\n        if (!url.startsWith('https:') && !this.allowHTTP) {\n            throw new Error('HTTPS facilitator can only use URLs that start with \"https:\"');\n        }\n        const headers = {\n            'Content-Type': 'application/octet-stream',\n            'X-Topics': JSON.stringify(taggedBEEF.topics)\n        };\n        let body;\n        if (Array.isArray(taggedBEEF.offChainValues)) {\n            headers['x-includes-off-chain-values'] = 'true';\n            const w = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n            w.writeVarIntNum(taggedBEEF.beef.length);\n            w.write(taggedBEEF.beef);\n            w.write(taggedBEEF.offChainValues);\n            body = new Uint8Array(w.toArray());\n        }\n        else {\n            body = new Uint8Array(taggedBEEF.beef);\n        }\n        const response = await fetch(`${url}/submit`, {\n            method: 'POST',\n            headers,\n            body\n        });\n        if (response.ok) {\n            return await response.json();\n        }\n        else {\n            throw new Error('Failed to facilitate broadcast');\n        }\n    }\n}\n/**\n * Broadcasts transactions to one or more overlay topics.\n */\nclass TopicBroadcaster {\n    topics;\n    facilitator;\n    resolver;\n    requireAcknowledgmentFromAllHostsForTopics;\n    requireAcknowledgmentFromAnyHostForTopics;\n    requireAcknowledgmentFromSpecificHostsForTopics;\n    networkPreset;\n    /**\n     * Constructs an instance of the SHIP broadcaster.\n     *\n     * @param {string[]} topics - The list of SHIP topic names where transactions are to be sent.\n     * @param {SHIPBroadcasterConfig} config - Configuration options for the SHIP broadcaster.\n     */\n    constructor(topics, config = {}) {\n        if (topics.length === 0) {\n            throw new Error('At least one topic is required for broadcast.');\n        }\n        if (topics.some((x) => !x.startsWith('tm_'))) {\n            throw new Error('Every topic must start with \"tm_\".');\n        }\n        this.topics = topics;\n        this.networkPreset = config.networkPreset ?? 'mainnet';\n        this.facilitator = config.facilitator ?? new HTTPSOverlayBroadcastFacilitator(undefined, this.networkPreset === 'local');\n        this.resolver = config.resolver ?? new _LookupResolver_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]({ networkPreset: this.networkPreset });\n        this.requireAcknowledgmentFromAllHostsForTopics =\n            config.requireAcknowledgmentFromAllHostsForTopics ?? [];\n        this.requireAcknowledgmentFromAnyHostForTopics =\n            config.requireAcknowledgmentFromAnyHostForTopics ?? 'all';\n        this.requireAcknowledgmentFromSpecificHostsForTopics =\n            config.requireAcknowledgmentFromSpecificHostsForTopics ?? {};\n    }\n    /**\n     * Broadcasts a transaction to Overlay Services via SHIP.\n     *\n     * @param {Transaction} tx - The transaction to be sent.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        let beef;\n        const offChainValues = tx.metadata.get('OffChainValues');\n        try {\n            beef = tx.toBEEF();\n        }\n        catch (error) {\n            throw new Error('Transactions sent via SHIP to Overlay Services must be serializable to BEEF format.');\n        }\n        const interestedHosts = await this.findInterestedHosts();\n        if (Object.keys(interestedHosts).length === 0) {\n            return {\n                status: 'error',\n                code: 'ERR_NO_HOSTS_INTERESTED',\n                description: `No ${this.networkPreset} hosts are interested in receiving this transaction.`\n            };\n        }\n        const hostPromises = Object.entries(interestedHosts).map(async ([host, topics]) => {\n            try {\n                const steak = await this.facilitator.send(host, {\n                    beef,\n                    offChainValues,\n                    topics: [...topics]\n                });\n                if (steak == null || Object.keys(steak).length === 0) {\n                    throw new Error('Steak has no topics.');\n                }\n                return { host, success: true, steak };\n            }\n            catch (error) {\n                console.error(error);\n                // Log error if needed\n                return { host, success: false, error };\n            }\n        });\n        const results = await Promise.all(hostPromises);\n        const successfulHosts = results.filter((result) => result.success);\n        if (successfulHosts.length === 0) {\n            return {\n                status: 'error',\n                code: 'ERR_ALL_HOSTS_REJECTED',\n                description: `All ${this.networkPreset} topical hosts have rejected the transaction.`\n            };\n        }\n        // Collect host acknowledgments\n        const hostAcknowledgments = {};\n        for (const result of successfulHosts) {\n            const host = result.host;\n            const steak = result.steak;\n            const acknowledgedTopics = new Set();\n            for (const [topic, instructions] of Object.entries(steak)) {\n                const outputsToAdmit = instructions.outputsToAdmit;\n                const coinsToRetain = instructions.coinsToRetain;\n                const coinsRemoved = instructions.coinsRemoved;\n                if (outputsToAdmit?.length > 0 ||\n                    coinsToRetain?.length > 0 ||\n                    coinsRemoved?.length > 0) {\n                    acknowledgedTopics.add(topic);\n                }\n            }\n            hostAcknowledgments[host] = acknowledgedTopics;\n        }\n        // Now, perform the checks\n        // Check requireAcknowledgmentFromAllHostsForTopics\n        let requiredTopicsAllHosts;\n        let requireAllHosts;\n        if (this.requireAcknowledgmentFromAllHostsForTopics === 'all') {\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'all';\n        }\n        else if (this.requireAcknowledgmentFromAllHostsForTopics === 'any') {\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'any';\n        }\n        else if (Array.isArray(this.requireAcknowledgmentFromAllHostsForTopics)) {\n            requiredTopicsAllHosts = this.requireAcknowledgmentFromAllHostsForTopics;\n            requireAllHosts = 'all';\n        }\n        else {\n            // Default to 'all' and 'all'\n            requiredTopicsAllHosts = this.topics;\n            requireAllHosts = 'all';\n        }\n        if (requiredTopicsAllHosts.length > 0) {\n            const allHostsAcknowledged = this.checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopicsAllHosts, requireAllHosts);\n            if (!allHostsAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_ALL_HOSTS_FAILED',\n                    description: 'Not all hosts acknowledged the required topics.'\n                };\n            }\n        }\n        // Check requireAcknowledgmentFromAnyHostForTopics\n        let requiredTopicsAnyHost;\n        let requireAnyHost;\n        if (this.requireAcknowledgmentFromAnyHostForTopics === 'all') {\n            requiredTopicsAnyHost = this.topics;\n            requireAnyHost = 'all';\n        }\n        else if (this.requireAcknowledgmentFromAnyHostForTopics === 'any') {\n            requiredTopicsAnyHost = this.topics;\n            requireAnyHost = 'any';\n        }\n        else if (Array.isArray(this.requireAcknowledgmentFromAnyHostForTopics)) {\n            requiredTopicsAnyHost = this.requireAcknowledgmentFromAnyHostForTopics;\n            requireAnyHost = 'all';\n        }\n        else {\n            // No requirement\n            requiredTopicsAnyHost = [];\n            requireAnyHost = 'all';\n        }\n        if (requiredTopicsAnyHost.length > 0) {\n            const anyHostAcknowledged = this.checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopicsAnyHost, requireAnyHost);\n            if (!anyHostAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_ANY_HOST_FAILED',\n                    description: 'No host acknowledged the required topics.'\n                };\n            }\n        }\n        // Check requireAcknowledgmentFromSpecificHostsForTopics\n        if (Object.keys(this.requireAcknowledgmentFromSpecificHostsForTopics).length >\n            0) {\n            const specificHostsAcknowledged = this.checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, this.requireAcknowledgmentFromSpecificHostsForTopics);\n            if (!specificHostsAcknowledged) {\n                return {\n                    status: 'error',\n                    code: 'ERR_REQUIRE_ACK_FROM_SPECIFIC_HOSTS_FAILED',\n                    description: 'Specific hosts did not acknowledge the required topics.'\n                };\n            }\n        }\n        // If all checks pass, return success\n        return {\n            status: 'success',\n            txid: tx.id('hex'),\n            message: `Sent to ${successfulHosts.length} Overlay Services ${successfulHosts.length === 1 ? 'host' : 'hosts'}.`\n        };\n    }\n    checkAcknowledgmentFromAllHosts(hostAcknowledgments, requiredTopics, require) {\n        for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n            if (require === 'all') {\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        return false;\n                    }\n                }\n            }\n            else if (require === 'any') {\n                let anyAcknowledged = false;\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        anyAcknowledged = true;\n                        break;\n                    }\n                }\n                if (!anyAcknowledged) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    checkAcknowledgmentFromAnyHost(hostAcknowledgments, requiredTopics, require) {\n        if (require === 'all') {\n            // All required topics must be acknowledged by at least one host\n            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n                let acknowledgesAllRequiredTopics = true;\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        acknowledgesAllRequiredTopics = false;\n                        break;\n                    }\n                }\n                if (acknowledgesAllRequiredTopics) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        else {\n            // At least one required topic must be acknowledged by at least one host\n            for (const acknowledgedTopics of Object.values(hostAcknowledgments)) {\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n    checkAcknowledgmentFromSpecificHosts(hostAcknowledgments, requirements) {\n        for (const [host, requiredTopicsOrAllAny] of Object.entries(requirements)) {\n            const acknowledgedTopics = hostAcknowledgments[host];\n            if (acknowledgedTopics == null) {\n                // Host did not respond successfully\n                return false;\n            }\n            let requiredTopics;\n            let require;\n            if (requiredTopicsOrAllAny === 'all' ||\n                requiredTopicsOrAllAny === 'any') {\n                require = requiredTopicsOrAllAny;\n                requiredTopics = this.topics;\n            }\n            else if (Array.isArray(requiredTopicsOrAllAny)) {\n                requiredTopics = requiredTopicsOrAllAny;\n                require = 'all';\n            }\n            else {\n                // Invalid configuration\n                continue;\n            }\n            if (require === 'all') {\n                for (const topic of requiredTopics) {\n                    if (!acknowledgedTopics.has(topic)) {\n                        return false;\n                    }\n                }\n            }\n            else if (require === 'any') {\n                let anyAcknowledged = false;\n                for (const topic of requiredTopics) {\n                    if (acknowledgedTopics.has(topic)) {\n                        anyAcknowledged = true;\n                        break;\n                    }\n                }\n                if (!anyAcknowledged) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * Finds which hosts are interested in transactions tagged with the given set of topics.\n     *\n     * @returns A mapping of URLs for hosts interested in this transaction. Keys are URLs, values are which of our topics the specific host cares about.\n     */\n    async findInterestedHosts() {\n        // Handle the local network preset\n        if (this.networkPreset === 'local') {\n            const resultSet = new Set();\n            for (let i = 0; i < this.topics.length; i++) {\n                resultSet.add(this.topics[i]);\n            }\n            return { 'http://localhost:8080': resultSet };\n        }\n        // TODO: cache the list of interested hosts to avoid spamming SHIP trackers.\n        // TODO: Monetize the operation of the SHIP tracker system.\n        // TODO: Cache ship/slap lookup with expiry (every 5min)\n        // Find all SHIP advertisements for the topics we care about\n        const results = {};\n        const answer = await this.resolver.query({\n            service: 'ls_ship',\n            query: {\n                topics: this.topics\n            }\n        }, MAX_SHIP_QUERY_TIMEOUT);\n        if (answer.type !== 'output-list') {\n            throw new Error('SHIP answer is not an output list.');\n        }\n        for (const output of answer.outputs) {\n            try {\n                const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.fromBEEF(output.beef);\n                const script = tx.outputs[output.outputIndex].lockingScript;\n                const parsed = _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].decode(script);\n                if (!this.topics.includes(parsed.topicOrService) ||\n                    parsed.protocol !== 'SHIP') {\n                    // This should make us think a LOT less highly of this SHIP tracker if it ever happens...\n                    continue;\n                }\n                if (results[parsed.domain] === undefined) {\n                    results[parsed.domain] = new Set();\n                }\n                results[parsed.domain].add(parsed.topicOrService);\n            }\n            catch (e) {\n                continue;\n            }\n        }\n        return results;\n    }\n}\n//# sourceMappingURL=SHIPBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/SHIPBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_SLAP_TRACKERS: () => (/* reexport safe */ _LookupResolver_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_SLAP_TRACKERS),\n/* harmony export */   DEFAULT_TESTNET_SLAP_TRACKERS: () => (/* reexport safe */ _LookupResolver_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_TESTNET_SLAP_TRACKERS),\n/* harmony export */   HTTPSOverlayBroadcastFacilitator: () => (/* reexport safe */ _SHIPBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__.HTTPSOverlayBroadcastFacilitator),\n/* harmony export */   HTTPSOverlayLookupFacilitator: () => (/* reexport safe */ _LookupResolver_js__WEBPACK_IMPORTED_MODULE_0__.HTTPSOverlayLookupFacilitator),\n/* harmony export */   LookupResolver: () => (/* reexport safe */ _LookupResolver_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   OverlayAdminTokenTemplate: () => (/* reexport safe */ _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   SHIPBroadcaster: () => (/* reexport safe */ _SHIPBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   SHIPCast: () => (/* reexport safe */ _SHIPBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   TopicBroadcaster: () => (/* reexport safe */ _SHIPBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _LookupResolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LookupResolver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/LookupResolver.js\");\n/* harmony import */ var _SHIPBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SHIPBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/SHIPBroadcaster.js\");\n/* harmony import */ var _OverlayAdminTokenTemplate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OverlayAdminTokenTemplate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/OverlayAdminTokenTemplate.js\");\n\n\n\n\n// For intuitive clarity, we name this the Topic Broadcaster.\n\n// Historically, it was also known by two other names:\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/AESGCM.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/AESGCM.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AES: () => (/* binding */ AES),\n/* harmony export */   AESGCM: () => (/* binding */ AESGCM),\n/* harmony export */   AESGCMDecrypt: () => (/* binding */ AESGCMDecrypt),\n/* harmony export */   checkBit: () => (/* binding */ checkBit),\n/* harmony export */   exclusiveOR: () => (/* binding */ exclusiveOR),\n/* harmony export */   getBytes: () => (/* binding */ getBytes),\n/* harmony export */   ghash: () => (/* binding */ ghash),\n/* harmony export */   incrementLeastSignificantThirtyTwoBits: () => (/* binding */ incrementLeastSignificantThirtyTwoBits),\n/* harmony export */   multiply: () => (/* binding */ multiply),\n/* harmony export */   rightShift: () => (/* binding */ rightShift)\n/* harmony export */ });\n// @ts-nocheck\nconst SBox = new Uint8Array([\n    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,\n    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,\n    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,\n    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,\n    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,\n    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,\n    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,\n    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,\n    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,\n    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,\n    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,\n    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,\n    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,\n    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,\n    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,\n    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16\n]);\nconst Rcon = [\n    [0x00, 0x00, 0x00, 0x00], [0x01, 0x00, 0x00, 0x00], [0x02, 0x00, 0x00, 0x00], [0x04, 0x00, 0x00, 0x00],\n    [0x08, 0x00, 0x00, 0x00], [0x10, 0x00, 0x00, 0x00], [0x20, 0x00, 0x00, 0x00], [0x40, 0x00, 0x00, 0x00],\n    [0x80, 0x00, 0x00, 0x00], [0x1b, 0x00, 0x00, 0x00], [0x36, 0x00, 0x00, 0x00]\n].map(v => new Uint8Array(v));\nconst mul2 = new Uint8Array(256);\nconst mul3 = new Uint8Array(256);\nfor (let i = 0; i < 256; i++) {\n    const m2 = ((i << 1) ^ ((i & 0x80) !== 0 ? 0x1b : 0)) & 0xff;\n    mul2[i] = m2;\n    mul3[i] = m2 ^ i;\n}\nfunction addRoundKey(state, roundKeyArray, offset) {\n    for (let c = 0; c < 4; c++) {\n        const keyCol = roundKeyArray[offset + c];\n        for (let r = 0; r < 4; r++) {\n            state[r][c] ^= keyCol[r];\n        }\n    }\n}\nfunction subBytes(state) {\n    for (let r = 0; r < 4; r++) {\n        for (let c = 0; c < 4; c++) {\n            state[r][c] = SBox[state[r][c]];\n        }\n    }\n}\nfunction subWord(value) {\n    for (let i = 0; i < 4; i++) {\n        value[i] = SBox[value[i]];\n    }\n}\nfunction rotWord(value) {\n    const temp = value[0];\n    value[0] = value[1];\n    value[1] = value[2];\n    value[2] = value[3];\n    value[3] = temp;\n}\nfunction shiftRows(state) {\n    let tmp = state[1][0];\n    state[1][0] = state[1][1];\n    state[1][1] = state[1][2];\n    state[1][2] = state[1][3];\n    state[1][3] = tmp;\n    tmp = state[2][0];\n    const tmp2 = state[2][1];\n    state[2][0] = state[2][2];\n    state[2][1] = state[2][3];\n    state[2][2] = tmp;\n    state[2][3] = tmp2;\n    tmp = state[3][3];\n    state[3][3] = state[3][2];\n    state[3][2] = state[3][1];\n    state[3][1] = state[3][0];\n    state[3][0] = tmp;\n}\nfunction mixColumns(state) {\n    for (let c = 0; c < 4; c++) {\n        const s0 = state[0][c];\n        const s1 = state[1][c];\n        const s2 = state[2][c];\n        const s3 = state[3][c];\n        state[0][c] = mul2[s0] ^ mul3[s1] ^ s2 ^ s3;\n        state[1][c] = s0 ^ mul2[s1] ^ mul3[s2] ^ s3;\n        state[2][c] = s0 ^ s1 ^ mul2[s2] ^ mul3[s3];\n        state[3][c] = mul3[s0] ^ s1 ^ s2 ^ mul2[s3];\n    }\n}\nfunction keyExpansion(roundLimit, key) {\n    const nK = key.length / 4;\n    const result = [];\n    for (let i = 0; i < key.length; i++) {\n        if (i % 4 === 0)\n            result.push([]);\n        result[i >> 2].push(key[i]);\n    }\n    for (let i = nK; i < 4 * roundLimit; i++) {\n        result[i] = [];\n        const temp = result[i - 1].slice();\n        if (i % nK === 0) {\n            rotWord(temp);\n            subWord(temp);\n            const r = Rcon[i / nK];\n            for (let j = 0; j < 4; j++) {\n                temp[j] ^= r[j];\n            }\n        }\n        else if (nK > 6 && (i % nK) === 4) {\n            subWord(temp);\n        }\n        for (let j = 0; j < 4; j++) {\n            result[i][j] = result[i - nK][j] ^ temp[j];\n        }\n    }\n    return result;\n}\nfunction AES(input, key) {\n    let i;\n    let j;\n    let round;\n    let roundLimit;\n    const state = [[], [], [], []];\n    const output = [];\n    // Since the BigNumber representation of keys ignores big endian zeroes,\n    // extend incoming key arrays with zeros to the smallest standard key size.\n    const ekey = Array.from(key);\n    if (ekey.length <= 16) {\n        while (ekey.length < 16)\n            ekey.unshift(0);\n        roundLimit = 11;\n    }\n    else if (ekey.length <= 24) {\n        while (ekey.length < 24)\n            ekey.unshift(0);\n        roundLimit = 13;\n    }\n    else if (key.length <= 32) {\n        while (ekey.length < 32)\n            ekey.unshift(0);\n        roundLimit = 15;\n    }\n    else {\n        throw new Error('Illegal key length: ' + String(key.length));\n    }\n    const w = keyExpansion(roundLimit, ekey);\n    for (let c = 0; c < 4; c++) {\n        state[0][c] = input[c * 4];\n        state[1][c] = input[c * 4 + 1];\n        state[2][c] = input[c * 4 + 2];\n        state[3][c] = input[c * 4 + 3];\n    }\n    addRoundKey(state, w, 0);\n    for (round = 1; round < roundLimit; round++) {\n        subBytes(state);\n        shiftRows(state);\n        if (round + 1 < roundLimit) {\n            mixColumns(state);\n        }\n        addRoundKey(state, w, round * 4);\n    }\n    for (i = 0; i < 4; i++) {\n        for (j = 0; j < 4; j++) {\n            output.push(state[j][i]);\n        }\n    }\n    return output;\n}\nconst checkBit = function (byteArray, byteIndex, bitIndex) {\n    return (byteArray[byteIndex] & (0x01 << bitIndex)) !== 0 ? 1 : 0;\n};\nconst getBytes = function (numericValue) {\n    return [\n        (numericValue & 0xFF000000) >>> 24,\n        (numericValue & 0x00FF0000) >> 16,\n        (numericValue & 0x0000FF00) >> 8,\n        numericValue & 0x000000FF\n    ];\n};\nconst createZeroBlock = function (length) {\n    return new Array(length).fill(0);\n};\nconst R = [0xe1].concat(createZeroBlock(15));\nconst exclusiveOR = function (block0, block1) {\n    const len = block0.length;\n    const result = new Array(len);\n    for (let i = 0; i < len; i++) {\n        result[i] = block0[i] ^ block1[i];\n    }\n    return result;\n};\nconst xorInto = function (target, block) {\n    for (let i = 0; i < target.length; i++) {\n        target[i] ^= block[i];\n    }\n};\nconst rightShift = function (block) {\n    let i;\n    let carry = 0;\n    let oldCarry = 0;\n    for (i = 0; i < block.length; i++) {\n        oldCarry = carry;\n        carry = block[i] & 0x01;\n        block[i] = block[i] >> 1;\n        if (oldCarry !== 0) {\n            block[i] = block[i] | 0x80;\n        }\n    }\n    return block;\n};\nconst multiply = function (block0, block1) {\n    const v = block1.slice();\n    const z = createZeroBlock(16);\n    for (let i = 0; i < 16; i++) {\n        for (let j = 7; j >= 0; j--) {\n            if ((block0[i] & (1 << j)) !== 0) {\n                xorInto(z, v);\n            }\n            if ((v[15] & 1) !== 0) {\n                rightShift(v);\n                xorInto(v, R);\n            }\n            else {\n                rightShift(v);\n            }\n        }\n    }\n    return z;\n};\nconst incrementLeastSignificantThirtyTwoBits = function (block) {\n    let i;\n    const result = block.slice();\n    for (i = 15; i !== 11; i--) {\n        result[i] = result[i] + 1;\n        if (result[i] === 256) {\n            result[i] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n};\nfunction ghash(input, hashSubKey) {\n    let result = createZeroBlock(16);\n    for (let i = 0; i < input.length; i += 16) {\n        const block = result.slice();\n        for (let j = 0; j < 16; j++) {\n            block[j] ^= input[i + j] ?? 0;\n        }\n        result = multiply(block, hashSubKey);\n    }\n    return result;\n}\nfunction gctr(input, initialCounterBlock, key) {\n    if (input.length === 0)\n        return [];\n    const output = new Array(input.length);\n    let counterBlock = initialCounterBlock;\n    let pos = 0;\n    const n = Math.ceil(input.length / 16);\n    for (let i = 0; i < n; i++) {\n        const counter = AES(counterBlock, key);\n        const chunk = Math.min(16, input.length - pos);\n        for (let j = 0; j < chunk; j++) {\n            output[pos] = input[pos] ^ counter[j];\n            pos++;\n        }\n        if (i + 1 < n) {\n            counterBlock = incrementLeastSignificantThirtyTwoBits(counterBlock);\n        }\n    }\n    return output;\n}\nfunction AESGCM(plainText, additionalAuthenticatedData, initializationVector, key) {\n    let preCounterBlock;\n    let plainTag;\n    const hashSubKey = AES(createZeroBlock(16), key);\n    preCounterBlock = [...initializationVector];\n    if (initializationVector.length === 12) {\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);\n    }\n    else {\n        if (initializationVector.length % 16 !== 0) {\n            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));\n        }\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));\n        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4))\n            .concat(getBytes(initializationVector.length * 8)), hashSubKey);\n    }\n    const cipherText = gctr(plainText, incrementLeastSignificantThirtyTwoBits(preCounterBlock), key);\n    plainTag = additionalAuthenticatedData.slice();\n    if (additionalAuthenticatedData.length === 0) {\n        plainTag = plainTag.concat(createZeroBlock(16));\n    }\n    else if (additionalAuthenticatedData.length % 16 !== 0) {\n        plainTag = plainTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));\n    }\n    plainTag = plainTag.concat(cipherText);\n    if (cipherText.length === 0) {\n        plainTag = plainTag.concat(createZeroBlock(16));\n    }\n    else if (cipherText.length % 16 !== 0) {\n        plainTag = plainTag.concat(createZeroBlock(16 - (cipherText.length % 16)));\n    }\n    plainTag = plainTag.concat(createZeroBlock(4))\n        .concat(getBytes(additionalAuthenticatedData.length * 8))\n        .concat(createZeroBlock(4)).concat(getBytes(cipherText.length * 8));\n    return {\n        result: cipherText,\n        authenticationTag: gctr(ghash(plainTag, hashSubKey), preCounterBlock, key)\n    };\n}\nfunction AESGCMDecrypt(cipherText, additionalAuthenticatedData, initializationVector, authenticationTag, key) {\n    let preCounterBlock;\n    let compareTag;\n    // Generate the hash subkey\n    const hashSubKey = AES(createZeroBlock(16), key);\n    preCounterBlock = [...initializationVector];\n    if (initializationVector.length === 12) {\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(3)).concat([0x01]);\n    }\n    else {\n        if (initializationVector.length % 16 !== 0) {\n            preCounterBlock = preCounterBlock.concat(createZeroBlock(16 - (initializationVector.length % 16)));\n        }\n        preCounterBlock = preCounterBlock.concat(createZeroBlock(8));\n        preCounterBlock = ghash(preCounterBlock.concat(createZeroBlock(4)).concat(getBytes(initializationVector.length * 8)), hashSubKey);\n    }\n    // Decrypt to obtain the plain text\n    const plainText = gctr(cipherText, incrementLeastSignificantThirtyTwoBits(preCounterBlock), key);\n    compareTag = additionalAuthenticatedData.slice();\n    if (additionalAuthenticatedData.length === 0) {\n        compareTag = compareTag.concat(createZeroBlock(16));\n    }\n    else if (additionalAuthenticatedData.length % 16 !== 0) {\n        compareTag = compareTag.concat(createZeroBlock(16 - (additionalAuthenticatedData.length % 16)));\n    }\n    compareTag = compareTag.concat(cipherText);\n    if (cipherText.length === 0) {\n        compareTag = compareTag.concat(createZeroBlock(16));\n    }\n    else if (cipherText.length % 16 !== 0) {\n        compareTag = compareTag.concat(createZeroBlock(16 - (cipherText.length % 16)));\n    }\n    compareTag = compareTag.concat(createZeroBlock(4))\n        .concat(getBytes(additionalAuthenticatedData.length * 8))\n        .concat(createZeroBlock(4)).concat(getBytes(cipherText.length * 8));\n    // Generate the authentication tag\n    const calculatedTag = gctr(ghash(compareTag, hashSubKey), preCounterBlock, key);\n    // If the calculated tag does not match the provided tag, return null - the decryption failed.\n    if (calculatedTag.join() !== authenticationTag.join()) {\n        return null;\n    }\n    return plainText;\n}\n//# sourceMappingURL=AESGCM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/AESGCM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BasePoint)\n/* harmony export */ });\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n\n/**\n * Base class for Point (affine coordinates) and JacobianPoint classes,\n * defining their curve and type.\n */\nclass BasePoint {\n    curve;\n    type;\n    precomputed;\n    constructor(type) {\n        this.curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](); // Always initialized, so never null\n        this.type = type;\n        this.precomputed = null;\n    }\n}\n//# sourceMappingURL=BasePoint.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BigNumber)\n/* harmony export */ });\n/**\n * JavaScript numbers are only precise up to 53 bits. Since Bitcoin relies on\n * 256-bit cryptography, this BigNumber class enables operations on larger\n * numbers.\n *\n * @class BigNumber\n */\nclass BigNumber {\n    /**\n     * @privateinitializer\n     */\n    static zeros = [\n        '', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000',\n        '000000000', '0000000000', '00000000000', '000000000000', '0000000000000',\n        '00000000000000', '000000000000000', '0000000000000000', '00000000000000000',\n        '000000000000000000', '0000000000000000000', '00000000000000000000',\n        '000000000000000000000', '0000000000000000000000', '00000000000000000000000',\n        '000000000000000000000000', '0000000000000000000000000'\n    ];\n    /**\n     * @privateinitializer\n     */\n    static groupSizes = [\n        0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5,\n        5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n    ];\n    /**\n     * @privateinitializer\n     */\n    static groupBases = [\n        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n        43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n        16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343,\n        7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000,\n        28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n    ];\n    /**\n     * The word size of big number chunks.\n     *\n     * @property wordSize\n     *\n     * @example\n     * console.log(BigNumber.wordSize);  // output: 26\n     */\n    static wordSize = 26;\n    static WORD_SIZE_BIGINT = BigInt(BigNumber.wordSize);\n    static WORD_MASK = (1n << BigNumber.WORD_SIZE_BIGINT) - 1n;\n    static MAX_SAFE_INTEGER_BIGINT = BigInt(Number.MAX_SAFE_INTEGER);\n    static MIN_SAFE_INTEGER_BIGINT = BigInt(Number.MIN_SAFE_INTEGER);\n    static MAX_IMULN_ARG = 0x4000000 - 1;\n    static MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT = (1n << 53n) - 1n;\n    _magnitude;\n    _sign;\n    _nominalWordLength;\n    /**\n     * Reduction context of the big number.\n     *\n     * @property red\n     */\n    red;\n    /**\n     * Negative flag. Indicates whether the big number is a negative number.\n     * - If 0, the number is positive.\n     * - If 1, the number is negative.\n     *\n     * @property negative\n     */\n    get negative() {\n        return this._sign;\n    }\n    /**\n     * Sets the negative flag. Only 0 (positive) or 1 (negative) are allowed.\n     */\n    set negative(val) {\n        this.assert(val === 0 || val === 1, 'Negative property must be 0 or 1');\n        const newSign = val === 1 ? 1 : 0;\n        if (this._magnitude === 0n) {\n            this._sign = 0;\n        }\n        else {\n            this._sign = newSign;\n        }\n    }\n    get _computedWordsArray() {\n        if (this._magnitude === 0n)\n            return [0];\n        const arr = [];\n        let temp = this._magnitude;\n        while (temp > 0n) {\n            arr.push(Number(temp & BigNumber.WORD_MASK));\n            temp >>= BigNumber.WORD_SIZE_BIGINT;\n        }\n        return arr.length > 0 ? arr : [0];\n    }\n    /**\n     * Array of numbers, where each number represents a part of the value of the big number.\n     *\n     * @property words\n     */\n    get words() {\n        const computed = this._computedWordsArray;\n        if (this._nominalWordLength <= computed.length) {\n            return computed;\n        }\n        const paddedWords = new Array(this._nominalWordLength).fill(0);\n        for (let i = 0; i < computed.length; i++) {\n            paddedWords[i] = computed[i];\n        }\n        return paddedWords;\n    }\n    /**\n     * Sets the words array representing the value of the big number.\n     */\n    set words(newWords) {\n        const oldSign = this._sign;\n        let newMagnitude = 0n;\n        const len = newWords.length > 0 ? newWords.length : 1;\n        for (let i = len - 1; i >= 0; i--) {\n            const wordVal = newWords[i] === undefined ? 0 : newWords[i];\n            newMagnitude = (newMagnitude << BigNumber.WORD_SIZE_BIGINT) | BigInt(wordVal & Number(BigNumber.WORD_MASK));\n        }\n        this._magnitude = newMagnitude;\n        this._sign = oldSign;\n        this._nominalWordLength = len;\n        this.normSign();\n    }\n    /**\n     * Length of the words array.\n     *\n     * @property length\n     */\n    get length() {\n        return Math.max(1, this._nominalWordLength);\n    }\n    /**\n     * Checks whether a value is an instance of BigNumber. Regular JS numbers fail this check.\n     *\n     * @method isBN\n     * @param num - The value to be checked.\n     * @returns - Returns a boolean value determining whether or not the checked num parameter is a BigNumber.\n     */\n    static isBN(num) {\n        if (num instanceof BigNumber)\n            return true;\n        return (num !== null &&\n            typeof num === 'object' &&\n            num.constructor?.wordSize === BigNumber.wordSize &&\n            Array.isArray(num.words));\n    }\n    /**\n     * Returns the bigger value between two BigNumbers\n     *\n     * @method max\n     * @param left - The first BigNumber to be compared.\n     * @param right - The second BigNumber to be compared.\n     * @returns - Returns the bigger BigNumber between left and right.\n     */\n    static max(left, right) { return left.cmp(right) > 0 ? left : right; }\n    /**\n     * Returns the smaller value between two BigNumbers\n     *\n     * @method min\n     * @param left - The first BigNumber to be compared.\n     * @param right - The second BigNumber to be compared.\n     * @returns - Returns the smaller value between left and right.\n     */\n    static min(left, right) { return left.cmp(right) < 0 ? left : right; }\n    /**\n     * @constructor\n     *\n     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.\n     * @param base - The base of number provided. By default is 10.\n     * @param endian - The endianness provided. By default is 'big endian'.\n     */\n    constructor(number = 0, base = 10, endian = 'be') {\n        this._magnitude = 0n;\n        this._sign = 0;\n        this._nominalWordLength = 1;\n        this.red = null;\n        if (number === undefined)\n            number = 0;\n        if (number === null) {\n            this._initializeState(0n, 0);\n            return;\n        }\n        if (typeof number === 'bigint') {\n            this._initializeState(number < 0n ? -number : number, number < 0n ? 1 : 0);\n            this.normSign();\n            return;\n        }\n        let effectiveBase = base;\n        let effectiveEndian = endian;\n        if (base === 'le' || base === 'be') {\n            effectiveEndian = base;\n            effectiveBase = 10;\n        }\n        if (typeof number === 'number') {\n            this.initNumber(number, effectiveEndian);\n            return;\n        }\n        if (Array.isArray(number)) {\n            this.initArray(number, effectiveEndian);\n            return;\n        }\n        if (typeof number === 'string') {\n            if (effectiveBase === 'hex')\n                effectiveBase = 16;\n            this.assert(typeof effectiveBase === 'number' && effectiveBase === (effectiveBase | 0) && effectiveBase >= 2 && effectiveBase <= 36, 'Base must be an integer between 2 and 36');\n            const originalNumberStr = number.toString().replace(/\\s+/g, '');\n            let start = 0;\n            let sign = 0;\n            if (originalNumberStr.startsWith('-')) {\n                start++;\n                sign = 1;\n            }\n            else if (originalNumberStr.startsWith('+')) {\n                start++;\n            }\n            const numStr = originalNumberStr.substring(start);\n            if (numStr.length === 0) {\n                this._initializeState(0n, (sign === 1 && originalNumberStr.startsWith('-')) ? 1 : 0);\n                this.normSign();\n                return;\n            }\n            if (effectiveBase === 16) {\n                let tempMagnitude;\n                if (effectiveEndian === 'le') {\n                    const bytes = [];\n                    let hexStr = numStr;\n                    if (hexStr.length % 2 !== 0)\n                        hexStr = '0' + hexStr;\n                    for (let i = 0; i < hexStr.length; i += 2) {\n                        const byteHex = hexStr.substring(i, i + 2);\n                        const byteVal = parseInt(byteHex, 16);\n                        if (isNaN(byteVal))\n                            throw new Error('Invalid character in ' + hexStr);\n                        bytes.push(byteVal);\n                    }\n                    this.initArray(bytes, 'le');\n                    this._sign = sign;\n                    this.normSign();\n                    return;\n                }\n                else {\n                    try {\n                        tempMagnitude = BigInt('0x' + numStr);\n                    }\n                    catch (e) {\n                        throw new Error('Invalid character in ' + numStr);\n                    }\n                }\n                this._initializeState(tempMagnitude, sign);\n                this.normSign();\n            }\n            else {\n                try {\n                    this._parseBaseString(numStr, effectiveBase);\n                    this._sign = sign;\n                    this.normSign();\n                    if (effectiveEndian === 'le') {\n                        const currentSign = this._sign;\n                        this.initArray(this.toArray('be'), 'le');\n                        this._sign = currentSign;\n                        this.normSign();\n                    }\n                }\n                catch (err) {\n                    const error = err;\n                    if (error.message.includes('Invalid character in string') ||\n                        error.message.includes('Invalid digit for base') ||\n                        error.message.startsWith('Invalid character:')) {\n                        throw new Error('Invalid character');\n                    }\n                    throw error;\n                }\n            }\n        }\n        else if (number !== 0) {\n            this.assert(false, 'Unsupported input type for BigNumber constructor');\n        }\n        else {\n            this._initializeState(0n, 0);\n        }\n    }\n    _bigIntToStringInBase(num, base) {\n        if (num === 0n)\n            return '0';\n        if (base < 2 || base > 36)\n            throw new Error('Base must be between 2 and 36');\n        const digits = '0123456789abcdefghijklmnopqrstuvwxyz';\n        let result = '';\n        let currentNum = num > 0n ? num : -num;\n        const bigBase = BigInt(base);\n        while (currentNum > 0n) {\n            result = digits[Number(currentNum % bigBase)] + result;\n            currentNum /= bigBase;\n        }\n        return result;\n    }\n    _parseBaseString(numberStr, base) {\n        if (numberStr.length === 0) {\n            this._magnitude = 0n;\n            this._finishInitialization();\n            return;\n        }\n        this._magnitude = 0n;\n        const bigBase = BigInt(base);\n        let groupSize = BigNumber.groupSizes[base];\n        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);\n        if (groupSize === 0 || groupBaseBigInt === 0n) {\n            groupSize = Math.floor(Math.log(0x3ffffff) / Math.log(base));\n            if (groupSize === 0)\n                groupSize = 1;\n            groupBaseBigInt = bigBase ** BigInt(groupSize);\n        }\n        let currentPos = 0;\n        const totalLen = numberStr.length;\n        let firstChunkLen = totalLen % groupSize;\n        if (firstChunkLen === 0 && totalLen > 0)\n            firstChunkLen = groupSize;\n        if (firstChunkLen > 0) {\n            const chunkStr = numberStr.substring(currentPos, currentPos + firstChunkLen);\n            this._magnitude = BigInt(this._parseBaseWord(chunkStr, base));\n            currentPos += firstChunkLen;\n        }\n        while (currentPos < totalLen) {\n            const chunkStr = numberStr.substring(currentPos, currentPos + groupSize);\n            const wordVal = BigInt(this._parseBaseWord(chunkStr, base));\n            this._magnitude = this._magnitude * groupBaseBigInt + wordVal;\n            currentPos += groupSize;\n        }\n        this._finishInitialization();\n    }\n    _parseBaseWord(str, base) {\n        let r = 0;\n        for (let i = 0; i < str.length; i++) {\n            const charCode = str.charCodeAt(i);\n            let digitVal;\n            if (charCode >= 48 && charCode <= 57)\n                digitVal = charCode - 48;\n            else if (charCode >= 65 && charCode <= 90)\n                digitVal = charCode - 65 + 10;\n            else if (charCode >= 97 && charCode <= 122)\n                digitVal = charCode - 97 + 10;\n            else\n                throw new Error('Invalid character: ' + str[i]);\n            if (digitVal >= base)\n                throw new Error('Invalid character');\n            r = r * base + digitVal;\n        }\n        return r;\n    }\n    _initializeState(magnitude, sign) {\n        this._magnitude = magnitude;\n        this._sign = (magnitude === 0n) ? 0 : sign;\n        this._finishInitialization();\n    }\n    _finishInitialization() {\n        if (this._magnitude === 0n) {\n            this._nominalWordLength = 1;\n            this._sign = 0;\n        }\n        else {\n            const bitLen = this._magnitude.toString(2).length;\n            this._nominalWordLength = Math.max(1, Math.ceil(bitLen / BigNumber.wordSize));\n        }\n    }\n    assert(val, msg = 'Assertion failed') { if (!val)\n        throw new Error(msg); }\n    initNumber(number, endian = 'be') {\n        this.assert(BigInt(Math.abs(number)) <= BigNumber.MAX_NUMBER_CONSTRUCTOR_MAG_BIGINT, 'The number is larger than 2 ^ 53 (unsafe)');\n        this.assert(number % 1 === 0, 'Number must be an integer for BigNumber conversion');\n        this._initializeState(BigInt(Math.abs(number)), number < 0 ? 1 : 0);\n        if (endian === 'le') {\n            const currentSign = this._sign;\n            const beBytes = this.toArray('be');\n            this.initArray(beBytes, 'le');\n            this._sign = currentSign;\n            this.normSign();\n        }\n        return this;\n    }\n    initArray(bytes, endian) {\n        if (bytes.length === 0) {\n            this._initializeState(0n, 0);\n            return this;\n        }\n        let magnitude = 0n;\n        if (endian === 'be') {\n            for (let i = 0; i < bytes.length; i++)\n                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);\n        }\n        else {\n            for (let i = bytes.length - 1; i >= 0; i--)\n                magnitude = (magnitude << 8n) | BigInt(bytes[i] & 0xff);\n        }\n        this._initializeState(magnitude, 0);\n        return this;\n    }\n    copy(dest) { dest._magnitude = this._magnitude; dest._sign = this._sign; dest._nominalWordLength = this._nominalWordLength; dest.red = this.red; }\n    static move(dest, src) { dest._magnitude = src._magnitude; dest._sign = src._sign; dest._nominalWordLength = src._nominalWordLength; dest.red = src.red; }\n    clone() { const r = new BigNumber(0n); this.copy(r); return r; }\n    expand(size) {\n        this.assert(size >= 0, 'Expand size must be non-negative');\n        this._nominalWordLength = Math.max(this._nominalWordLength, size, 1);\n        return this;\n    }\n    strip() { this._finishInitialization(); return this.normSign(); }\n    normSign() { if (this._magnitude === 0n)\n        this._sign = 0; return this; }\n    inspect() { return (this.red !== null ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'; }\n    _getMinimalHex() {\n        if (this._magnitude === 0n)\n            return '0';\n        return this._magnitude.toString(16);\n    }\n    /**\n     * Converts the BigNumber instance to a string representation.\n     *\n     * @method toString\n     * @param base - The base for representing number. Default is 10. Other accepted values are 16 and 'hex'.\n     * @param padding - Represents the minimum number of digits to represent the BigNumber as a string. Default is 1.\n     * @returns The string representation of the BigNumber instance\n     */\n    toString(base = 10, padding = 1) {\n        if (base === 16 || base === 'hex') {\n            // For toString('hex', N), N is the 'multiple-of-N characters' rule from bn.js tests\n            // For toString(16, P) where P=1 (default) or P=0, it means minimal hex.\n            let hexStr = this._getMinimalHex(); // e.g., \"f\", \"123\", \"0\"\n            if (padding > 1) { // N-multiple rule for characters\n                // Ensure hexStr is even length if not \"0\" to represent full bytes before applying multiple rule\n                if (hexStr !== '0' && hexStr.length % 2 !== 0) {\n                    hexStr = '0' + hexStr;\n                }\n                while (hexStr.length % padding !== 0) {\n                    hexStr = '0' + hexStr;\n                }\n            }\n            // If padding is 0 or 1, hexStr (minimal) is used as is.\n            // \"0\" is always \"0\" unless toHex(\"\") specific case.\n            // Single digit hex like \"f\" is not \"0f\" by default from toString(16).\n            return (this.isNeg() ? '-' : '') + hexStr;\n        }\n        if (typeof base !== 'number' || base < 2 || base > 36 || base % 1 !== 0)\n            throw new Error('Base should be an integer between 2 and 36');\n        return this.toBaseString(base, padding);\n    }\n    toBaseString(base, padding) {\n        if (this._magnitude === 0n) {\n            let out = '0';\n            if (padding > 1) {\n                while (out.length < padding)\n                    out = '0' + out;\n            }\n            return out;\n        }\n        let groupSize = BigNumber.groupSizes[base];\n        let groupBaseBigInt = BigInt(BigNumber.groupBases[base]);\n        if (groupSize === 0 || groupBaseBigInt === 0n) {\n            groupSize = Math.floor(Math.log(Number.MAX_SAFE_INTEGER) / Math.log(base));\n            if (groupSize === 0)\n                groupSize = 1;\n            groupBaseBigInt = BigInt(base) ** BigInt(groupSize);\n        }\n        let out = '';\n        let tempMag = this._magnitude;\n        while (tempMag > 0n) {\n            const remainder = tempMag % groupBaseBigInt;\n            tempMag /= groupBaseBigInt;\n            const chunkStr = this._bigIntToStringInBase(remainder, base);\n            if (tempMag > 0n) {\n                const zerosToPrepend = groupSize - chunkStr.length;\n                if (zerosToPrepend > 0 && zerosToPrepend < BigNumber.zeros.length) {\n                    out = BigNumber.zeros[zerosToPrepend] + chunkStr + out;\n                }\n                else if (zerosToPrepend > 0) {\n                    out = '0'.repeat(zerosToPrepend) + chunkStr + out;\n                }\n                else {\n                    out = chunkStr + out;\n                }\n            }\n            else {\n                out = chunkStr + out;\n            }\n        }\n        if (padding > 0) {\n            while (out.length < padding)\n                out = '0' + out;\n        }\n        return (this._sign === 1 ? '-' : '') + out;\n    }\n    /**\n     * Converts the BigNumber instance to a JavaScript number.\n     * Please note that JavaScript numbers are only precise up to 53 bits.\n     *\n     * @method toNumber\n     * @throws If the BigNumber instance cannot be safely stored in a JavaScript number\n     * @returns The JavaScript number representation of the BigNumber instance.\n     */\n    toNumber() {\n        const val = this._getSignedValue();\n        if (val > BigNumber.MAX_SAFE_INTEGER_BIGINT || val < BigNumber.MIN_SAFE_INTEGER_BIGINT)\n            throw new Error('Number can only safely store up to 53 bits');\n        return Number(val);\n    }\n    /**\n     * Converts the BigNumber instance to a JSON-formatted string.\n     *\n     * @method toJSON\n     * @returns The JSON string representation of the BigNumber instance.\n     */\n    toJSON() {\n        const hex = this._getMinimalHex();\n        return (this.isNeg() ? '-' : '') + hex;\n    }\n    toArrayLikeGeneric(res, isLE) {\n        let tempMag = this._magnitude;\n        let position = isLE ? 0 : res.length - 1;\n        const increment = isLE ? 1 : -1;\n        for (let k = 0; k < res.length; ++k) {\n            if (tempMag === 0n && position >= 0 && position < res.length) {\n                res[position] = 0;\n            }\n            else if (position >= 0 && position < res.length) {\n                res[position] = Number(tempMag & 0xffn);\n            }\n            else {\n                break;\n            }\n            tempMag >>= 8n;\n            position += increment;\n        }\n    }\n    /**\n     * Converts the BigNumber instance to an array of bytes.\n     *\n     * @method toArray\n     * @param endian - Endianness of the output array, defaults to 'be'.\n     * @param length - Optional length of the output array.\n     * @returns Array of bytes representing the BigNumber.\n     */\n    toArray(endian = 'be', length) {\n        this.strip();\n        const actualByteLength = this.byteLength();\n        const reqLength = length ?? Math.max(1, actualByteLength);\n        this.assert(actualByteLength <= reqLength, 'byte array longer than desired length');\n        this.assert(reqLength > 0, 'Requested array length <= 0');\n        const res = new Array(reqLength).fill(0);\n        if (this._magnitude === 0n && reqLength > 0)\n            return res;\n        if (this._magnitude === 0n && reqLength === 0)\n            return [];\n        this.toArrayLikeGeneric(res, endian === 'le');\n        return res;\n    }\n    /**\n     * Calculates the number of bits required to represent the BigNumber.\n     *\n     * @method bitLength\n     * @returns The bit length of the BigNumber.\n     */\n    bitLength() { if (this._magnitude === 0n)\n        return 0; return this._magnitude.toString(2).length; }\n    /**\n     * Converts a BigNumber to an array of bits.\n     *\n     * @method toBitArray\n     * @param num - The BigNumber to convert.\n     * @returns An array of bits.\n     */\n    static toBitArray(num) {\n        const len = num.bitLength();\n        if (len === 0)\n            return [];\n        const w = new Array(len);\n        const mag = num._magnitude;\n        for (let bit = 0; bit < len; bit++) {\n            w[bit] = ((mag >> BigInt(bit)) & 1n) !== 0n ? 1 : 0;\n        }\n        return w;\n    }\n    /**\n     * Instance version of {@link toBitArray}.\n     */\n    toBitArray() { return BigNumber.toBitArray(this); }\n    /**\n     * Returns the number of trailing zero bits in the big number.\n     *\n     * @method zeroBits\n     * @returns Returns the number of trailing zero bits\n     * in the binary representation of the big number.\n     *\n     * @example\n     * const bn = new BigNumber('8'); // binary: 1000\n     * const zeroBits = bn.zeroBits(); // 3\n     */\n    zeroBits() {\n        if (this._magnitude === 0n)\n            return 0;\n        let c = 0;\n        let t = this._magnitude;\n        while ((t & 1n) === 0n && t !== 0n) {\n            c++;\n            t >>= 1n;\n        }\n        return c;\n    }\n    /**\n     * Calculates the number of bytes required to represent the BigNumber.\n     *\n     * @method byteLength\n     * @returns The byte length of the BigNumber.\n     */\n    byteLength() { if (this._magnitude === 0n)\n        return 0; return Math.ceil(this.bitLength() / 8); }\n    _getSignedValue() { return this._sign === 1 ? -this._magnitude : this._magnitude; }\n    _setValueFromSigned(sVal) {\n        if (sVal < 0n) {\n            this._magnitude = -sVal;\n            this._sign = 1;\n        }\n        else {\n            this._magnitude = sVal;\n            this._sign = 0;\n        }\n        this._finishInitialization();\n        this.normSign();\n    }\n    toTwos(width) {\n        this.assert(width >= 0);\n        const Bw = BigInt(width);\n        let v = this._getSignedValue();\n        if (this._sign === 1 && this._magnitude !== 0n)\n            v = (1n << Bw) + v;\n        const m = (1n << Bw) - 1n;\n        v &= m;\n        const r = new BigNumber(0n);\n        r._initializeState(v, 0);\n        return r;\n    }\n    fromTwos(width) {\n        this.assert(width >= 0);\n        const Bw = BigInt(width);\n        const m = this._magnitude;\n        if (width > 0 && ((m >> (Bw - 1n)) & 1n) !== 0n && this._sign === 0) {\n            const sVal = m - (1n << Bw);\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(sVal);\n            return r;\n        }\n        return this.clone();\n    }\n    isNeg() { return this._sign === 1 && this._magnitude !== 0n; }\n    neg() { return this.clone().ineg(); }\n    ineg() { if (this._magnitude !== 0n)\n        this._sign = this._sign === 1 ? 0 : 1; return this; }\n    _iuop(num, op) {\n        const newMag = op(this._magnitude, num._magnitude);\n        const isXor = op === ((a, b) => a ^ b);\n        let targetNominalLength = this._nominalWordLength;\n        if (isXor)\n            targetNominalLength = Math.max(this.length, num.length);\n        this._magnitude = newMag;\n        this._finishInitialization();\n        if (isXor)\n            this._nominalWordLength = Math.max(this._nominalWordLength, targetNominalLength);\n        return this.strip();\n    }\n    iuor(num) { return this._iuop(num, (a, b) => a | b); }\n    iuand(num) { return this._iuop(num, (a, b) => a & b); }\n    iuxor(num) { return this._iuop(num, (a, b) => a ^ b); }\n    _iop(num, op) { this.assert(this._sign === 0 && num._sign === 0); return this._iuop(num, op); }\n    ior(num) { return this._iop(num, (a, b) => a | b); }\n    iand(num) { return this._iop(num, (a, b) => a & b); }\n    ixor(num) { return this._iop(num, (a, b) => a ^ b); }\n    _uop_new(num, opName) { if (this.length >= num.length)\n        return this.clone()[opName](num); return num.clone()[opName](this); }\n    or(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuor'); }\n    uor(num) { return this._uop_new(num, 'iuor'); }\n    and(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuand'); }\n    uand(num) { return this._uop_new(num, 'iuand'); }\n    xor(num) { this.assert(this._sign === 0 && num._sign === 0); return this._uop_new(num, 'iuxor'); }\n    uxor(num) { return this._uop_new(num, 'iuxor'); }\n    inotn(width) {\n        this.assert(typeof width === 'number' && width >= 0);\n        const Bw = BigInt(width);\n        const m = (1n << Bw) - 1n;\n        this._magnitude = (~this._magnitude) & m;\n        const wfw = width === 0 ? 1 : Math.ceil(width / BigNumber.wordSize);\n        this._nominalWordLength = Math.max(1, wfw);\n        this.strip();\n        this._nominalWordLength = Math.max(this._nominalWordLength, Math.max(1, wfw));\n        return this;\n    }\n    notn(width) { return this.clone().inotn(width); }\n    setn(bit, val) { this.assert(typeof bit === 'number' && bit >= 0); const Bb = BigInt(bit); if (val === 1 || val === true)\n        this._magnitude |= (1n << Bb);\n    else\n        this._magnitude &= ~(1n << Bb); const wnb = Math.floor(bit / BigNumber.wordSize) + 1; this._nominalWordLength = Math.max(this._nominalWordLength, wnb); this._finishInitialization(); return this.strip(); }\n    iadd(num) { this._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return this; }\n    add(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() + num._getSignedValue()); return r; }\n    isub(num) { this._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return this; }\n    sub(num) { const r = new BigNumber(0n); r._setValueFromSigned(this._getSignedValue() - num._getSignedValue()); return r; }\n    mul(num) {\n        const r = new BigNumber(0n);\n        r._magnitude = this._magnitude * num._magnitude;\n        r._sign = r._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        r._nominalWordLength = this.length + num.length;\n        r.red = null;\n        return r.normSign();\n    }\n    imul(num) {\n        this._magnitude *= num._magnitude;\n        this._sign = this._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        this._nominalWordLength = this.length + num.length;\n        this.red = null;\n        return this.normSign();\n    }\n    imuln(num) { this.assert(typeof num === 'number', 'Assertion failed'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() * BigInt(num)); return this; }\n    muln(num) { return this.clone().imuln(num); }\n    sqr() {\n        const r = new BigNumber(0n);\n        r._magnitude = this._magnitude * this._magnitude;\n        r._sign = 0;\n        r._nominalWordLength = this.length * 2;\n        r.red = null;\n        return r;\n    }\n    isqr() {\n        this._magnitude *= this._magnitude;\n        this._sign = 0;\n        this._nominalWordLength = this.length * 2;\n        this.red = null;\n        return this;\n    }\n    pow(num) {\n        this.assert(num._sign === 0, 'Exponent for pow must be non-negative');\n        if (num.isZero())\n            return new BigNumber(1n);\n        const res = new BigNumber(1n);\n        const currentBase = this.clone();\n        const exp = num.clone();\n        const baseIsNegative = currentBase.isNeg();\n        const expIsOdd = exp.isOdd();\n        if (baseIsNegative)\n            currentBase.ineg();\n        while (!exp.isZero()) {\n            if (exp.isOdd()) {\n                res.imul(currentBase);\n            }\n            currentBase.isqr();\n            exp.iushrn(1);\n        }\n        if (baseIsNegative && expIsOdd) {\n            res.ineg();\n        }\n        return res;\n    }\n    iushln(bits) { this.assert(typeof bits === 'number' && bits >= 0); if (bits === 0)\n        return this; this._magnitude <<= BigInt(bits); this._finishInitialization(); return this.strip(); }\n    ishln(bits) { this.assert(this._sign === 0, 'ishln requires positive number'); return this.iushln(bits); }\n    iushrn(bits, hint, extended) {\n        this.assert(typeof bits === 'number' && bits >= 0);\n        if (bits === 0) {\n            if (extended != null)\n                extended._initializeState(0n, 0);\n            return this;\n        }\n        if (extended != null) {\n            const m = (1n << BigInt(bits)) - 1n;\n            const sOut = this._magnitude & m;\n            extended._initializeState(sOut, 0);\n        }\n        this._magnitude >>= BigInt(bits);\n        this._finishInitialization();\n        return this.strip();\n    }\n    ishrn(bits, hint, extended) {\n        this.assert(this._sign === 0, 'ishrn requires positive number');\n        return this.iushrn(bits, hint, extended);\n    }\n    shln(bits) { return this.clone().ishln(bits); }\n    ushln(bits) { return this.clone().iushln(bits); }\n    shrn(bits) { return this.clone().ishrn(bits); }\n    ushrn(bits) { return this.clone().iushrn(bits); }\n    testn(bit) {\n        this.assert(typeof bit === 'number' && bit >= 0);\n        return ((this._magnitude >> BigInt(bit)) & 1n) !== 0n;\n    }\n    imaskn(bits) {\n        this.assert(typeof bits === 'number' && bits >= 0);\n        this.assert(this._sign === 0, 'imaskn works only with positive numbers');\n        const Bb = BigInt(bits);\n        const m = Bb === 0n ? 0n : (1n << Bb) - 1n;\n        this._magnitude &= m;\n        const wfm = bits === 0 ? 1 : Math.max(1, Math.ceil(bits / BigNumber.wordSize));\n        this._nominalWordLength = wfm;\n        this._finishInitialization();\n        this._nominalWordLength = Math.max(this._nominalWordLength, wfm);\n        return this.strip();\n    }\n    maskn(bits) { return this.clone().imaskn(bits); }\n    iaddn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large'); this._setValueFromSigned(this._getSignedValue() + BigInt(num)); return this; }\n    _iaddn(num) { return this.iaddn(num); }\n    isubn(num) { this.assert(typeof num === 'number'); this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Assertion failed'); this._setValueFromSigned(this._getSignedValue() - BigInt(num)); return this; }\n    addn(num) { return this.clone().iaddn(num); }\n    subn(num) { return this.clone().isubn(num); }\n    iabs() { this._sign = 0; return this; }\n    abs() { return this.clone().iabs(); }\n    divmod(num, mode, positive) {\n        this.assert(!num.isZero(), 'Division by zero');\n        if (this.isZero()) {\n            const z = new BigNumber(0n);\n            return { div: mode !== 'mod' ? z : null, mod: mode !== 'div' ? z : null };\n        }\n        const tV = this._getSignedValue();\n        const nV = num._getSignedValue();\n        let dV = null;\n        let mV = null;\n        if (mode !== 'mod')\n            dV = tV / nV;\n        if (mode !== 'div') {\n            mV = tV % nV;\n            if (positive === true && mV < 0n)\n                mV += nV < 0n ? -nV : nV;\n        }\n        const rd = dV !== null ? new BigNumber(0n) : null;\n        if (rd !== null && dV !== null)\n            rd._setValueFromSigned(dV);\n        const rm = mV !== null ? new BigNumber(0n) : null;\n        if (rm !== null && mV !== null)\n            rm._setValueFromSigned(mV);\n        return { div: rd, mod: rm };\n    }\n    div(num) {\n        return this.divmod(num, 'div', false).div;\n    }\n    mod(num) {\n        return this.divmod(num, 'mod', false).mod;\n    }\n    umod(num) {\n        return this.divmod(num, 'mod', true).mod;\n    }\n    divRound(num) {\n        this.assert(!num.isZero());\n        const tV = this._getSignedValue();\n        const nV = num._getSignedValue();\n        let d = tV / nV;\n        const m = tV % nV;\n        if (m === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(d);\n            return r;\n        }\n        const absM = m < 0n ? -m : m;\n        const absNV = nV < 0n ? -nV : nV;\n        if (absM * 2n >= absNV) {\n            if ((tV > 0n && nV > 0n) || (tV < 0n && nV < 0n)) {\n                d += 1n;\n            }\n            else {\n                d -= 1n;\n            }\n        }\n        const r = new BigNumber(0n);\n        r._setValueFromSigned(d);\n        return r;\n    }\n    modrn(numArg) {\n        this.assert(numArg !== 0, 'Division by zero in modrn');\n        const absDivisor = BigInt(Math.abs(numArg));\n        if (absDivisor === 0n)\n            throw new Error('Division by zero in modrn');\n        const remainderMag = this._magnitude % absDivisor;\n        return numArg < 0 ? Number(-remainderMag) : Number(remainderMag);\n    }\n    idivn(num) {\n        this.assert(num !== 0);\n        this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'num is too large');\n        this._setValueFromSigned(this._getSignedValue() / BigInt(num));\n        return this;\n    }\n    divn(num) { return this.clone().idivn(num); }\n    egcd(p) {\n        this.assert(p._sign === 0, 'p must not be negative');\n        this.assert(!p.isZero(), 'p must not be zero');\n        let uV = this._getSignedValue();\n        let vV = p._magnitude;\n        let a = 1n;\n        let pa = 0n;\n        let b = 0n;\n        let pb = 1n;\n        while (vV !== 0n) {\n            const q = uV / vV;\n            let t = vV;\n            vV = uV % vV;\n            uV = t;\n            t = pa;\n            pa = a - q * pa;\n            a = t;\n            t = pb;\n            pb = b - q * pb;\n            b = t;\n        }\n        const ra = new BigNumber(0n);\n        ra._setValueFromSigned(a);\n        const rb = new BigNumber(0n);\n        rb._setValueFromSigned(b);\n        const rg = new BigNumber(0n);\n        rg._initializeState(uV < 0n ? -uV : uV, 0);\n        return { a: ra, b: rb, gcd: rg };\n    }\n    gcd(num) {\n        let u = this._magnitude;\n        let v = num._magnitude;\n        if (u === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(v);\n            return r.iabs();\n        }\n        if (v === 0n) {\n            const r = new BigNumber(0n);\n            r._setValueFromSigned(u);\n            return r.iabs();\n        }\n        while (v !== 0n) {\n            const t = u % v;\n            u = v;\n            v = t;\n        }\n        const res = new BigNumber(0n);\n        res._initializeState(u, 0);\n        return res;\n    }\n    invm(num) {\n        this.assert(!num.isZero() && num._sign === 0, 'Modulus for invm must be positive and non-zero');\n        const eg = this.egcd(num);\n        if (!eg.gcd.eqn(1)) {\n            throw new Error('Inverse does not exist (numbers are not coprime).');\n        }\n        return eg.a.umod(num);\n    }\n    isEven() { return this._magnitude % 2n === 0n; }\n    isOdd() { return this._magnitude % 2n === 1n; }\n    andln(num) { this.assert(num >= 0); return Number(this._magnitude & BigInt(num)); }\n    bincn(bit) { this.assert(typeof bit === 'number' && bit >= 0); const BVal = 1n << BigInt(bit); this._setValueFromSigned(this._getSignedValue() + BVal); return this; }\n    isZero() { return this._magnitude === 0n; }\n    cmpn(num) { this.assert(Math.abs(num) <= BigNumber.MAX_IMULN_ARG, 'Number is too big'); const tV = this._getSignedValue(); const nV = BigInt(num); if (tV < nV)\n        return -1; if (tV > nV)\n        return 1; return 0; }\n    cmp(num) { const tV = this._getSignedValue(); const nV = num._getSignedValue(); if (tV < nV)\n        return -1; if (tV > nV)\n        return 1; return 0; }\n    ucmp(num) { if (this._magnitude < num._magnitude)\n        return -1; if (this._magnitude > num._magnitude)\n        return 1; return 0; }\n    gtn(num) { return this.cmpn(num) === 1; }\n    gt(num) { return this.cmp(num) === 1; }\n    gten(num) { return this.cmpn(num) >= 0; }\n    gte(num) { return this.cmp(num) >= 0; }\n    ltn(num) { return this.cmpn(num) === -1; }\n    lt(num) { return this.cmp(num) === -1; }\n    lten(num) { return this.cmpn(num) <= 0; }\n    lte(num) { return this.cmp(num) <= 0; }\n    eqn(num) { return this.cmpn(num) === 0; }\n    eq(num) { return this.cmp(num) === 0; }\n    toRed(ctx) { this.assert(this.red == null, 'Already a number in reduction context'); this.assert(this._sign === 0, 'toRed works only with positives'); return ctx.convertTo(this).forceRed(ctx); }\n    fromRed() { this.assert(this.red, 'fromRed works only with numbers in reduction context'); return this.red.convertFrom(this); }\n    forceRed(ctx) { this.red = ctx; return this; }\n    redAdd(num) { this.assert(this.red, 'redAdd works only with red numbers'); return this.red.add(this, num); }\n    redIAdd(num) { this.assert(this.red, 'redIAdd works only with red numbers'); return this.red.iadd(this, num); }\n    redSub(num) { this.assert(this.red, 'redSub works only with red numbers'); return this.red.sub(this, num); }\n    redISub(num) { this.assert(this.red, 'redISub works only with red numbers'); return this.red.isub(this, num); }\n    redShl(num) { this.assert(this.red, 'redShl works only with red numbers'); return this.red.shl(this, num); }\n    redMul(num) { this.assert(this.red, 'redMul works only with red numbers'); this.red.verify2(this, num); return this.red.mul(this, num); }\n    redIMul(num) { this.assert(this.red, 'redIMul works only with red numbers'); this.red.verify2(this, num); return this.red.imul(this, num); }\n    redSqr() { this.assert(this.red, 'redSqr works only with red numbers'); this.red.verify1(this); return this.red.sqr(this); }\n    redISqr() { this.assert(this.red, 'redISqr works only with red numbers'); this.red.verify1(this); return this.red.isqr(this); }\n    redSqrt() { this.assert(this.red, 'redSqrt works only with red numbers'); this.red.verify1(this); return this.red.sqrt(this); }\n    redInvm() { this.assert(this.red, 'redInvm works only with red numbers'); this.red.verify1(this); return this.red.invm(this); }\n    redNeg() { this.assert(this.red, 'redNeg works only with red numbers'); this.red.verify1(this); return this.red.neg(this); }\n    redPow(num) { this.assert(this.red != null && num.red == null, 'redPow(normalNum)'); this.red.verify1(this); return this.red.pow(this, num); }\n    /**\n     * Creates a BigNumber from a hexadecimal string.\n     *\n     * @static\n     * @method fromHex\n     * @param hex - The hexadecimal string to create a BigNumber from.\n     * @param endian - Optional endianness for parsing the hex string.\n     * @returns Returns a BigNumber created from the hexadecimal input string.\n     *\n     * @example\n     * const exampleHex = 'a1b2c3';\n     * const bigNumber = BigNumber.fromHex(exampleHex);\n     */\n    static fromHex(hex, endian) {\n        let eE = 'be';\n        if (endian === 'little' || endian === 'le')\n            eE = 'le';\n        return new BigNumber(hex, 16, eE);\n    }\n    /**\n     * Converts this BigNumber to a hexadecimal string.\n     *\n     * @method toHex\n     * @param length - The minimum length of the hex string\n     * @returns Returns a string representing the hexadecimal value of this BigNumber.\n     *\n     * @example\n     * const bigNumber = new BigNumber(255)\n     * const hex = bigNumber.toHex()\n     */\n    toHex(byteLength = 0) {\n        if (this.isZero() && byteLength === 0)\n            return '';\n        let hexStr = this._getMinimalHex(); // Raw hex: \"0\", \"f\", \"10\", \"123\"\n        // Ensure even length for non-zero values (byte alignment)\n        if (hexStr !== '0' && hexStr.length % 2 !== 0) {\n            hexStr = '0' + hexStr;\n        }\n        // Pad to minimum character length (byteLength * 2)\n        const minChars = byteLength * 2;\n        while (hexStr.length < minChars) {\n            hexStr = '0' + hexStr;\n        }\n        return (this.isNeg() ? '-' : '') + hexStr;\n    }\n    /**\n     * Creates a BigNumber from a JSON-serialized string.\n     *\n     * @static\n     * @method fromJSON\n     * @param str - The JSON-serialized string to create a BigNumber from.\n     * @returns Returns a BigNumber created from the JSON input string.\n     */\n    static fromJSON(str) { return new BigNumber(str, 16); }\n    /**\n     * Creates a BigNumber from a number.\n     *\n     * @static\n     * @method fromNumber\n     * @param n - The number to create a BigNumber from.\n     * @returns Returns a BigNumber equivalent to the input number.\n     */\n    static fromNumber(n) { return new BigNumber(n); }\n    /**\n     * Creates a BigNumber from a string, considering an optional base.\n     *\n     * @static\n     * @method fromString\n     * @param str - The string to create a BigNumber from.\n     * @param base - The base used for conversion. If not provided, base 10 is assumed.\n     * @returns Returns a BigNumber equivalent to the string after conversion from the specified base.\n     */\n    static fromString(str, base) { return new BigNumber(str, base); }\n    /**\n     * Creates a BigNumber from a signed magnitude number.\n     *\n     * @static\n     * @method fromSm\n     * @param bytes - The signed magnitude number to convert to a BigNumber.\n     * @param endian - Defines endianess. If not provided, big endian is assumed.\n     * @returns Returns a BigNumber equivalent to the signed magnitude number interpreted with specified endianess.\n     */\n    static fromSm(bytes, endian = 'big') {\n        if (bytes.length === 0)\n            return new BigNumber(0n);\n        let sign = 0;\n        let hex = '';\n        if (endian === 'little') {\n            const last = bytes.length - 1;\n            let firstByte = bytes[last];\n            if ((firstByte & 0x80) !== 0) {\n                sign = 1;\n                firstByte &= 0x7f;\n            }\n            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);\n            for (let i = last - 1; i >= 0; i--) {\n                const b = bytes[i];\n                hex += (b < 16 ? '0' : '') + b.toString(16);\n            }\n        }\n        else {\n            let firstByte = bytes[0];\n            if ((firstByte & 0x80) !== 0) {\n                sign = 1;\n                firstByte &= 0x7f;\n            }\n            hex += (firstByte < 16 ? '0' : '') + firstByte.toString(16);\n            for (let i = 1; i < bytes.length; i++) {\n                const b = bytes[i];\n                hex += (b < 16 ? '0' : '') + b.toString(16);\n            }\n        }\n        const mag = hex === '' ? 0n : BigInt('0x' + hex);\n        const r = new BigNumber(0n);\n        r._initializeState(mag, sign);\n        return r;\n    }\n    /**\n     * Converts this BigNumber to a signed magnitude number.\n     *\n     * @method toSm\n     * @param endian - Defines endianess. If not provided, big endian is assumed.\n     * @returns Returns an array equivalent to this BigNumber interpreted as a signed magnitude with specified endianess.\n     */\n    toSm(endian = 'big') {\n        if (this._magnitude === 0n) {\n            return this._sign === 1 ? [0x80] : [];\n        }\n        let hex = this._getMinimalHex();\n        if (hex.length % 2 !== 0)\n            hex = '0' + hex;\n        const byteLen = hex.length / 2;\n        const bytes = new Array(byteLen);\n        for (let i = 0, j = 0; i < hex.length; i += 2) {\n            bytes[j++] = parseInt(hex.slice(i, i + 2), 16);\n        }\n        if (this._sign === 1) {\n            if ((bytes[0] & 0x80) !== 0)\n                bytes.unshift(0x80);\n            else\n                bytes[0] |= 0x80;\n        }\n        else if ((bytes[0] & 0x80) !== 0) {\n            bytes.unshift(0x00);\n        }\n        return endian === 'little' ? bytes.reverse() : bytes;\n    }\n    /**\n     * Creates a BigNumber from a number representing the \"bits\" value in a block header.\n     *\n     * @static\n     * @method fromBits\n     * @param bits - The number representing the bits value in a block header.\n     * @param strict - If true, an error is thrown if the number has negative bit set.\n     * @returns Returns a BigNumber equivalent to the \"bits\" value in a block header.\n     * @throws Will throw an error if `strict` is `true` and the number has negative bit set.\n     */\n    static fromBits(bits, strict = false) {\n        const nSize = bits >>> 24;\n        const nWordCompact = bits & 0x007fffff;\n        const isNegativeFromBit = (bits & 0x00800000) !== 0;\n        if (strict && isNegativeFromBit) {\n            throw new Error('negative bit set');\n        }\n        if (nSize === 0 && nWordCompact === 0) {\n            if (isNegativeFromBit && strict)\n                throw new Error('negative bit set for zero value');\n            return new BigNumber(0n);\n        }\n        const bn = new BigNumber(nWordCompact);\n        // This logic comes from original bn.js `fromCompact`\n        if (nSize <= 3) {\n            bn.iushrn((3 - nSize) * 8);\n        }\n        else {\n            bn.iushln((nSize - 3) * 8);\n        }\n        if (isNegativeFromBit) {\n            bn.ineg();\n        }\n        return bn;\n    }\n    /**\n     * Converts this BigNumber to a number representing the \"bits\" value in a block header.\n     *\n     * @method toBits\n     * @returns Returns a number equivalent to the \"bits\" value in a block header.\n     */\n    toBits() {\n        this.strip();\n        if (this.isZero() && !this.isNeg())\n            return 0;\n        const isActualNegative = this.isNeg();\n        const bnAbs = this.abs(); // Work with absolute value for magnitude\n        // Get byte array of absolute value\n        let mB = bnAbs.toArray('be'); // Minimal byte array\n        // Remove leading zeros from byte array, if any (toArray('be') might already do this if no length specified)\n        let firstNonZeroIdx = 0;\n        while (firstNonZeroIdx < mB.length - 1 && mB[firstNonZeroIdx] === 0) { // Keep last byte if it's [0]\n            firstNonZeroIdx++;\n        }\n        mB = mB.slice(firstNonZeroIdx);\n        let nSize = mB.length;\n        if (nSize === 0 && !bnAbs.isZero()) { // Should not happen if bnAbs is truly non-zero and toArray is correct\n            mB = [0]; // Should not be needed if toArray works for small numbers\n            nSize = 1;\n        }\n        if (bnAbs.isZero()) { // if original was, e.g., -0, bnAbs is 0.\n            nSize = 0; // Size for 0 is 0, unless it's negative 0 to be encoded\n            mB = [];\n        }\n        let nWordNum;\n        if (nSize === 0) {\n            nWordNum = 0;\n        }\n        else if (nSize <= 3) {\n            nWordNum = 0;\n            for (let i = 0; i < nSize; i++) {\n                nWordNum = (nWordNum << 8) | mB[i];\n            }\n        }\n        else { // nSize > 3\n            nWordNum = (mB[0] << 16) | (mB[1] << 8) | mB[2];\n        }\n        if ((nWordNum & 0x00800000) !== 0 && nSize <= 0xff) { // MSB of 3-byte mantissa is set\n            nWordNum >>>= 8; // Shift mantissa over by one byte\n            nSize++; // Increase size component by one\n        }\n        let b = (nSize << 24) | nWordNum;\n        if (isActualNegative)\n            b |= 0x00800000;\n        return b >>> 0;\n    }\n    /**\n     * Creates a BigNumber from the format used in Bitcoin scripts.\n     *\n     * @static\n     * @method fromScriptNum\n     * @param num - The number in the format used in Bitcoin scripts.\n     * @param requireMinimal - If true, non-minimally encoded values will throw an error.\n     * @param maxNumSize - The maximum allowed size for the number.\n     * @returns Returns a BigNumber equivalent to the number used in a Bitcoin script.\n     */\n    static fromScriptNum(num, requireMinimal = false, maxNumSize) {\n        if (maxNumSize !== undefined && num.length > maxNumSize)\n            throw new Error('script number overflow');\n        if (num.length === 0)\n            return new BigNumber(0n);\n        if (requireMinimal) {\n            if ((num[num.length - 1] & 0x7f) === 0) {\n                if (num.length <= 1 || (num[num.length - 2] & 0x80) === 0) {\n                    throw new Error('non-minimally encoded script number');\n                }\n            }\n        }\n        return BigNumber.fromSm(num, 'little');\n    }\n    /**\n     * Converts this BigNumber to a number in the format used in Bitcoin scripts.\n     *\n     * @method toScriptNum\n     * @returns Returns the equivalent to this BigNumber as a Bitcoin script number.\n     */\n    toScriptNum() { return this.toSm('little'); }\n    /**\n     * Compute the multiplicative inverse of the current BigNumber in the modulus field specified by `p`.\n     * The multiplicative inverse is a number which when multiplied with the current BigNumber gives '1' in the modulus field.\n     *\n     * @method _invmp\n     * @param p - The `BigNumber` specifying the modulus field.\n     * @returns The multiplicative inverse `BigNumber` in the modulus field specified by `p`.\n     */\n    _invmp(p) {\n        this.assert(p._sign === 0, 'p must not be negative for _invmp');\n        this.assert(!p.isZero(), 'p must not be zero for _invmp');\n        const aBN = this.umod(p);\n        let aVal = aBN._magnitude;\n        let bVal = p._magnitude;\n        let x1Val = 1n;\n        let x2Val = 0n;\n        const modulus = p._magnitude;\n        while (aVal > 1n && bVal > 1n) {\n            let i = 0;\n            while (((aVal >> BigInt(i)) & 1n) === 0n)\n                i++;\n            if (i > 0) {\n                aVal >>= BigInt(i);\n                for (let k = 0; k < i; ++k) {\n                    if ((x1Val & 1n) !== 0n)\n                        x1Val += modulus;\n                    x1Val >>= 1n;\n                }\n            }\n            let j = 0;\n            while (((bVal >> BigInt(j)) & 1n) === 0n)\n                j++;\n            if (j > 0) {\n                bVal >>= BigInt(j);\n                for (let k = 0; k < j; ++k) {\n                    if ((x2Val & 1n) !== 0n)\n                        x2Val += modulus;\n                    x2Val >>= 1n;\n                }\n            }\n            if (aVal >= bVal) {\n                aVal -= bVal;\n                x1Val -= x2Val;\n            }\n            else {\n                bVal -= aVal;\n                x2Val -= x1Val;\n            }\n        }\n        let resultVal;\n        if (aVal === 1n)\n            resultVal = x1Val;\n        else if (bVal === 1n)\n            resultVal = x2Val;\n        else if (aVal === 0n && bVal === 1n)\n            resultVal = x2Val;\n        else if (bVal === 0n && aVal === 1n)\n            resultVal = x1Val;\n        else\n            throw new Error('_invmp: GCD is not 1, inverse does not exist. aVal=' + aVal + ', bVal=' + bVal);\n        resultVal %= modulus;\n        if (resultVal < 0n)\n            resultVal += modulus;\n        const resultBN = new BigNumber(0n);\n        resultBN._initializeState(resultVal, 0);\n        return resultBN;\n    }\n    /**\n     * Performs multiplication between the BigNumber instance and a given BigNumber.\n     * It chooses the multiplication method based on the lengths of the numbers to optimize execution time.\n     *\n     * @method mulTo\n     * @param num - The BigNumber multiply with.\n     * @param out - The BigNumber where to store the result.\n     * @returns The BigNumber resulting from the multiplication operation.\n     */\n    mulTo(num, out) {\n        out._magnitude = this._magnitude * num._magnitude;\n        out._sign = out._magnitude === 0n ? 0 : (this._sign ^ num._sign);\n        out._nominalWordLength = this.length + num.length;\n        out.red = null;\n        out.normSign();\n        return out;\n    }\n}\n//# sourceMappingURL=BigNumber.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Curve)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _ReductionContext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReductionContext.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js\");\n/* harmony import */ var _MontgomoryMethod_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MontgomoryMethod.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/MontgomoryMethod.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\n\n// This ensures that only one curve is ever created, enhancing performance.\n// This assumes there is never a need to have multiple distinct Curve instances.\n// So far, this assumption has proven to be valid.\nlet globalCurve;\nclass Curve {\n    p;\n    red;\n    redN;\n    zero;\n    one;\n    two;\n    g;\n    n;\n    a;\n    b;\n    tinv;\n    zeroA;\n    threeA;\n    endo; // beta, lambda, basis\n    _endoWnafT1;\n    _endoWnafT2;\n    _wnafT1;\n    _wnafT2;\n    _wnafT3;\n    _wnafT4;\n    _bitLength;\n    // Represent num in a w-NAF form\n    static assert(expression, message = 'Elliptic curve assertion failed') {\n        if (!expression) {\n            throw new Error(message);\n        }\n    }\n    getNAF(num, w, bits) {\n        const naf = new Array(Math.max(num.bitLength(), bits) + 1);\n        naf.fill(0);\n        const ws = 1 << (w + 1);\n        const k = num.clone();\n        for (let i = 0; i < naf.length; i++) {\n            let z;\n            const mod = k.andln(ws - 1);\n            if (k.isOdd()) {\n                if (mod > (ws >> 1) - 1) {\n                    z = (ws >> 1) - mod;\n                }\n                else {\n                    z = mod;\n                }\n                k.isubn(z);\n            }\n            else {\n                z = 0;\n            }\n            naf[i] = z;\n            k.iushrn(1);\n        }\n        return naf;\n    }\n    // Represent k1, k2 in a Joint Sparse Form\n    getJSF(k1, k2) {\n        const jsf = [[], []];\n        k1 = k1.clone();\n        k2 = k2.clone();\n        let d1 = 0;\n        let d2 = 0;\n        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n            // First phase\n            let m14 = (k1.andln(3) + d1) & 3;\n            let m24 = (k2.andln(3) + d2) & 3;\n            if (m14 === 3) {\n                m14 = -1;\n            }\n            if (m24 === 3) {\n                m24 = -1;\n            }\n            let u1;\n            if ((m14 & 1) === 0) {\n                u1 = 0;\n            }\n            else {\n                const m8 = (k1.andln(7) + d1) & 7;\n                if ((m8 === 3 || m8 === 5) && m24 === 2) {\n                    u1 = -m14;\n                }\n                else {\n                    u1 = m14;\n                }\n            }\n            jsf[0].push(u1);\n            let u2;\n            if ((m24 & 1) === 0) {\n                u2 = 0;\n            }\n            else {\n                const m8 = (k2.andln(7) + d2) & 7;\n                if ((m8 === 3 || m8 === 5) && m14 === 2) {\n                    u2 = -m24;\n                }\n                else {\n                    u2 = m24;\n                }\n            }\n            jsf[1].push(u2);\n            // Second phase\n            if (2 * d1 === u1 + 1) {\n                d1 = 1 - d1;\n            }\n            if (2 * d2 === u2 + 1) {\n                d2 = 1 - d2;\n            }\n            k1.iushrn(1);\n            k2.iushrn(1);\n        }\n        return jsf;\n    }\n    static cachedProperty(obj, name, computer) {\n        const key = '_' + name;\n        obj.prototype[name] = function cachedProperty() {\n            const r = this[key] !== undefined ? this[key] : (this[key] = computer.call(this));\n            return r;\n        };\n    }\n    static parseBytes(bytes) {\n        return typeof bytes === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toArray)(bytes, 'hex') : bytes;\n    }\n    static intFromLE(bytes) {\n        return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bytes, 'hex', 'le');\n    }\n    constructor() {\n        if (typeof globalCurve !== 'undefined') {\n            return globalCurve;\n        }\n        else {\n            /* eslint-disable @typescript-eslint/no-this-alias */\n            globalCurve = this;\n        }\n        const precomputed = {\n            doubles: {\n                step: 4,\n                points: [\n                    [\n                        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',\n                        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'\n                    ],\n                    [\n                        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',\n                        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'\n                    ],\n                    [\n                        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',\n                        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'\n                    ],\n                    [\n                        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',\n                        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'\n                    ],\n                    [\n                        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',\n                        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'\n                    ],\n                    [\n                        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',\n                        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'\n                    ],\n                    [\n                        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',\n                        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'\n                    ],\n                    [\n                        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',\n                        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'\n                    ],\n                    [\n                        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',\n                        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'\n                    ],\n                    [\n                        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',\n                        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'\n                    ],\n                    [\n                        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',\n                        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'\n                    ],\n                    [\n                        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',\n                        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'\n                    ],\n                    [\n                        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',\n                        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'\n                    ],\n                    [\n                        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',\n                        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'\n                    ],\n                    [\n                        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',\n                        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'\n                    ],\n                    [\n                        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',\n                        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'\n                    ],\n                    [\n                        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',\n                        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'\n                    ],\n                    [\n                        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',\n                        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'\n                    ],\n                    [\n                        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',\n                        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'\n                    ],\n                    [\n                        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',\n                        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'\n                    ],\n                    [\n                        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',\n                        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'\n                    ],\n                    [\n                        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',\n                        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'\n                    ],\n                    [\n                        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',\n                        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'\n                    ],\n                    [\n                        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',\n                        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'\n                    ],\n                    [\n                        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',\n                        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'\n                    ],\n                    [\n                        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',\n                        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'\n                    ],\n                    [\n                        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',\n                        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'\n                    ],\n                    [\n                        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',\n                        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'\n                    ],\n                    [\n                        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',\n                        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'\n                    ],\n                    [\n                        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',\n                        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'\n                    ],\n                    [\n                        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',\n                        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'\n                    ],\n                    [\n                        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',\n                        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'\n                    ],\n                    [\n                        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',\n                        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'\n                    ],\n                    [\n                        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',\n                        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'\n                    ],\n                    [\n                        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',\n                        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'\n                    ],\n                    [\n                        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',\n                        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'\n                    ],\n                    [\n                        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',\n                        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'\n                    ],\n                    [\n                        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',\n                        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'\n                    ],\n                    [\n                        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',\n                        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'\n                    ],\n                    [\n                        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',\n                        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'\n                    ],\n                    [\n                        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',\n                        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'\n                    ],\n                    [\n                        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',\n                        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'\n                    ],\n                    [\n                        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',\n                        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'\n                    ],\n                    [\n                        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',\n                        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'\n                    ],\n                    [\n                        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',\n                        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'\n                    ],\n                    [\n                        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',\n                        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'\n                    ],\n                    [\n                        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',\n                        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'\n                    ],\n                    [\n                        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',\n                        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'\n                    ],\n                    [\n                        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',\n                        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'\n                    ],\n                    [\n                        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',\n                        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'\n                    ],\n                    [\n                        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',\n                        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'\n                    ],\n                    [\n                        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',\n                        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'\n                    ],\n                    [\n                        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',\n                        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'\n                    ],\n                    [\n                        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',\n                        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'\n                    ],\n                    [\n                        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',\n                        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'\n                    ],\n                    [\n                        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',\n                        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'\n                    ],\n                    [\n                        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',\n                        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'\n                    ],\n                    [\n                        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',\n                        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'\n                    ],\n                    [\n                        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',\n                        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'\n                    ],\n                    [\n                        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',\n                        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'\n                    ],\n                    [\n                        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',\n                        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'\n                    ],\n                    [\n                        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',\n                        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'\n                    ],\n                    [\n                        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',\n                        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'\n                    ],\n                    [\n                        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',\n                        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'\n                    ],\n                    [\n                        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',\n                        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'\n                    ]\n                ]\n            },\n            naf: {\n                wnd: 7,\n                points: [\n                    [\n                        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',\n                        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'\n                    ],\n                    [\n                        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',\n                        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'\n                    ],\n                    [\n                        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',\n                        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'\n                    ],\n                    [\n                        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',\n                        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'\n                    ],\n                    [\n                        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',\n                        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'\n                    ],\n                    [\n                        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',\n                        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'\n                    ],\n                    [\n                        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',\n                        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'\n                    ],\n                    [\n                        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',\n                        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'\n                    ],\n                    [\n                        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',\n                        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'\n                    ],\n                    [\n                        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',\n                        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'\n                    ],\n                    [\n                        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',\n                        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'\n                    ],\n                    [\n                        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',\n                        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'\n                    ],\n                    [\n                        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',\n                        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'\n                    ],\n                    [\n                        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',\n                        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'\n                    ],\n                    [\n                        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',\n                        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'\n                    ],\n                    [\n                        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',\n                        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'\n                    ],\n                    [\n                        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',\n                        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'\n                    ],\n                    [\n                        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',\n                        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'\n                    ],\n                    [\n                        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',\n                        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'\n                    ],\n                    [\n                        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',\n                        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'\n                    ],\n                    [\n                        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',\n                        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'\n                    ],\n                    [\n                        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',\n                        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'\n                    ],\n                    [\n                        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',\n                        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'\n                    ],\n                    [\n                        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',\n                        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'\n                    ],\n                    [\n                        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',\n                        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'\n                    ],\n                    [\n                        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',\n                        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'\n                    ],\n                    [\n                        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',\n                        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'\n                    ],\n                    [\n                        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',\n                        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'\n                    ],\n                    [\n                        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',\n                        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'\n                    ],\n                    [\n                        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',\n                        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'\n                    ],\n                    [\n                        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',\n                        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'\n                    ],\n                    [\n                        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',\n                        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'\n                    ],\n                    [\n                        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',\n                        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'\n                    ],\n                    [\n                        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',\n                        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'\n                    ],\n                    [\n                        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',\n                        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'\n                    ],\n                    [\n                        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',\n                        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'\n                    ],\n                    [\n                        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',\n                        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'\n                    ],\n                    [\n                        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',\n                        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'\n                    ],\n                    [\n                        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',\n                        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'\n                    ],\n                    [\n                        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',\n                        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'\n                    ],\n                    [\n                        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',\n                        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'\n                    ],\n                    [\n                        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',\n                        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'\n                    ],\n                    [\n                        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',\n                        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'\n                    ],\n                    [\n                        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',\n                        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'\n                    ],\n                    [\n                        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',\n                        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'\n                    ],\n                    [\n                        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',\n                        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'\n                    ],\n                    [\n                        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',\n                        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'\n                    ],\n                    [\n                        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',\n                        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'\n                    ],\n                    [\n                        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',\n                        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'\n                    ],\n                    [\n                        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',\n                        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'\n                    ],\n                    [\n                        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',\n                        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'\n                    ],\n                    [\n                        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',\n                        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'\n                    ],\n                    [\n                        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',\n                        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'\n                    ],\n                    [\n                        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',\n                        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'\n                    ],\n                    [\n                        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',\n                        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'\n                    ],\n                    [\n                        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',\n                        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'\n                    ],\n                    [\n                        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',\n                        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'\n                    ],\n                    [\n                        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',\n                        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'\n                    ],\n                    [\n                        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',\n                        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'\n                    ],\n                    [\n                        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',\n                        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'\n                    ],\n                    [\n                        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',\n                        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'\n                    ],\n                    [\n                        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',\n                        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'\n                    ],\n                    [\n                        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',\n                        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'\n                    ],\n                    [\n                        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',\n                        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'\n                    ],\n                    [\n                        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',\n                        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'\n                    ],\n                    [\n                        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',\n                        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'\n                    ],\n                    [\n                        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',\n                        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'\n                    ],\n                    [\n                        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',\n                        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'\n                    ],\n                    [\n                        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',\n                        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'\n                    ],\n                    [\n                        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',\n                        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'\n                    ],\n                    [\n                        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',\n                        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'\n                    ],\n                    [\n                        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',\n                        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'\n                    ],\n                    [\n                        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',\n                        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'\n                    ],\n                    [\n                        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',\n                        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'\n                    ],\n                    [\n                        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',\n                        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'\n                    ],\n                    [\n                        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',\n                        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'\n                    ],\n                    [\n                        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',\n                        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'\n                    ],\n                    [\n                        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',\n                        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'\n                    ],\n                    [\n                        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',\n                        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'\n                    ],\n                    [\n                        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',\n                        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'\n                    ],\n                    [\n                        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',\n                        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'\n                    ],\n                    [\n                        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',\n                        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'\n                    ],\n                    [\n                        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',\n                        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'\n                    ],\n                    [\n                        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',\n                        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'\n                    ],\n                    [\n                        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',\n                        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'\n                    ],\n                    [\n                        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',\n                        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'\n                    ],\n                    [\n                        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',\n                        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'\n                    ],\n                    [\n                        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',\n                        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'\n                    ],\n                    [\n                        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',\n                        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'\n                    ],\n                    [\n                        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',\n                        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'\n                    ],\n                    [\n                        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',\n                        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'\n                    ],\n                    [\n                        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',\n                        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'\n                    ],\n                    [\n                        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',\n                        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'\n                    ],\n                    [\n                        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',\n                        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'\n                    ],\n                    [\n                        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',\n                        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'\n                    ],\n                    [\n                        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',\n                        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'\n                    ],\n                    [\n                        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',\n                        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'\n                    ],\n                    [\n                        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',\n                        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'\n                    ],\n                    [\n                        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',\n                        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'\n                    ],\n                    [\n                        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',\n                        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'\n                    ],\n                    [\n                        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',\n                        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'\n                    ],\n                    [\n                        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',\n                        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'\n                    ],\n                    [\n                        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',\n                        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'\n                    ],\n                    [\n                        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',\n                        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'\n                    ],\n                    [\n                        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',\n                        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'\n                    ],\n                    [\n                        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',\n                        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'\n                    ],\n                    [\n                        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',\n                        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'\n                    ],\n                    [\n                        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',\n                        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'\n                    ],\n                    [\n                        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',\n                        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'\n                    ],\n                    [\n                        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',\n                        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'\n                    ],\n                    [\n                        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',\n                        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'\n                    ],\n                    [\n                        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',\n                        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'\n                    ],\n                    [\n                        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',\n                        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'\n                    ],\n                    [\n                        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',\n                        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'\n                    ],\n                    [\n                        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',\n                        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'\n                    ],\n                    [\n                        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',\n                        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'\n                    ],\n                    [\n                        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',\n                        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'\n                    ],\n                    [\n                        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',\n                        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'\n                    ],\n                    [\n                        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',\n                        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'\n                    ],\n                    [\n                        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',\n                        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'\n                    ],\n                    [\n                        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',\n                        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'\n                    ],\n                    [\n                        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',\n                        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'\n                    ],\n                    [\n                        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',\n                        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'\n                    ],\n                    [\n                        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',\n                        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'\n                    ],\n                    [\n                        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',\n                        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'\n                    ],\n                    [\n                        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',\n                        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'\n                    ],\n                    [\n                        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',\n                        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'\n                    ]\n                ]\n            }\n        };\n        const conf = {\n            prime: 'k256',\n            p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',\n            a: '0',\n            b: '7',\n            n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',\n            h: '1',\n            // Precomputed endomorphism\n            beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',\n            lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',\n            basis: [\n                {\n                    a: '3086d221a7d46bcde86c90e49284eb15',\n                    b: '-e4437ed6010e88286f547fa90abfe4c3'\n                },\n                {\n                    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n                    b: '3086d221a7d46bcde86c90e49284eb15'\n                }\n            ],\n            gRed: false,\n            g: [\n                '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n                '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',\n                precomputed\n            ]\n        };\n        this.p = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.p, 16);\n        // Use Montgomery, when there is no fast reduction for the prime\n        this.red = new _ReductionContext_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](conf.prime);\n        // Useful for many curves\n        this.zero = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0).toRed(this.red);\n        this.one = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1).toRed(this.red);\n        this.two = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2).toRed(this.red);\n        // Curve configuration, optional\n        this.n = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.n, 16);\n        this.g = _Point_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromJSON(conf.g, conf.gRed);\n        // Temporary arrays\n        this._wnafT1 = new Array(4);\n        this._wnafT2 = new Array(4);\n        this._wnafT3 = new Array(4);\n        this._wnafT4 = new Array(4);\n        this._bitLength = this.n.bitLength();\n        this.redN = this.n.toRed(this.red);\n        this.a = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.a, 16).toRed(this.red);\n        this.b = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.b, 16).toRed(this.red);\n        this.tinv = this.two.redInvm();\n        this.zeroA = this.a.fromRed().cmpn(0) === 0;\n        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n        // If the curve is endomorphic, precalculate beta and lambda\n        this.endo = this._getEndomorphism(conf);\n        this._endoWnafT1 = new Array(4);\n        this._endoWnafT2 = new Array(4);\n    }\n    _getEndomorphism(conf) {\n        // No efficient endomorphism\n        if (!this.zeroA || this.p.modrn(3) !== 1) {\n            return;\n        }\n        // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n        let beta;\n        let lambda;\n        if (conf.beta !== undefined) {\n            beta = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.beta, 16).toRed(this.red);\n        }\n        else {\n            const betas = this._getEndoRoots(this.p);\n            if (betas === null) {\n                throw new Error('Failed to get endomorphism roots for beta.');\n            }\n            // Choose the smallest beta\n            beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n            beta = beta.toRed(this.red);\n        }\n        if (conf.lambda !== undefined) {\n            lambda = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](conf.lambda, 16);\n        }\n        else {\n            // Choose the lambda that matches selected beta\n            const lambdas = this._getEndoRoots(this.n);\n            if (lambdas === null) {\n                throw new Error('Failed to get endomorphism roots for lambda.');\n            }\n            if (this.g == null) {\n                throw new Error('Curve generator point (g) is not defined.');\n            }\n            const gMulX = this.g.mul(lambdas[0])?.x;\n            const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;\n            if ((gMulX != null) && (gXRedMulBeta != null) && gMulX.cmp(gXRedMulBeta) === 0) {\n                lambda = lambdas[0];\n            }\n            else {\n                lambda = lambdas[1];\n                if (this.g == null) {\n                    throw new Error('Curve generator point (g) is not defined.');\n                }\n                const gMulX = this.g.mul(lambda)?.x;\n                const gXRedMulBeta = (this.g.x != null) ? this.g.x.redMul(beta) : undefined;\n                if ((gMulX == null) || (gXRedMulBeta == null)) {\n                    throw new Error('Lambda computation failed: g.mul(lambda).x or g.x.redMul(beta) is undefined.');\n                }\n                Curve.assert(gMulX.cmp(gXRedMulBeta) === 0, 'Lambda selection does not match computed beta.');\n            }\n        }\n        // Get basis vectors, used for balanced length-two representation\n        let basis;\n        if (typeof conf.basis === 'object' && conf.basis !== null) {\n            basis = conf.basis.map(function (vec) {\n                return {\n                    a: new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vec.a, 16),\n                    b: new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](vec.b, 16)\n                };\n            });\n        }\n        else {\n            basis = this._getEndoBasis(lambda);\n        }\n        return {\n            beta,\n            lambda,\n            basis\n        };\n    }\n    _getEndoRoots(num) {\n        // Find roots of for x^2 + x + 1 in F\n        // Root = (-1 +- Sqrt(-3)) / 2\n        //\n        const red = num === this.p ? this.red : new _MontgomoryMethod_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](num);\n        const tinv = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2).toRed(red).redInvm();\n        const ntinv = tinv.redNeg();\n        const s = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](3).toRed(red).redNeg().redSqrt().redMul(tinv);\n        const l1 = ntinv.redAdd(s).fromRed();\n        const l2 = ntinv.redSub(s).fromRed();\n        return [l1, l2];\n    }\n    _getEndoBasis(lambda) {\n        // aprxSqrt >= sqrt(this.n)\n        const aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n        // 3.74\n        // Run EGCD, until r(L + 1) < aprxSqrt\n        let u = lambda;\n        let v = this.n.clone();\n        let x1 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1);\n        let y1 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0);\n        let x2 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0);\n        let y2 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1);\n        // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n        let a0;\n        let b0;\n        // First vector\n        let a1;\n        let b1;\n        // Second vector\n        let a2;\n        let b2;\n        let prevR = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0);\n        let i = 0;\n        let r = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0);\n        let x = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0); // Ensure x is initialized\n        while (u.cmpn(0) !== 0) {\n            const q = v.div(u);\n            r = v.sub(q.mul(u));\n            x = x2.sub(q.mul(x1)); // Now TypeScript knows x is always assigned\n            const y = y2.sub(q.mul(y1));\n            if (a1 === undefined && r.cmp(aprxSqrt) < 0) {\n                a0 = prevR.neg();\n                b0 = x1;\n                a1 = r.neg();\n                b1 = x;\n            }\n            else if (a1 !== undefined && ++i === 2) {\n                break;\n            }\n            prevR = r;\n            v = u;\n            u = r;\n            x2 = x1;\n            x1 = x;\n            y2 = y1;\n            y1 = y;\n        }\n        // Ensure a0 and b0 have been assigned\n        if (a0 === undefined ||\n            b0 === undefined ||\n            a1 === undefined ||\n            b1 === undefined) {\n            throw new Error('Failed to compute Endo Basis values');\n        }\n        a2 = r.neg();\n        b2 = x;\n        const len1 = a1.sqr().add(b1.sqr());\n        const len2 = a2.sqr().add(b2.sqr());\n        if (len2.cmp(len1) >= 0) {\n            a2 = a0;\n            b2 = b0;\n        }\n        // Normalize signs\n        if (a1.negative !== 0) {\n            a1 = a1.neg();\n            b1 = b1.neg();\n        }\n        if (a2.negative !== 0) {\n            a2 = a2.neg();\n            b2 = b2.neg();\n        }\n        return [\n            { a: a1, b: b1 },\n            { a: a2, b: b2 }\n        ];\n    }\n    _endoSplit(k) {\n        if (this.endo == null) {\n            throw new Error('Endomorphism is not defined.');\n        }\n        const basis = this.endo.basis;\n        const v1 = basis[0];\n        const v2 = basis[1];\n        const c1 = v2.b.mul(k).divRound(this.n);\n        const c2 = v1.b.neg().mul(k).divRound(this.n);\n        const p1 = c1.mul(v1.a);\n        const p2 = c2.mul(v2.a);\n        const q1 = c1.mul(v1.b);\n        const q2 = c2.mul(v2.b);\n        // Calculate answer\n        const k1 = k.sub(p1).sub(p2);\n        const k2 = q1.add(q2).neg();\n        return { k1, k2 };\n    }\n    validate(point) {\n        if (point.inf) {\n            return true;\n        }\n        const x = point.x;\n        const y = point.y;\n        // Ensure x and y are not null before proceeding\n        if (x === null || y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        const ax = this.a.redMul(x);\n        const rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n        return y.redSqr().redISub(rhs).cmpn(0) === 0;\n    }\n}\n//# sourceMappingURL=Curve.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DRBG)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n/**\n * This class behaves as a HMAC-based deterministic random bit generator (DRBG). It implements a deterministic random number generator using SHA256HMAC HASH function. It takes an initial entropy and nonce when instantiated for seeding purpose.\n * @class DRBG\n *\n * @constructor\n * @param entropy - Initial entropy either in number array or hexadecimal string.\n * @param nonce - Initial nonce either in number array or hexadecimal string.\n *\n * @throws Throws an error message 'Not enough entropy. Minimum is 256 bits' when entropy's length is less than 32.\n *\n * @example\n * const drbg = new DRBG('af12de...', '123ef...');\n */\nclass DRBG {\n    K;\n    V;\n    constructor(entropy, nonce) {\n        entropy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(entropy, 'hex');\n        nonce = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(nonce, 'hex');\n        if (entropy.length < 32) {\n            throw new Error('Not enough entropy. Minimum is 256 bits');\n        }\n        const seed = entropy.concat(nonce);\n        this.K = new Array(32);\n        this.V = new Array(32);\n        for (let i = 0; i < 32; i++) {\n            this.K[i] = 0x00;\n            this.V[i] = 0x01;\n        }\n        this.update(seed);\n    }\n    /**\n     * Generates HMAC using the K value of the instance. This method is used internally for operations.\n     *\n     * @method hmac\n     * @returns The SHA256HMAC object created with K value.\n     *\n     * @example\n     * const hmac = drbg.hmac();\n     */\n    hmac() {\n        return new _Hash_js__WEBPACK_IMPORTED_MODULE_0__.SHA256HMAC(this.K);\n    }\n    /**\n     * Updates the `K` and `V` values of the instance based on the seed.\n     * The seed if not provided uses `V` as seed.\n     *\n     * @method update\n     * @param seed - an optional value that used to update `K` and `V`. Default is `undefined`.\n     * @returns Nothing, but updates the internal state `K` and `V` value.\n     *\n     * @example\n     * drbg.update('e13af...');\n     */\n    update(seed) {\n        let kmac = this.hmac().update(this.V).update([0x00]);\n        if (seed !== undefined) {\n            kmac = kmac.update(seed);\n        }\n        this.K = kmac.digest();\n        this.V = this.hmac().update(this.V).digest();\n        if (seed === undefined) {\n            return;\n        }\n        this.K = this.hmac().update(this.V).update([0x01]).update(seed).digest();\n        this.V = this.hmac().update(this.V).digest();\n    }\n    /**\n     * Generates deterministic random hexadecimal string of given length.\n     * In every generation process, it also updates the internal state `K` and `V`.\n     *\n     * @method generate\n     * @param len - The length of required random number.\n     * @returns The required deterministic random hexadecimal string.\n     *\n     * @example\n     * const randomHex = drbg.generate(256);\n     */\n    generate(len) {\n        let temp = [];\n        while (temp.length < len) {\n            this.V = this.hmac().update(this.V).digest();\n            temp = temp.concat(this.V);\n        }\n        const res = temp.slice(0, len);\n        this.update();\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(res);\n    }\n}\n//# sourceMappingURL=DRBG.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sign: () => (/* binding */ sign),\n/* harmony export */   verify: () => (/* binding */ verify)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _DRBG_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DRBG.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js\");\n\n\n\n\n\n/**\n * Truncates a BigNumber message to the length of the curve order n, in the context of the Elliptic Curve Digital Signature Algorithm (ECDSA).\n * This method is used as part of ECDSA signing and verification.\n *\n * The method calculates `delta`, which is a difference obtained by subtracting the bit length of the curve order `n` from the byte length of the message in bits.\n * If `delta` is greater than zero, logical shifts msg to the right by `delta`, retaining the sign.\n *\n * Another condition is tested, but only if `truncOnly` is false. This condition compares the value of msg to curve order `n`.\n * If msg is greater or equal to `n`, it is decreased by `n` and returned.\n *\n * @method truncateToN\n * @param msg - The BigNumber message to be truncated.\n * @param truncOnly - An optional boolean parameter that if set to true, the method will only perform truncation of the BigNumber without doing the additional subtraction from the curve order.\n * @returns Returns the truncated BigNumber value, potentially subtracted by the curve order n.\n *\n * @example\n * let msg = new BigNumber('1234567890abcdef', 16);\n * let truncatedMsg = truncateToN(msg);\n */\nfunction truncateToN(msg, truncOnly, curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]()) {\n    const delta = msg.byteLength() * 8 - curve.n.bitLength();\n    if (delta > 0) {\n        msg.iushrn(delta);\n    }\n    if (truncOnly === null && msg.cmp(curve.n) >= 0) {\n        return msg.sub(curve.n);\n    }\n    else {\n        return msg;\n    }\n}\nconst curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\nconst bytes = curve.n.byteLength();\nconst ns1 = curve.n.subn(1);\nconst halfN = _Point_js__WEBPACK_IMPORTED_MODULE_3__.N_BIGINT >> 1n;\n/**\n * Generates a digital signature for a given message.\n *\n * @function sign\n * @param msg - The BigNumber message for which the signature has to be computed.\n * @param key - Private key in BigNumber.\n * @param forceLowS - Optional boolean flag if True forces \"s\" to be the lower of two possible values.\n * @param customK - Optional specification for k value, which can be a function or BigNumber.\n * @returns Returns the elliptic curve digital signature of the message.\n *\n * @example\n * const msg = new BigNumber('2664878')\n * const key = new BigNumber('123456')\n * const signature = sign(msg, key)\n */\nconst sign = (msg, key, forceLowS = false, customK) => {\n    //  prepare inputs \n    msg = truncateToN(msg);\n    const msgBig = BigInt('0x' + msg.toString(16));\n    const keyBig = BigInt('0x' + key.toString(16));\n    // DRBG seeding identical to previous implementation\n    const bkey = key.toArray('be', bytes);\n    const nonce = msg.toArray('be', bytes);\n    const drbg = new _DRBG_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](bkey, nonce);\n    for (let iter = 0;; iter++) {\n        //  k generation & basic validity checks \n        let kBN = typeof customK === 'function'\n            ? customK(iter)\n            : _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBN(customK)\n                ? customK\n                : new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](drbg.generate(bytes), 16);\n        if (kBN == null)\n            throw new Error('k is undefined');\n        kBN = truncateToN(kBN, true);\n        if (kBN.cmpn(1) <= 0 || kBN.cmp(ns1) >= 0) {\n            if (_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (must be >1 and <N1)');\n            }\n            continue;\n        }\n        const kBig = BigInt('0x' + kBN.toString(16));\n        //  R = kG (Jacobian, windowNAF) \n        const R = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.scalarMultiplyWNAF)(kBig, { x: _Point_js__WEBPACK_IMPORTED_MODULE_3__.GX_BIGINT, y: _Point_js__WEBPACK_IMPORTED_MODULE_3__.GY_BIGINT });\n        if (R.Z === 0n) { // point at infinity  should never happen for valid k\n            if (_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (kG at infinity)');\n            }\n            continue;\n        }\n        // affine X coordinate of R\n        const zInv = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModInv)(R.Z);\n        const zInv2 = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModMul)(zInv, zInv);\n        const xAff = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModMul)(R.X, zInv2);\n        const rBig = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modN)(xAff);\n        if (rBig === 0n) {\n            if (_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (r == 0)');\n            }\n            continue;\n        }\n        //  s = k  (msg + rkey)  mod n \n        const kInv = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modInvN)(kBig);\n        const rTimesKey = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modMulN)(rBig, keyBig);\n        const sum = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modN)(msgBig + rTimesKey);\n        let sBig = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modMulN)(kInv, sum);\n        if (sBig === 0n) {\n            if (_BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isBN(customK)) {\n                throw new Error('Invalid fixed custom K value (s == 0)');\n            }\n            continue;\n        }\n        // lowS mitigation (BIP62/BIP340 style)\n        if (forceLowS && sBig > halfN) {\n            sBig = _Point_js__WEBPACK_IMPORTED_MODULE_3__.N_BIGINT - sBig;\n        }\n        //  convert back to BigNumber & return \n        const r = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](rBig.toString(16), 16);\n        const s = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](sBig.toString(16), 16);\n        return new _Signature_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](r, s);\n    }\n};\n/**\n * Verifies a digital signature of a given message.\n *\n * Message and key used during the signature generation process, and the previously computed signature\n * are used to validate the authenticity of the digital signature.\n *\n * @function verify\n * @param msg - The BigNumber message for which the signature has to be verified.\n * @param sig - Signature object consisting of parameters 'r' and 's'.\n * @param key - Public key in Point.\n * @returns Returns true if the signature is valid and false otherwise.\n *\n * @example\n * const msg = new BigNumber('2664878', 16)\n * const key = new Point(new BigNumber(10), new BigNumber(20)\n * const signature = sign(msg, new BigNumber('123456'))\n * const isVerified = verify(msg, sig, key)\n */\nconst verify = (msg, sig, key) => {\n    // Convert inputs to BigInt\n    const hash = BigInt('0x' + msg.toString(16));\n    if ((key.x == null) || (key.y == null)) {\n        throw new Error('Invalid public key: missing coordinates.');\n    }\n    const publicKey = {\n        x: BigInt('0x' + key.x.toString(16)),\n        y: BigInt('0x' + key.y.toString(16))\n    };\n    const signature = {\n        r: BigInt('0x' + sig.r.toString(16)),\n        s: BigInt('0x' + sig.s.toString(16))\n    };\n    const { r, s } = signature;\n    const z = hash;\n    // Check r and s are in [1, n - 1]\n    if (r <= _Point_js__WEBPACK_IMPORTED_MODULE_3__.BI_ZERO || r >= _Point_js__WEBPACK_IMPORTED_MODULE_3__.N_BIGINT || s <= _Point_js__WEBPACK_IMPORTED_MODULE_3__.BI_ZERO || s >= _Point_js__WEBPACK_IMPORTED_MODULE_3__.N_BIGINT) {\n        return false;\n    }\n    //  compute u = zs mod n  and  u = rs mod n \n    const w = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modInvN)(s); // s mod n\n    if (w === 0n)\n        return false; // should never happen\n    const u1 = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modMulN)(z, w);\n    const u2 = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modMulN)(r, w);\n    //  R = uG + uQ  (Jacobian, windowNAF) \n    const RG = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.scalarMultiplyWNAF)(u1, { x: _Point_js__WEBPACK_IMPORTED_MODULE_3__.GX_BIGINT, y: _Point_js__WEBPACK_IMPORTED_MODULE_3__.GY_BIGINT });\n    const RQ = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.scalarMultiplyWNAF)(u2, publicKey);\n    const R = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.jpAdd)(RG, RQ);\n    if (R.Z === 0n)\n        return false; // point at infinity\n    //  affine xcoordinate of R  (mod p) \n    const zInv = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModInv)(R.Z); // (Z mod p)\n    const zInv2 = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModMul)(zInv, zInv); // Z\n    const xAff = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.biModMul)(R.X, zInv2); // X / Z  mod p\n    //  v = xAff mod n  and final check \n    const v = (0,_Point_js__WEBPACK_IMPORTED_MODULE_3__.modN)(xAff);\n    return v === r;\n};\n//# sourceMappingURL=ECDSA.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   SHA1: () => (/* binding */ SHA1),\n/* harmony export */   SHA1HMAC: () => (/* binding */ SHA1HMAC),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA256HMAC: () => (/* binding */ SHA256HMAC),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512HMAC: () => (/* binding */ SHA512HMAC),\n/* harmony export */   hash160: () => (/* binding */ hash160),\n/* harmony export */   hash256: () => (/* binding */ hash256),\n/* harmony export */   pbkdf2: () => (/* binding */ pbkdf2),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha1: () => (/* binding */ sha1),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha256hmac: () => (/* binding */ sha256hmac),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512hmac: () => (/* binding */ sha512hmac),\n/* harmony export */   toArray: () => (/* binding */ toArray)\n/* harmony export */ });\n// @ts-nocheck\n/* eslint-disable @typescript-eslint/naming-convention */\nconst assert = (expression, message = 'Hash assertion failed') => {\n    if (!expression) {\n        throw new Error(message);\n    }\n};\n/**\n * The BaseHash class is an abstract base class for cryptographic hash functions.\n * It provides a common structure and functionality for hash function classes.\n *\n * @class BaseHash\n *\n * @property pending - Stores partially processed message segments.\n * @property pendingTotal - The total number of characters that are being stored in `pending`\n * @property blockSize - The size of each block to processed.\n * @property outSize - The size of the final hash output.\n * @property endian - The endianness used during processing, can either be 'big' or 'little'.\n * @property _delta8 - The block size divided by 8, useful in various computations.\n * @property _delta32 - The block size divided by 32, useful in various computations.\n * @property padLength - The length of padding to be added to finalize the computation.\n * @property hmacStrength - The HMAC strength value.\n *\n * @param blockSize - The size of the block to be hashed.\n * @param outSize - The size of the resulting hash.\n * @param hmacStrength - The strength of the HMAC.\n * @param padLength - The length of the padding to be added.\n *\n * @example\n * Sub-classes would extend this base BaseHash class like:\n * class RIPEMD160 extends BaseHash {\n *   constructor () {\n *     super(512, 160, 192, 64);\n *     // ...\n *   }\n *   // ...\n * }\n */\nclass BaseHash {\n    pending;\n    pendingTotal;\n    blockSize;\n    outSize;\n    endian;\n    _delta8;\n    _delta32;\n    padLength;\n    hmacStrength;\n    constructor(blockSize, outSize, hmacStrength, padLength) {\n        this.pending = null;\n        this.pendingTotal = 0;\n        this.blockSize = blockSize;\n        this.outSize = outSize;\n        this.hmacStrength = hmacStrength;\n        this.padLength = padLength / 8;\n        this.endian = 'big';\n        this._delta8 = this.blockSize / 8;\n        this._delta32 = this.blockSize / 32;\n    }\n    _update(msg, start) {\n        throw new Error('Not implemented');\n    }\n    _digest() {\n        throw new Error('Not implemented');\n    }\n    _digestHex() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * Converts the input message into an array, pads it, and joins into 32bit blocks.\n     * If there is enough data, it tries updating the hash computation.\n     *\n     * @method update\n     * @param msg - The message segment to include in the hashing computation.\n     * @param enc - The encoding of the message. If 'hex', the string will be treated as such, 'utf8' otherwise.\n     *\n     * @returns Returns the instance of the object for chaining.\n     *\n     * @example\n     * sha256.update('Hello World', 'utf8');\n     */\n    update(msg, enc) {\n        // Convert message to array, pad it, and join into 32bit blocks\n        msg = toArray(msg, enc);\n        if (this.pending == null) {\n            this.pending = msg;\n        }\n        else {\n            this.pending = this.pending.concat(msg);\n        }\n        this.pendingTotal += msg.length;\n        // Enough data, try updating\n        if (this.pending.length >= this._delta8) {\n            msg = this.pending;\n            // Process pending data in blocks\n            const r = msg.length % this._delta8;\n            this.pending = msg.slice(msg.length - r, msg.length);\n            if (this.pending.length === 0) {\n                this.pending = null;\n            }\n            msg = join32(msg, 0, msg.length - r, this.endian);\n            for (let i = 0; i < msg.length; i += this._delta32) {\n                this._update(msg, i);\n            }\n        }\n        return this;\n    }\n    /**\n     * Finalizes the hash computation and returns the hash value/result.\n     *\n     * @method digest\n     *\n     * @returns Returns the final hash value.\n     *\n     * @example\n     * const hash = sha256.digest();\n     */\n    digest() {\n        this.update(this._pad());\n        assert(this.pending === null);\n        return this._digest();\n    }\n    /**\n     * Finalizes the hash computation and returns the hash value/result as a hex string.\n     *\n     * @method digest\n     *\n     * @returns Returns the final hash value as a hex string.\n     *\n     * @example\n     * const hash = sha256.digestHex();\n     */\n    digestHex() {\n        this.update(this._pad());\n        assert(this.pending === null);\n        return this._digestHex();\n    }\n    /**\n     * [Private Method] Used internally to prepare the padding for the final stage of the hash computation.\n     *\n     * @method _pad\n     * @private\n     *\n     * @returns Returns an array denoting the padding.\n     */\n    _pad() {\n        //\n        let len = this.pendingTotal;\n        const bytes = this._delta8;\n        const k = bytes - ((len + this.padLength) % bytes);\n        const res = new Array(k + this.padLength);\n        res[0] = 0x80;\n        let i;\n        for (i = 1; i < k; i++) {\n            res[i] = 0;\n        }\n        // Append length\n        len <<= 3;\n        let t;\n        if (this.endian === 'big') {\n            for (t = 8; t < this.padLength; t++) {\n                res[i++] = 0;\n            }\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = (len >>> 24) & 0xff;\n            res[i++] = (len >>> 16) & 0xff;\n            res[i++] = (len >>> 8) & 0xff;\n            res[i++] = len & 0xff;\n        }\n        else {\n            res[i++] = len & 0xff;\n            res[i++] = (len >>> 8) & 0xff;\n            res[i++] = (len >>> 16) & 0xff;\n            res[i++] = (len >>> 24) & 0xff;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            res[i++] = 0;\n            for (t = 8; t < this.padLength; t++) {\n                res[i++] = 0;\n            }\n        }\n        return res;\n    }\n}\nfunction isSurrogatePair(msg, i) {\n    if ((msg.charCodeAt(i) & 0xfc00) !== 0xd800) {\n        return false;\n    }\n    if (i < 0 || i + 1 >= msg.length) {\n        return false;\n    }\n    return (msg.charCodeAt(i + 1) & 0xfc00) === 0xdc00;\n}\n/**\n *\n * @param msg\n * @param enc Optional. Encoding to use if msg is string. Default is 'utf8'.\n * @returns array of byte values from msg. If msg is an array, a copy is returned.\n */\nfunction toArray(msg, enc) {\n    if (Array.isArray(msg)) {\n        return msg.slice();\n    }\n    if (!msg) {\n        return [];\n    }\n    const res = [];\n    if (typeof msg === 'string') {\n        if (enc !== 'hex') {\n            // Inspired by stringToUtf8ByteArray() in closure-library by Google\n            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt#L117-L143\n            // Apache License 2.0\n            // https://github.com/google/closure-library/blob/master/LICENSE\n            let p = 0;\n            for (let i = 0; i < msg.length; i++) {\n                let c = msg.charCodeAt(i);\n                if (c < 128) {\n                    res[p++] = c;\n                }\n                else if (c < 2048) {\n                    res[p++] = (c >> 6) | 192;\n                    res[p++] = (c & 63) | 128;\n                }\n                else if (isSurrogatePair(msg, i)) {\n                    c = 0x10000 + ((c & 0x03ff) << 10) + (msg.charCodeAt(++i) & 0x03ff);\n                    res[p++] = (c >> 18) | 240;\n                    res[p++] = ((c >> 12) & 63) | 128;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n                else {\n                    res[p++] = (c >> 12) | 224;\n                    res[p++] = ((c >> 6) & 63) | 128;\n                    res[p++] = (c & 63) | 128;\n                }\n            }\n        }\n        else {\n            msg = msg.replace(/[^a-z0-9]+/gi, '');\n            if (msg.length % 2 !== 0) {\n                msg = '0' + msg;\n            }\n            for (let i = 0; i < msg.length; i += 2) {\n                res.push(parseInt(msg[i] + msg[i + 1], 16));\n            }\n        }\n    }\n    else {\n        msg = msg;\n        for (let i = 0; i < msg.length; i++) {\n            res[i] = msg[i] | 0;\n        }\n    }\n    return res;\n}\nfunction htonl(w) {\n    const res = (w >>> 24) |\n        ((w >>> 8) & 0xff00) |\n        ((w << 8) & 0xff0000) |\n        ((w & 0xff) << 24);\n    return res >>> 0;\n}\nfunction toHex32(msg, endian) {\n    let res = '';\n    for (let i = 0; i < msg.length; i++) {\n        let w = msg[i];\n        if (endian === 'little') {\n            w = htonl(w);\n        }\n        res += zero8(w.toString(16));\n    }\n    return res;\n}\nfunction zero8(word) {\n    if (word.length === 7) {\n        return '0' + word;\n    }\n    else if (word.length === 6) {\n        return '00' + word;\n    }\n    else if (word.length === 5) {\n        return '000' + word;\n    }\n    else if (word.length === 4) {\n        return '0000' + word;\n    }\n    else if (word.length === 3) {\n        return '00000' + word;\n    }\n    else if (word.length === 2) {\n        return '000000' + word;\n    }\n    else if (word.length === 1) {\n        return '0000000' + word;\n    }\n    else {\n        return word;\n    }\n}\nfunction bytesToHex(data) {\n    let res = '';\n    for (const b of data)\n        res += b.toString(16).padStart(2, '0');\n    return res;\n}\nfunction join32(msg, start, end, endian) {\n    const len = end - start;\n    assert(len % 4 === 0);\n    const res = new Array(len / 4);\n    for (let i = 0, k = start; i < res.length; i++, k += 4) {\n        let w;\n        if (endian === 'big') {\n            w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n        }\n        else {\n            w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n        }\n        res[i] = w >>> 0;\n    }\n    return res;\n}\nfunction split32(msg, endian) {\n    const res = new Array(msg.length * 4);\n    for (let i = 0, k = 0; i < msg.length; i++, k += 4) {\n        const m = msg[i];\n        if (endian === 'big') {\n            res[k] = m >>> 24;\n            res[k + 1] = (m >>> 16) & 0xff;\n            res[k + 2] = (m >>> 8) & 0xff;\n            res[k + 3] = m & 0xff;\n        }\n        else {\n            res[k + 3] = m >>> 24;\n            res[k + 2] = (m >>> 16) & 0xff;\n            res[k + 1] = (m >>> 8) & 0xff;\n            res[k] = m & 0xff;\n        }\n    }\n    return res;\n}\nfunction rotr32(w, b) {\n    return (w >>> b) | (w << (32 - b));\n}\nfunction rotl32(w, b) {\n    return (w << b) | (w >>> (32 - b));\n}\nfunction sum32(a, b) {\n    return (a + b) >>> 0;\n}\nfunction SUM32_3(a, b, c) {\n    return (a + b + c) >>> 0;\n}\nfunction SUM32_4(a, b, c, d) {\n    return (a + b + c + d) >>> 0;\n}\nfunction SUM32_5(a, b, c, d, e) {\n    return (a + b + c + d + e) >>> 0;\n}\nfunction FT_1(s, x, y, z) {\n    if (s === 0) {\n        return ch32(x, y, z);\n    }\n    if (s === 1 || s === 3) {\n        return p32(x, y, z);\n    }\n    if (s === 2) {\n        return maj32(x, y, z);\n    }\n    return 0;\n}\nfunction ch32(x, y, z) {\n    return (x & y) ^ (~x & z);\n}\nfunction maj32(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n}\nfunction p32(x, y, z) {\n    return x ^ y ^ z;\n}\nfunction S0_256(x) {\n    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);\n}\nfunction S1_256(x) {\n    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);\n}\nfunction G0_256(x) {\n    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);\n}\nfunction G1_256(x) {\n    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);\n}\nconst r = [\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15,\n    3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11,\n    5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7,\n    12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n];\nconst rh = [\n    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5,\n    10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0,\n    4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1,\n    5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n];\nconst s = [\n    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7,\n    15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5,\n    12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5,\n    11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n];\nconst sh = [\n    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8,\n    9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14,\n    13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5,\n    12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n];\nfunction f(j, x, y, z) {\n    if (j <= 15) {\n        return x ^ y ^ z;\n    }\n    else if (j <= 31) {\n        return (x & y) | (~x & z);\n    }\n    else if (j <= 47) {\n        return (x | ~y) ^ z;\n    }\n    else if (j <= 63) {\n        return (x & z) | (y & ~z);\n    }\n    else {\n        return x ^ (y | ~z);\n    }\n}\nfunction K(j) {\n    if (j <= 15) {\n        return 0x00000000;\n    }\n    else if (j <= 31) {\n        return 0x5a827999;\n    }\n    else if (j <= 47) {\n        return 0x6ed9eba1;\n    }\n    else if (j <= 63) {\n        return 0x8f1bbcdc;\n    }\n    else {\n        return 0xa953fd4e;\n    }\n}\nfunction Kh(j) {\n    if (j <= 15) {\n        return 0x50a28be6;\n    }\n    else if (j <= 31) {\n        return 0x5c4dd124;\n    }\n    else if (j <= 47) {\n        return 0x6d703ef3;\n    }\n    else if (j <= 63) {\n        return 0x7a6d76e9;\n    }\n    else {\n        return 0x00000000;\n    }\n}\n/**\n * An implementation of RIPEMD160 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class RIPEMD160\n * @param None\n *\n * @constructor\n * Use the RIPEMD160 constructor to create an instance of RIPEMD160 hash function.\n *\n * @example\n * const ripemd160 = new RIPEMD160();\n *\n * @property h - Array that is updated iteratively as part of hashing computation.\n */\nclass RIPEMD160 extends BaseHash {\n    h;\n    constructor() {\n        super(512, 160, 192, 64);\n        this.endian = 'little';\n        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n        this.endian = 'little';\n    }\n    _update(msg, start) {\n        let A = this.h[0];\n        let B = this.h[1];\n        let C = this.h[2];\n        let D = this.h[3];\n        let E = this.h[4];\n        let Ah = A;\n        let Bh = B;\n        let Ch = C;\n        let Dh = D;\n        let Eh = E;\n        let T;\n        for (let j = 0; j < 80; j++) {\n            T = sum32(rotl32(SUM32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);\n            A = E;\n            E = D;\n            D = rotl32(C, 10);\n            C = B;\n            B = T;\n            T = sum32(rotl32(SUM32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);\n            Ah = Eh;\n            Eh = Dh;\n            Dh = rotl32(Ch, 10);\n            Ch = Bh;\n            Bh = T;\n        }\n        T = SUM32_3(this.h[1], C, Dh);\n        this.h[1] = SUM32_3(this.h[2], D, Eh);\n        this.h[2] = SUM32_3(this.h[3], E, Ah);\n        this.h[3] = SUM32_3(this.h[4], A, Bh);\n        this.h[4] = SUM32_3(this.h[0], B, Ch);\n        this.h[0] = T;\n    }\n    _digest() {\n        return split32(this.h, 'little');\n    }\n    _digestHex() {\n        return toHex32(this.h, 'little');\n    }\n}\n/**\n * An implementation of SHA256 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA256\n * @param None\n *\n * @constructor\n * Use the SHA256 constructor to create an instance of SHA256 hash function.\n *\n * @example\n * const sha256 = new SHA256();\n *\n * @property h - The initial hash constants\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-256\n */\nclass SHA256 {\n    h;\n    constructor() {\n        this.h = new FastSHA256();\n    }\n    update(msg, enc) {\n        const data = Uint8Array.from(toArray(msg, enc));\n        this.h.update(data);\n        return this;\n    }\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\n/**\n * An implementation of SHA1 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA1\n * @param None\n *\n * @constructor\n * Use the SHA1 constructor to create an instance of SHA1 hash function.\n *\n * @example\n * const sha1 = new SHA1();\n *\n * @property h - The initial hash constants.\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-1.\n */\nclass SHA1 extends BaseHash {\n    h;\n    W;\n    k;\n    constructor() {\n        super(512, 160, 80, 64);\n        this.k = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n        this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n        this.W = new Array(80);\n    }\n    _update(msg, start) {\n        const W = this.W;\n        // Default start to 0\n        if (start === undefined) {\n            start = 0;\n        }\n        let i;\n        for (i = 0; i < 16; i++) {\n            W[i] = msg[start + i];\n        }\n        for (; i < W.length; i++) {\n            W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);\n        }\n        let a = this.h[0];\n        let b = this.h[1];\n        let c = this.h[2];\n        let d = this.h[3];\n        let e = this.h[4];\n        for (i = 0; i < W.length; i++) {\n            const s = ~~(i / 20);\n            const t = SUM32_5(rotl32(a, 5), FT_1(s, b, c, d), e, W[i], this.k[s]);\n            e = d;\n            d = c;\n            c = rotl32(b, 30);\n            b = a;\n            a = t;\n        }\n        this.h[0] = sum32(this.h[0], a);\n        this.h[1] = sum32(this.h[1], b);\n        this.h[2] = sum32(this.h[2], c);\n        this.h[3] = sum32(this.h[3], d);\n        this.h[4] = sum32(this.h[4], e);\n    }\n    _digest() {\n        return split32(this.h, 'big');\n    }\n    _digestHex() {\n        return toHex32(this.h, 'big');\n    }\n}\n/**\n * An implementation of SHA512 cryptographic hash function. Extends the BaseHash class.\n * It provides a way to compute a 'digest' for any kind of input data; transforming the data\n * into a unique output of fixed size. The output is deterministic; it will always be\n * the same for the same input.\n *\n * @class SHA512\n * @param None\n *\n * @constructor\n * Use the SHA512 constructor to create an instance of SHA512 hash function.\n *\n * @example\n * const sha512 = new SHA512();\n *\n * @property h - The initial hash constants.\n * @property W - Provides a way to recycle usage of the array memory.\n * @property k - The round constants used for each round of SHA-512.\n */\nclass SHA512 {\n    h;\n    constructor() {\n        this.h = new FastSHA512();\n    }\n    update(msg, enc) {\n        const data = Uint8Array.from(toArray(msg, enc));\n        this.h.update(data);\n        return this;\n    }\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\n/**\n * The `SHA256HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-256 cryptographic hash function.\n *\n * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.\n *\n * This class also uses the SHA-256 cryptographic hash algorithm that produces a 256-bit (32-byte) hash value.\n *\n * @property inner - Represents the inner hash of SHA-256.\n * @property outer - Represents the outer hash of SHA-256.\n * @property blockSize - The block size for the SHA-256 hash function, in bytes. It's set to 64 bytes.\n * @property outSize - The output size of the SHA-256 hash function, in bytes. It's set to 32 bytes.\n */\nclass SHA256HMAC {\n    h;\n    blockSize = 64;\n    outSize = 32;\n    /**\n     * The constructor for the `SHA256HMAC` class.\n     *\n     * It initializes the `SHA256HMAC` object and sets up the inner and outer padded keys.\n     * If the key size is larger than the blockSize, it is digested using SHA-256.\n     * If the key size is less than the blockSize, it is padded with zeroes.\n     *\n     * @constructor\n     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.\n     *\n     * @example\n     * const myHMAC = new SHA256HMAC('deadbeef');\n     */\n    constructor(key) {\n        const k = Uint8Array.from(toArray(key, 'hex'));\n        this.h = new HMAC(sha256Fast, k);\n    }\n    /**\n     * Updates the `SHA256HMAC` object with part of the message to be hashed.\n     *\n     * @method update\n     * @param msg - Part of the message to hash. Can be a number array or a string.\n     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.\n     * @returns Returns the instance of `SHA256HMAC` for chaining calls.\n     *\n     * @example\n     * myHMAC.update('deadbeef', 'hex');\n     */\n    update(msg, enc) {\n        this.h.update(Uint8Array.from(toArray(msg, enc)));\n        return this;\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data. Can be a number array or a string.\n     *\n     * @example\n     * let hashedMessage = myHMAC.digest();\n     */\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash as a hex string.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a hex string\n     *\n     * @example\n     * let hashedMessage = myHMAC.digestHex();\n     */\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\nclass SHA1HMAC {\n    inner;\n    outer;\n    blockSize = 64;\n    constructor(key) {\n        key = toArray(key, 'hex');\n        // Shorten key, if needed\n        if (key.length > this.blockSize) {\n            key = new SHA1().update(key).digest();\n        }\n        // Keys shorter than block size are padded with zeros on the right\n        let i;\n        for (i = key.length; i < this.blockSize; i++) {\n            key.push(0);\n        }\n        for (i = 0; i < key.length; i++) {\n            key[i] ^= 0x36;\n        }\n        this.inner = new SHA1().update(key);\n        // 0x36 ^ 0x5c = 0x6a\n        for (i = 0; i < key.length; i++) {\n            key[i] ^= 0x6a;\n        }\n        this.outer = new SHA1().update(key);\n    }\n    update(msg, enc) {\n        this.inner.update(msg, enc);\n        return this;\n    }\n    digest() {\n        this.outer.update(this.inner.digest());\n        return this.outer.digest();\n    }\n    digestHex() {\n        this.outer.update(this.inner.digest());\n        return this.outer.digestHex();\n    }\n}\n/**\n * The `SHA512HMAC` class is used to create Hash-based Message Authentication Code (HMAC) using the SHA-512 cryptographic hash function.\n *\n * HMAC is a specific type of MAC involving a cryptographic hash function and a secret cryptographic key. It may be used to simultaneously verify both the data integrity and the authenticity of a message.\n *\n * This class also uses the SHA-512 cryptographic hash algorithm that produces a 512-bit (64-byte) hash value.\n *\n * @property inner - Represents the inner hash of SHA-512.\n * @property outer - Represents the outer hash of SHA-512.\n * @property blockSize - The block size for the SHA-512 hash function, in bytes. It's set to 128 bytes.\n * @property outSize - The output size of the SHA-512 hash function, in bytes. It's set to 64 bytes.\n */\nclass SHA512HMAC {\n    h;\n    blockSize = 128;\n    outSize = 32;\n    /**\n     * The constructor for the `SHA512HMAC` class.\n     *\n     * It initializes the `SHA512HMAC` object and sets up the inner and outer padded keys.\n     * If the key size is larger than the blockSize, it is digested using SHA-512.\n     * If the key size is less than the blockSize, it is padded with zeroes.\n     *\n     * @constructor\n     * @param key - The key to use to create the HMAC. Can be a number array or a string in hexadecimal format.\n     *\n     * @example\n     * const myHMAC = new SHA512HMAC('deadbeef');\n     */\n    constructor(key) {\n        const k = Uint8Array.from(toArray(key, 'hex'));\n        this.h = new HMAC(sha512Fast, k);\n    }\n    /**\n     * Updates the `SHA512HMAC` object with part of the message to be hashed.\n     *\n     * @method update\n     * @param msg - Part of the message to hash. Can be a number array or a string.\n     * @param enc - If 'hex', then the input is encoded as hexadecimal. If undefined or not 'hex', then no encoding is performed.\n     * @returns Returns the instance of `SHA512HMAC` for chaining calls.\n     *\n     * @example\n     * myHMAC.update('deadbeef', 'hex');\n     */\n    update(msg, enc) {\n        this.h.update(Uint8Array.from(toArray(msg, enc)));\n        return this;\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a number array.\n     *\n     * @example\n     * let hashedMessage = myHMAC.digest();\n     */\n    digest() {\n        return Array.from(this.h.digest());\n    }\n    /**\n     * Finalizes the HMAC computation and returns the resultant hash as a hex string.\n     *\n     * @method digest\n     * @returns Returns the digest of the hashed data as a hex string\n     *\n     * @example\n     * let hashedMessage = myHMAC.digestHex();\n     */\n    digestHex() {\n        return bytesToHex(this.h.digest());\n    }\n}\n/**\n * Computes RIPEMD160 hash of a given message.\n * @function ripemd160\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed RIPEMD160 hash of the message.\n *\n * @example\n * const digest = ripemd160('Hello, world!');\n */\nconst ripemd160 = (msg, enc) => {\n    return new RIPEMD160().update(msg, enc).digest();\n};\n/**\n * Computes SHA1 hash of a given message.\n * @function sha1\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA1 hash of the message.\n *\n * @example\n * const digest = sha1('Hello, world!');\n */\nconst sha1 = (msg, enc) => {\n    return new SHA1().update(msg, enc).digest();\n};\n/**\n * Computes SHA256 hash of a given message.\n * @function sha256\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA256 hash of the message.\n *\n * @example\n * const digest = sha256('Hello, world!');\n */\nconst sha256 = (msg, enc) => {\n    return new SHA256().update(msg, enc).digest();\n};\n/**\n * Computes SHA512 hash of a given message.\n * @function sha512\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed SHA512 hash of the message.\n *\n * @example\n * const digest = sha512('Hello, world!');\n */\nconst sha512 = (msg, enc) => {\n    return new SHA512().update(msg, enc).digest();\n};\n/**\n * Performs a 'double hash' using SHA256. This means the data is hashed twice\n * with SHA256. First, the SHA256 hash of the message is computed, then the\n * SHA256 hash of the resulting hash is computed.\n * @function hash256\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the double hashed SHA256 output.\n *\n * @example\n * const doubleHash = hash256('Hello, world!');\n */\nconst hash256 = (msg, enc) => {\n    const first = new SHA256().update(msg, enc).digest();\n    return new SHA256().update(first).digest();\n};\n/**\n * Computes SHA256 hash of a given message and then computes a RIPEMD160 hash of the result.\n *\n * @function hash160\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the RIPEMD160 hash of the SHA256 hash of the input message.\n *\n * @example\n * const hash = hash160('Hello, world!');\n */\nconst hash160 = (msg, enc) => {\n    const first = new SHA256().update(msg, enc).digest();\n    return new RIPEMD160().update(first).digest();\n};\n/**\n * Computes SHA256 HMAC of a given message with a given key.\n * @function sha256hmac\n * @param key - The key used to compute the HMAC\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed HMAC of the message.\n *\n * @example\n * const digest = sha256hmac('deadbeef', 'ffff001d');\n */\nconst sha256hmac = (key, msg, enc) => {\n    return new SHA256HMAC(key).update(msg, enc).digest();\n};\n/**\n * Computes SHA512 HMAC of a given message with a given key.\n * @function sha512hmac\n * @param key - The key used to compute the HMAC\n * @param msg - The message to compute the hash for.\n * @param enc - The encoding of msg if string. Default is 'utf8'.\n *\n * @returns the computed HMAC of the message.\n *\n * @example\n * const digest = sha512hmac('deadbeef', 'ffff001d');\n */\nconst sha512hmac = (key, msg, enc) => {\n    return new SHA512HMAC(key).update(msg, enc).digest();\n};\n// BEGIN fast-pbkdf2 helpers\n// Utils\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0) {\n        throw new Error(`positive integer expected, got ${n}`);\n    }\n}\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length)) {\n        const lens = lengths.join(',');\n        throw new Error(`Uint8Array expected of length ${lens}, got length=${b.length}`);\n    }\n}\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function') {\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    }\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed === true)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished === true) {\n        throw new Error('Hash#digest() has already been called');\n    }\n}\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++)\n        arrays[i].fill(0);\n}\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str));\n}\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\nclass Hash {\n}\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\n// u64 helpers\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    const Ah = new Uint32Array(len);\n    const Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        Ah[i] = h;\n        Al[i] = l;\n    }\n    return [Ah, Al];\n}\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// _md helpers\nclass HashMD extends Hash {\n    blockLen;\n    outputLen;\n    padOffset;\n    isLE;\n    buffer;\n    view;\n    finished = false;\n    length = 0;\n    pos = 0;\n    destroyed = false;\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = createView(this.buffer);\n    }\n    update(data) {\n        aexists(this);\n        data = toBytes(data);\n        abytes(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            if (take === blockLen) {\n                const dataView = createView(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        aoutput(out, this);\n        this.finished = true;\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        buffer[pos++] = 0b10000000;\n        clean(this.buffer.subarray(pos));\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = createView(out);\n        const len = this.outputLen;\n        if (len % 4 !== 0)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to ||= new this.constructor();\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen !== 0)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// sha256 fast constants\nconst SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\nconst K256 = Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\nconst SHA256_W = new Uint32Array(64);\nclass FastSHA256 extends HashMD {\n    A = SHA256_IV[0] | 0;\n    B = SHA256_IV[1] | 0;\n    C = SHA256_IV[2] | 0;\n    D = SHA256_IV[3] | 0;\n    E = SHA256_IV[4] | 0;\n    F = SHA256_IV[5] | 0;\n    G = SHA256_IV[6] | 0;\n    H = SHA256_IV[7] | 0;\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA256_W[i] = view.getUint32(offset);\n        }\n        for (let i = 16; i < 64; i++) {\n            const w15 = SHA256_W[i - 15];\n            const w2 = SHA256_W[i - 2];\n            const s0 = G0_256(w15);\n            const s1 = G1_256(w2);\n            SHA256_W[i] = sum32(sum32(s0, SHA256_W[i - 7]), sum32(s1, SHA256_W[i - 16]));\n        }\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const T1 = SUM32_5(H, S1_256(E), ch32(E, F, G), K256[i], SHA256_W[i]);\n            const T2 = sum32(S0_256(A), maj32(A, B, C));\n            H = G;\n            G = F;\n            F = E;\n            E = sum32(D, T1);\n            D = C;\n            C = B;\n            B = A;\n            A = sum32(T1, T2);\n        }\n        this.A = sum32(this.A, A);\n        this.B = sum32(this.B, B);\n        this.C = sum32(this.C, C);\n        this.D = sum32(this.D, D);\n        this.E = sum32(this.E, E);\n        this.F = sum32(this.F, F);\n        this.G = sum32(this.G, G);\n        this.H = sum32(this.H, H);\n    }\n    roundClean() {\n        clean(SHA256_W);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nconst sha256Fast = createHasher(() => new FastSHA256());\n// sha512\nconst SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179\n]);\nconst K512 = (() => split([\n    '0x428a2f98d728ae22',\n    '0x7137449123ef65cd',\n    '0xb5c0fbcfec4d3b2f',\n    '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538',\n    '0x59f111f1b605d019',\n    '0x923f82a4af194f9b',\n    '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242',\n    '0x12835b0145706fbe',\n    '0x243185be4ee4b28c',\n    '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f',\n    '0x80deb1fe3b1696b1',\n    '0x9bdc06a725c71235',\n    '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2',\n    '0xefbe4786384f25e3',\n    '0x0fc19dc68b8cd5b5',\n    '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275',\n    '0x4a7484aa6ea6e483',\n    '0x5cb0a9dcbd41fbd4',\n    '0x76f988da831153b5',\n    '0x983e5152ee66dfab',\n    '0xa831c66d2db43210',\n    '0xb00327c898fb213f',\n    '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2',\n    '0xd5a79147930aa725',\n    '0x06ca6351e003826f',\n    '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc',\n    '0x2e1b21385c26c926',\n    '0x4d2c6dfc5ac42aed',\n    '0x53380d139d95b3df',\n    '0x650a73548baf63de',\n    '0x766a0abb3c77b2a8',\n    '0x81c2c92e47edaee6',\n    '0x92722c851482353b',\n    '0xa2bfe8a14cf10364',\n    '0xa81a664bbc423001',\n    '0xc24b8b70d0f89791',\n    '0xc76c51a30654be30',\n    '0xd192e819d6ef5218',\n    '0xd69906245565a910',\n    '0xf40e35855771202a',\n    '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8',\n    '0x1e376c085141ab53',\n    '0x2748774cdf8eeb99',\n    '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63',\n    '0x4ed8aa4ae3418acb',\n    '0x5b9cca4f7763e373',\n    '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc',\n    '0x78a5636f43172f60',\n    '0x84c87814a1f0ab72',\n    '0x8cc702081a6439ec',\n    '0x90befffa23631e28',\n    '0xa4506cebde82bde9',\n    '0xbef9a3f7b2c67915',\n    '0xc67178f2e372532b',\n    '0xca273eceea26619c',\n    '0xd186b8c721c0c207',\n    '0xeada7dd6cde0eb1e',\n    '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba',\n    '0x0a637dc5a2c898a6',\n    '0x113f9804bef90dae',\n    '0x1b710b35131c471b',\n    '0x28db77f523047d84',\n    '0x32caab7b40c72493',\n    '0x3c9ebe0a15c9bebc',\n    '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6',\n    '0x597f299cfc657e2a',\n    '0x5fcb6fab3ad6faec',\n    '0x6c44198c4a475817'\n].map((n) => BigInt(n))))();\nconst SHA512_Kh = (() => K512[0])();\nconst SHA512_Kl = (() => K512[1])();\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass FastSHA512 extends HashMD {\n    Ah = SHA512_IV[0] | 0;\n    Al = SHA512_IV[1] | 0;\n    Bh = SHA512_IV[2] | 0;\n    Bl = SHA512_IV[3] | 0;\n    Ch = SHA512_IV[4] | 0;\n    Cl = SHA512_IV[5] | 0;\n    Dh = SHA512_IV[6] | 0;\n    Dl = SHA512_IV[7] | 0;\n    Eh = SHA512_IV[8] | 0;\n    El = SHA512_IV[9] | 0;\n    Fh = SHA512_IV[10] | 0;\n    Fl = SHA512_IV[11] | 0;\n    Gh = SHA512_IV[12] | 0;\n    Gl = SHA512_IV[13] | 0;\n    Hh = SHA512_IV[14] | 0;\n    Hl = SHA512_IV[15] | 0;\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n    }\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);\n            const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);\n            const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);\n            const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        for (let i = 0; i < 80; i++) {\n            const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);\n            const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);\n            const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const T2l = add3L(sigma0l, MAJl, T1l);\n            Ah = add3H(T2l, sigma0h, MAJh, T1h);\n            Al = T2l | 0;\n        }\n        ;\n        ({ h: Ah, l: Al } = add(Ah, Al, this.Ah, this.Al));\n        ({ h: Bh, l: Bl } = add(Bh, Bl, this.Bh, this.Bl));\n        ({ h: Ch, l: Cl } = add(Ch, Cl, this.Ch, this.Cl));\n        ({ h: Dh, l: Dl } = add(Dh, Dl, this.Dh, this.Dl));\n        ({ h: Eh, l: El } = add(Eh, El, this.Eh, this.El));\n        ({ h: Fh, l: Fl } = add(Fh, Fl, this.Fh, this.Fl));\n        ({ h: Gh, l: Gl } = add(Gh, Gl, this.Gh, this.Gl));\n        ({ h: Hh, l: Hl } = add(Hh, Hl, this.Hh, this.Hl));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        clean(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nconst sha512Fast = createHasher(() => new FastSHA512());\nclass HMAC extends Hash {\n    oHash;\n    iHash;\n    blockLen;\n    outputLen;\n    finished = false;\n    destroyed = false;\n    constructor(hash, _key) {\n        super();\n        ahash(hash);\n        const key = toBytes(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function') {\n            throw new Error('Expected instance of class which extends utils.Hash');\n        }\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        this.oHash = hash.create();\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        clean(pad);\n    }\n    update(buf) {\n        aexists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        aexists(this);\n        abytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        to ||= Object.create(Object.getPrototypeOf(this), {});\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash ?? undefined);\n        to.iHash = iHash._cloneInto(to.iHash ?? undefined);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\nfunction pbkdf2Core(hash, password, salt, opts) {\n    ahash(hash);\n    const { c, dkLen } = Object.assign({ dkLen: 32 }, opts);\n    anumber(c);\n    anumber(dkLen);\n    if (c < 1)\n        throw new Error('iterations (c) should be >= 1');\n    const pwd = kdfInputToBytes(password);\n    const slt = kdfInputToBytes(salt);\n    const DK = new Uint8Array(dkLen);\n    const PRF = hmac.create(hash, pwd);\n    const PRFSalt = PRF._cloneInto().update(slt);\n    let prfW;\n    const arr = new Uint8Array(4);\n    const view = createView(arr);\n    const u = new Uint8Array(PRF.outputLen);\n    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {\n        const Ti = DK.subarray(pos, pos + PRF.outputLen);\n        view.setInt32(0, ti, false);\n        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);\n        Ti.set(u.subarray(0, Ti.length));\n        for (let ui = 1; ui < c; ui++) {\n            PRF._cloneInto(prfW).update(u).digestInto(u);\n            for (let i = 0; i < Ti.length; i++)\n                Ti[i] ^= u[i];\n        }\n    }\n    PRF.destroy();\n    PRFSalt.destroy();\n    if (prfW != null)\n        prfW.destroy();\n    clean(u);\n    return DK;\n}\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\nfunction pbkdf2Fast(password, salt, iterations, keylen) {\n    return pbkdf2Core(sha512Fast, password, salt, { c: iterations, dkLen: keylen });\n}\n// END fast-pbkdf2 helpers\n/**\n * Limited SHA-512-only PBKDF2 function for use in deprecated BIP39 code.\n * @function pbkdf2\n * @param password - The PBKDF2 password\n * @param salt - The PBKDF2 salt\n * @param iterations - The number of of iterations to run\n * @param keylen - The length of the key\n * @param digest - The digest (must be sha512 for this implementation)\n *\n * @returns The computed key\n */\nfunction pbkdf2(password, salt, iterations, keylen, digest = 'sha512') {\n    if (digest !== 'sha512') {\n        throw new Error('Only sha512 is supported in this PBKDF2 implementation');\n    }\n    // Attempt to use the native Node.js implementation if available as it is\n    // considerably faster than the pure TypeScript fallback below. If the crypto\n    // module isn't present (for example in a browser build) we'll silently fall\n    // back to the original implementation.\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-var-requires\n        const nodeCrypto = require('crypto');\n        if (typeof nodeCrypto.pbkdf2Sync === 'function') {\n            const p = Buffer.from(password);\n            const s = Buffer.from(salt);\n            return [...nodeCrypto.pbkdf2Sync(p, s, iterations, keylen, digest)];\n        }\n    }\n    catch {\n        // ignore\n    }\n    const p = Uint8Array.from(password);\n    const s = Uint8Array.from(salt);\n    const out = pbkdf2Fast(p, s, iterations, keylen);\n    return Array.from(out);\n}\n//# sourceMappingURL=Hash.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/JacobianPoint.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/JacobianPoint.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ JacobianPoint)\n/* harmony export */ });\n/* harmony import */ var _BasePoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BasePoint.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js\");\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n\n\n\n/**\n * The `JacobianPoint` class extends the `BasePoint` class for handling Jacobian coordinates on an Elliptic Curve.\n * This class defines the properties and the methods needed to work with points in Jacobian coordinates.\n *\n * The Jacobian coordinates represent a point (x, y, z) on an Elliptic Curve such that the usual (x, y) coordinates are given by (x/z^2, y/z^3).\n *\n * @property x - The `x` coordinate of the point in the Jacobian form.\n * @property y - The `y` coordinate of the point in the Jacobian form.\n * @property z - The `z` coordinate of the point in the Jacobian form.\n * @property zOne - Flag that indicates if the `z` coordinate is one.\n *\n * @example\n * const pointJ = new JacobianPoint('3', '4', '1');\n */\nclass JacobianPoint extends _BasePoint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    x;\n    y;\n    z;\n    zOne;\n    /**\n     * Constructs a new `JacobianPoint` instance.\n     *\n     * @param x - If `null`, the x-coordinate will default to the curve's defined 'one' constant.\n     * If `x` is not a BigNumber, `x` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @param y - If `null`, the y-coordinate will default to the curve's defined 'one' constant.\n     * If `y` is not a BigNumber, `y` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @param z - If `null`, the z-coordinate will default to 0.\n     * If `z` is not a BigNumber, `z` will be converted to a `BigNumber` assuming it is a hex string.\n     *\n     * @example\n     * const pointJ1 = new JacobianPoint(null, null, null); // creates point at infinity\n     * const pointJ2 = new JacobianPoint('3', '4', '1'); // creates point (3, 4, 1)\n     */\n    constructor(x, y, z) {\n        super('jacobian');\n        if (x === null && y === null && z === null) {\n            this.x = this.curve.one;\n            this.y = this.curve.one;\n            this.z = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0);\n        }\n        else {\n            if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBN(x)) {\n                x = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](x, 16);\n            }\n            this.x = x;\n            if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBN(y)) {\n                y = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](y, 16);\n            }\n            this.y = y;\n            if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isBN(z)) {\n                z = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](z, 16);\n            }\n            this.z = z;\n        }\n        if (this.x.red == null) {\n            this.x = this.x.toRed(this.curve.red);\n        }\n        if (this.y.red == null) {\n            this.y = this.y.toRed(this.curve.red);\n        }\n        if (this.z.red == null) {\n            this.z = this.z.toRed(this.curve.red);\n        }\n        this.zOne = this.z === this.curve.one;\n    }\n    /**\n     * Converts the `JacobianPoint` object instance to standard affine `Point` format and returns `Point` type.\n     *\n     * @returns The `Point`(affine) object representing the same point as the original `JacobianPoint`.\n     *\n     * If the initial `JacobianPoint` represents point at infinity, an instance of `Point` at infinity is returned.\n     *\n     * @example\n     * const pointJ = new JacobianPoint('3', '4', '1');\n     * const pointP = pointJ.toP();  // The point in affine coordinates.\n     */\n    toP() {\n        if (this.isInfinity()) {\n            return new _Point_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](null, null);\n        }\n        const zinv = this.z.redInvm();\n        const zinv2 = zinv.redSqr();\n        const ax = this.x.redMul(zinv2);\n        const ay = this.y.redMul(zinv2).redMul(zinv);\n        return new _Point_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](ax, ay);\n    }\n    /**\n     * Negation operation. It returns the additive inverse of the Jacobian point.\n     *\n     * @method neg\n     * @returns Returns a new Jacobian point as the result of the negation.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.neg()\n     */\n    neg() {\n        return new JacobianPoint(this.x, this.y.redNeg(), this.z);\n    }\n    /**\n     * Addition operation in the Jacobian coordinates. It takes a Jacobian point as an argument\n     * and returns a new Jacobian point as a result of the addition. In the special cases,\n     * when either one of the points is the point at infinity, it will return the other point.\n     *\n     * @method add\n     * @param p - The Jacobian point to be added.\n     * @returns Returns a new Jacobian point as the result of the addition.\n     *\n     * @example\n     * const p1 = new JacobianPoint(x1, y1, z1)\n     * const p2 = new JacobianPoint(x2, y2, z2)\n     * const result = p1.add(p2)\n     */\n    add(p) {\n        // O + P = P\n        if (this.isInfinity()) {\n            return p;\n        }\n        // P + O = P\n        if (p.isInfinity()) {\n            return this;\n        }\n        // 12M + 4S + 7A\n        const pz2 = p.z.redSqr();\n        const z2 = this.z.redSqr();\n        const u1 = this.x.redMul(pz2);\n        const u2 = p.x.redMul(z2);\n        const s1 = this.y.redMul(pz2.redMul(p.z));\n        const s2 = p.y.redMul(z2.redMul(this.z));\n        const h = u1.redSub(u2);\n        const r = s1.redSub(s2);\n        if (h.cmpn(0) === 0) {\n            if (r.cmpn(0) !== 0) {\n                return new JacobianPoint(null, null, null);\n            }\n            else {\n                return this.dbl();\n            }\n        }\n        const h2 = h.redSqr();\n        const h3 = h2.redMul(h);\n        const v = u1.redMul(h2);\n        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n        const nz = this.z.redMul(p.z).redMul(h);\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Mixed addition operation. This function combines the standard point addition with\n     * the transformation from the affine to Jacobian coordinates. It first converts\n     * the affine point to Jacobian, and then preforms the addition.\n     *\n     * @method mixedAdd\n     * @param p - The affine point to be added.\n     * @returns Returns the result of the mixed addition as a new Jacobian point.\n     *\n     * @example\n     * const jp = new JacobianPoint(x1, y1, z1)\n     * const ap = new Point(x2, y2)\n     * const result = jp.mixedAdd(ap)\n     */\n    mixedAdd(p) {\n        // O + P = P\n        if (this.isInfinity()) {\n            return p.toJ();\n        }\n        // P + O = P\n        if (p.isInfinity()) {\n            return this;\n        }\n        // Ensure x and y are not null\n        if (p.x === null || p.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        // 8M + 3S + 7A\n        const z2 = this.z.redSqr();\n        const u1 = this.x;\n        const u2 = p.x.redMul(z2);\n        const s1 = this.y;\n        const s2 = p.y.redMul(z2).redMul(this.z);\n        const h = u1.redSub(u2);\n        const r = s1.redSub(s2);\n        if (h.cmpn(0) === 0) {\n            if (r.cmpn(0) !== 0) {\n                return new JacobianPoint(null, null, null);\n            }\n            else {\n                return this.dbl();\n            }\n        }\n        const h2 = h.redSqr();\n        const h3 = h2.redMul(h);\n        const v = u1.redMul(h2);\n        const nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n        const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n        const nz = this.z.redMul(h);\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Multiple doubling operation. It doubles the Jacobian point as many times as the pow parameter specifies. If pow is 0 or the point is the point at infinity, it will return the point itself.\n     *\n     * @method dblp\n     * @param pow - The number of times the point should be doubled.\n     * @returns Returns a new Jacobian point as the result of multiple doublings.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.dblp(3)\n     */\n    dblp(pow) {\n        if (pow === 0) {\n            return this;\n        }\n        if (this.isInfinity()) {\n            return this;\n        }\n        if (typeof pow === 'undefined') {\n            return this.dbl();\n        }\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let r = this;\n        for (let i = 0; i < pow; i++) {\n            r = r.dbl();\n        }\n        return r;\n    }\n    /**\n     * Point doubling operation in the Jacobian coordinates. A special case is when the point is the point at infinity, in this case, this function will return the point itself.\n     *\n     * @method dbl\n     * @returns Returns a new Jacobian point as the result of the doubling.\n     *\n     * @example\n     * const jp = new JacobianPoint(x, y, z)\n     * const result = jp.dbl()\n     */\n    dbl() {\n        if (this.isInfinity()) {\n            return this;\n        }\n        let nx;\n        let ny;\n        let nz;\n        // Z = 1\n        if (this.zOne) {\n            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n            //     #doubling-mdbl-2007-bl\n            // 1M + 5S + 14A\n            // XX = X1^2\n            const xx = this.x.redSqr();\n            // YY = Y1^2\n            const yy = this.y.redSqr();\n            // YYYY = YY^2\n            const yyyy = yy.redSqr();\n            // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n            let s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n            s = s.redIAdd(s);\n            // M = 3 * XX + a; a = 0\n            const m = xx.redAdd(xx).redIAdd(xx);\n            // T = M ^ 2 - 2*S\n            const t = m.redSqr().redISub(s).redISub(s);\n            // 8 * YYYY\n            let yyyy8 = yyyy.redIAdd(yyyy);\n            yyyy8 = yyyy8.redIAdd(yyyy8);\n            yyyy8 = yyyy8.redIAdd(yyyy8);\n            // X3 = T\n            nx = t;\n            // Y3 = M * (S - T) - 8 * YYYY\n            ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n            // Z3 = 2*Y1\n            nz = this.y.redAdd(this.y);\n        }\n        else {\n            // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n            //     #doubling-dbl-2009-l\n            // 2M + 5S + 13A\n            // A = X1^2\n            const a = this.x.redSqr();\n            // B = Y1^2\n            const b = this.y.redSqr();\n            // C = B^2\n            const c = b.redSqr();\n            // D = 2 * ((X1 + B)^2 - A - C)\n            let d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n            d = d.redIAdd(d);\n            // E = 3 * A\n            const e = a.redAdd(a).redIAdd(a);\n            // F = E^2\n            const f = e.redSqr();\n            // 8 * C\n            let c8 = c.redIAdd(c);\n            c8 = c8.redIAdd(c8);\n            c8 = c8.redIAdd(c8);\n            // X3 = F - 2 * D\n            nx = f.redISub(d).redISub(d);\n            // Y3 = E * (D - X3) - 8 * C\n            ny = e.redMul(d.redISub(nx)).redISub(c8);\n            // Z3 = 2 * Y1 * Z1\n            nz = this.y.redMul(this.z);\n            nz = nz.redIAdd(nz);\n        }\n        return new JacobianPoint(nx, ny, nz);\n    }\n    /**\n     * Equality check operation. It checks whether the affine or Jacobian point is equal to this Jacobian point.\n     *\n     * @method eq\n     * @param p - The affine or Jacobian point to compare with.\n     * @returns Returns true if the points are equal, otherwise returns false.\n     *\n     * @example\n     * const jp1 = new JacobianPoint(x1, y1, z1)\n     * const jp2 = new JacobianPoint(x2, y2, z2)\n     * const areEqual = jp1.eq(jp2)\n     */\n    eq(p) {\n        if (p.type === 'affine') {\n            return this.eq(p.toJ());\n        }\n        if (this === p) {\n            return true;\n        }\n        // x1 * z2^2 == x2 * z1^2\n        const z2 = this.z.redSqr();\n        p = p;\n        const pz2 = p.z.redSqr();\n        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) {\n            return false;\n        }\n        // y1 * z2^3 == y2 * z1^3\n        const z3 = z2.redMul(this.z);\n        const pz3 = pz2.redMul(p.z);\n        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n    }\n    /**\n     * Equality check operation in relation to an x coordinate of a point in projective coordinates.\n     * It checks whether the x coordinate of the Jacobian point is equal to the provided x coordinate\n     * of a point in projective coordinates.\n     *\n     * @method eqXToP\n     * @param x - The x coordinate of a point in projective coordinates.\n     * @returns Returns true if the x coordinates are equal, otherwise returns false.\n     *\n     * @example\n     * const jp = new JacobianPoint(x1, y1, z1)\n     * const isXEqual = jp.eqXToP(x2)\n     */\n    eqXToP(x) {\n        const zs = this.z.redSqr();\n        const rx = x.toRed(this.curve?.red).redMul(zs);\n        if (this.x.cmp(rx) === 0) {\n            return true;\n        }\n        const xc = x.clone();\n        if (this.curve === null || (this.curve.redN == null)) {\n            throw new Error('Curve or redN is not initialized.');\n        }\n        const t = this.curve.redN.redMul(zs);\n        while (xc.cmp(this.curve.p) < 0) {\n            xc.iadd(this.curve.n);\n            if (xc.cmp(this.curve.p) >= 0) {\n                return false;\n            }\n            rx.redIAdd(t);\n            if (this.x.cmp(rx) === 0) {\n                return true;\n            }\n        }\n        //  Ensure function always returns a boolean\n        return false;\n    }\n    /**\n     * Returns the string representation of the JacobianPoint instance.\n     * @method inspect\n     * @returns Returns the string description of the JacobianPoint. If the JacobianPoint represents a point at infinity, the return value of this function is '<EC JPoint Infinity>'. For a normal point, it returns the string description format as '<EC JPoint x: x-coordinate y: y-coordinate z: z-coordinate>'.\n     *\n     * @example\n     * const point = new JacobianPoint('5', '6', '1');\n     * console.log(point.inspect()); // Output: '<EC JPoint x: 5 y: 6 z: 1>'\n     */\n    inspect() {\n        if (this.isInfinity()) {\n            return '<EC JPoint Infinity>';\n        }\n        return ('<EC JPoint x: ' +\n            this.x.toString(16, 2) +\n            ' y: ' +\n            this.y.toString(16, 2) +\n            ' z: ' +\n            this.z.toString(16, 2) +\n            '>');\n    }\n    /**\n     * Checks whether the JacobianPoint instance represents a point at infinity.\n     * @method isInfinity\n     * @returns Returns true if the JacobianPoint's z-coordinate equals to zero (which represents the point at infinity in Jacobian coordinates). Returns false otherwise.\n     *\n     * @example\n     * const point = new JacobianPoint('5', '6', '0');\n     * console.log(point.isInfinity()); // Output: true\n     */\n    isInfinity() {\n        return this.z.cmpn(0) === 0;\n    }\n}\n//# sourceMappingURL=JacobianPoint.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/JacobianPoint.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/K256.js":
/*!***************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/K256.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ K256)\n/* harmony export */ });\n/* harmony import */ var _Mersenne_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Mersenne.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Mersenne.js\");\n\n/**\n * A class representing K-256, a prime number with optimizations, specifically used in the secp256k1 curve.\n * It extends the functionalities of the Mersenne class.\n * K-256 prime is represented as 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f'\n *\n * @class K256\n * @extends {Mersenne}\n *\n * @example\n * const k256 = new K256();\n */\nclass K256 extends _Mersenne_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * Constructor for the K256 class.\n     * Creates an instance of K256 using the super constructor from Mersenne.\n     *\n     * @constructor\n     *\n     * @example\n     * const k256 = new K256();\n     */\n    constructor() {\n        super('k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n    }\n    /**\n     * Splits a BigNumber into a new BigNumber based on specific computation\n     * rules. This method modifies the input and output big numbers.\n     *\n     * @method split\n     * @param input - The BigNumber to be split.\n     * @param output - The BigNumber that results from the split.\n     *\n     * @example\n     * const input = new BigNumber(3456);\n     * const output = new BigNumber(0);\n     * k256.split(input, output);\n     */\n    split(input, output) {\n        const mask = 0x3fffff; // 22 bits\n        const inputWords = input.words; // Access via getter\n        const inputNominalLength = input.length; // Access via getter, respects _nominalWordLength\n        const outLen = Math.min(inputNominalLength, 9);\n        const tempOutputWords = new Array(outLen + (inputNominalLength > 9 ? 1 : 0)).fill(0);\n        for (let i = 0; i < outLen; i++) {\n            tempOutputWords[i] = inputWords[i];\n        }\n        let currentOutputWordCount = outLen;\n        if (inputNominalLength <= 9) {\n            const finalOutputWords = new Array(currentOutputWordCount);\n            for (let i = 0; i < currentOutputWordCount; ++i)\n                finalOutputWords[i] = tempOutputWords[i];\n            output.words = finalOutputWords; // Use setter\n            input.words = [0]; // Use setter to set to 0\n            return;\n        }\n        // Shift by 9 limbs\n        let prev = inputWords[9];\n        tempOutputWords[currentOutputWordCount++] = prev & mask;\n        const finalOutputWords = new Array(currentOutputWordCount);\n        for (let i = 0; i < currentOutputWordCount; ++i)\n            finalOutputWords[i] = tempOutputWords[i];\n        output.words = finalOutputWords; // Use setter for output\n        // For input modification\n        const tempInputNewWords = new Array(Math.max(1, inputNominalLength - 9)).fill(0);\n        let currentInputNewWordCount = 0;\n        for (let i = 10; i < inputNominalLength; i++) {\n            const next = inputWords[i] | 0;\n            if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check\n                tempInputNewWords[currentInputNewWordCount++] = ((next & mask) << 4) | (prev >>> 22);\n            }\n            prev = next;\n        }\n        prev >>>= 22;\n        if (currentInputNewWordCount < tempInputNewWords.length) { // Boundary check\n            tempInputNewWords[currentInputNewWordCount++] = prev;\n        }\n        else if (prev !== 0 && tempInputNewWords.length > 0) { // If prev is non-zero but no space, this is an issue.\n            // This case implies original logic might have relied on array auto-expansion or specific length handling\n            // For safety, if there's still a carry and no space, the array should have been bigger.\n            // However, the original logic `input.length -= 9` suggests truncation.\n        }\n        const finalInputNewWords = new Array(currentInputNewWordCount);\n        for (let i = 0; i < currentInputNewWordCount; ++i)\n            finalInputNewWords[i] = tempInputNewWords[i];\n        input.words = finalInputNewWords; // Use setter, which will strip and set magnitude\n    }\n    /**\n     * Multiplies a BigNumber ('num') with the constant 'K' in-place and returns the result.\n     * 'K' is equal to 0x1000003d1 or in decimal representation: [ 64, 977 ].\n     *\n     * @method imulK\n     * @param num - The BigNumber to multiply with K.\n     * @returns Returns the mutated BigNumber after multiplication.\n     *\n     * @example\n     * const number = new BigNumber(12345);\n     * const result = k256.imulK(number);\n     */\n    imulK(num) {\n        const currentWords = num.words; // Get current words based on _magnitude and _nominalWordLength\n        const originalNominalLength = num.length; // Getter\n        const newNominalLength = originalNominalLength + 2;\n        const tempWords = new Array(newNominalLength).fill(0);\n        for (let i = 0; i < originalNominalLength; i++) {\n            tempWords[i] = currentWords[i];\n        }\n        // tempWords is now effectively num.words expanded with zeroes\n        let lo = 0;\n        for (let i = 0; i < newNominalLength; i++) { // Iterate up to new expanded length\n            const w = tempWords[i] | 0;\n            lo += w * 0x3d1; // 0x3d1 = 977\n            tempWords[i] = lo & 0x3ffffff; // 26-bit mask\n            lo = w * 0x40 + ((lo / 0x4000000) | 0); // 0x40 = 64. 0x4000000 = 2^26\n        }\n        num.words = tempWords; // Use setter to re-initialize from tempWords\n        // The setter will handle _magnitude, _sign, _nominalWordLength, and strip.\n        return num;\n    }\n}\n//# sourceMappingURL=K256.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/K256.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Mersenne.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Mersenne.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Mersenne)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n\n/**\n * A representation of a pseudo-Mersenne prime.\n * A pseudo-Mersenne prime has the general form 2^n - k, where n and k are integers.\n *\n * @class Mersenne\n *\n * @property name - The identifier for the Mersenne instance.\n * @property p - BigNumber equivalent to 2^n - k.\n * @property k - The constant subtracted from 2^n to derive a pseudo-Mersenne prime.\n * @property n - The exponent which determines the magnitude of the prime.\n */\nclass Mersenne {\n    name;\n    p;\n    k;\n    n;\n    tmp;\n    /**\n     * @constructor\n     * @param name - An identifier for the Mersenne instance.\n     * @param p - A string representation of the pseudo-Mersenne prime, expressed in hexadecimal.\n     *\n     * @example\n     * const mersenne = new Mersenne('M31', '7FFFFFFF');\n     */\n    constructor(name, p) {\n        // P = 2 ^ N - K\n        this.name = name;\n        this.p = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](p, 16);\n        this.n = this.p.bitLength();\n        this.k = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](BigInt(1)).iushln(this.n).isub(this.p); // Use 1n for BigInt compatibility\n        this.tmp = this._tmp();\n    }\n    /**\n     * Creates a temporary BigNumber structure for computations,\n     * ensuring the appropriate number of words are initially allocated.\n     *\n     * @method _tmp\n     * @returns A BigNumber with scaled size depending on prime magnitude.\n     */\n    _tmp() {\n        const tmp = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](BigInt(0)); // Initialize with BigInt 0\n        const requiredWords = Math.ceil(this.n / _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].wordSize);\n        tmp.expand(Math.max(1, requiredWords)); // Expand sets _nominalWordLength\n        return tmp;\n    }\n    /**\n     * Reduces an input BigNumber in place, under the assumption that\n     * it is less than the square of the pseudo-Mersenne prime.\n     *\n     * @method ireduce\n     * @param num - The BigNumber to be reduced.\n     * @returns The reduced BigNumber.\n     *\n     * @example\n     * const reduced = mersenne.ireduce(new BigNumber('2345', 16));\n     */\n    ireduce(num) {\n        // Assumes that `num` is less than `P^2`\n        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n        const r = num; // num is directly modified\n        let rlen;\n        do {\n            this.split(r, this.tmp); // r is modified (becomes HI), this.tmp becomes LO\n            this.imulK(r); // r becomes HI * K\n            r.iadd(this.tmp); // r becomes HI * K + LO\n            rlen = r.bitLength();\n        } while (rlen > this.n);\n        const cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n        if (cmp === 0) {\n            r.words = [0]; // Set to zero using the words setter\n        }\n        else if (cmp > 0) {\n            r.isub(this.p);\n        }\n        // No explicit strip needed here if operations maintain correctness and setter handles it.\n        // However, ensuring it's stripped to minimal form after reduction is good.\n        r.strip();\n        return r;\n    }\n    /**\n     * Shifts bits of the input BigNumber to the right, in place,\n     * to meet the magnitude of the pseudo-Mersenne prime.\n     *\n     * @method split\n     * @param input - The BigNumber to be shifted (will contain HI part).\n     * @param out - The BigNumber to hold the shifted result (LO part).\n     *\n     * @example\n     * mersenne.split(new BigNumber('2345', 16), new BigNumber());\n     */\n    split(input, out) {\n        // out gets the LO bits (shifted out part)\n        // input gets modified to be the HI bits (remaining part after shift)\n        input.iushrn(this.n, 0, out);\n    }\n    /**\n     * Performs an in-place multiplication of the parameter by constant k.\n     *\n     * @method imulK\n     * @param num - The BigNumber to multiply with k.\n     * @returns The result of the multiplication, in BigNumber format.\n     *\n     * @example\n     * const multiplied = mersenne.imulK(new BigNumber('2345', 16));\n     */\n    imulK(num) {\n        return num.imul(this.k);\n    }\n}\n//# sourceMappingURL=Mersenne.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Mersenne.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/MontgomoryMethod.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/MontgomoryMethod.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MontgomoryMethod)\n/* harmony export */ });\n/* harmony import */ var _ReductionContext_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ReductionContext.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js\");\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n\n\n/**\n * Represents a Montgomery reduction context, which is a mathematical method\n * for performing modular multiplication without division.\n *\n * Montgomery reduction is an algorithm used mainly in cryptography which can\n * help to speed up calculations in contexts where there are many repeated\n * computations.\n *\n * This class extends the `ReductionContext` class.\n *\n * @class MontgomoryMethod\n * @extends {ReductionContext}\n *\n * @property shift - The number of bits in the modulus.\n * @property r - The 2^shift, shifted left by the bit length of modulus `m`.\n * @property r2 - The square of `r` modulo `m`.\n * @property rinv - The modular multiplicative inverse of `r` mod `m`.\n * @property minv - The modular multiplicative inverse of `m` mod `r`.\n */\nclass MontgomoryMethod extends _ReductionContext_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    shift;\n    r;\n    r2;\n    rinv;\n    minv;\n    /**\n     * @constructor\n     * @param m - The modulus to be used for the Montgomery method reductions.\n     */\n    constructor(m) {\n        super(m);\n        this.shift = this.m.bitLength();\n        if (this.shift % 26 !== 0) {\n            this.shift += 26 - (this.shift % 26);\n        }\n        this.r = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1).iushln(this.shift);\n        this.r2 = this.imod(this.r.sqr());\n        this.rinv = this.r._invmp(this.m);\n        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n        this.minv = this.minv.umod(this.r);\n        this.minv = this.r.sub(this.minv);\n    }\n    /**\n     * Converts a number into the Montgomery domain.\n     *\n     * @method convertTo\n     * @param num - The number to be converted into the Montgomery domain.\n     * @returns The result of the conversion into the Montgomery domain.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const convertedNum = montMethod.convertTo(num);\n     */\n    convertTo(num) {\n        return this.imod(num.ushln(this.shift));\n    }\n    /**\n     * Converts a number from the Montgomery domain back to the original domain.\n     *\n     * @method convertFrom\n     * @param num - The number to be converted from the Montgomery domain.\n     * @returns The result of the conversion from the Montgomery domain.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const convertedNum = montMethod.convertFrom(num);\n     */\n    convertFrom(num) {\n        const r = this.imod(num.mul(this.rinv));\n        r.red = null;\n        return r;\n    }\n    /**\n     * Performs an in-place multiplication of two numbers in the Montgomery domain.\n     *\n     * @method imul\n     * @param a - The first number to multiply.\n     * @param b - The second number to multiply.\n     * @returns The result of the in-place multiplication.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const product = montMethod.imul(a, b);\n     */\n    imul(a, b) {\n        if (a.isZero() || b.isZero()) {\n            a.words[0] = 0;\n            a.length = 1;\n            return a;\n        }\n        const t = a.imul(b);\n        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        const u = t.isub(c).iushrn(this.shift);\n        let res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        }\n        else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs the multiplication of two numbers in the Montgomery domain.\n     *\n     * @method mul\n     * @param a - The first number to multiply.\n     * @param b - The second number to multiply.\n     * @returns The result of the multiplication.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const product = montMethod.mul(a, b);\n     */\n    mul(a, b) {\n        if (a.isZero() || b.isZero())\n            return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0).forceRed(this);\n        const t = a.mul(b);\n        const c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n        const u = t.isub(c).iushrn(this.shift);\n        let res = u;\n        if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n        }\n        else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Calculates the modular multiplicative inverse of a number in the Montgomery domain.\n     *\n     * @method invm\n     * @param a - The number to compute the modular multiplicative inverse of.\n     * @returns The modular multiplicative inverse of 'a'.\n     *\n     * @example\n     * const montMethod = new MontgomoryMethod(m);\n     * const inverse = montMethod.invm(a);\n     */\n    invm(a) {\n        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n        const res = this.imod(a._invmp(this.m).mul(this.r2));\n        return res.forceRed(this);\n    }\n}\n//# sourceMappingURL=MontgomoryMethod.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/MontgomoryMethod.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BI_EIGHT: () => (/* binding */ BI_EIGHT),\n/* harmony export */   BI_FOUR: () => (/* binding */ BI_FOUR),\n/* harmony export */   BI_ONE: () => (/* binding */ BI_ONE),\n/* harmony export */   BI_THREE: () => (/* binding */ BI_THREE),\n/* harmony export */   BI_TWO: () => (/* binding */ BI_TWO),\n/* harmony export */   BI_ZERO: () => (/* binding */ BI_ZERO),\n/* harmony export */   GX_BIGINT: () => (/* binding */ GX_BIGINT),\n/* harmony export */   GY_BIGINT: () => (/* binding */ GY_BIGINT),\n/* harmony export */   MASK_256: () => (/* binding */ MASK_256),\n/* harmony export */   N_BIGINT: () => (/* binding */ N_BIGINT),\n/* harmony export */   P_BIGINT: () => (/* binding */ P_BIGINT),\n/* harmony export */   P_PLUS1_DIV4: () => (/* binding */ P_PLUS1_DIV4),\n/* harmony export */   biMod: () => (/* binding */ biMod),\n/* harmony export */   biModAdd: () => (/* binding */ biModAdd),\n/* harmony export */   biModInv: () => (/* binding */ biModInv),\n/* harmony export */   biModMul: () => (/* binding */ biModMul),\n/* harmony export */   biModPow: () => (/* binding */ biModPow),\n/* harmony export */   biModSqr: () => (/* binding */ biModSqr),\n/* harmony export */   biModSqrt: () => (/* binding */ biModSqrt),\n/* harmony export */   biModSub: () => (/* binding */ biModSub),\n/* harmony export */   \"default\": () => (/* binding */ Point),\n/* harmony export */   jpAdd: () => (/* binding */ jpAdd),\n/* harmony export */   jpDouble: () => (/* binding */ jpDouble),\n/* harmony export */   jpNeg: () => (/* binding */ jpNeg),\n/* harmony export */   modInvN: () => (/* binding */ modInvN),\n/* harmony export */   modMulN: () => (/* binding */ modMulN),\n/* harmony export */   modN: () => (/* binding */ modN),\n/* harmony export */   red: () => (/* binding */ red),\n/* harmony export */   scalarMultiplyWNAF: () => (/* binding */ scalarMultiplyWNAF)\n/* harmony export */ });\n/* harmony import */ var _BasePoint_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BasePoint.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BasePoint.js\");\n/* harmony import */ var _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./JacobianPoint.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/JacobianPoint.js\");\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\n// -----------------------------------------------------------------------------\n// BigInt helpers & constants (secp256k1)  hoisted so we don't recreate them on\n// every Point.mul() call.\n// -----------------------------------------------------------------------------\nconst BI_ZERO = 0n;\nconst BI_ONE = 1n;\nconst BI_TWO = 2n;\nconst BI_THREE = 3n;\nconst BI_FOUR = 4n;\nconst BI_EIGHT = 8n;\nconst P_BIGINT = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn;\nconst N_BIGINT = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n;\nconst MASK_256 = (1n << 256n) - 1n; // 0xffffffff (256 sones)\nfunction red(x) {\n    // first fold\n    let hi = x >> 256n;\n    x = (x & MASK_256) + (hi << 32n) + hi * 977n;\n    // second fold  (hi  2 + 977 here, so one more pass is enough)\n    hi = x >> 256n;\n    x = (x & MASK_256) + (hi << 32n) + hi * 977n;\n    // final conditional subtraction\n    if (x >= P_BIGINT)\n        x -= P_BIGINT;\n    return x;\n}\nconst biMod = (a) => red((a % P_BIGINT + P_BIGINT) % P_BIGINT);\nconst biModSub = (a, b) => (a >= b ? a - b : P_BIGINT - (b - a));\nconst biModMul = (a, b) => red(a * b);\nconst biModAdd = (a, b) => red(a + b);\nconst biModInv = (a) => {\n    let lm = BI_ONE;\n    let hm = BI_ZERO;\n    let low = biMod(a);\n    let high = P_BIGINT;\n    while (low > BI_ONE) {\n        const r = high / low;\n        [lm, hm] = [hm - lm * r, lm];\n        [low, high] = [high - low * r, low];\n    }\n    return biMod(lm);\n};\nconst biModSqr = (a) => biModMul(a, a);\nconst biModPow = (base, exp) => {\n    let result = BI_ONE;\n    base = biMod(base);\n    let e = exp;\n    while (e > BI_ZERO) {\n        if ((e & BI_ONE) === BI_ONE)\n            result = biModMul(result, base);\n        base = biModMul(base, base);\n        e >>= BI_ONE;\n    }\n    return result;\n};\nconst P_PLUS1_DIV4 = (P_BIGINT + 1n) >> 2n;\nconst biModSqrt = (a) => {\n    const r = biModPow(a, P_PLUS1_DIV4);\n    return biModMul(r, r) === biMod(a) ? r : null;\n};\nconst toBigInt = (x) => {\n    if (_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isBN(x))\n        return BigInt('0x' + x.toString(16));\n    if (typeof x === 'string')\n        return BigInt('0x' + x);\n    if (Array.isArray(x))\n        return BigInt('0x' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(x));\n    return BigInt(x);\n};\n// Generator point coordinates as bigint constants\nconst GX_BIGINT = BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798');\nconst GY_BIGINT = BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8');\n// Cache for precomputed windowed tables keyed by 'window:x:y'\nconst WNAF_TABLE_CACHE = new Map();\nconst jpDouble = (P) => {\n    const { X: X1, Y: Y1, Z: Z1 } = P;\n    if (Y1 === BI_ZERO)\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO };\n    const Y1sq = biModMul(Y1, Y1);\n    const S = biModMul(BI_FOUR, biModMul(X1, Y1sq));\n    const M = biModMul(BI_THREE, biModMul(X1, X1));\n    const X3 = biModSub(biModMul(M, M), biModMul(BI_TWO, S));\n    const Y3 = biModSub(biModMul(M, biModSub(S, X3)), biModMul(BI_EIGHT, biModMul(Y1sq, Y1sq)));\n    const Z3 = biModMul(BI_TWO, biModMul(Y1, Z1));\n    return { X: X3, Y: Y3, Z: Z3 };\n};\nconst jpAdd = (P, Q) => {\n    if (P.Z === BI_ZERO)\n        return Q;\n    if (Q.Z === BI_ZERO)\n        return P;\n    const Z1Z1 = biModMul(P.Z, P.Z);\n    const Z2Z2 = biModMul(Q.Z, Q.Z);\n    const U1 = biModMul(P.X, Z2Z2);\n    const U2 = biModMul(Q.X, Z1Z1);\n    const S1 = biModMul(P.Y, biModMul(Z2Z2, Q.Z));\n    const S2 = biModMul(Q.Y, biModMul(Z1Z1, P.Z));\n    const H = biModSub(U2, U1);\n    const r = biModSub(S2, S1);\n    if (H === BI_ZERO) {\n        if (r === BI_ZERO)\n            return jpDouble(P);\n        return { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO }; // Infinity\n    }\n    const HH = biModMul(H, H);\n    const HHH = biModMul(H, HH);\n    const V = biModMul(U1, HH);\n    const X3 = biModSub(biModSub(biModMul(r, r), HHH), biModMul(BI_TWO, V));\n    const Y3 = biModSub(biModMul(r, biModSub(V, X3)), biModMul(S1, HHH));\n    const Z3 = biModMul(H, biModMul(P.Z, Q.Z));\n    return { X: X3, Y: Y3, Z: Z3 };\n};\nconst jpNeg = (P) => {\n    if (P.Z === BI_ZERO)\n        return P;\n    return { X: P.X, Y: P_BIGINT - P.Y, Z: P.Z };\n};\n// Fast windowed-NAF scalar multiplication (default window = 5) in Jacobian\n// coordinates.  Returns Q = k * P0 as a JacobianPoint.\nconst scalarMultiplyWNAF = (k, P0, window = 5) => {\n    const key = `${window}:${P0.x.toString(16)}:${P0.y.toString(16)}`;\n    let tbl = WNAF_TABLE_CACHE.get(key);\n    let P;\n    if (tbl === undefined) {\n        // Convert affine to Jacobian and pre-compute odd multiples\n        const tblSize = 1 << (window - 1); // e.g. w=5  16 entries\n        tbl = new Array(tblSize);\n        P = { X: P0.x, Y: P0.y, Z: BI_ONE };\n        tbl[0] = P;\n        const twoP = jpDouble(P);\n        for (let i = 1; i < tblSize; i++) {\n            tbl[i] = jpAdd(tbl[i - 1], twoP);\n        }\n        WNAF_TABLE_CACHE.set(key, tbl);\n    }\n    else {\n        P = tbl[0];\n    }\n    // Build wNAF representation of k\n    const wnaf = [];\n    const wBig = 1n << BigInt(window);\n    const wHalf = wBig >> 1n;\n    let kTmp = k;\n    while (kTmp > 0n) {\n        if ((kTmp & BI_ONE) === BI_ZERO) {\n            wnaf.push(0);\n            kTmp >>= BI_ONE;\n        }\n        else {\n            let z = kTmp & (wBig - 1n); // kTmp mod 2^w\n            if (z > wHalf)\n                z -= wBig; // make it odd & within (-2^{w-1}, 2^{w-1})\n            wnaf.push(Number(z));\n            kTmp -= z;\n            kTmp >>= BI_ONE;\n        }\n    }\n    // Accumulate from MSB to LSB\n    let Q = { X: BI_ZERO, Y: BI_ONE, Z: BI_ZERO }; // infinity\n    for (let i = wnaf.length - 1; i >= 0; i--) {\n        Q = jpDouble(Q);\n        const di = wnaf[i];\n        if (di !== 0) {\n            const idx = Math.abs(di) >> 1; // (|di|-1)/2  because di is odd\n            const addend = di > 0 ? tbl[idx] : jpNeg(tbl[idx]);\n            Q = jpAdd(Q, addend);\n        }\n    }\n    return Q;\n};\nconst modN = (a) => {\n    let r = a % N_BIGINT;\n    if (r < 0n)\n        r += N_BIGINT;\n    return r;\n};\nconst modMulN = (a, b) => modN(a * b);\n/** modular inverse modulo n with plain extendedgcd (not constanttime) */\nconst modInvN = (a) => {\n    let lm = 1n;\n    let hm = 0n;\n    let low = modN(a);\n    let high = N_BIGINT;\n    while (low > 1n) {\n        const q = high / low;\n        [lm, hm] = [hm - lm * q, lm];\n        [low, high] = [high - low * q, low];\n    }\n    return modN(lm);\n};\n/**\n * `Point` class is a representation of an elliptic curve point with affine coordinates.\n * It extends the functionality of BasePoint and carries x, y coordinates of point on the curve.\n * It also introduces new methods for handling Point operations in elliptic curve.\n *\n * @class Point\n * @extends {BasePoint}\n *\n * @property x - The x-coordinate of the point.\n * @property y - The y-coordinate of the point.\n * @property inf - Flag to record if the point is at infinity in the Elliptic Curve.\n */\nclass Point extends _BasePoint_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    x;\n    y;\n    inf;\n    /**\n     * Creates a point object from a given Array. These numbers can represent coordinates in hex format, or points\n     * in multiple established formats.\n     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.\n     *\n     * @method fromDER\n     * @static\n     * @param bytes - The point representation number array.\n     * @returns Returns a new point representing the given string.\n     * @throws `Error` If the point number[] value has a wrong length.\n     * @throws `Error` If the point format is unknown.\n     *\n     * @example\n     * const derPoint = [ 2, 18, 123, 108, 125, 83, 1, 251, 164, 214, 16, 119, 200, 216, 210, 193, 251, 193, 129, 67, 97, 146, 210, 216, 77, 254, 18, 6, 150, 190, 99, 198, 128 ];\n     * const point = Point.fromDER(derPoint);\n     */\n    static fromDER(bytes) {\n        const len = 32;\n        // uncompressed, hybrid-odd, hybrid-even\n        if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n            bytes.length - 1 === 2 * len) {\n            if (bytes[0] === 0x06) {\n                if (bytes[bytes.length - 1] % 2 !== 0) {\n                    throw new Error('Point string value is wrong length');\n                }\n            }\n            else if (bytes[0] === 0x07) {\n                if (bytes[bytes.length - 1] % 2 !== 1) {\n                    throw new Error('Point string value is wrong length');\n                }\n            }\n            const res = new Point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));\n            return res;\n        }\n        else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n            bytes.length - 1 === len) {\n            return Point.fromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n        }\n        throw new Error('Unknown point format');\n    }\n    /**\n     * Creates a point object from a given string. This string can represent coordinates in hex format, or points\n     * in multiple established formats.\n     * The function verifies the integrity of the provided data and throws errors if inconsistencies are found.\n     *\n     * @method fromString\n     * @static\n     *\n     * @param str The point representation string.\n     * @returns Returns a new point representing the given string.\n     * @throws `Error` If the point string value has a wrong length.\n     * @throws `Error` If the point format is unknown.\n     *\n     * @example\n     * const pointStr = 'abcdef';\n     * const point = Point.fromString(pointStr);\n     */\n    static fromString(str) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(str, 'hex');\n        return Point.fromDER(bytes);\n    }\n    /**\n     * Generates a point from an x coordinate and a boolean indicating whether the corresponding\n     * y coordinate is odd.\n     *\n     * @method fromX\n     * @static\n     * @param x - The x coordinate of the point.\n     * @param odd - Boolean indicating whether the corresponding y coordinate is odd or not.\n     * @returns Returns the new point.\n     * @throws `Error` If the point is invalid.\n     *\n     * @example\n     * const xCoordinate = new BigNumber('10');\n     * const point = Point.fromX(xCoordinate, true);\n     */\n    static fromX(x, odd) {\n        let xBigInt = toBigInt(x);\n        xBigInt = biMod(xBigInt);\n        const y2 = biModAdd(biModMul(biModSqr(xBigInt), xBigInt), 7n);\n        const y = biModSqrt(y2);\n        if (y === null)\n            throw new Error('Invalid point');\n        let yBig = y;\n        if ((yBig & BI_ONE) !== (odd ? BI_ONE : BI_ZERO)) {\n            yBig = biModSub(P_BIGINT, yBig);\n        }\n        const xBN = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](xBigInt.toString(16), 16);\n        const yBN = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](yBig.toString(16), 16);\n        return new Point(xBN, yBN);\n    }\n    /**\n     * Generates a point from a serialized JSON object. The function accounts for different options in the JSON object,\n     * including precomputed values for optimization of EC operations, and calls another helper function to turn nested\n     * JSON points into proper Point objects.\n     *\n     * @method fromJSON\n     * @static\n     * @param obj - An object or array that holds the data for the point.\n     * @param isRed - A boolean to direct how the Point is constructed from the JSON object.\n     * @returns Returns a new point based on the deserialized JSON object.\n     *\n     * @example\n     * const serializedPoint = '{\"x\":52,\"y\":15}';\n     * const point = Point.fromJSON(serializedPoint, true);\n     */\n    static fromJSON(obj, isRed) {\n        if (typeof obj === 'string') {\n            obj = JSON.parse(obj);\n        }\n        const res = new Point(obj[0], obj[1], isRed);\n        if (typeof obj[2] !== 'object') {\n            return res;\n        }\n        const obj2point = (obj) => {\n            return new Point(obj[0], obj[1], isRed);\n        };\n        const pre = obj[2];\n        res.precomputed = {\n            beta: null,\n            doubles: typeof pre.doubles === 'object' && pre.doubles !== null\n                ? {\n                    step: pre.doubles.step,\n                    points: [res].concat(pre.doubles.points.map(obj2point))\n                }\n                : undefined,\n            naf: typeof pre.naf === 'object' && pre.naf !== null\n                ? {\n                    wnd: pre.naf.wnd,\n                    points: [res].concat(pre.naf.points.map(obj2point))\n                }\n                : undefined\n        };\n        return res;\n    }\n    /**\n     * @constructor\n     * @param x - The x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.\n     * @param y - The y-coordinate of the point, similar to x.\n     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.\n     *\n     * @example\n     * new Point('abc123', 'def456');\n     * new Point(null, null); // Generates Infinity point.\n     */\n    constructor(x, y, isRed = true) {\n        super('affine');\n        this.precomputed = null;\n        if (x === null && y === null) {\n            this.x = null;\n            this.y = null;\n            this.inf = true;\n        }\n        else {\n            if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isBN(x)) {\n                x = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](x, 16);\n            }\n            this.x = x;\n            if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isBN(y)) {\n                y = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](y, 16);\n            }\n            this.y = y;\n            // Force redgomery representation when loading from JSON\n            if (isRed) {\n                this.x.forceRed(this.curve.red);\n                this.y.forceRed(this.curve.red);\n            }\n            if (this.x.red === null) {\n                this.x = this.x.toRed(this.curve.red);\n            }\n            if (this.y.red === null) {\n                this.y = this.y.toRed(this.curve.red);\n            }\n            this.inf = false;\n        }\n    }\n    /**\n     * Validates if a point belongs to the curve. Follows the short Weierstrass\n     * equation for elliptic curves: y^2 = x^3 + ax + b.\n     *\n     * @method validate\n     * @returns {boolean} true if the point is on the curve, false otherwise.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const isValid = aPoint.validate();\n     */\n    validate() {\n        return this.curve.validate(this);\n    }\n    /**\n     * Encodes the coordinates of a point into an array or a hexadecimal string.\n     * The details of encoding are determined by the optional compact and enc parameters.\n     *\n     * @method encode\n     * @param compact - If true, an additional prefix byte 0x02 or 0x03 based on the 'y' coordinate being even or odd respectively is used. If false, byte 0x04 is used.\n     * @param enc - Expects the string 'hex' if hexadecimal string encoding is required instead of an array of numbers.\n     * @throws Will throw an error if the specified encoding method is not recognized. Expects 'hex'.\n     * @returns If enc is undefined, a byte array representation of the point will be returned. if enc is 'hex', a hexadecimal string representation of the point will be returned.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const encodedPointArray = aPoint.encode();\n     * const encodedPointHex = aPoint.encode(true, 'hex');\n     */\n    encode(compact = true, enc) {\n        const len = this.curve.p.byteLength();\n        const x = this.getX().toArray('be', len);\n        let res;\n        if (compact) {\n            res = [this.getY().isEven() ? 0x02 : 0x03].concat(x);\n        }\n        else {\n            res = [0x04].concat(x, this.getY().toArray('be', len));\n        }\n        if (enc !== 'hex') {\n            return res;\n        }\n        else {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toHex)(res);\n        }\n    }\n    /**\n     * Converts the point coordinates to a hexadecimal string. A wrapper method\n     * for encode. Byte 0x02 or 0x03 is used as prefix based on the 'y' coordinate being even or odd respectively.\n     *\n     * @method toString\n     * @returns {string} A hexadecimal string representation of the point coordinates.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const stringPoint = aPoint.toString();\n     */\n    toString() {\n        return this.encode(true, 'hex');\n    }\n    /**\n     * Exports the x and y coordinates of the point, and the precomputed doubles and non-adjacent form (NAF) for optimization. The output is an array.\n     *\n     * @method toJSON\n     * @returns An Array where first two elements are the coordinates of the point and optional third element is an object with doubles and NAF points.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * const jsonPoint = aPoint.toJSON();\n     */\n    toJSON() {\n        if (this.precomputed == null) {\n            return [this.x, this.y];\n        }\n        return [\n            this.x,\n            this.y,\n            typeof this.precomputed === 'object' && this.precomputed !== null\n                ? {\n                    doubles: this.precomputed.doubles != null\n                        ? {\n                            step: this.precomputed.doubles.step,\n                            points: this.precomputed.doubles.points.slice(1)\n                        }\n                        : undefined,\n                    naf: this.precomputed.naf != null\n                        ? {\n                            wnd: this.precomputed.naf.wnd,\n                            points: this.precomputed.naf.points.slice(1)\n                        }\n                        : undefined\n                }\n                : undefined\n        ];\n    }\n    /**\n     * Provides the point coordinates in a human-readable string format for debugging purposes.\n     *\n     * @method inspect\n     * @returns String of the format '<EC Point x: x-coordinate y: y-coordinate>', or '<EC Point Infinity>' if the point is at infinity.\n     *\n     * @example\n     * const aPoint = new Point(x, y);\n     * console.log(aPoint.inspect());\n     */\n    inspect() {\n        if (this.isInfinity()) {\n            return '<EC Point Infinity>';\n        }\n        return ('<EC Point x: ' +\n            (this.x?.fromRed()?.toString(16, 2) ?? 'undefined') +\n            ' y: ' +\n            (this.y?.fromRed()?.toString(16, 2) ?? 'undefined') +\n            '>');\n    }\n    /**\n     * Checks if the point is at infinity.\n     * @method isInfinity\n     * @returns Returns whether or not the point is at infinity.\n     *\n     * @example\n     * const p = new Point(null, null);\n     * console.log(p.isInfinity()); // outputs: true\n     */\n    isInfinity() {\n        return this.inf;\n    }\n    /**\n     * Adds another Point to this Point, returning a new Point.\n     *\n     * @method add\n     * @param p - The Point to add to this one.\n     * @returns A new Point that results from the addition.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.add(p2);\n     */\n    add(p) {\n        // O + P = P\n        if (this.inf) {\n            return p;\n        }\n        // P + O = P\n        if (p.inf) {\n            return this;\n        }\n        // P + P = 2P\n        if (this.eq(p)) {\n            return this.dbl();\n        }\n        // P + (-P) = O\n        if (this.neg().eq(p)) {\n            return new Point(null, null);\n        }\n        // P + Q = O\n        if (this.x?.cmp(p.x ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)) === 0) {\n            return new Point(null, null);\n        }\n        const P1 = {\n            X: BigInt('0x' + this.x.fromRed().toString(16)),\n            Y: BigInt('0x' + this.y.fromRed().toString(16)),\n            Z: BI_ONE\n        };\n        const Q1 = {\n            X: BigInt('0x' + p.x.fromRed().toString(16)),\n            Y: BigInt('0x' + p.y.fromRed().toString(16)),\n            Z: BI_ONE\n        };\n        const R = jpAdd(P1, Q1);\n        if (R.Z === BI_ZERO)\n            return new Point(null, null);\n        const zInv = biModInv(R.Z);\n        const zInv2 = biModMul(zInv, zInv);\n        const xRes = biModMul(R.X, zInv2);\n        const yRes = biModMul(R.Y, biModMul(zInv2, zInv));\n        return new Point(xRes.toString(16), yRes.toString(16));\n    }\n    /**\n     * Doubles the current point.\n     *\n     * @method dbl\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const result = P.dbl();\n     * */\n    dbl() {\n        if (this.inf)\n            return this;\n        if (this.x === null || this.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        const X = BigInt('0x' + this.x.fromRed().toString(16));\n        const Y = BigInt('0x' + this.y.fromRed().toString(16));\n        if (Y === BI_ZERO)\n            return new Point(null, null);\n        const R = jpDouble({ X, Y, Z: BI_ONE });\n        const zInv = biModInv(R.Z);\n        const zInv2 = biModMul(zInv, zInv);\n        const xRes = biModMul(R.X, zInv2);\n        const yRes = biModMul(R.Y, biModMul(zInv2, zInv));\n        return new Point(xRes.toString(16), yRes.toString(16));\n    }\n    /**\n     * Returns X coordinate of point\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const x = P.getX();\n     */\n    getX() {\n        return (this.x ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).fromRed();\n    }\n    /**\n     * Returns X coordinate of point\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const x = P.getX();\n     */\n    getY() {\n        return (this.y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).fromRed();\n    }\n    /**\n     * Multiplies this Point by a scalar value, returning a new Point.\n     *\n     * @method mul\n     * @param k - The scalar value to multiply this Point by.\n     * @returns  A new Point that results from the multiplication.\n     *\n     * @example\n     * const p = new Point(1, 2);\n     * const result = p.mul(2); // this doubles the Point\n     */\n    mul(k) {\n        if (!_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isBN(k)) {\n            k = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](k, 16);\n        }\n        k = k;\n        if (this.inf) {\n            return this;\n        }\n        let kBig = BigInt('0x' + k.toString(16));\n        const isNeg = kBig < BI_ZERO;\n        if (isNeg)\n            kBig = -kBig;\n        kBig = biMod(kBig);\n        if (kBig === BI_ZERO) {\n            return new Point(null, null);\n        }\n        if (this.x === null || this.y === null) {\n            throw new Error('Point coordinates cannot be null');\n        }\n        let Px;\n        let Py;\n        if (this === this.curve.g) {\n            Px = GX_BIGINT;\n            Py = GY_BIGINT;\n        }\n        else {\n            Px = BigInt('0x' + this.x.fromRed().toString(16));\n            Py = BigInt('0x' + this.y.fromRed().toString(16));\n        }\n        const R = scalarMultiplyWNAF(kBig, { x: Px, y: Py });\n        if (R.Z === BI_ZERO) {\n            return new Point(null, null);\n        }\n        const zInv = biModInv(R.Z);\n        const zInv2 = biModMul(zInv, zInv);\n        const xRes = biModMul(R.X, zInv2);\n        const yRes = biModMul(R.Y, biModMul(zInv2, zInv));\n        const xBN = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](xRes.toString(16), 16);\n        const yBN = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](yRes.toString(16), 16);\n        const result = new Point(xBN, yBN);\n        if (isNeg) {\n            return result.neg();\n        }\n        return result;\n    }\n    /**\n     * Performs a multiplication and addition operation in a single step.\n     * Multiplies this Point by k1, adds the resulting Point to the result of p2 multiplied by k2.\n     *\n     * @method mulAdd\n     * @param k1 - The scalar value to multiply this Point by.\n     * @param p2 - The other Point to be involved in the operation.\n     * @param k2 - The scalar value to multiply the Point p2 by.\n     * @returns A Point that results from the combined multiplication and addition operations.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.mulAdd(2, p2, 3);\n     */\n    mulAdd(k1, p2, k2) {\n        const points = [this, p2];\n        const coeffs = [k1, k2];\n        return this._endoWnafMulAdd(points, coeffs);\n    }\n    /**\n     * Performs the Jacobian multiplication and addition operation in a single\n     * step. Instead of returning a regular Point, the result is a JacobianPoint.\n     *\n     * @method jmulAdd\n     * @param k1 - The scalar value to multiply this Point by.\n     * @param p2 - The other Point to be involved in the operation\n     * @param k2 - The scalar value to multiply the Point p2 by.\n     * @returns A JacobianPoint that results from the combined multiplication and addition operation.\n     *\n     * @example\n     * const p1 = new Point(1, 2);\n     * const p2 = new Point(2, 3);\n     * const result = p1.jmulAdd(2, p2, 3);\n     */\n    jmulAdd(k1, p2, k2) {\n        const points = [this, p2];\n        const coeffs = [k1, k2];\n        return this._endoWnafMulAdd(points, coeffs, true);\n    }\n    /**\n     * Checks if the Point instance is equal to another given Point.\n     *\n     * @method eq\n     * @param p - The Point to be checked if equal to the current instance.\n     *\n     * @returns Whether the two Point instances are equal. Both the 'x' and 'y' coordinates have to match, and both points have to either be valid or at infinity for equality. If both conditions are true, it returns true, else it returns false.\n     *\n     * @example\n     * const p1 = new Point(5, 20);\n     * const p2 = new Point(5, 20);\n     * const areEqual = p1.eq(p2); // returns true\n     */\n    eq(p) {\n        return (this === p ||\n            (this.inf === p.inf &&\n                (this.inf || ((this.x ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).cmp(p.x ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)) === 0 && (this.y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).cmp(p.y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)) === 0))));\n    }\n    /**\n     * Negate a point. The negation of a point P is the mirror of P about x-axis.\n     *\n     * @method neg\n     *\n     * @example\n     * const P = new Point('123', '456');\n     * const result = P.neg();\n     */\n    neg(_precompute) {\n        if (this.inf) {\n            return this;\n        }\n        const res = new Point(this.x, (this.y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).redNeg());\n        if (_precompute === true && this.precomputed != null) {\n            const pre = this.precomputed;\n            const negate = (p) => p.neg();\n            res.precomputed = {\n                naf: pre.naf != null\n                    ? {\n                        wnd: pre.naf.wnd,\n                        points: pre.naf.points.map(negate)\n                    }\n                    : undefined,\n                doubles: pre.doubles != null\n                    ? {\n                        step: pre.doubles.step,\n                        points: pre.doubles.points.map((p) => p.neg())\n                    }\n                    : undefined,\n                beta: undefined\n            };\n        }\n        return res;\n    }\n    /**\n     * Performs the \"doubling\" operation on the Point a given number of times.\n     * This is used in elliptic curve operations to perform multiplication by 2, multiple times.\n     * If the point is at infinity, it simply returns the point because doubling\n     * a point at infinity is still infinity.\n     *\n     * @method dblp\n     * @param k - The number of times the \"doubling\" operation is to be performed on the Point.\n     * @returns The Point after 'k' \"doubling\" operations have been performed.\n     *\n     * @example\n     * const p = new Point(5, 20);\n     * const doubledPoint = p.dblp(10); // returns the point after \"doubled\" 10 times\n     */\n    dblp(k) {\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let r = this;\n        for (let i = 0; i < k; i++) {\n            r = r.dbl();\n        }\n        return r;\n    }\n    /**\n     * Converts the point to a Jacobian point. If the point is at infinity, the corresponding Jacobian point\n     * will also be at infinity.\n     *\n     * @method toJ\n     * @returns Returns a new Jacobian point based on the current point.\n     *\n     * @example\n     * const point = new Point(xCoordinate, yCoordinate);\n     * const jacobianPoint = point.toJ();\n     */\n    toJ() {\n        if (this.inf) {\n            return new _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](null, null, null);\n        }\n        const res = new _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.x, this.y, this.curve.one);\n        return res;\n    }\n    _getBeta() {\n        if (typeof this.curve.endo !== 'object') {\n            return;\n        }\n        const pre = this.precomputed;\n        if (typeof pre === 'object' &&\n            pre !== null &&\n            typeof pre.beta === 'object' &&\n            pre.beta !== null) {\n            return pre.beta;\n        }\n        const beta = new Point((this.x ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).redMul(this.curve.endo.beta), this.y);\n        if (pre != null) {\n            const curve = this.curve;\n            const endoMul = (p) => {\n                if (p.x === null) {\n                    throw new Error('p.x is null');\n                }\n                if (curve.endo === undefined || curve.endo === null) {\n                    throw new Error('curve.endo is undefined');\n                }\n                return new Point(p.x.redMul(curve.endo.beta), p.y);\n            };\n            pre.beta = beta;\n            beta.precomputed = {\n                beta: null,\n                naf: pre.naf != null\n                    ? {\n                        wnd: pre.naf.wnd,\n                        points: pre.naf.points.map(endoMul)\n                    }\n                    : undefined,\n                doubles: pre.doubles != null\n                    ? {\n                        step: pre.doubles.step,\n                        points: pre.doubles.points.map(endoMul)\n                    }\n                    : undefined\n            };\n        }\n        return beta;\n    }\n    _fixedNafMul(k) {\n        if (typeof this.precomputed !== 'object' || this.precomputed === null) {\n            throw new Error('_fixedNafMul requires precomputed values for the point');\n        }\n        const doubles = this._getDoubles();\n        const naf = this.curve.getNAF(k, 1, this.curve._bitLength);\n        let I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n        I /= 3;\n        // Translate into more windowed form\n        const repr = [];\n        for (let j = 0; j < naf.length; j += doubles.step) {\n            let nafW = 0;\n            for (let k = j + doubles.step - 1; k >= j; k--) {\n                nafW = (nafW << 1) + naf[k];\n            }\n            repr.push(nafW);\n        }\n        let a = new _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](null, null, null);\n        let b = new _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](null, null, null);\n        for (let i = I; i > 0; i--) {\n            for (let j = 0; j < repr.length; j++) {\n                const nafW = repr[j];\n                if (nafW === i) {\n                    b = b.mixedAdd(doubles.points[j]);\n                }\n                else if (nafW === -i) {\n                    b = b.mixedAdd(doubles.points[j].neg());\n                }\n            }\n            a = a.add(b);\n        }\n        return a.toP();\n    }\n    _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {\n        const wndWidth = this.curve._wnafT1.map(num => num.toNumber()); // Convert BigNumber to number\n        const wnd = this.curve._wnafT2.map(() => []); // Initialize as empty Point[][] array\n        const naf = this.curve._wnafT3.map(() => []); // Initialize as empty number[][] array\n        // Fill all arrays\n        let max = 0;\n        for (let i = 0; i < len; i++) {\n            const p = points[i];\n            const nafPoints = p._getNAFPoints(defW);\n            wndWidth[i] = nafPoints.wnd; // Ensure correct type\n            wnd[i] = nafPoints.points; // Ensure correct type\n        }\n        // Comb small window NAFs\n        for (let i = len - 1; i >= 1; i -= 2) {\n            const a = i - 1;\n            const b = i;\n            if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n                naf[a] = this.curve.getNAF(coeffs[a], wndWidth[a], this.curve._bitLength);\n                naf[b] = this.curve.getNAF(coeffs[b], wndWidth[b], this.curve._bitLength);\n                max = Math.max(naf[a].length, max);\n                max = Math.max(naf[b].length, max);\n                continue;\n            }\n            const comb = [\n                points[a] /* 1 */,\n                null /* 3 */,\n                null /* 5 */,\n                points[b] /* 7 */\n            ];\n            // Try to avoid Projective points, if possible\n            if ((points[a].y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).cmp(points[b].y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)) === 0) {\n                comb[1] = points[a].add(points[b]);\n                comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n            }\n            else if ((points[a].y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).cmp((points[b].y ?? new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0)).redNeg()) === 0) {\n                comb[1] = points[a].toJ().mixedAdd(points[b]);\n                comb[2] = points[a].add(points[b].neg());\n            }\n            else {\n                comb[1] = points[a].toJ().mixedAdd(points[b]);\n                comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n            }\n            const index = [\n                -3 /* -1 -1 */, -1 /* -1 0 */, -5 /* -1 1 */, -7 /* 0 -1 */,\n                0 /* 0 0 */, 7 /* 0 1 */, 5 /* 1 -1 */, 1 /* 1 0 */, 3 /* 1 1 */\n            ];\n            const jsf = this.curve.getJSF(coeffs[a], coeffs[b]);\n            max = Math.max(jsf[0].length, max);\n            naf[a] = new Array(max);\n            naf[b] = new Array(max);\n            for (let j = 0; j < max; j++) {\n                const ja = jsf[0][j] | 0;\n                const jb = jsf[1][j] | 0;\n                naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n                naf[b][j] = 0;\n                wnd[a] = comb;\n            }\n        }\n        let acc = new _JacobianPoint_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](null, null, null);\n        const tmp = this.curve._wnafT4;\n        for (let i = max; i >= 0; i--) {\n            let k = 0;\n            while (i >= 0) {\n                let zero = true;\n                for (let j = 0; j < len; j++) {\n                    tmp[j] = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](typeof naf[j][i] === 'number' ? naf[j][i] : 0); // Ensure type consistency\n                    if (!tmp[j].isZero()) { // Use BigNumber's built-in comparison\n                        zero = false;\n                    }\n                }\n                if (!zero) {\n                    break;\n                }\n                k++;\n                i--;\n            }\n            if (i >= 0) {\n                k++;\n            }\n            acc = acc.dblp(k);\n            if (i < 0) {\n                break;\n            }\n            const one = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](1);\n            const two = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](2);\n            for (let j = 0; j < len; j++) {\n                const z = tmp[j];\n                let p;\n                if (z.cmpn(0) === 0) { // Check if z is 0\n                    continue;\n                }\n                else if (!z.isNeg()) { // If z is positive\n                    p = wnd[j][z.sub(one).div(two).toNumber()];\n                }\n                else { // If z is negative\n                    p = wnd[j][z.neg().sub(one).div(two).toNumber()].neg();\n                }\n                if (p.type === 'affine') {\n                    acc = acc.mixedAdd(p);\n                }\n                else {\n                    acc = acc.add(p);\n                }\n            }\n        }\n        // Zeroify references\n        for (let i = 0; i < len; i++) {\n            wnd[i] = [];\n        }\n        if (jacobianResult === true) {\n            return acc;\n        }\n        else {\n            return acc.toP();\n        }\n    }\n    _endoWnafMulAdd(points, coeffs, // Explicitly type coeffs\n    jacobianResult) {\n        const npoints = new Array(points.length * 2);\n        const ncoeffs = new Array(points.length * 2);\n        let i;\n        for (i = 0; i < points.length; i++) {\n            const split = this.curve._endoSplit(coeffs[i]);\n            let p = points[i];\n            let beta = p._getBeta() ?? new Point(null, null);\n            if (split.k1.negative !== 0) {\n                split.k1.ineg();\n                p = p.neg(true);\n            }\n            if (split.k2.negative !== 0) {\n                split.k2.ineg();\n                beta = beta.neg(true);\n            }\n            npoints[i * 2] = p;\n            npoints[i * 2 + 1] = beta;\n            ncoeffs[i * 2] = split.k1;\n            ncoeffs[i * 2 + 1] = split.k2;\n        }\n        const res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n        // Clean-up references to points and coefficients\n        for (let j = 0; j < i * 2; j++) {\n            npoints[j] = null;\n            ncoeffs[j] = null;\n        }\n        return res;\n    }\n    _hasDoubles(k) {\n        if (this.precomputed == null) {\n            return false;\n        }\n        const doubles = this.precomputed.doubles;\n        if (typeof doubles !== 'object') {\n            return false;\n        }\n        return (doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step));\n    }\n    _getDoubles(step, power) {\n        if (typeof this.precomputed === 'object' &&\n            this.precomputed !== null &&\n            typeof this.precomputed.doubles === 'object' &&\n            this.precomputed.doubles !== null) {\n            return this.precomputed.doubles;\n        }\n        const doubles = [this];\n        /* eslint-disable @typescript-eslint/no-this-alias */\n        let acc = this;\n        for (let i = 0; i < (power ?? 0); i += (step ?? 1)) {\n            for (let j = 0; j < (step ?? 1); j++) {\n                acc = acc.dbl();\n            }\n            doubles.push(acc);\n        }\n        return {\n            step: step ?? 1,\n            points: doubles\n        };\n    }\n    _getNAFPoints(wnd) {\n        if (typeof this.precomputed === 'object' &&\n            this.precomputed !== null &&\n            typeof this.precomputed.naf === 'object' &&\n            this.precomputed.naf !== null) {\n            return this.precomputed.naf;\n        }\n        const res = [this];\n        const max = (1 << wnd) - 1;\n        const dbl = max === 1 ? null : this.dbl();\n        for (let i = 1; i < max; i++) {\n            if (dbl !== null) {\n                res[i] = res[i - 1].add(dbl);\n            }\n        }\n        return {\n            wnd,\n            points: res\n        };\n    }\n}\n//# sourceMappingURL=Point.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Polynomial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Polynomial.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointInFiniteField: () => (/* binding */ PointInFiniteField),\n/* harmony export */   \"default\": () => (/* binding */ Polynomial)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _Random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\nclass PointInFiniteField {\n    x;\n    y;\n    constructor(x, y) {\n        const P = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]().p; // arithmetic is mod P\n        this.x = x.umod(P);\n        this.y = y.umod(P);\n    }\n    toString() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase58)(this.x.toArray()) + '.' + (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toBase58)(this.y.toArray());\n    }\n    static fromString(str) {\n        const [x, y] = str.split('.');\n        return new PointInFiniteField(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.fromBase58)(x)), new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.fromBase58)(y)));\n    }\n}\n/**\n * Polynomial class\n *\n * This class is used to create a polynomial with a given threshold and a private key.\n * The polynomial is used to create shares of the private key.\n *\n * @param key - The private key to split\n * @param threshold - The number of shares required to recombine the private key\n *\n * @example\n * const key = new PrivateKey()\n * const threshold = 2\n * const polynomial = new Polynomial(key, threshold)\n *\n */\nclass Polynomial {\n    points;\n    threshold;\n    constructor(points, threshold) {\n        this.points = points;\n        this.threshold = threshold ?? points.length; //  Handles undefined safely\n    }\n    static fromPrivateKey(key, threshold) {\n        const P = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]().p; // arithmetic is mod P\n        // The key is the y-intercept of the polynomial where x=0.\n        const points = [\n            new PointInFiniteField(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0), new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](key.toArray()))\n        ];\n        // The other values are random\n        for (let i = 1; i < threshold; i++) {\n            const randomX = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32)).umod(P);\n            const randomY = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32)).umod(P);\n            points.push(new PointInFiniteField(randomX, randomY));\n        }\n        return new Polynomial(points);\n    }\n    // Evaluate the polynomial at x by using Lagrange interpolation\n    valueAt(x) {\n        const P = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]().p; // arithmetic is mod P\n        let y = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0);\n        for (let i = 0; i < this.threshold; i++) {\n            let term = this.points[i].y;\n            for (let j = 0; j < this.threshold; j++) {\n                if (i !== j) {\n                    const xj = this.points[j].x;\n                    const xi = this.points[i].x;\n                    const numerator = x.sub(xj).umod(P);\n                    const denominator = xi.sub(xj).umod(P);\n                    const denominatorInverse = denominator.invm(P);\n                    const fraction = numerator.mul(denominatorInverse).umod(P);\n                    term = term.mul(fraction).umod(P);\n                }\n            }\n            y = y.add(term).umod(P);\n        }\n        return y;\n    }\n}\n//# sourceMappingURL=Polynomial.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Polynomial.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyShares: () => (/* binding */ KeyShares),\n/* harmony export */   \"default\": () => (/* binding */ PrivateKey)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _ECDSA_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _Random_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _Polynomial_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Polynomial.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Polynomial.js\");\n\n\n\n\n\n\n\n\n/**\n * @class KeyShares\n *\n * This class is used to store the shares of a private key.\n *\n * @param shares - An array of shares\n * @param threshold - The number of shares required to recombine the private key\n *\n * @returns KeyShares\n *\n * @example\n * const key = PrivateKey.fromShares(shares)\n *\n */\nclass KeyShares {\n    points;\n    threshold;\n    integrity;\n    constructor(points, threshold, integrity) {\n        this.points = points;\n        this.threshold = threshold;\n        this.integrity = integrity;\n    }\n    static fromBackupFormat(shares) {\n        let threshold = 0;\n        let integrity = '';\n        const points = shares.map((share, idx) => {\n            const shareParts = share.split('.');\n            if (shareParts.length !== 4) {\n                throw new Error('Invalid share format in share ' +\n                    idx.toString() +\n                    '. Expected format: \"x.y.t.i\" - received ' +\n                    share);\n            }\n            const [x, y, t, i] = shareParts;\n            if (t === undefined)\n                throw new Error('Threshold not found in share ' + idx.toString());\n            if (i === undefined)\n                throw new Error('Integrity not found in share ' + idx.toString());\n            const tInt = parseInt(t);\n            if (idx !== 0 && threshold !== tInt) {\n                throw new Error('Threshold mismatch in share ' + idx.toString());\n            }\n            if (idx !== 0 && integrity !== i) {\n                throw new Error('Integrity mismatch in share ' + idx.toString());\n            }\n            threshold = tInt;\n            integrity = i;\n            return _Polynomial_js__WEBPACK_IMPORTED_MODULE_7__.PointInFiniteField.fromString([x, y].join('.'));\n        });\n        return new KeyShares(points, threshold, integrity);\n    }\n    toBackupFormat() {\n        return this.points.map((share) => share.toString() + '.' + this.threshold.toString() + '.' + this.integrity);\n    }\n}\n/**\n * Represents a Private Key, which is a secret that can be used to generate signatures in a cryptographic system.\n *\n * The `PrivateKey` class extends from the `BigNumber` class. It offers methods to create signatures, verify them,\n * create a corresponding public key and derive a shared secret from a public key.\n *\n * @extends {BigNumber}\n * @see {@link BigNumber} for more information on BigNumber.\n */\nclass PrivateKey extends _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * Generates a private key randomly.\n     *\n     * @method fromRandom\n     * @static\n     * @returns The newly generated Private Key.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     */\n    static fromRandom() {\n        return new PrivateKey((0,_Random_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(32));\n    }\n    /**\n     * Generates a private key from a string.\n     *\n     * @method fromString\n     * @static\n     * @param str - The string to generate the private key from.\n     * @param base - The base of the string.\n     * @returns The generated Private Key.\n     * @throws Will throw an error if the string is not valid.\n     **/\n    static fromString(str, base = 'hex') {\n        return new PrivateKey(super.fromString(str, base).toArray());\n    }\n    /**\n     * Generates a private key from a hexadecimal string.\n     *\n     * @method fromHex\n     * @static\n     * @param {string} str - The hexadecimal string representing the private key. The string must represent a valid private key in big-endian format.\n     * @returns {PrivateKey} The generated Private Key instance.\n     * @throws {Error} If the string is not a valid hexadecimal or represents an invalid private key.\n     **/\n    static fromHex(str) {\n        return new PrivateKey(super.fromHex(str, 'big'));\n    }\n    /**\n     * Generates a private key from a WIF (Wallet Import Format) string.\n     *\n     * @method fromWif\n     * @static\n     * @param wif - The WIF string to generate the private key from.\n     * @param base - The base of the string.\n     * @returns The generated Private Key.\n     * @throws Will throw an error if the string is not a valid WIF.\n     **/\n    static fromWif(wif, prefixLength = 1) {\n        const decoded = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.fromBase58Check)(wif, undefined, prefixLength);\n        if (decoded.data.length !== 33) {\n            throw new Error('Invalid WIF length');\n        }\n        if (decoded.data[32] !== 1) {\n            throw new Error('Invalid WIF padding');\n        }\n        return new PrivateKey(decoded.data.slice(0, 32));\n    }\n    /**\n     * @constructor\n     *\n     * @param number - The number (various types accepted) to construct a BigNumber from. Default is 0.\n     *\n     * @param base - The base of number provided. By default is 10. Ignored if number is BigNumber.\n     *\n     * @param endian - The endianness provided. By default is 'big endian'. Ignored if number is BigNumber.\n     *\n     * @param modN - Optional. Default 'apply. If 'apply', apply modN to input to guarantee a valid PrivateKey. If 'error', if input is out of field throw new Error('Input is out of field'). If 'nocheck', assumes input is in field.\n     *\n     * @example\n     * import PrivateKey from './PrivateKey';\n     * import BigNumber from './BigNumber';\n     * const privKey = new PrivateKey(new BigNumber('123456', 10, 'be'));\n     */\n    constructor(number = 0, base = 10, endian = 'be', modN = 'apply') {\n        if (number instanceof _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            super();\n            number.copy(this);\n        }\n        else {\n            super(number, base, endian);\n        }\n        if (modN !== 'nocheck') {\n            const check = this.checkInField();\n            if (!check.inField) {\n                if (modN === 'error') {\n                    throw new Error('Input is out of field');\n                }\n                // Force the PrivateKey BigNumber value to lie in the field limited by curve.n\n                _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].move(this, check.modN);\n            }\n        }\n    }\n    /**\n     * A utility function to check that the value of this PrivateKey lies in the field limited by curve.n\n     * @returns { inField, modN } where modN is this PrivateKey's current BigNumber value mod curve.n, and inField is true only if modN equals current BigNumber value.\n     */\n    checkInField() {\n        const curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        const modN = this.mod(curve.n);\n        const inField = this.cmp(modN) === 0;\n        return { inField, modN };\n    }\n    /**\n     * @returns true if the PrivateKey's current BigNumber value lies in the field limited by curve.n\n     */\n    isValid() {\n        return this.checkInField().inField;\n    }\n    /**\n     * Signs a message using the private key.\n     *\n     * @method sign\n     * @param msg - The message (array of numbers or string) to be signed.\n     * @param enc - If 'hex' the string will be treated as hex, utf8 otherwise.\n     * @param forceLowS - If true (the default), the signature will be forced to have a low S value.\n     * @param customK  If provided, uses a custom K-value for the signature. Provie a function that returns a BigNumber, or the BigNumber itself.\n     * @returns A digital signature generated from the hash of the message and the private key.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const signature = privateKey.sign('Hello, World!');\n     */\n    sign(msg, enc, forceLowS = true, customK) {\n        const msgHash = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256)(msg, enc), 16);\n        return (0,_ECDSA_js__WEBPACK_IMPORTED_MODULE_3__.sign)(msgHash, this, forceLowS, customK);\n    }\n    /**\n     * Verifies a message's signature using the public key associated with this private key.\n     *\n     * @method verify\n     * @param msg - The original message which has been signed.\n     * @param sig - The signature to be verified.\n     * @param enc - The data encoding method.\n     * @returns Whether or not the signature is valid.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const signature = privateKey.sign('Hello, World!');\n     * const isSignatureValid = privateKey.verify('Hello, World!', signature);\n     */\n    verify(msg, sig, enc) {\n        const msgHash = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256)(msg, enc), 16);\n        return (0,_ECDSA_js__WEBPACK_IMPORTED_MODULE_3__.verify)(msgHash, sig, this.toPublicKey());\n    }\n    /**\n     * Converts the private key to its corresponding public key.\n     *\n     * The public key is generated by multiplying the base point G of the curve and the private key.\n     *\n     * @method toPublicKey\n     * @returns The generated PublicKey.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const publicKey = privateKey.toPublicKey();\n     */\n    toPublicKey() {\n        const c = new _Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        const p = c.g.mul(this);\n        return new _PublicKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](p.x, p.y);\n    }\n    /**\n     * Converts the private key to a Wallet Import Format (WIF) string.\n     *\n     * Base58Check encoding is used for encoding the private key.\n     * The prefix\n     *\n     * @method toWif\n     * @returns The WIF string.\n     *\n     * @param prefix defaults to [0x80] for mainnet, set it to [0xef] for testnet.\n     *\n     * @throws Error('Value is out of field') if current BigNumber value is out of field limited by curve.n\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const wif = privateKey.toWif();\n     * const testnetWif = privateKey.toWif([0xef]);\n     */\n    toWif(prefix = [0x80]) {\n        if (!this.isValid()) {\n            throw new Error('Value is out of field');\n        }\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toBase58Check)([...this.toArray('be', 32), 1], prefix);\n    }\n    /**\n     * Base58Check encodes the hash of the public key associated with this private key with a prefix to indicate locking script type.\n     * Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".\n     *\n     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'testnet' or 'mainnet'\n     *\n     * @returns Returns the address encoding associated with the hash of the public key associated with this private key.\n     *\n     * @example\n     * const address = privkey.toAddress()\n     * const address = privkey.toAddress('mainnet')\n     * const testnetAddress = privkey.toAddress([0x6f])\n     * const testnetAddress = privkey.toAddress('testnet')\n     */\n    toAddress(prefix = [0x00]) {\n        return this.toPublicKey().toAddress(prefix);\n    }\n    /**\n     * Converts this PrivateKey to a hexadecimal string.\n     *\n     * @method toHex\n     * @param length - The minimum length of the hex string\n     * @returns Returns a string representing the hexadecimal value of this BigNumber.\n     *\n     * @example\n     * const bigNumber = new BigNumber(255);\n     * const hex = bigNumber.toHex();\n     */\n    toHex() {\n        return super.toHex(32);\n    }\n    /**\n     * Converts this PrivateKey to a string representation.\n     *\n     * @method toString\n     * @param {number | 'hex'} [base='hex'] - The base for representing the number. Default is hexadecimal ('hex').\n     * @param {number} [padding=64] - The minimum number of digits for the output string. Default is 64, ensuring a 256-bit representation in hexadecimal.\n     * @returns {string} A string representation of the PrivateKey in the specified base, padded to the specified length.\n     *\n     **/\n    toString(base = 'hex', padding = 64) {\n        return super.toString(base, padding);\n    }\n    /**\n     * Derives a shared secret from the public key.\n     *\n     * @method deriveSharedSecret\n     * @param key - The public key to derive the shared secret from.\n     * @returns The derived shared secret (a point on the curve).\n     * @throws Will throw an error if the public key is not valid.\n     *\n     * @example\n     * const privateKey = PrivateKey.fromRandom();\n     * const publicKey = privateKey.toPublicKey();\n     * const sharedSecret = privateKey.deriveSharedSecret(publicKey);\n     */\n    deriveSharedSecret(key) {\n        if (!key.validate()) {\n            throw new Error('Public key not valid for ECDH secret derivation');\n        }\n        return key.mul(this);\n    }\n    /**\n     * Derives a child key with BRC-42.\n     * @param publicKey The public key of the other party\n     * @param invoiceNumber The invoice number used to derive the child key\n     * @param cacheSharedSecret Optional function to cache shared secrets\n     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache\n     * @returns The derived child key.\n     */\n    deriveChild(publicKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {\n        let sharedSecret;\n        if (typeof retrieveCachedSharedSecret === 'function') {\n            const retrieved = retrieveCachedSharedSecret(this, publicKey);\n            if (typeof retrieved !== 'undefined') {\n                sharedSecret = retrieved;\n            }\n            else {\n                sharedSecret = this.deriveSharedSecret(publicKey);\n                if (typeof cacheSharedSecret === 'function') {\n                    cacheSharedSecret(this, publicKey, sharedSecret);\n                }\n            }\n        }\n        else {\n            sharedSecret = this.deriveSharedSecret(publicKey);\n        }\n        const invoiceNumberBin = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toArray)(invoiceNumber, 'utf8');\n        const hmac = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);\n        const curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        return new PrivateKey(this.add(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](hmac)).mod(curve.n).toArray());\n    }\n    /**\n     * Splits the private key into shares using Shamir's Secret Sharing Scheme.\n     *\n     * @param threshold The minimum number of shares required to reconstruct the private key.\n     * @param totalShares The total number of shares to generate.\n     * @param prime The prime number to be used in Shamir's Secret Sharing Scheme.\n     * @returns An array of shares.\n     *\n     * @example\n     * const key = PrivateKey.fromRandom()\n     * const shares = key.toKeyShares(2, 5)\n     */\n    toKeyShares(threshold, totalShares) {\n        if (typeof threshold !== 'number' || typeof totalShares !== 'number') {\n            throw new Error('threshold and totalShares must be numbers');\n        }\n        if (threshold < 2)\n            throw new Error('threshold must be at least 2');\n        if (totalShares < 2)\n            throw new Error('totalShares must be at least 2');\n        if (threshold > totalShares) {\n            throw new Error('threshold should be less than or equal to totalShares');\n        }\n        const poly = _Polynomial_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromPrivateKey(this, threshold);\n        const points = [];\n        for (let i = 0; i < totalShares; i++) {\n            const x = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](PrivateKey.fromRandom().toArray());\n            const y = poly.valueAt(x);\n            points.push(new _Polynomial_js__WEBPACK_IMPORTED_MODULE_7__.PointInFiniteField(x, y));\n        }\n        const integrity = this.toPublicKey().toHash('hex').slice(0, 8);\n        return new KeyShares(points, threshold, integrity);\n    }\n    /**\n     * @method toBackupShares\n     *\n     * Creates a backup of the private key by splitting it into shares.\n     *\n     *\n     * @param threshold The number of shares which will be required to reconstruct the private key.\n     * @param totalShares The number of shares to generate for distribution.\n     * @returns\n     */\n    toBackupShares(threshold, totalShares) {\n        return this.toKeyShares(threshold, totalShares).toBackupFormat();\n    }\n    /**\n     *\n     * @method fromBackupShares\n     *\n     * Creates a private key from backup shares.\n     *\n     * @param shares\n     * @returns PrivateKey\n     *\n     * @example\n     *\n     * const share1 = '3znuzt7DZp8HzZTfTh5MF9YQKNX3oSxTbSYmSRGrH2ev.2Nm17qoocmoAhBTCs8TEBxNXCskV9N41rB2PckcgYeqV.2.35449bb9'\n     * const share2 = 'Cm5fuUc39X5xgdedao8Pr1kvCSm8Gk7Cfenc7xUKcfLX.2juyK9BxCWn2DiY5JUAgj9NsQ77cc9bWksFyW45haXZm.2.35449bb9'\n     *\n     * const recoveredKey = PrivateKey.fromBackupShares([share1, share2])\n     */\n    static fromBackupShares(shares) {\n        return PrivateKey.fromKeyShares(KeyShares.fromBackupFormat(shares));\n    }\n    /**\n     * Combines shares to reconstruct the private key.\n     *\n     * @param shares An array of points (shares) to be used to reconstruct the private key.\n     * @param threshold The minimum number of shares required to reconstruct the private key.\n     *\n     * @returns The reconstructed private key.\n     *\n     **/\n    static fromKeyShares(keyShares) {\n        const { points, threshold, integrity } = keyShares;\n        if (threshold < 2)\n            throw new Error('threshold must be at least 2');\n        if (points.length < threshold) {\n            throw new Error(`At least ${threshold} shares are required to reconstruct the private key`);\n        }\n        // check to see if two points have the same x value\n        for (let i = 0; i < threshold; i++) {\n            for (let j = i + 1; j < threshold; j++) {\n                if (points[i].x.eq(points[j].x)) {\n                    throw new Error('Duplicate share detected, each must be unique.');\n                }\n            }\n        }\n        const poly = new _Polynomial_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"](points, threshold);\n        const privateKey = new PrivateKey(poly.valueAt(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0)).toArray());\n        const integrityHash = privateKey.toPublicKey().toHash('hex').slice(0, 8);\n        if (integrityHash !== integrity) {\n            throw new Error('Integrity hash mismatch');\n        }\n        return privateKey;\n    }\n}\n//# sourceMappingURL=PrivateKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PublicKey)\n/* harmony export */ });\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _ECDSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\n\n\n\n/**\n * The PublicKey class extends the Point class. It is used in public-key cryptography to derive shared secret, verify message signatures, and encode the public key in the DER format.\n * The class comes with static methods to generate PublicKey instances from private keys or from strings.\n *\n * @extends {Point}\n * @see {@link Point} for more information on Point.\n */\nclass PublicKey extends _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * Static factory method to derive a public key from a private key.\n     * It multiplies the generator point 'g' on the elliptic curve by the private key.\n     *\n     * @static\n     * @method fromPrivateKey\n     *\n     * @param key - The private key from which to derive the public key.\n     *\n     * @returns Returns the PublicKey derived from the given PrivateKey.\n     *\n     * @example\n     * const myPrivKey = new PrivateKey(...)\n     * const myPubKey = PublicKey.fromPrivateKey(myPrivKey)\n     */\n    static fromPrivateKey(key) {\n        const c = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        const p = c.g.mul(key);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * Static factory method to create a PublicKey instance from a string.\n     *\n     * @param str - A string representing a public key.\n     *\n     * @returns Returns the PublicKey created from the string.\n     *\n     * @example\n     * const myPubKey = PublicKey.fromString(\"03....\")\n     */\n    static fromString(str) {\n        const p = _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromString(str);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * Static factory method to create a PublicKey instance from a number array.\n     *\n     * @param bytes - A number array representing a public key.\n     *\n     * @returns Returns the PublicKey created from the number array.\n     *\n     * @example\n     * const myPubKey = PublicKey.fromString(\"03....\")\n     */\n    static fromDER(bytes) {\n        const p = _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDER(bytes);\n        return new PublicKey(p.x, p.y);\n    }\n    /**\n     * @constructor\n     * @param x - A point or the x-coordinate of the point. May be a number, a BigNumber, a string (which will be interpreted as hex), a number array, or null. If null, an \"Infinity\" point is constructed.\n     * @param y - If x is not a point, the y-coordinate of the point, similar to x.\n     * @param isRed - A boolean indicating if the point is a member of the field of integers modulo the k256 prime. Default is true.\n     *\n     * @example\n     * new PublicKey(point1);\n     * new PublicKey('abc123', 'def456');\n     */\n    constructor(x, y = null, isRed = true) {\n        if (x instanceof _Point_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n            super(x.getX(), x.getY());\n        }\n        else {\n            // Common gotcha: constructing PublicKey with a DER value when you should use .fromString()\n            if (y === null && isRed && typeof x === 'string') {\n                if (x.length === 66 || x.length === 130) {\n                    throw new Error('You are using the \"new PublicKey()\" constructor with a DER hex string. You need to use \"PublicKey.fromString()\" instead.');\n                }\n            }\n            super(x, y, isRed);\n        }\n    }\n    /**\n     * Derive a shared secret from a public key and a private key for use in symmetric encryption.\n     * This method multiplies the public key (an instance of Point) with a private key.\n     *\n     * @param priv - The private key to use in deriving the shared secret.\n     *\n     * @returns Returns the Point representing the shared secret.\n     *\n     * @throws Will throw an error if the public key is not valid for ECDH secret derivation.\n     *\n     * @example\n     * const myPrivKey = new PrivateKey(...)\n     * const sharedSecret = myPubKey.deriveSharedSecret(myPrivKey)\n     */\n    deriveSharedSecret(priv) {\n        if (!this.validate()) {\n            throw new Error('Public key not valid for ECDH secret derivation');\n        }\n        return this.mul(priv);\n    }\n    /**\n     * Verify a signature of a message using this public key.\n     *\n     * @param msg - The message to verify. It can be a string or an array of numbers.\n     * @param sig - The Signature of the message that needs verification.\n     * @param enc - The encoding of the message. It defaults to 'utf8'.\n     *\n     * @returns Returns true if the signature is verified successfully, otherwise false.\n     *\n     * @example\n     * const myMessage = \"Hello, world!\"\n     * const mySignature = new Signature(...)\n     * const isVerified = myPubKey.verify(myMessage, mySignature)\n     */\n    verify(msg, sig, enc) {\n        const msgHash = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]((0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256)(msg, enc), 16);\n        return (0,_ECDSA_js__WEBPACK_IMPORTED_MODULE_2__.verify)(msgHash, sig, this);\n    }\n    /**\n     * Encode the public key to DER (Distinguished Encoding Rules) format.\n     *\n     * @returns Returns the DER-encoded public key in number array or string.\n     *\n     * @param enc - The encoding of the DER string. undefined = number array, 'hex' = hex string.\n     *\n     * @example\n     * const derPublicKey = myPubKey.toDER()\n     */\n    toDER(enc) {\n        if (enc === 'hex')\n            return this.encode(true, enc);\n        return this.encode(true);\n    }\n    /**\n     * Hash sha256 and ripemd160 of the public key.\n     *\n     * @returns Returns the hash of the public key.\n     *\n     * @example\n     * const publicKeyHash = pubkey.toHash()\n     */\n    toHash(enc) {\n        const pkh = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.hash160)(this.encode(true));\n        if (enc === 'hex') {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toHex)(pkh);\n        }\n        return pkh;\n    }\n    /**\n     * Base58Check encodes the hash of the public key with a prefix to indicate locking script type.\n     * Defaults to P2PKH for mainnet, otherwise known as a \"Bitcoin Address\".\n     *\n     * @param prefix defaults to [0x00] for mainnet, set to [0x6f] for testnet or use the strings 'mainnet' or 'testnet'\n     *\n     * @returns Returns the address encoding associated with the hash of the public key.\n     *\n     * @example\n     * const address = pubkey.toAddress()\n     * const address = pubkey.toAddress('mainnet')\n     * const testnetAddress = pubkey.toAddress([0x6f])\n     * const testnetAddress = pubkey.toAddress('testnet')\n     */\n    toAddress(prefix = [0x00]) {\n        if (typeof prefix === 'string') {\n            if (prefix === 'testnet' || prefix === 'test') {\n                prefix = [0x6f];\n            }\n            else if (prefix === 'mainnet' || prefix === 'main') {\n                prefix = [0x00];\n            }\n            else {\n                throw new Error(`Invalid prefix ${prefix}`);\n            }\n        }\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toBase58Check)(this.toHash(), prefix);\n    }\n    /**\n     * Derives a child key with BRC-42.\n     * @param privateKey The private key of the other party\n     * @param invoiceNumber The invoice number used to derive the child key\n     * @param cacheSharedSecret Optional function to cache shared secrets\n     * @param retrieveCachedSharedSecret Optional function to retrieve shared secrets from the cache\n     * @returns The derived child key.\n     */\n    deriveChild(privateKey, invoiceNumber, cacheSharedSecret, retrieveCachedSharedSecret) {\n        let sharedSecret;\n        if (typeof retrieveCachedSharedSecret === 'function') {\n            const retrieved = retrieveCachedSharedSecret(privateKey, this);\n            if (typeof retrieved !== 'undefined') {\n                sharedSecret = retrieved;\n            }\n            else {\n                sharedSecret = this.deriveSharedSecret(privateKey);\n                if (typeof cacheSharedSecret === 'function') {\n                    cacheSharedSecret(privateKey, this, sharedSecret);\n                }\n            }\n        }\n        else {\n            sharedSecret = this.deriveSharedSecret(privateKey);\n        }\n        const invoiceNumberBin = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toArray)(invoiceNumber, 'utf8');\n        const hmac = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_4__.sha256hmac)(sharedSecret.encode(true), invoiceNumberBin);\n        const curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        const point = curve.g.mul(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](hmac));\n        const finalPoint = this.add(point);\n        return new PublicKey(finalPoint.x, finalPoint.y);\n    }\n    /**\n     * Takes an array of numbers or a string and returns a new PublicKey instance.\n     * This method will throw an error if the Compact encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     * compactByte value 27-30 means uncompressed public key.\n     * 31-34 means compressed public key.\n     * The range represents the recovery param which can be 0,1,2,3.\n     *\n     * @static\n     * @method fromMsgHashAndCompactSignature\n     * @param msgHash - The message hash which was signed.\n     * @param signature - The signature in compact format.\n     * @param enc - The encoding of the signature string.\n     * @returns A PublicKey instance derived from the message hash and compact signature.\n     * @example\n     * const publicKey = Signature.fromMsgHashAndCompactSignature(msgHash, 'IMOl2mVKfDgsSsHT4uIYBNN4e...', 'base64');\n     */\n    static fromMsgHashAndCompactSignature(msgHash, signature, enc) {\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.toArray)(signature, enc);\n        if (data.length !== 65) {\n            throw new Error('Invalid Compact Signature');\n        }\n        const compactByte = data[0];\n        if (compactByte < 27 || compactByte >= 35) {\n            throw new Error('Invalid Compact Byte');\n        }\n        let r = data[0] - 27;\n        // NOTE: We don't use uncompressed pubkeys in this library,\n        // but whether the key is compressed is captured in the recovery param.\n        // Code below is commented out for reference of how you could capture this.\n        // let compressed = false\n        if (r > 3) {\n            // compressed = true\n            r -= 4;\n        }\n        const s = new _Signature_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](new _BigNumber_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data.slice(1, 33)), new _BigNumber_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](data.slice(33, 65)));\n        return s.RecoverPublicKey(r, msgHash);\n    }\n}\n//# sourceMappingURL=PublicKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nclass Rand {\n    _rand; //  Explicit function type\n    constructor() {\n        const noRand = () => {\n            throw new Error('No secure random number generator is available in this environment.');\n        };\n        this._rand = noRand; // Assign the function\n        if (typeof self === 'object') {\n            /* eslint-disable-next-line */\n            if (self.crypto?.getRandomValues) {\n                this._rand = (n) => {\n                    const arr = new Uint8Array(n);\n                    /* eslint-disable-next-line */\n                    self.crypto.getRandomValues(arr);\n                    return [...arr];\n                };\n            } /* if (typeof window === 'object') */\n            else {\n                this._rand = noRand;\n            }\n        }\n        else {\n            try {\n                /* eslint-disable-next-line */\n                const crypto = require(\"crypto\");\n                if (typeof crypto.randomBytes === 'function') {\n                    this._rand = (n) => [...crypto.randomBytes(n)];\n                }\n            }\n            catch {\n                this._rand = noRand;\n            }\n        }\n    }\n    generate(len) {\n        return this._rand(len);\n    }\n}\nlet ayn = null;\n/**\n * Generates a sequence of pseudo-random bytes with the given length.\n *\n * @param len - The number of bytes to generate\n *\n * @returns The generated bytes\n *\n * @example\n * import Random from '@bsv/sdk/primitives/Random'\n * const bytes = Random(32) // Produces 32 random bytes\n */\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((len) => {\n    if (ayn == null) {\n        ayn = new Rand();\n    }\n    return ayn.generate(len);\n});\n//# sourceMappingURL=Random.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReductionContext)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _K256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./K256.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/K256.js\");\n\n\n/**\n * A base reduction engine that provides several arithmetic operations over\n * big numbers under a modulus context. It's particularly suitable for\n * calculations required in cryptography algorithms and encoding schemas.\n *\n * @class ReductionContext\n *\n * @property prime - The prime number utilised in the reduction context, typically an instance of Mersenne class.\n * @property m - The modulus used for reduction operations.\n */\nclass ReductionContext {\n    prime;\n    m;\n    /**\n     * Constructs a new ReductionContext.\n     *\n     * @constructor\n     * @param m - A BigNumber representing the modulus, or 'k256' to create a context for Koblitz curve.\n     *\n     * @example\n     * new ReductionContext(new BigNumber(11));\n     * new ReductionContext('k256');\n     */\n    constructor(m) {\n        if (m === 'k256') {\n            const prime = new _K256_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n            this.m = prime.p;\n            this.prime = prime;\n        }\n        else {\n            this.assert(m.gtn(1), 'modulus must be greater than 1');\n            this.m = m;\n            this.prime = null;\n        }\n    }\n    /**\n     * Asserts that given value is truthy. Throws an Error with a provided message\n     * if the value is falsy.\n     *\n     * @private\n     * @param val - The value to be checked.\n     * @param msg - The error message to be thrown if the value is falsy.\n     *\n     * @example\n     * this.assert(1 < 2, '1 is not less than 2');\n     * this.assert(2 < 1, '2 is less than 1'); // throws an Error with message '2 is less than 1'\n     */\n    assert(val, msg = 'Assertion failed') {\n        if (!val)\n            throw new Error(msg);\n    }\n    /**\n     * Verifies that a BigNumber is positive and red. Throws an error if these\n     * conditions are not met.\n     *\n     * @param a - The BigNumber to be verified.\n     *\n     * @example\n     * this.verify1(new BigNumber(10).toRed());\n     * this.verify1(new BigNumber(-10).toRed()); //throws an Error\n     * this.verify1(new BigNumber(10)); //throws an Error\n     */\n    verify1(a) {\n        this.assert(a.negative === 0, 'red works only with positives');\n        this.assert(a.red, 'red works only with red numbers');\n    }\n    /**\n     * Verifies that two BigNumbers are both positive and red. Also checks\n     * that they have the same reduction context. Throws an error if these\n     * conditions are not met.\n     *\n     * @param a - The first BigNumber to be verified.\n     * @param b - The second BigNumber to be verified.\n     *\n     * @example\n     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20).toRed(this));\n     * this.verify2(new BigNumber(-10).toRed(this), new BigNumber(20).toRed(this)); //throws an Error\n     * this.verify2(new BigNumber(10).toRed(this), new BigNumber(20)); //throws an Error\n     */\n    verify2(a, b) {\n        this.assert((a.negative | b.negative) === 0, 'red works only with positives');\n        this.assert(a.red != null && a.red === b.red, 'red works only with red numbers');\n    }\n    /**\n     * Performs an in-place reduction of the given BigNumber by the modulus of the reduction context, 'm'.\n     *\n     * @method imod\n     *\n     * @param a - BigNumber to be reduced.\n     *\n     * @returns Returns the reduced result.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.imod(new BigNumber(19)); // Returns 5\n     */\n    imod(a) {\n        if (this.prime != null)\n            return this.prime.ireduce(a).forceRed(this);\n        _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].move(a, a.umod(this.m).forceRed(this));\n        return a;\n    }\n    /**\n     * Negates a BigNumber in the context of the modulus.\n     *\n     * @method neg\n     *\n     * @param a - BigNumber to negate.\n     *\n     * @returns Returns the negation of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.neg(new BigNumber(3)); // Returns 4\n     */\n    neg(a) {\n        if (a.isZero()) {\n            return a.clone();\n        }\n        return this.m.sub(a).forceRed(this);\n    }\n    /**\n     * Performs the addition operation on two BigNumbers in the reduction context.\n     *\n     * @method add\n     *\n     * @param a - First BigNumber to add.\n     * @param b - Second BigNumber to add.\n     *\n     * @returns Returns the result of 'a + b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * context.add(new BigNumber(2), new BigNumber(4)); // Returns 1\n     */\n    add(a, b) {\n        this.verify2(a, b);\n        const res = a.add(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs an in-place addition operation on two BigNumbers in the reduction context\n     * in order to avoid creating a new BigNumber, it modifies the first one with the result.\n     *\n     * @method iadd\n     *\n     * @param a - First BigNumber to add.\n     * @param b - Second BigNumber to add.\n     *\n     * @returns Returns the modified 'a' after addition with 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * const a = new BigNumber(2);\n     * context.iadd(a, new BigNumber(4)); // Modifies 'a' to be 1\n     */\n    iadd(a, b) {\n        this.verify2(a, b);\n        const res = a.iadd(b);\n        if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n        }\n        return res;\n    }\n    /**\n     * Subtracts one BigNumber from another BigNumber in the reduction context.\n     *\n     * @method sub\n     *\n     * @param a - BigNumber to be subtracted from.\n     * @param b - BigNumber to subtract.\n     *\n     * @returns Returns the result of 'a - b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.sub(new BigNumber(3), new BigNumber(2)); // Returns 1\n     */\n    sub(a, b) {\n        this.verify2(a, b);\n        const res = a.sub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res.forceRed(this);\n    }\n    /**\n     * Performs in-place subtraction of one BigNumber from another in the reduction context,\n     * it modifies the first BigNumber with the result.\n     *\n     * @method isub\n     *\n     * @param a - BigNumber to be subtracted from.\n     * @param b - BigNumber to subtract.\n     *\n     * @returns Returns the modified 'a' after subtraction of 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(5));\n     * const a = new BigNumber(4);\n     * context.isub(a, new BigNumber(2)); // Modifies 'a' to be 2\n     */\n    isub(a, b) {\n        this.verify2(a, b);\n        const res = a.isub(b);\n        if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n        }\n        return res;\n    }\n    /**\n     * Performs bitwise shift left operation on a BigNumber in the reduction context.\n     *\n     * @method shl\n     *\n     * @param a - BigNumber to perform shift on.\n     * @param num - The number of positions to shift.\n     *\n     * @returns Returns the result of shifting 'a' left by 'num' positions in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(32));\n     * context.shl(new BigNumber(4), 2); // Returns 16\n     */\n    shl(a, num) {\n        this.verify1(a);\n        return this.imod(a.ushln(num));\n    }\n    /**\n     * Performs in-place multiplication of two BigNumbers in the reduction context,\n     * modifying the first BigNumber with the result.\n     *\n     * @method imul\n     *\n     * @param a - First BigNumber to multiply.\n     * @param b - Second BigNumber to multiply.\n     *\n     * @returns Returns the modified 'a' after multiplication with 'b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = new BigNumber(3);\n     * context.imul(a, new BigNumber(2)); // Modifies 'a' to be 6\n     */\n    imul(a, b) {\n        this.verify2(a, b);\n        return this.imod(a.imul(b));\n    }\n    /**\n     * Multiplies two BigNumbers in the reduction context.\n     *\n     * @method mul\n     *\n     * @param a - First BigNumber to multiply.\n     * @param b - Second BigNumber to multiply.\n     *\n     * @returns Returns the result of 'a * b' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.mul(new BigNumber(3), new BigNumber(2)); // Returns 6\n     */\n    mul(a, b) {\n        this.verify2(a, b);\n        return this.imod(a.mul(b));\n    }\n    /**\n     * Calculates the square of a BigNumber in the reduction context,\n     * modifying the original BigNumber with the result.\n     *\n     * @method isqr\n     *\n     * @param a - BigNumber to be squared.\n     *\n     * @returns Returns the squared 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = new BigNumber(3);\n     * context.isqr(a); // Modifies 'a' to be 2 (9 % 7 = 2)\n     */\n    isqr(a) {\n        return this.imul(a, a.clone());\n    }\n    /**\n     * Calculates the square of a BigNumber in the reduction context.\n     *\n     * @method sqr\n     *\n     * @param a - BigNumber to be squared.\n     *\n     * @returns Returns the result of 'a^2' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.sqr(new BigNumber(3)); // Returns 2 (9 % 7 = 2)\n     */\n    sqr(a) {\n        return this.mul(a, a);\n    }\n    /**\n     * Calculates the square root of a BigNumber in the reduction context.\n     *\n     * @method sqrt\n     *\n     * @param a - The BigNumber to calculate the square root of.\n     *\n     * @returns Returns the square root of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(9));\n     * context.sqrt(new BigNumber(4)); // Returns 2\n     */\n    sqrt(a) {\n        if (a.isZero())\n            return a.clone();\n        const mod3 = this.m.andln(3);\n        this.assert(mod3 % 2 === 1);\n        // Fast case\n        if (mod3 === 3) {\n            const pow = this.m.add(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1)).iushrn(2);\n            return this.pow(a, pow);\n        }\n        // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n        //\n        // Find Q and S, that Q * 2 ^ S = (P - 1)\n        const q = this.m.subn(1);\n        let s = 0;\n        while (!q.isZero() && q.andln(1) === 0) {\n            s++;\n            q.iushrn(1);\n        }\n        this.assert(!q.isZero());\n        const one = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1).toRed(this);\n        const nOne = one.redNeg();\n        // Find quadratic non-residue\n        // NOTE: Max is such because of generalized Riemann hypothesis.\n        const lpow = this.m.subn(1).iushrn(1);\n        const zl = this.m.bitLength();\n        const z = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2 * zl * zl).toRed(this);\n        while (this.pow(z, lpow).cmp(nOne) !== 0) {\n            z.redIAdd(nOne);\n        }\n        let c = this.pow(z, q);\n        let r = this.pow(a, q.addn(1).iushrn(1));\n        let t = this.pow(a, q);\n        let m = s;\n        while (t.cmp(one) !== 0) {\n            let tmp = t;\n            let i = 0;\n            for (; tmp.cmp(one) !== 0; i++) {\n                tmp = tmp.redSqr();\n            }\n            this.assert(i < m);\n            const b = this.pow(c, new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1).iushln(m - i - 1));\n            r = r.redMul(b);\n            c = b.redSqr();\n            t = t.redMul(c);\n            m = i;\n        }\n        return r;\n    }\n    /**\n     * Calculates the multiplicative inverse of a BigNumber in the reduction context.\n     *\n     * @method invm\n     *\n     * @param a - The BigNumber to find the multiplicative inverse of.\n     *\n     * @returns Returns the multiplicative inverse of 'a' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(11));\n     * context.invm(new BigNumber(3)); // Returns 4 (3*4 mod 11 = 1)\n     */\n    invm(a) {\n        const inv = a._invmp(this.m);\n        if (inv.negative !== 0) {\n            inv.negative = 0;\n            return this.imod(inv).redNeg();\n        }\n        else {\n            return this.imod(inv);\n        }\n    }\n    /**\n     * Raises a BigNumber to a power in the reduction context.\n     *\n     * @method pow\n     *\n     * @param a - The BigNumber to be raised to a power.\n     * @param num - The power to raise the BigNumber to.\n     *\n     * @returns Returns the result of 'a' raised to the power of 'num' in the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.pow(new BigNumber(3), new BigNumber(2)); // Returns 2 (3^2 % 7)\n     */\n    pow(a, num) {\n        if (num.isZero())\n            return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1).toRed(this);\n        if (num.cmpn(1) === 0)\n            return a.clone();\n        const windowSize = 4;\n        const wnd = new Array(1 << windowSize);\n        wnd[0] = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1).toRed(this);\n        wnd[1] = a;\n        let i = 2;\n        for (; i < wnd.length; i++) {\n            wnd[i] = this.mul(wnd[i - 1], a);\n        }\n        let res = wnd[0];\n        let current = 0;\n        let currentLen = 0;\n        let start = num.bitLength() % 26;\n        if (start === 0) {\n            start = 26;\n        }\n        for (i = num.length - 1; i >= 0; i--) {\n            const word = num.words[i];\n            for (let j = start - 1; j >= 0; j--) {\n                const bit = (word >> j) & 1;\n                if (res !== wnd[0]) {\n                    res = this.sqr(res);\n                }\n                if (bit === 0 && current === 0) {\n                    currentLen = 0;\n                    continue;\n                }\n                current <<= 1;\n                current |= bit;\n                currentLen++;\n                if (currentLen !== windowSize && (i !== 0 || j !== 0))\n                    continue;\n                res = this.mul(res, wnd[current]);\n                currentLen = 0;\n                current = 0;\n            }\n            start = 26;\n        }\n        return res;\n    }\n    /**\n     * Converts a BigNumber to its equivalent in the reduction context.\n     *\n     * @method convertTo\n     *\n     * @param num - The BigNumber to convert to the reduction context.\n     *\n     * @returns Returns the converted BigNumber compatible with the reduction context.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * context.convertTo(new BigNumber(8)); // Returns 1 (8 % 7)\n     */\n    convertTo(num) {\n        const r = num.umod(this.m);\n        return r === num ? r.clone() : r;\n    }\n    /**\n     * Converts a BigNumber from reduction context to its regular form.\n     *\n     * @method convertFrom\n     *\n     * @param num - The BigNumber to convert from the reduction context.\n     *\n     * @returns Returns the converted BigNumber in its regular form.\n     *\n     * @example\n     * const context = new ReductionContext(new BigNumber(7));\n     * const a = context.convertTo(new BigNumber(8)); // 'a' is now 1 in the reduction context\n     * context.convertFrom(a); // Returns 1\n     */\n    convertFrom(num) {\n        const res = num.clone();\n        res.red = null;\n        return res;\n    }\n}\n//# sourceMappingURL=ReductionContext.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/ReductionContext.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Schnorr.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Schnorr.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Schnorr)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n\n\n\n/**\n * Class representing the Schnorr Zero-Knowledge Proof (ZKP) protocol.\n *\n * This class provides methods to generate and verify proofs that demonstrate knowledge of a secret without revealing it.\n * Specifically, it allows one party to prove to another that they know the private key corresponding to a public key\n * and have correctly computed a shared secret, without disclosing the private key itself.\n *\n * The protocol involves two main methods:\n * - `generateProof`: Generates a proof linking a public key `A` and a shared secret `S`, proving knowledge of the corresponding private key `a`.\n * - `verifyProof`: Verifies the provided proof, ensuring its validity without revealing any secret information.\n *\n * The class utilizes elliptic curve cryptography (ECC) and the SHA-256 hash function to compute challenges within the proof.\n *\n * @example\n * ```typescript\n * const schnorr = new Schnorr();\n * const a = PrivateKey.fromRandom(); // Prover's private key\n * const A = a.toPublicKey();         // Prover's public key\n * const b = PrivateKey.fromRandom(); // Other party's private key\n * const B = b.toPublicKey();         // Other party's public key\n * const S = B.mul(a);                // Shared secret\n *\n * // Prover generates the proof\n * const proof = schnorr.generateProof(a, A, B, S);\n *\n * // Verifier verifies the proof\n * const isValid = schnorr.verifyProof(A.point, B.point, S.point, proof);\n * console.log(`Proof is valid: ${isValid}`);\n * ```\n */\nclass Schnorr {\n    curve;\n    constructor() {\n        this.curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    }\n    /**\n     * Generates a proof that demonstrates the link between public key A and shared secret S\n     * @param a Private key corresponding to public key A\n     * @param A Public key\n     * @param B Other party's public key\n     * @param S Shared secret\n     * @returns Proof (R, S', z)\n     */\n    generateProof(aArg, AArg, BArg, S) {\n        const r = _index_js__WEBPACK_IMPORTED_MODULE_3__.PrivateKey.fromRandom();\n        const R = r.toPublicKey();\n        const SPrime = BArg.mul(r);\n        const e = this.computeChallenge(AArg, BArg, S, SPrime, R);\n        const z = r.add(e.mul(aArg)).umod(this.curve.n);\n        return { R, SPrime, z };\n    }\n    /**\n     * Verifies the proof of the link between public key A and shared secret S\n     * @param A Public key\n     * @param B Other party's public key\n     * @param S Shared secret\n     * @param proof Proof (R, S', z)\n     * @returns True if the proof is valid, false otherwise\n     */\n    verifyProof(A, B, S, proof) {\n        const { R, SPrime, z } = proof;\n        const e = this.computeChallenge(A, B, S, SPrime, R);\n        // Check zG = R + eA\n        const zG = this.curve.g.mul(z);\n        const RpluseA = R.add(A.mul(e));\n        if (!zG.eq(RpluseA)) {\n            return false;\n        }\n        // Check zB = S' + eS\n        const zB = B.mul(z);\n        const SprimeeS = SPrime.add(S.mul(e));\n        if (!zB.eq(SprimeeS)) {\n            return false;\n        }\n        return true;\n    }\n    computeChallenge(A, B, S, SPrime, R) {\n        const message = [\n            ...A.encode(true),\n            ...B.encode(true),\n            ...S.encode(true),\n            ...SPrime.encode(true),\n            ...R.encode(true)\n        ];\n        const hash = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_2__.sha256)(message);\n        return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](hash).umod(this.curve.n);\n    }\n}\n//# sourceMappingURL=Schnorr.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Schnorr.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Signature)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _ECDSA_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n\n\n\n\n\n\n\n/**\n * Represents a digital signature.\n *\n * A digital signature is a mathematical scheme for verifying the authenticity of\n * digital messages or documents. In many scenarios, it is equivalent to a handwritten signature or stamped seal.\n * The signature pair (R, S) corresponds to the raw ECDSA ([Elliptic Curve Digital Signature Algorithm](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm)) signature.\n * Signatures are often serialized into a format known as '[DER encoding](https://en.wikipedia.org/wiki/X.690#DER_encoding)' for transmission.\n *\n * @class Signature\n */\nclass Signature {\n    /**\n     * @property Represents the \"r\" component of the digital signature\n     */\n    r;\n    /**\n     * @property Represents the \"s\" component of the digital signature\n     */\n    s;\n    /**\n     * Takes an array of numbers or a string and returns a new Signature instance.\n     * This method will throw an error if the DER encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     *\n     * @static\n     * @method fromDER\n     * @param data - The sequence to decode from DER encoding.\n     * @param enc - The encoding of the data string.\n     * @returns The decoded data in the form of Signature instance.\n     *\n     * @example\n     * const signature = Signature.fromDER('30440220018c1f5502f8...', 'hex');\n     */\n    static fromDER(data, enc) {\n        const getLength = (buf, p) => {\n            const initial = buf[p.place++];\n            if ((initial & 0x80) === 0) {\n                return initial;\n            }\n            else {\n                throw new Error('Invalid DER entity length');\n            }\n        };\n        class Position {\n            place;\n            constructor() {\n                this.place = 0;\n            }\n        }\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toArray)(data, enc);\n        const p = new Position();\n        if (data[p.place++] !== 0x30) {\n            throw new Error('Signature DER must start with 0x30');\n        }\n        const len = getLength(data, p);\n        if (len + p.place !== data.length) {\n            throw new Error('Signature DER invalid');\n        }\n        if (data[p.place++] !== 0x02) {\n            throw new Error('Signature DER invalid');\n        }\n        const rlen = getLength(data, p);\n        let r = data.slice(p.place, rlen + p.place);\n        p.place += rlen;\n        if (data[p.place++] !== 0x02) {\n            throw new Error('Signature DER invalid');\n        }\n        const slen = getLength(data, p);\n        if (data.length !== slen + p.place) {\n            throw new Error('Invalid R-length in signature DER');\n        }\n        let s = data.slice(p.place, slen + p.place);\n        if (r[0] === 0) {\n            if ((r[1] & 0x80) !== 0) {\n                r = r.slice(1);\n            }\n            else {\n                throw new Error('Invalid R-value in signature DER');\n            }\n        }\n        if (s[0] === 0) {\n            if ((s[1] & 0x80) !== 0) {\n                s = s.slice(1);\n            }\n            else {\n                throw new Error('Invalid S-value in signature DER');\n            }\n        }\n        return new Signature(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](r), new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](s));\n    }\n    /**\n     * Takes an array of numbers or a string and returns a new Signature instance.\n     * This method will throw an error if the Compact encoding is invalid.\n     * If a string is provided, it is assumed to represent a hexadecimal sequence.\n     * compactByte value 27-30 means uncompressed public key.\n     * 31-34 means compressed public key.\n     * The range represents the recovery param which can be 0,1,2,3.\n     * We could support recovery functions in future if there's demand.\n     *\n     * @static\n     * @method fromCompact\n     * @param data - The sequence to decode from Compact encoding.\n     * @param enc - The encoding of the data string.\n     * @returns The decoded data in the form of Signature instance.\n     *\n     * @example\n     * const signature = Signature.fromCompact('1b18c1f5502f8...', 'hex');\n     */\n    static fromCompact(data, enc) {\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toArray)(data, enc);\n        if (data.length !== 65) {\n            throw new Error('Invalid Compact Signature');\n        }\n        const compactByte = data[0];\n        if (compactByte < 27 || compactByte >= 35) {\n            throw new Error('Invalid Compact Byte');\n        }\n        return new Signature(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data.slice(1, 33)), new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](data.slice(33, 65)));\n    }\n    /**\n     * Creates an instance of the Signature class.\n     *\n     * @constructor\n     * @param r - The R component of the signature.\n     * @param s - The S component of the signature.\n     *\n     * @example\n     * const r = new BigNumber('208755674028...');\n     * const s = new BigNumber('564745627577...');\n     * const signature = new Signature(r, s);\n     */\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n    }\n    /**\n     * Verifies a digital signature.\n     *\n     * This method will return true if the signature, key, and message hash match.\n     * If the data or key do not match the signature, the function returns false.\n     *\n     * @method verify\n     * @param msg - The message to verify.\n     * @param key - The public key used to sign the original message.\n     * @param enc - The encoding of the msg string.\n     * @returns A boolean representing whether the signature is valid.\n     *\n     * @example\n     * const msg = 'The quick brown fox jumps over the lazy dog';\n     * const publicKey = PublicKey.fromString('04188ca1050...');\n     * const isVerified = signature.verify(msg, publicKey);\n     */\n    verify(msg, key, enc) {\n        const msgHash = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]((0,_Hash_js__WEBPACK_IMPORTED_MODULE_3__.sha256)(msg, enc), 16);\n        return (0,_ECDSA_js__WEBPACK_IMPORTED_MODULE_2__.verify)(msgHash, this, key);\n    }\n    /**\n     * Converts an instance of Signature into DER encoding.\n     * An alias for the toDER method.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toDER\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const der = signature.toString('base64');\n     */\n    toString(enc) {\n        return this.toDER(enc);\n    }\n    /**\n     * Converts an instance of Signature into DER encoding.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toDER\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const der = signature.toDER('hex');\n     */\n    toDER(enc) {\n        const constructLength = (arr, len) => {\n            if (len < 0x80) {\n                arr.push(len);\n            }\n            else {\n                throw new Error('len must be < 0x80');\n            }\n        };\n        const rmPadding = (buf) => {\n            let i = 0;\n            const len = buf.length - 1;\n            while (buf[i] === 0 && (buf[i + 1] & 0x80) === 0 && i < len) {\n                i++;\n            }\n            if (i === 0) {\n                return buf;\n            }\n            return buf.slice(i);\n        };\n        let r = this.r.toArray();\n        let s = this.s.toArray();\n        // Pad values\n        if ((r[0] & 0x80) !== 0) {\n            r = [0].concat(r);\n        }\n        // Pad values\n        if ((s[0] & 0x80) !== 0) {\n            s = [0].concat(s);\n        }\n        r = rmPadding(r);\n        s = rmPadding(s);\n        while (s[0] === 0 && (s[1] & 0x80) === 0) {\n            s = s.slice(1);\n        }\n        let arr = [0x02];\n        constructLength(arr, r.length);\n        arr = arr.concat(r);\n        arr.push(0x02);\n        constructLength(arr, s.length);\n        const backHalf = arr.concat(s);\n        let res = [0x30];\n        constructLength(res, backHalf.length);\n        res = res.concat(backHalf);\n        if (enc === 'hex') {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toHex)(res);\n        }\n        else if (enc === 'base64') {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toBase64)(res);\n        }\n        else {\n            return res;\n        }\n    }\n    /**\n     * Converts an instance of Signature into Compact encoding.\n     *\n     * If the encoding parameter is set to 'hex', the function will return a hex string.\n     * If 'base64', it will return a base64 string.\n     * Otherwise, it will return an array of numbers.\n     *\n     * @method toCompact\n     * @param enc - The encoding to use for the output.\n     * @returns The current instance in DER encoding.\n     *\n     * @example\n     * const compact = signature.toCompact(3, true, 'base64');\n     */\n    toCompact(recovery, compressed, enc) {\n        if (recovery < 0 || recovery > 3)\n            throw new Error('Invalid recovery param');\n        if (typeof compressed !== 'boolean') {\n            throw new Error('Invalid compressed param');\n        }\n        let compactByte = 27 + recovery;\n        if (compressed) {\n            compactByte += 4;\n        }\n        let arr = [compactByte];\n        arr = arr.concat(this.r.toArray('be', 32));\n        arr = arr.concat(this.s.toArray('be', 32));\n        if (enc === 'hex') {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toHex)(arr);\n        }\n        else if (enc === 'base64') {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.toBase64)(arr);\n        }\n        else {\n            return arr;\n        }\n    }\n    /**\n     * Recovers the public key from a signature.\n     * This method will return the public key if it finds a valid public key.\n     * If it does not find a valid public key, it will throw an error.\n     * The recovery factor is a number between 0 and 3.\n     * @method RecoverPublicKey\n     * @param recovery - The recovery factor.\n     * @param e - The message hash.\n     * @returns The public key associated with the signature.\n     *\n     * @example\n     * const publicKey = signature.RecoverPublicKey(0, msgHash);\n     */\n    RecoverPublicKey(recovery, e) {\n        const r = this.r;\n        const s = this.s;\n        // A set LSB signifies that the y-coordinate is odd\n        const isYOdd = (recovery & 1) !== 0;\n        // The more significant bit specifies whether we should use the\n        // first or second candidate key.\n        const isSecondKey = recovery >> 1;\n        const curve = new _Curve_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\n        const n = curve.n;\n        const G = curve.g;\n        // 1.1 LEt x = r + jn\n        const x = isSecondKey !== 0 ? r.add(n) : r;\n        const R = _Point_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].fromX(x, isYOdd);\n        // 1.4 Check that nR is at infinity\n        const nR = R.mul(n);\n        if (!nR.isInfinity()) {\n            throw new Error('nR is not at infinity');\n        }\n        // Compute -e from e\n        const eNeg = e.neg().umod(n);\n        // 1.6.1 Compute Q = r^-1 (sR - eG)\n        // Q = r^-1 (sR + -eG)\n        const rInv = r.invm(n);\n        // const Q = R.multiplyTwo(s, G, eNeg).mul(rInv)\n        const srInv = rInv.mul(s).umod(n);\n        const eInvrInv = rInv.mul(eNeg).umod(n);\n        const Q = G.mul(eInvrInv).add(R.mul(srInv));\n        const pubKey = new _PublicKey_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](Q);\n        pubKey.validate();\n        return pubKey;\n    }\n    /**\n     * Calculates the recovery factor which will work for a particular public key and message hash.\n     * This method will return the recovery factor if it finds a valid recovery factor.\n     * If it does not find a valid recovery factor, it will throw an error.\n     * The recovery factor is a number between 0 and 3.\n     *\n     * @method CalculateRecoveryFactor\n     * @param msgHash - The message hash.\n     * @returns the recovery factor: number\n     * /\n     * @example\n     * const recovery = signature.CalculateRecoveryFactor(publicKey, msgHash);\n     */\n    CalculateRecoveryFactor(pubkey, msgHash) {\n        for (let recovery = 0; recovery < 4; recovery++) {\n            let Qprime;\n            try {\n                Qprime = this.RecoverPublicKey(recovery, msgHash);\n            }\n            catch {\n                continue;\n            }\n            if (pubkey.eq(Qprime)) {\n                return recovery;\n            }\n        }\n        throw new Error('Unable to find valid recovery factor');\n    }\n}\n//# sourceMappingURL=Signature.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SymmetricKey)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _AESGCM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AESGCM.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/AESGCM.js\");\n/* harmony import */ var _Random_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\n/**\n * `SymmetricKey` is a class that extends the `BigNumber` class and implements symmetric encryption and decryption methods.\n * Symmetric-Key encryption is a form of encryption where the same key is used to encrypt and decrypt the message.\n * It leverages the Advanced Encryption Standard Galois/Counter Mode (AES-GCM) for encryption and decryption of messages.\n *\n * @class SymmetricKey\n * @extends {BigNumber}\n */\nclass SymmetricKey extends _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * Generates a symmetric key randomly.\n     *\n     * @method fromRandom\n     * @static\n     * @returns The newly generated Symmetric Key.\n     *\n     * @example\n     * const symmetricKey = SymmetricKey.fromRandom();\n     */\n    static fromRandom() {\n        return new SymmetricKey((0,_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32));\n    }\n    /**\n     * Encrypts a given message using AES-GCM encryption.\n     * The generated Initialization Vector (IV) is attached to the encrypted message for decryption purposes.\n     * The OpenSSL format of |IV|encryptedContent|authTag| is used.\n     *\n     * @method encrypt\n     * @param msg - The message to be encrypted. It can be a string or an array of numbers.\n     * @param enc - optional. The encoding of the message. If hex, the string is assumed to be hex, UTF-8 otherwise.\n     * @returns Returns the encrypted message as a string or an array of numbers, depending on `enc` argument.\n     *\n     * @example\n     * const key = new SymmetricKey(1234);\n     * const encryptedMessage = key.encrypt('plainText', 'utf8');\n     */\n    encrypt(msg, enc) {\n        const iv = (0,_Random_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(32);\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(msg, enc);\n        const { result, authenticationTag } = (0,_AESGCM_js__WEBPACK_IMPORTED_MODULE_1__.AESGCM)(msg, [], iv, this.toArray('be', 32));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.encode)([...iv, ...result, ...authenticationTag], enc);\n    }\n    /**\n     * Decrypts a given AES-GCM encrypted message using the same key that was used for encryption.\n     * The method extracts the IV and the authentication tag from the encrypted message, then attempts to decrypt it.\n     * If the decryption fails (e.g., due to message tampering), an error is thrown.\n     *\n     * @method decrypt\n     * @param msg - The encrypted message to be decrypted. It can be a string or an array of numbers.\n     * @param enc - optional. The encoding of the message (if no encoding is provided, uses utf8 for strings, unless specified as hex).\n     * @returns Returns the decrypted message as a string or an array of numbers, depending on `enc` argument. If absent, an array of numbers is returned.\n     *\n     * @example\n     * const key = new SymmetricKey(1234);\n     * const decryptedMessage = key.decrypt(encryptedMessage, 'utf8');\n     *\n     * @throws {Error} Will throw an error if the decryption fails, likely due to message tampering or incorrect decryption key.\n     */\n    decrypt(msg, enc) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(msg, enc);\n        const iv = msg.slice(0, 32);\n        const ciphertextWithTag = msg.slice(32);\n        const messageTag = ciphertextWithTag.slice(-16);\n        const ciphertext = ciphertextWithTag.slice(0, -16);\n        const result = (0,_AESGCM_js__WEBPACK_IMPORTED_MODULE_1__.AESGCMDecrypt)(ciphertext, [], iv, messageTag, this.toArray());\n        if (result === null) {\n            throw new Error('Decryption failed!');\n        }\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.encode)(result, enc);\n    }\n}\n//# sourceMappingURL=SymmetricKey.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ TransactionSignature)\n/* harmony export */ });\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\n\nclass TransactionSignature extends _Signature_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    static SIGHASH_ALL = 0x00000001;\n    static SIGHASH_NONE = 0x00000002;\n    static SIGHASH_SINGLE = 0x00000003;\n    static SIGHASH_FORKID = 0x00000040;\n    static SIGHASH_ANYONECANPAY = 0x00000080;\n    scope;\n    static format(params) {\n        const currentInput = {\n            sourceTXID: params.sourceTXID,\n            sourceOutputIndex: params.sourceOutputIndex,\n            sequence: params.inputSequence\n        };\n        const inputs = [...params.otherInputs];\n        inputs.splice(params.inputIndex, 0, currentInput);\n        const getPrevoutHash = () => {\n            const writer = new _utils_js__WEBPACK_IMPORTED_MODULE_3__.Writer();\n            for (const input of inputs) {\n                if (typeof input.sourceTXID === 'undefined') {\n                    if (input.sourceTransaction == null) {\n                        throw new Error('Missing sourceTransaction for input');\n                    }\n                    writer.write(input.sourceTransaction.hash());\n                }\n                else {\n                    writer.writeReverse((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(input.sourceTXID, 'hex'));\n                }\n                writer.writeUInt32LE(input.sourceOutputIndex);\n            }\n            const buf = writer.toArray();\n            const ret = _Hash_js__WEBPACK_IMPORTED_MODULE_2__.hash256(buf);\n            return ret;\n        };\n        const getSequenceHash = () => {\n            const writer = new _utils_js__WEBPACK_IMPORTED_MODULE_3__.Writer();\n            for (const input of inputs) {\n                const sequence = input.sequence ?? 0xffffffff; // Default to max sequence number\n                writer.writeUInt32LE(sequence);\n            }\n            const buf = writer.toArray();\n            const ret = _Hash_js__WEBPACK_IMPORTED_MODULE_2__.hash256(buf);\n            return ret;\n        };\n        function getOutputsHash(outputIndex) {\n            const writer = new _utils_js__WEBPACK_IMPORTED_MODULE_3__.Writer();\n            if (typeof outputIndex === 'undefined') {\n                for (const output of params.outputs) {\n                    const satoshis = output.satoshis ?? 0; // Default to 0 if undefined\n                    writer.writeUInt64LE(satoshis);\n                    const script = output.lockingScript?.toBinary() ?? [];\n                    writer.writeVarIntNum(script.length);\n                    writer.write(script);\n                }\n            }\n            else {\n                const output = params.outputs[outputIndex];\n                if (output === undefined) { //  Explicitly check for undefined\n                    throw new Error(`Output at index ${outputIndex} does not exist`);\n                }\n                const satoshis = output.satoshis ?? 0; // Default to 0 if undefined\n                writer.writeUInt64LE(satoshis);\n                const script = output.lockingScript?.toBinary() ?? [];\n                writer.writeVarIntNum(script.length);\n                writer.write(script);\n            }\n            const buf = writer.toArray();\n            const ret = _Hash_js__WEBPACK_IMPORTED_MODULE_2__.hash256(buf);\n            return ret;\n        }\n        let hashPrevouts = new Array(32).fill(0);\n        let hashSequence = new Array(32).fill(0);\n        let hashOutputs = new Array(32).fill(0);\n        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0) {\n            hashPrevouts = getPrevoutHash();\n        }\n        if ((params.scope & TransactionSignature.SIGHASH_ANYONECANPAY) === 0 &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {\n            hashSequence = getSequenceHash();\n        }\n        if ((params.scope & 31) !== TransactionSignature.SIGHASH_SINGLE &&\n            (params.scope & 31) !== TransactionSignature.SIGHASH_NONE) {\n            hashOutputs = getOutputsHash();\n        }\n        else if ((params.scope & 31) === TransactionSignature.SIGHASH_SINGLE &&\n            params.inputIndex < params.outputs.length) {\n            hashOutputs = getOutputsHash(params.inputIndex);\n        }\n        const writer = new _utils_js__WEBPACK_IMPORTED_MODULE_3__.Writer();\n        // Version\n        writer.writeInt32LE(params.transactionVersion);\n        // Input prevouts/nSequence (none/all, depending on flags)\n        writer.write(hashPrevouts);\n        writer.write(hashSequence);\n        //  outpoint (32-byte hash + 4-byte little endian)\n        writer.writeReverse((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.toArray)(params.sourceTXID, 'hex'));\n        writer.writeUInt32LE(params.sourceOutputIndex);\n        // scriptCode of the input (serialized as scripts inside CTxOuts)\n        const subscriptBin = params.subscript.toBinary();\n        writer.writeVarIntNum(subscriptBin.length);\n        writer.write(subscriptBin);\n        // value of the output spent by this input (8-byte little endian)\n        writer.writeUInt64LE(params.sourceSatoshis);\n        // nSequence of the input (4-byte little endian)\n        const sequenceNumber = currentInput.sequence;\n        writer.writeUInt32LE(sequenceNumber);\n        // Outputs (none/one/all, depending on flags)\n        writer.write(hashOutputs);\n        // Locktime\n        writer.writeUInt32LE(params.lockTime);\n        // sighashType\n        writer.writeUInt32LE(params.scope >>> 0);\n        const buf = writer.toArray();\n        return buf;\n    }\n    // The format used in a tx\n    static fromChecksigFormat(buf) {\n        if (buf.length === 0) {\n            // allow setting a \"blank\" signature\n            const r = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1);\n            const s = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1);\n            const scope = 1;\n            return new TransactionSignature(r, s, scope);\n        }\n        const scope = buf[buf.length - 1];\n        const derbuf = buf.slice(0, buf.length - 1);\n        const tempSig = _Signature_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromDER(derbuf);\n        return new TransactionSignature(tempSig.r, tempSig.s, scope);\n    }\n    constructor(r, s, scope) {\n        super(r, s);\n        this.scope = scope;\n    }\n    /**\n     * Compares to bitcoind's IsLowDERSignature\n     * See also Ecdsa signature algorithm which enforces this.\n     * See also Bip 62, \"low S values in signatures\"\n     */\n    hasLowS() {\n        if (this.s.ltn(1) ||\n            this.s.gt(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex'))) {\n            return false;\n        }\n        return true;\n    }\n    toChecksigFormat() {\n        const derbuf = this.toDER();\n        return [...derbuf, this.scope];\n    }\n}\n//# sourceMappingURL=TransactionSignature.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* reexport safe */ _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Curve: () => (/* reexport safe */ _Curve_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   DRBG: () => (/* reexport safe */ _DRBG_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   ECDSA: () => (/* reexport module object */ _ECDSA_js__WEBPACK_IMPORTED_MODULE_8__),\n/* harmony export */   Hash: () => (/* reexport module object */ _Hash_js__WEBPACK_IMPORTED_MODULE_10__),\n/* harmony export */   KeyShares: () => (/* reexport safe */ _PrivateKey_js__WEBPACK_IMPORTED_MODULE_5__.KeyShares),\n/* harmony export */   Point: () => (/* reexport safe */ _Point_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   PointInFiniteField: () => (/* reexport safe */ _Polynomial_js__WEBPACK_IMPORTED_MODULE_13__.PointInFiniteField),\n/* harmony export */   Polynomial: () => (/* reexport safe */ _Polynomial_js__WEBPACK_IMPORTED_MODULE_13__[\"default\"]),\n/* harmony export */   PrivateKey: () => (/* reexport safe */ _PrivateKey_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   PublicKey: () => (/* reexport safe */ _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   Random: () => (/* reexport safe */ _Random_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"]),\n/* harmony export */   Schnorr: () => (/* reexport safe */ _Schnorr_js__WEBPACK_IMPORTED_MODULE_14__[\"default\"]),\n/* harmony export */   Signature: () => (/* reexport safe */ _Signature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   SymmetricKey: () => (/* reexport safe */ _SymmetricKey_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   TransactionSignature: () => (/* reexport safe */ _TransactionSignature_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"]),\n/* harmony export */   Utils: () => (/* reexport module object */ _utils_js__WEBPACK_IMPORTED_MODULE_9__)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Curve.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Curve.js\");\n/* harmony import */ var _Point_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Point.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Point.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Signature.js\");\n/* harmony import */ var _PrivateKey_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _SymmetricKey_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./SymmetricKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/SymmetricKey.js\");\n/* harmony import */ var _DRBG_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./DRBG.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/DRBG.js\");\n/* harmony import */ var _ECDSA_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _Random_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _TransactionSignature_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js\");\n/* harmony import */ var _Polynomial_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Polynomial.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Polynomial.js\");\n/* harmony import */ var _Schnorr_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Schnorr.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Schnorr.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Reader: () => (/* binding */ Reader),\n/* harmony export */   Writer: () => (/* binding */ Writer),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   fromBase58: () => (/* binding */ fromBase58),\n/* harmony export */   fromBase58Check: () => (/* binding */ fromBase58Check),\n/* harmony export */   minimallyEncode: () => (/* binding */ minimallyEncode),\n/* harmony export */   toArray: () => (/* binding */ toArray),\n/* harmony export */   toBase58: () => (/* binding */ toBase58),\n/* harmony export */   toBase58Check: () => (/* binding */ toBase58Check),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toUTF8: () => (/* binding */ toUTF8),\n/* harmony export */   zero2: () => (/* binding */ zero2)\n/* harmony export */ });\n/* harmony import */ var _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n\n\n/**\n * Prepends a '0' to an odd character length word to ensure it has an even number of characters.\n * @param {string} word - The input word.\n * @returns {string} - The word with a leading '0' if it's an odd character length; otherwise, the original word.\n */\nconst zero2 = (word) => {\n    if (word.length % 2 === 1) {\n        return '0' + word;\n    }\n    else {\n        return word;\n    }\n};\n/**\n * Converts an array of numbers to a hexadecimal string representation.\n * @param {number[]} msg - The input array of numbers.\n * @returns {string} - The hexadecimal string representation of the input array.\n */\nconst toHex = (msg) => {\n    let res = '';\n    for (const num of msg) {\n        res += zero2(num.toString(16));\n    }\n    return res;\n};\n/**\n * Converts various message formats into an array of numbers.\n * Supports arrays, hexadecimal strings, base64 strings, and UTF-8 strings.\n *\n * @param {any} msg - The input message (array or string).\n * @param {('hex' | 'utf8' | 'base64')} enc - Specifies the string encoding, if applicable.\n * @returns {any[]} - Array representation of the input.\n */\nconst toArray = (msg, enc) => {\n    if (Array.isArray(msg))\n        return msg.slice();\n    if (msg === undefined)\n        return [];\n    if (typeof msg !== 'string') {\n        return Array.from(msg, (item) => item | 0);\n    }\n    switch (enc) {\n        case 'hex':\n            return hexToArray(msg);\n        case 'base64':\n            return base64ToArray(msg);\n        default:\n            return utf8ToArray(msg);\n    }\n};\nconst hexToArray = (msg) => {\n    msg = msg.replace(/[^a-z0-9]+/gi, '');\n    if (msg.length % 2 !== 0)\n        msg = '0' + msg;\n    const res = [];\n    for (let i = 0; i < msg.length; i += 2) {\n        res.push(parseInt(msg[i] + msg[i + 1], 16));\n    }\n    return res;\n};\nconst base64ToArray = (msg) => {\n    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    const result = [];\n    let currentBit = 0;\n    let currentByte = 0;\n    for (const char of msg.replace(/=+$/, '')) {\n        currentBit = (currentBit << 6) | base64Chars.indexOf(char);\n        currentByte += 6;\n        if (currentByte >= 8) {\n            currentByte -= 8;\n            result.push((currentBit >> currentByte) & 0xff);\n            currentBit &= (1 << currentByte) - 1;\n        }\n    }\n    return result;\n};\n/**\n * Encodes a string into an array of bytes representing its UTF-8 encoding.\n * Any lone surrogates are replaced with the Unicode replacement character (U+FFFD).\n *\n * @param str - The string to encode.\n * @returns An array of numbers, each representing a byte in the UTF-8 encoded string.\n */\nfunction utf8ToArray(str) {\n    const result = [];\n    for (let i = 0; i < str.length; i++) {\n        const cp = str.codePointAt(i);\n        if (cp === undefined) {\n            // Should never be out of range.\n            throw new Error(`Index out of range: ${i}`);\n        }\n        let codePoint = cp;\n        if (codePoint > 0xFFFF) {\n            // Valid surrogate pair => skip the next code unit because codePointAt\n            // has already combined them into a single code point.\n            i++;\n        }\n        else {\n            // Check if codePoint is a lone (unpaired) high surrogate or low surrogate.\n            if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {\n                // Replace with the replacement character (U+FFFD).\n                codePoint = 0xFFFD;\n            }\n        }\n        // Encode according to the UTF-8 standard\n        if (codePoint <= 0x7F) {\n            result.push(codePoint);\n        }\n        else if (codePoint <= 0x7FF) {\n            result.push(0xC0 | (codePoint >> 6), 0x80 | (codePoint & 0x3F));\n        }\n        else if (codePoint <= 0xFFFF) {\n            result.push(0xE0 | (codePoint >> 12), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));\n        }\n        else {\n            result.push(0xF0 | (codePoint >> 18), 0x80 | ((codePoint >> 12) & 0x3F), 0x80 | ((codePoint >> 6) & 0x3F), 0x80 | (codePoint & 0x3F));\n        }\n    }\n    return result;\n}\n/**\n * Converts an array of numbers to a UTF-8 encoded string.\n * @param {number[]} arr - The input array of numbers.\n * @returns {string} - The UTF-8 encoded string.\n */\nconst toUTF8 = (arr) => {\n    let result = '';\n    let skip = 0;\n    for (let i = 0; i < arr.length; i++) {\n        const byte = arr[i];\n        // this byte is part of a multi-byte sequence, skip it\n        // added to avoid modifying i within the loop which is considered unsafe.\n        if (skip > 0) {\n            skip--;\n            continue;\n        }\n        // 1-byte sequence (0xxxxxxx)\n        if (byte <= 0x7f) {\n            result += String.fromCharCode(byte);\n        }\n        else if (byte >= 0xc0 && byte <= 0xdf) {\n            // 2-byte sequence (110xxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            skip = 1;\n            const codePoint = ((byte & 0x1f) << 6) | (byte2 & 0x3f);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte >= 0xe0 && byte <= 0xef) {\n            // 3-byte sequence (1110xxxx 10xxxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            skip = 2;\n            const codePoint = ((byte & 0x0f) << 12) | ((byte2 & 0x3f) << 6) | (byte3 & 0x3f);\n            result += String.fromCharCode(codePoint);\n        }\n        else if (byte >= 0xf0 && byte <= 0xf7) {\n            // 4-byte sequence (11110xxx 10xxxxxx 10xxxxxx 10xxxxxx)\n            const byte2 = arr[i + 1];\n            const byte3 = arr[i + 2];\n            const byte4 = arr[i + 3];\n            skip = 3;\n            const codePoint = ((byte & 0x07) << 18) |\n                ((byte2 & 0x3f) << 12) |\n                ((byte3 & 0x3f) << 6) |\n                (byte4 & 0x3f);\n            // Convert to UTF-16 surrogate pair\n            const surrogate1 = 0xd800 + ((codePoint - 0x10000) >> 10);\n            const surrogate2 = 0xdc00 + ((codePoint - 0x10000) & 0x3ff);\n            result += String.fromCharCode(surrogate1, surrogate2);\n        }\n    }\n    return result;\n};\n/**\n * Encodes an array of numbers into a specified encoding ('hex' or 'utf8'). If no encoding is provided, returns the original array.\n * @param {number[]} arr - The input array of numbers.\n * @param {('hex' | 'utf8')} enc - The desired encoding.\n * @returns {string | number[]} - The encoded message as a string (for 'hex' and 'utf8') or the original array.\n */\nconst encode = (arr, enc) => {\n    switch (enc) {\n        case 'hex':\n            return toHex(arr);\n        case 'utf8':\n            return toUTF8(arr);\n        // If no encoding is provided, return the original array\n        default:\n            return arr;\n    }\n};\n/**\n * Converts an array of bytes (each between 0 and 255) into a base64 encoded string.\n *\n * @param {number[]} byteArray - An array of numbers where each number is a byte (0-255).\n * @returns {string} The base64 encoded string.\n *\n * @example\n * const bytes = [72, 101, 108, 108, 111]; // Represents the string \"Hello\"\n * console.log(toBase64(bytes)); // Outputs: SGVsbG8=\n */\nfunction toBase64(byteArray) {\n    const base64Chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    let result = '';\n    let i;\n    for (i = 0; i < byteArray.length; i += 3) {\n        const byte1 = byteArray[i];\n        const byte2 = i + 1 < byteArray.length ? byteArray[i + 1] : 0;\n        const byte3 = i + 2 < byteArray.length ? byteArray[i + 2] : 0;\n        const encoded1 = byte1 >> 2;\n        const encoded2 = ((byte1 & 0x03) << 4) | (byte2 >> 4);\n        const encoded3 = ((byte2 & 0x0f) << 2) | (byte3 >> 6);\n        const encoded4 = byte3 & 0x3f;\n        result += base64Chars.charAt(encoded1) + base64Chars.charAt(encoded2);\n        result += i + 1 < byteArray.length ? base64Chars.charAt(encoded3) : '=';\n        result += i + 2 < byteArray.length ? base64Chars.charAt(encoded4) : '=';\n    }\n    return result;\n}\nconst base58chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n/**\n * Converts a string from base58 to a binary array\n * @param str - The string representation\n * @returns The binary representation\n */\nconst fromBase58 = (str) => {\n    if (str === '' || typeof str !== 'string') {\n        throw new Error(`Expected base58 string but got ${str}`);\n    }\n    const match = str.match(/[IOl0]/gmu);\n    if (match !== null) {\n        throw new Error(`Invalid base58 character ${match.join('')}`);\n    }\n    const lz = str.match(/^1+/gmu);\n    const psz = (lz !== null) ? lz[0].length : 0;\n    const size = ((str.length - psz) * (Math.log(58) / Math.log(256)) + 1) >>> 0;\n    const uint8 = new Uint8Array([\n        ...new Uint8Array(psz),\n        ...(str.match(/./gmu) ?? [] //  Safe Fix: If null, use []\n        )\n            .map((i) => base58chars.indexOf(i))\n            .reduce((acc, i) => {\n            acc = acc.map((j) => {\n                const x = j * 58 + i;\n                i = x >> 8;\n                return x;\n            });\n            return acc;\n        }, new Uint8Array(size))\n            .reverse()\n            .filter(((lastValue) => (value) => \n        // @ts-expect-error\n        (lastValue = lastValue || value))(false))\n    ]);\n    return [...uint8];\n};\n/**\n * Converts a binary array into a base58 string\n * @param bin - The binary array to convert to base58\n * @returns The base58 string representation\n */\nconst toBase58 = (bin) => {\n    const base58Map = Array(256).fill(-1);\n    for (let i = 0; i < base58chars.length; ++i) {\n        base58Map[base58chars.charCodeAt(i)] = i;\n    }\n    const result = [];\n    for (const byte of bin) {\n        let carry = byte;\n        for (let j = 0; j < result.length; ++j) {\n            const x = (base58Map[result[j]] << 8) + carry;\n            result[j] = base58chars.charCodeAt(x % 58);\n            carry = (x / 58) | 0;\n        }\n        while (carry !== 0) {\n            result.push(base58chars.charCodeAt(carry % 58));\n            carry = (carry / 58) | 0;\n        }\n    }\n    for (const byte of bin) {\n        if (byte !== 0)\n            break;\n        else\n            result.push('1'.charCodeAt(0));\n    }\n    result.reverse();\n    return String.fromCharCode(...result);\n};\n/**\n * Converts a binary array into a base58check string with a checksum\n * @param bin - The binary array to convert to base58check\n * @returns The base58check string representation\n */\nconst toBase58Check = (bin, prefix = [0]) => {\n    let hash = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_1__.hash256)([...prefix, ...bin]);\n    hash = [...prefix, ...bin, ...hash.slice(0, 4)];\n    return toBase58(hash);\n};\n/**\n * Converts a base58check string into a binary array after validating the checksum\n * @param str - The base58check string to convert to binary\n * @param enc - If hex, the return values will be hex strings, arrays of numbers otherwise\n * @param prefixLength - The length of the prefix. Optional, defaults to 1.\n * @returns The binary array representation\n */\nconst fromBase58Check = (str, enc, prefixLength = 1) => {\n    const bin = fromBase58(str);\n    let prefix = bin.slice(0, prefixLength);\n    let data = bin.slice(prefixLength, -4);\n    let hash = [...prefix, ...data];\n    hash = (0,_Hash_js__WEBPACK_IMPORTED_MODULE_1__.hash256)(hash);\n    bin.slice(-4).forEach((check, index) => {\n        if (check !== hash[index]) {\n            throw new Error('Invalid checksum');\n        }\n    });\n    if (enc === 'hex') {\n        prefix = toHex(prefix);\n        data = toHex(data);\n    }\n    return { prefix, data };\n};\nclass Writer {\n    bufs;\n    length;\n    constructor(bufs) {\n        this.bufs = bufs !== undefined ? bufs : [];\n        this.length = 0;\n        for (const b of this.bufs)\n            this.length += b.length;\n    }\n    getLength() {\n        return this.length;\n    }\n    toArray() {\n        const totalLength = this.length;\n        const ret = new Array(totalLength);\n        let offset = 0;\n        for (const buf of this.bufs) {\n            for (const value of buf) {\n                ret[offset++] = value;\n            }\n        }\n        return ret;\n    }\n    write(buf) {\n        this.bufs.push(buf);\n        this.length += buf.length;\n        return this;\n    }\n    writeReverse(buf) {\n        const buf2 = new Array(buf.length);\n        for (let i = 0; i < buf2.length; i++) {\n            buf2[i] = buf[buf.length - 1 - i];\n        }\n        this.bufs.push(buf2);\n        this.length += buf2.length;\n        return this;\n    }\n    writeUInt8(n) {\n        const buf = new Array(1);\n        buf[0] = n;\n        this.write(buf);\n        return this;\n    }\n    writeInt8(n) {\n        const buf = new Array(1);\n        buf[0] = n & 0xff;\n        this.write(buf);\n        return this;\n    }\n    writeUInt16BE(n) {\n        const buf = [\n            (n >> 8) & 0xff,\n            n & 0xff // low byte is just the last 8 bits\n        ];\n        this.bufs.push(buf);\n        this.length += 2;\n        return this;\n    }\n    writeInt16BE(n) {\n        return this.writeUInt16BE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits\n    }\n    writeUInt16LE(n) {\n        const buf = [\n            n & 0xff,\n            (n >> 8) & 0xff // shift right 8 bits to get the high byte\n        ];\n        this.bufs.push(buf);\n        this.length += 2;\n        return this;\n    }\n    writeInt16LE(n) {\n        return this.writeUInt16LE(n & 0xffff); // Mask with 0xFFFF to get the lower 16 bits\n    }\n    writeUInt32BE(n) {\n        const buf = [\n            (n >> 24) & 0xff,\n            (n >> 16) & 0xff,\n            (n >> 8) & 0xff,\n            n & 0xff // lowest byte\n        ];\n        this.bufs.push(buf);\n        this.length += 4;\n        return this;\n    }\n    writeInt32BE(n) {\n        return this.writeUInt32BE(n >>> 0); // Using unsigned right shift to handle negative numbers\n    }\n    writeUInt32LE(n) {\n        const buf = [\n            n & 0xff,\n            (n >> 8) & 0xff,\n            (n >> 16) & 0xff,\n            (n >> 24) & 0xff // highest byte\n        ];\n        this.bufs.push(buf);\n        this.length += 4;\n        return this;\n    }\n    writeInt32LE(n) {\n        return this.writeUInt32LE(n >>> 0); // Using unsigned right shift to handle negative numbers\n    }\n    writeUInt64BEBn(bn) {\n        const buf = bn.toArray('be', 8);\n        this.write(buf);\n        return this;\n    }\n    writeUInt64LEBn(bn) {\n        const buf = bn.toArray('be', 8);\n        this.writeReverse(buf);\n        return this;\n    }\n    writeUInt64LE(n) {\n        const buf = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n).toArray('be', 8);\n        this.writeReverse(buf);\n        return this;\n    }\n    writeVarIntNum(n) {\n        const buf = Writer.varIntNum(n);\n        this.write(buf);\n        return this;\n    }\n    writeVarIntBn(bn) {\n        const buf = Writer.varIntBn(bn);\n        this.write(buf);\n        return this;\n    }\n    static varIntNum(n) {\n        let buf;\n        if (n < 0) {\n            return this.varIntBn(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](n));\n        }\n        if (n < 253) {\n            buf = [n]; // 1 byte\n        }\n        else if (n < 0x10000) {\n            // 253 followed by the number in little-endian format\n            buf = [\n                253,\n                n & 0xff,\n                (n >> 8) & 0xff // high byte\n            ];\n        }\n        else if (n < 0x100000000) {\n            // 254 followed by the number in little-endian format\n            buf = [\n                254,\n                n & 0xff,\n                (n >> 8) & 0xff,\n                (n >> 16) & 0xff,\n                (n >> 24) & 0xff\n            ];\n        }\n        else {\n            // 255 followed by the number in little-endian format\n            // Since JavaScript bitwise operations work on 32 bits, we need to handle 64-bit numbers in two parts\n            const low = n & 0xffffffff;\n            const high = Math.floor(n / 0x100000000) & 0xffffffff;\n            buf = [\n                255,\n                low & 0xff,\n                (low >> 8) & 0xff,\n                (low >> 16) & 0xff,\n                (low >> 24) & 0xff,\n                high & 0xff,\n                (high >> 8) & 0xff,\n                (high >> 16) & 0xff,\n                (high >> 24) & 0xff\n            ];\n        }\n        return buf;\n    }\n    static varIntBn(bn) {\n        let buf;\n        if (bn.isNeg()) {\n            bn = bn.add(OverflowUint64); // Adjust for negative numbers\n        }\n        if (bn.ltn(253)) {\n            const n = bn.toNumber();\n            // No need for bitwise operation as the value is within a byte's range\n            buf = [n];\n        }\n        else if (bn.ltn(0x10000)) {\n            const n = bn.toNumber();\n            // Value fits in a uint16\n            buf = [253, n & 0xff, (n >> 8) & 0xff];\n        }\n        else if (bn.lt(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0x100000000))) {\n            const n = bn.toNumber();\n            // Value fits in a uint32\n            buf = [\n                254,\n                n & 0xff,\n                (n >> 8) & 0xff,\n                (n >> 16) & 0xff,\n                (n >> 24) & 0xff\n            ];\n        }\n        else {\n            const bw = new Writer();\n            bw.writeUInt8(255);\n            bw.writeUInt64LEBn(bn);\n            buf = bw.toArray();\n        }\n        return buf;\n    }\n}\nclass Reader {\n    bin;\n    pos;\n    length;\n    constructor(bin = [], pos = 0) {\n        this.bin = bin;\n        this.pos = pos;\n        this.length = bin.length;\n    }\n    eof() {\n        return this.pos >= this.length;\n    }\n    read(len = this.length) {\n        const start = this.pos;\n        const end = this.pos + len;\n        this.pos = end;\n        return this.bin.slice(start, end);\n    }\n    readReverse(len = this.length) {\n        const buf2 = new Array(len);\n        for (let i = 0; i < len; i++) {\n            buf2[i] = this.bin[this.pos + len - 1 - i];\n        }\n        this.pos += len;\n        return buf2;\n    }\n    readUInt8() {\n        const val = this.bin[this.pos];\n        this.pos += 1;\n        return val;\n    }\n    readInt8() {\n        const val = this.bin[this.pos];\n        this.pos += 1;\n        // If the sign bit is set, convert to negative value\n        return (val & 0x80) !== 0 ? val - 0x100 : val;\n    }\n    readUInt16BE() {\n        const val = (this.bin[this.pos] << 8) | this.bin[this.pos + 1];\n        this.pos += 2;\n        return val;\n    }\n    readInt16BE() {\n        const val = this.readUInt16BE();\n        // If the sign bit is set, convert to negative value\n        return (val & 0x8000) !== 0 ? val - 0x10000 : val;\n    }\n    readUInt16LE() {\n        const val = this.bin[this.pos] | (this.bin[this.pos + 1] << 8);\n        this.pos += 2;\n        return val;\n    }\n    readInt16LE() {\n        const val = this.readUInt16LE();\n        // If the sign bit is set, convert to negative value\n        const x = (val & 0x8000) !== 0 ? val - 0x10000 : val;\n        return x;\n    }\n    readUInt32BE() {\n        const val = this.bin[this.pos] * 0x1000000 + // Shift the first byte by 24 bits\n            ((this.bin[this.pos + 1] << 16) | // Shift the second byte by 16 bits\n                (this.bin[this.pos + 2] << 8) | // Shift the third byte by 8 bits\n                this.bin[this.pos + 3]); // The fourth byte\n        this.pos += 4;\n        return val;\n    }\n    readInt32BE() {\n        const val = this.readUInt32BE();\n        // If the sign bit is set, convert to negative value\n        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;\n    }\n    readUInt32LE() {\n        const val = (this.bin[this.pos] |\n            (this.bin[this.pos + 1] << 8) |\n            (this.bin[this.pos + 2] << 16) |\n            (this.bin[this.pos + 3] << 24)) >>>\n            0;\n        this.pos += 4;\n        return val;\n    }\n    readInt32LE() {\n        const val = this.readUInt32LE();\n        // Explicitly check if the sign bit is set and then convert to a negative value\n        return (val & 0x80000000) !== 0 ? val - 0x100000000 : val;\n    }\n    readUInt64BEBn() {\n        const bin = this.bin.slice(this.pos, this.pos + 8);\n        const bn = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bin);\n        this.pos = this.pos + 8;\n        return bn;\n    }\n    readUInt64LEBn() {\n        const bin = this.readReverse(8);\n        const bn = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bin);\n        return bn;\n    }\n    readInt64LEBn() {\n        const bin = this.readReverse(8);\n        let bn = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](bin);\n        if (bn.gte(OverflowInt64)) {\n            bn = bn.sub(OverflowUint64); // Adjust for negative numbers\n        }\n        return bn;\n    }\n    readVarIntNum(signed = true) {\n        const first = this.readUInt8();\n        let bn;\n        switch (first) {\n            case 0xfd:\n                return this.readUInt16LE();\n            case 0xfe:\n                return this.readUInt32LE();\n            case 0xff:\n                bn = signed ? this.readInt64LEBn() : this.readUInt64LEBn();\n                if (bn.lte(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2).pow(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](53)))) {\n                    return bn.toNumber();\n                }\n                else {\n                    throw new Error('number too large to retain precision - use readVarIntBn');\n                }\n            default:\n                return first;\n        }\n    }\n    readVarInt() {\n        const first = this.bin[this.pos];\n        switch (first) {\n            case 0xfd:\n                return this.read(1 + 2);\n            case 0xfe:\n                return this.read(1 + 4);\n            case 0xff:\n                return this.read(1 + 8);\n            default:\n                return this.read(1);\n        }\n    }\n    readVarIntBn() {\n        const first = this.readUInt8();\n        switch (first) {\n            case 0xfd:\n                return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.readUInt16LE());\n            case 0xfe:\n                return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.readUInt32LE());\n            case 0xff:\n                return this.readUInt64LEBn();\n            default:\n                return new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](first);\n        }\n    }\n}\nconst minimallyEncode = (buf) => {\n    if (buf.length === 0) {\n        return buf;\n    }\n    // If the last byte is not 0x00 or 0x80, we are minimally encoded.\n    const last = buf[buf.length - 1];\n    if ((last & 0x7f) !== 0) {\n        return buf;\n    }\n    // If the script is one byte long, then we have a zero, which encodes as an\n    // empty array.\n    if (buf.length === 1) {\n        return [];\n    }\n    // If the next byte has it sign bit set, then we are minimaly encoded.\n    if ((buf[buf.length - 2] & 0x80) !== 0) {\n        return buf;\n    }\n    // We are not minimally encoded, we need to figure out how much to trim.\n    for (let i = buf.length - 1; i > 0; i--) {\n        // We found a non zero byte, time to encode.\n        if (buf[i - 1] !== 0) {\n            if ((buf[i - 1] & 0x80) !== 0) {\n                // We found a byte with it sign bit set so we need one more\n                // byte.\n                buf[i] = last;\n                return buf.slice(0, i + 1);\n            }\n            else {\n                // the sign bit is clear, we can use it.\n                buf[i - 1] |= last;\n                return buf.slice(0, i);\n            }\n        }\n    }\n    // If we found the whole thing is zeros, then we have a zero.\n    return [];\n};\nconst OverflowInt64 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2).pow(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](63));\nconst OverflowUint64 = new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2).pow(new _BigNumber_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](64));\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/registry/RegistryClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/registry/RegistryClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegistryClient: () => (/* binding */ RegistryClient),\n/* harmony export */   deserializeWalletProtocol: () => (/* binding */ deserializeWalletProtocol)\n/* harmony export */ });\n/* harmony import */ var _wallet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wallet/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n/* harmony import */ var _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js\");\n/* harmony import */ var _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js\");\n/* harmony import */ var _script_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../script/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/index.js\");\n\n\n\n\n\nconst REGISTRANT_TOKEN_AMOUNT = 1;\n/**\n * RegistryClient manages on-chain registry definitions for three types:\n * - basket (basket-based items)\n * - protocol (protocol-based items)\n * - certificate (certificate-based items)\n *\n * It provides methods to:\n * - Register new definitions using pushdrop-based UTXOs.\n * - Resolve existing definitions using a lookup service.\n * - List registry entries associated with the operator's wallet.\n * - Revoke an existing registry entry by spending its UTXO.\n *\n * Registry operators use this client to establish and manage\n * canonical references for baskets, protocols, and certificate types.\n */\nclass RegistryClient {\n    wallet;\n    network;\n    constructor(wallet = new _wallet_index_js__WEBPACK_IMPORTED_MODULE_0__.WalletClient()) {\n        this.wallet = wallet;\n    }\n    /**\n     * Publishes a new on-chain definition for baskets, protocols, or certificates.\n     * The definition data is encoded in a pushdrop-based UTXO.\n     *\n     * Registry operators (i.e., identity key owners) can create these definitions\n     * to establish canonical references for basket IDs, protocol specs, or certificate schemas.\n     *\n     * @param data - Structured information about a 'basket', 'protocol', or 'certificate'.\n     * @returns A promise with the broadcast result or failure.\n     */\n    async registerDefinition(data) {\n        const registryOperator = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;\n        const pushdrop = new _script_index_js__WEBPACK_IMPORTED_MODULE_4__.PushDrop(this.wallet);\n        // Convert definition data into PushDrop fields\n        const fields = this.buildPushDropFields(data, registryOperator);\n        // Convert the user-friendly definitionType to the actual wallet protocol\n        const protocol = this.mapDefinitionTypeToWalletProtocol(data.definitionType);\n        // Lock the fields into a pushdrop-based UTXO\n        const lockingScript = await pushdrop.lock(fields, protocol, '1', 'anyone', true);\n        // Create a transaction\n        const { tx } = await this.wallet.createAction({\n            description: `Register a new ${data.definitionType} item`,\n            outputs: [\n                {\n                    satoshis: REGISTRANT_TOKEN_AMOUNT,\n                    lockingScript: lockingScript.toHex(),\n                    outputDescription: `New ${data.definitionType} registration token`,\n                    basket: this.mapDefinitionTypeToBasketName(data.definitionType)\n                }\n            ],\n            options: {\n                randomizeOutputs: false\n            }\n        });\n        if (tx === undefined) {\n            throw new Error(`Failed to create ${data.definitionType} registration transaction!`);\n        }\n        // Broadcast to the relevant topic\n        const broadcaster = new _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_3__.TopicBroadcaster([this.mapDefinitionTypeToTopic(data.definitionType)], {\n            networkPreset: this.network ??= (await this.wallet.getNetwork({})).network\n        });\n        return await broadcaster.broadcast(_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.fromAtomicBEEF(tx));\n    }\n    /**\n     * Resolves registrant tokens of a particular type using a lookup service.\n     *\n     * The query object shape depends on the registry type:\n     * - For \"basket\", the query is of type BasketMapQuery:\n     *   { basketID?: string; name?: string; registryOperators?: string[]; }\n     * - For \"protocol\", the query is of type ProtoMapQuery:\n     *   { name?: string; registryOperators?: string[]; protocolID?: WalletProtocol; }\n     * - For \"certificate\", the query is of type CertMapQuery:\n     *   { type?: string; name?: string; registryOperators?: string[]; }\n     *\n     * @param definitionType - The registry type, which can be 'basket', 'protocol', or 'certificate'.\n     * @param query - The query object used to filter registry records, whose shape is determined by the registry type.\n     * @returns A promise that resolves to an array of matching registry records.\n     */\n    async resolve(definitionType, query) {\n        const resolver = new _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_3__.LookupResolver();\n        const serviceName = this.mapDefinitionTypeToServiceName(definitionType);\n        // Make the lookup query\n        const result = await resolver.query({ service: serviceName, query });\n        if (result.type !== 'output-list') {\n            return [];\n        }\n        const parsedRegistryRecords = [];\n        for (const output of result.outputs) {\n            try {\n                const parsedTx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.fromBEEF(output.beef);\n                const lockingScript = parsedTx.outputs[output.outputIndex].lockingScript;\n                const record = await this.parseLockingScript(definitionType, lockingScript);\n                parsedRegistryRecords.push(record);\n            }\n            catch {\n                // Skip invalid or non-pushdrop outputs\n            }\n        }\n        return parsedRegistryRecords;\n    }\n    /**\n     * Lists the registry operator's published definitions for the given type.\n     *\n     * Returns parsed registry records including transaction details such as txid, outputIndex, satoshis, and the locking script.\n     *\n     * @param definitionType - The type of registry definition to list ('basket', 'protocol', or 'certificate').\n     * @returns A promise that resolves to an array of RegistryRecord objects.\n     */\n    async listOwnRegistryEntries(definitionType) {\n        const relevantBasketName = this.mapDefinitionTypeToBasketName(definitionType);\n        const { outputs, BEEF } = await this.wallet.listOutputs({\n            basket: relevantBasketName,\n            include: 'entire transactions'\n        });\n        const results = [];\n        for (const output of outputs) {\n            if (!output.spendable) {\n                continue;\n            }\n            try {\n                const [txid, outputIndex] = output.outpoint.split('.');\n                const tx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.fromBEEF(BEEF);\n                const lockingScript = tx.outputs[outputIndex].lockingScript;\n                const record = await this.parseLockingScript(definitionType, lockingScript);\n                results.push({\n                    ...record,\n                    txid,\n                    outputIndex: Number(outputIndex),\n                    satoshis: output.satoshis,\n                    lockingScript: lockingScript.toHex(),\n                    beef: BEEF\n                });\n            }\n            catch {\n                // Ignore parse errors\n            }\n        }\n        return results;\n    }\n    /**\n     * Revokes a registry record by spending its associated UTXO.\n     *\n     * @param registryRecord - Must have valid txid, outputIndex, and lockingScript.\n     * @returns Broadcast success/failure.\n     */\n    async revokeOwnRegistryEntry(registryRecord) {\n        if (registryRecord.txid === undefined || typeof registryRecord.outputIndex === 'undefined' || registryRecord.lockingScript === undefined) {\n            throw new Error('Invalid registry record. Missing txid, outputIndex, or lockingScript.');\n        }\n        // Check if the registry record belongs to the current user\n        const currentIdentityKey = (await this.wallet.getPublicKey({ identityKey: true })).publicKey;\n        if (registryRecord.registryOperator !== currentIdentityKey) {\n            throw new Error('This registry token does not belong to the current wallet.');\n        }\n        // Create a descriptive label for the item were revoking\n        const itemIdentifier = registryRecord.definitionType === 'basket'\n            ? registryRecord.basketID\n            : registryRecord.definitionType === 'protocol'\n                ? registryRecord.name\n                : registryRecord.definitionType === 'certificate'\n                    ? (registryRecord.name !== undefined ? registryRecord.name : registryRecord.type)\n                    : 'unknown';\n        const outpoint = `${registryRecord.txid}.${registryRecord.outputIndex}`;\n        const { signableTransaction } = await this.wallet.createAction({\n            description: `Revoke ${registryRecord.definitionType} item: ${itemIdentifier}`,\n            inputBEEF: registryRecord.beef,\n            inputs: [\n                {\n                    outpoint,\n                    unlockingScriptLength: 73,\n                    inputDescription: `Revoking ${registryRecord.definitionType} token`\n                }\n            ]\n        });\n        if (signableTransaction === undefined) {\n            throw new Error('Failed to create signable transaction.');\n        }\n        const partialTx = _transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.fromBEEF(signableTransaction.tx);\n        // Prepare the unlocker\n        const pushdrop = new _script_index_js__WEBPACK_IMPORTED_MODULE_4__.PushDrop(this.wallet);\n        const unlocker = await pushdrop.unlock(this.mapDefinitionTypeToWalletProtocol(registryRecord.definitionType), '1', 'anyone', 'all', false, registryRecord.satoshis, _script_index_js__WEBPACK_IMPORTED_MODULE_4__.LockingScript.fromHex(registryRecord.lockingScript));\n        // Convert to Transaction, apply signature\n        const finalUnlockScript = await unlocker.sign(partialTx, registryRecord.outputIndex);\n        // Complete signing with the final unlock script\n        const { tx: signedTx } = await this.wallet.signAction({\n            reference: signableTransaction.reference,\n            spends: {\n                [registryRecord.outputIndex]: {\n                    unlockingScript: finalUnlockScript.toHex()\n                }\n            },\n            options: {\n                acceptDelayedBroadcast: false\n            }\n        });\n        if (signedTx === undefined) {\n            throw new Error('Failed to finalize the transaction signature.');\n        }\n        // Broadcast\n        const broadcaster = new _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_3__.TopicBroadcaster([this.mapDefinitionTypeToTopic(registryRecord.definitionType)], {\n            networkPreset: this.network ??= (await this.wallet.getNetwork({})).network\n        });\n        return await broadcaster.broadcast(_transaction_index_js__WEBPACK_IMPORTED_MODULE_2__.Transaction.fromAtomicBEEF(signedTx));\n    }\n    // --------------------------------------------------------------------------\n    // INTERNAL UTILITY METHODS\n    // --------------------------------------------------------------------------\n    /**\n     * Convert definition data into an array of pushdrop fields (strings).\n     * Each definition type has a slightly different shape.\n     */\n    buildPushDropFields(data, registryOperator) {\n        let fields;\n        switch (data.definitionType) {\n            case 'basket':\n                fields = [\n                    data.basketID,\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL\n                ];\n                break;\n            case 'protocol':\n                fields = [\n                    JSON.stringify(data.protocolID),\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL\n                ];\n                break;\n            case 'certificate':\n                fields = [\n                    data.type,\n                    data.name,\n                    data.iconURL,\n                    data.description,\n                    data.documentationURL,\n                    JSON.stringify(data.fields)\n                ];\n                break;\n            default:\n                throw new Error('Unsupported definition type');\n        }\n        // Append the operator's public identity key last\n        fields.push(registryOperator);\n        return fields.map(field => _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(field));\n    }\n    /**\n     * Decodes a pushdrop locking script for a given definition type,\n     * returning a typed record with the appropriate fields.\n     */\n    async parseLockingScript(definitionType, lockingScript) {\n        const decoded = _script_index_js__WEBPACK_IMPORTED_MODULE_4__.PushDrop.decode(lockingScript);\n        if (decoded.fields.length === 0) {\n            throw new Error('Not a valid registry pushdrop script.');\n        }\n        let registryOperator;\n        let parsedData;\n        switch (definitionType) {\n            case 'basket': {\n                if (decoded.fields.length !== 7) {\n                    throw new Error('Unexpected field count for basket type.');\n                }\n                const [basketID, name, iconURL, description, docURL, operator] = decoded.fields;\n                registryOperator = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(operator);\n                parsedData = {\n                    definitionType: 'basket',\n                    basketID: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(basketID),\n                    name: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(name),\n                    iconURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(iconURL),\n                    description: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(description),\n                    documentationURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(docURL)\n                };\n                break;\n            }\n            case 'protocol': {\n                if (decoded.fields.length !== 7) {\n                    throw new Error('Unexpected field count for protocol type.');\n                }\n                const [protocolID, name, iconURL, description, docURL, operator] = decoded.fields;\n                registryOperator = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(operator);\n                parsedData = {\n                    definitionType: 'protocol',\n                    protocolID: deserializeWalletProtocol(_primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(protocolID)),\n                    name: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(name),\n                    iconURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(iconURL),\n                    description: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(description),\n                    documentationURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(docURL)\n                };\n                break;\n            }\n            case 'certificate': {\n                if (decoded.fields.length !== 8) {\n                    throw new Error('Unexpected field count for certificate type.');\n                }\n                const [certType, name, iconURL, description, docURL, fieldsJSON, operator] = decoded.fields;\n                registryOperator = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(operator);\n                let parsedFields = {};\n                try {\n                    parsedFields = JSON.parse(_primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(fieldsJSON));\n                }\n                catch {\n                    // If there's a JSON parse error, assume empty\n                }\n                parsedData = {\n                    definitionType: 'certificate',\n                    type: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(certType),\n                    name: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(name),\n                    iconURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(iconURL),\n                    description: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(description),\n                    documentationURL: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toUTF8(docURL),\n                    fields: parsedFields\n                };\n                break;\n            }\n            default:\n                throw new Error(`Unsupported definition type: ${definitionType}`);\n        }\n        // Return the typed data plus the operator key\n        return { ...parsedData, registryOperator };\n    }\n    /**\n     * Convert our definitionType to the wallet protocol format ([protocolID, keyID]).\n     */\n    mapDefinitionTypeToWalletProtocol(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return [1, 'basketmap'];\n            case 'protocol':\n                return [1, 'protomap'];\n            case 'certificate':\n                return [1, 'certmap'];\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the basket name used by the wallet.\n     */\n    mapDefinitionTypeToBasketName(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'basketmap';\n            case 'protocol':\n                return 'protomap';\n            case 'certificate':\n                return 'certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the broadcast topic name.\n     */\n    mapDefinitionTypeToTopic(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'tm_basketmap';\n            case 'protocol':\n                return 'tm_protomap';\n            case 'certificate':\n                return 'tm_certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n    /**\n     * Convert 'basket'|'protocol'|'certificate' to the lookup service name.\n     */\n    mapDefinitionTypeToServiceName(definitionType) {\n        switch (definitionType) {\n            case 'basket':\n                return 'ls_basketmap';\n            case 'protocol':\n                return 'ls_protomap';\n            case 'certificate':\n                return 'ls_certmap';\n            default:\n                throw new Error(`Unknown definition type: ${definitionType}`);\n        }\n    }\n}\nfunction deserializeWalletProtocol(str) {\n    // Parse the JSON string back into a JavaScript value.\n    const parsed = JSON.parse(str);\n    // Validate that the parsed value is an array with exactly two elements.\n    if (!Array.isArray(parsed) || parsed.length !== 2) {\n        throw new Error('Invalid wallet protocol format.');\n    }\n    const [security, protocolString] = parsed;\n    // Validate that the security level is one of the allowed numbers.\n    if (![0, 1, 2].includes(security)) {\n        throw new Error('Invalid security level.');\n    }\n    // Validate that the protocol string is a string and its length is within the allowed bounds.\n    if (typeof protocolString !== 'string') {\n        throw new Error('Invalid protocolID');\n    }\n    return [security, protocolString];\n}\n//# sourceMappingURL=RegistryClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/registry/RegistryClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/registry/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/registry/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RegistryClient: () => (/* reexport safe */ _RegistryClient_js__WEBPACK_IMPORTED_MODULE_0__.RegistryClient),\n/* harmony export */   deserializeWalletProtocol: () => (/* reexport safe */ _RegistryClient_js__WEBPACK_IMPORTED_MODULE_0__.deserializeWalletProtocol)\n/* harmony export */ });\n/* harmony import */ var _RegistryClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RegistryClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/registry/RegistryClient.js\");\n/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/registry/types/index.js\");\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/registry/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/registry/types/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/registry/types/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/registry/types/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ LockingScript)\n/* harmony export */ });\n/* harmony import */ var _Script_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Script.js\");\n\n/**\n * The LockingScript class represents a locking script in a Bitcoin SV transaction.\n * It extends the Script class and is used specifically for output scripts that lock funds.\n *\n * Inherits all properties and methods from the Script class.\n *\n * @extends {Script}\n * @see {@link Script} for more information on Script.\n */\nclass LockingScript extends _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns {boolean} Always returns true for a LockingScript instance.\n     */\n    isLockingScript() {\n        return true;\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns {boolean} Always returns false for a LockingScript instance.\n     */\n    isUnlockingScript() {\n        return false;\n    }\n}\n//# sourceMappingURL=LockingScript.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/OP.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/OP.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * An object mapping opcode names (such as OP_DUP) to their corresponding numbers (such as 0x76), and vice versa.\n */\nconst OP = {\n    // push value\n    OP_FALSE: 0x00,\n    OP_0: 0x00,\n    OP_PUSHDATA1: 0x4c,\n    OP_PUSHDATA2: 0x4d,\n    OP_PUSHDATA4: 0x4e,\n    OP_1NEGATE: 0x4f,\n    OP_RESERVED: 0x50,\n    OP_TRUE: 0x51,\n    OP_1: 0x51,\n    OP_2: 0x52,\n    OP_3: 0x53,\n    OP_4: 0x54,\n    OP_5: 0x55,\n    OP_6: 0x56,\n    OP_7: 0x57,\n    OP_8: 0x58,\n    OP_9: 0x59,\n    OP_10: 0x5a,\n    OP_11: 0x5b,\n    OP_12: 0x5c,\n    OP_13: 0x5d,\n    OP_14: 0x5e,\n    OP_15: 0x5f,\n    OP_16: 0x60,\n    // control\n    OP_NOP: 0x61,\n    OP_VER: 0x62,\n    OP_IF: 0x63,\n    OP_NOTIF: 0x64,\n    OP_VERIF: 0x65,\n    OP_VERNOTIF: 0x66,\n    OP_ELSE: 0x67,\n    OP_ENDIF: 0x68,\n    OP_VERIFY: 0x69,\n    OP_RETURN: 0x6a,\n    // stack ops\n    OP_TOALTSTACK: 0x6b,\n    OP_FROMALTSTACK: 0x6c,\n    OP_2DROP: 0x6d,\n    OP_2DUP: 0x6e,\n    OP_3DUP: 0x6f,\n    OP_2OVER: 0x70,\n    OP_2ROT: 0x71,\n    OP_2SWAP: 0x72,\n    OP_IFDUP: 0x73,\n    OP_DEPTH: 0x74,\n    OP_DROP: 0x75,\n    OP_DUP: 0x76,\n    OP_NIP: 0x77,\n    OP_OVER: 0x78,\n    OP_PICK: 0x79,\n    OP_ROLL: 0x7a,\n    OP_ROT: 0x7b,\n    OP_SWAP: 0x7c,\n    OP_TUCK: 0x7d,\n    // data manipulation ops\n    OP_CAT: 0x7e,\n    OP_SUBSTR: 0x7f,\n    OP_SPLIT: 0x7f,\n    OP_LEFT: 0x80,\n    OP_NUM2BIN: 0x80,\n    OP_RIGHT: 0x81,\n    OP_BIN2NUM: 0x81,\n    OP_SIZE: 0x82,\n    // bit logic\n    OP_INVERT: 0x83,\n    OP_AND: 0x84,\n    OP_OR: 0x85,\n    OP_XOR: 0x86,\n    OP_EQUAL: 0x87,\n    OP_EQUALVERIFY: 0x88,\n    OP_RESERVED1: 0x89,\n    OP_RESERVED2: 0x8a,\n    // numeric\n    OP_1ADD: 0x8b,\n    OP_1SUB: 0x8c,\n    OP_2MUL: 0x8d,\n    OP_2DIV: 0x8e,\n    OP_NEGATE: 0x8f,\n    OP_ABS: 0x90,\n    OP_NOT: 0x91,\n    OP_0NOTEQUAL: 0x92,\n    OP_ADD: 0x93,\n    OP_SUB: 0x94,\n    OP_MUL: 0x95,\n    OP_DIV: 0x96,\n    OP_MOD: 0x97,\n    OP_LSHIFT: 0x98,\n    OP_RSHIFT: 0x99,\n    OP_BOOLAND: 0x9a,\n    OP_BOOLOR: 0x9b,\n    OP_NUMEQUAL: 0x9c,\n    OP_NUMEQUALVERIFY: 0x9d,\n    OP_NUMNOTEQUAL: 0x9e,\n    OP_LESSTHAN: 0x9f,\n    OP_GREATERTHAN: 0xa0,\n    OP_LESSTHANOREQUAL: 0xa1,\n    OP_GREATERTHANOREQUAL: 0xa2,\n    OP_MIN: 0xa3,\n    OP_MAX: 0xa4,\n    OP_WITHIN: 0xa5,\n    // crypto\n    OP_RIPEMD160: 0xa6,\n    OP_SHA1: 0xa7,\n    OP_SHA256: 0xa8,\n    OP_HASH160: 0xa9,\n    OP_HASH256: 0xaa,\n    OP_CODESEPARATOR: 0xab,\n    OP_CHECKSIG: 0xac,\n    OP_CHECKSIGVERIFY: 0xad,\n    OP_CHECKMULTISIG: 0xae,\n    OP_CHECKMULTISIGVERIFY: 0xaf,\n    // expansion\n    OP_NOP1: 0xb0,\n    OP_NOP2: 0xb1,\n    OP_NOP3: 0xb2,\n    OP_NOP4: 0xb3,\n    OP_NOP5: 0xb4,\n    OP_NOP6: 0xb5,\n    OP_NOP7: 0xb6,\n    OP_NOP8: 0xb7,\n    OP_NOP9: 0xb8,\n    OP_NOP10: 0xb9,\n    OP_NOP11: 0xba,\n    OP_NOP12: 0xbb,\n    OP_NOP13: 0xbc,\n    OP_NOP14: 0xbd,\n    OP_NOP15: 0xbe,\n    OP_NOP16: 0xbf,\n    OP_NOP17: 0xc0,\n    OP_NOP18: 0xc1,\n    OP_NOP19: 0xc2,\n    OP_NOP20: 0xc3,\n    OP_NOP21: 0xc4,\n    OP_NOP22: 0xc5,\n    OP_NOP23: 0xc6,\n    OP_NOP24: 0xc7,\n    OP_NOP25: 0xc8,\n    OP_NOP26: 0xc9,\n    OP_NOP27: 0xca,\n    OP_NOP28: 0xcb,\n    OP_NOP29: 0xcc,\n    OP_NOP30: 0xcd,\n    OP_NOP31: 0xce,\n    OP_NOP32: 0xcf,\n    OP_NOP33: 0xd0,\n    OP_NOP34: 0xd1,\n    OP_NOP35: 0xd2,\n    OP_NOP36: 0xd3,\n    OP_NOP37: 0xd4,\n    OP_NOP38: 0xd5,\n    OP_NOP39: 0xd6,\n    OP_NOP40: 0xd7,\n    OP_NOP41: 0xd8,\n    OP_NOP42: 0xd9,\n    OP_NOP43: 0xda,\n    OP_NOP44: 0xdb,\n    OP_NOP45: 0xdc,\n    OP_NOP46: 0xdd,\n    OP_NOP47: 0xde,\n    OP_NOP48: 0xdf,\n    OP_NOP49: 0xe0,\n    OP_NOP50: 0xe1,\n    OP_NOP51: 0xe2,\n    OP_NOP52: 0xe3,\n    OP_NOP53: 0xe4,\n    OP_NOP54: 0xe5,\n    OP_NOP55: 0xe6,\n    OP_NOP56: 0xe7,\n    OP_NOP57: 0xe8,\n    OP_NOP58: 0xe9,\n    OP_NOP59: 0xea,\n    OP_NOP60: 0xeb,\n    OP_NOP61: 0xec,\n    OP_NOP62: 0xed,\n    OP_NOP63: 0xee,\n    OP_NOP64: 0xef,\n    OP_NOP65: 0xf0,\n    OP_NOP66: 0xf1,\n    OP_NOP67: 0xf2,\n    OP_NOP68: 0xf3,\n    OP_NOP69: 0xf4,\n    OP_NOP70: 0xf5,\n    OP_NOP71: 0xf6,\n    OP_NOP72: 0xf7,\n    OP_NOP73: 0xf8,\n    OP_NOP77: 0xfc,\n    // template matching params\n    OP_SMALLDATA: 0xf9,\n    OP_SMALLINTEGER: 0xfa,\n    OP_PUBKEYS: 0xfb,\n    OP_PUBKEYHASH: 0xfd,\n    OP_PUBKEY: 0xfe,\n    OP_INVALIDOPCODE: 0xff\n};\nfor (const name in OP) {\n    OP[OP[name]] = name;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OP);\n//# sourceMappingURL=OP.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/OP.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/Script.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/Script.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Script)\n/* harmony export */ });\n/* harmony import */ var _OP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/OP.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n\n\n\n/**\n * The Script class represents a script in a Bitcoin SV transaction,\n * encapsulating the functionality to construct, parse, and serialize\n * scripts used in both locking (output) and unlocking (input) scripts.\n *\n * @property {ScriptChunk[]} chunks - An array of script chunks that make up the script.\n */\nclass Script {\n    chunks;\n    /**\n     * @method fromASM\n     * Static method to construct a Script instance from an ASM (Assembly) formatted string.\n     * @param asm - The script in ASM string format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromASM(\"OP_DUP OP_HASH160 abcd... OP_EQUALVERIFY OP_CHECKSIG\")\n     */\n    static fromASM(asm) {\n        const chunks = [];\n        const tokens = asm.split(' ');\n        let i = 0;\n        while (i < tokens.length) {\n            const token = tokens[i];\n            let opCode;\n            let opCodeNum = 0;\n            if (token.startsWith('OP_') && typeof _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][token] !== 'undefined') {\n                opCode = token;\n                opCodeNum = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][token];\n            }\n            // we start with two special cases, 0 and -1, which are handled specially in\n            // toASM. see _chunkToString.\n            if (token === '0') {\n                opCodeNum = 0;\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (token === '-1') {\n                opCodeNum = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_1NEGATE;\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (opCode === undefined) {\n                let hex = tokens[i];\n                if (hex.length % 2 !== 0) {\n                    hex = '0' + hex;\n                }\n                const arr = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(hex, 'hex');\n                if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.encode)(arr, 'hex') !== hex) {\n                    throw new Error('invalid hex string in script');\n                }\n                const len = arr.length;\n                if (len >= 0 && len < _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n                    opCodeNum = len;\n                }\n                else if (len < Math.pow(2, 8)) {\n                    opCodeNum = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1;\n                }\n                else if (len < Math.pow(2, 16)) {\n                    opCodeNum = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA2;\n                }\n                else if (len < Math.pow(2, 32)) {\n                    opCodeNum = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA4;\n                }\n                chunks.push({\n                    data: arr,\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n            else if (opCodeNum === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1 ||\n                opCodeNum === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA2 ||\n                opCodeNum === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA4) {\n                chunks.push({\n                    data: (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(tokens[i + 2], 'hex'),\n                    op: opCodeNum\n                });\n                i = i + 3;\n            }\n            else {\n                chunks.push({\n                    op: opCodeNum\n                });\n                i = i + 1;\n            }\n        }\n        return new Script(chunks);\n    }\n    /**\n     * @method fromHex\n     * Static method to construct a Script instance from a hexadecimal string.\n     * @param hex - The script in hexadecimal format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromHex(\"76a9...\");\n     */\n    static fromHex(hex) {\n        if (hex.length === 0)\n            return Script.fromBinary([]);\n        if (hex.length % 2 !== 0) {\n            throw new Error('There is an uneven number of characters in the string which suggests it is not hex encoded.');\n        }\n        if (!/^[0-9a-fA-F]+$/.test(hex)) {\n            throw new Error('Some elements in this string are not hex encoded.');\n        }\n        return Script.fromBinary((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(hex, 'hex'));\n    }\n    /**\n     * @method fromBinary\n     * Static method to construct a Script instance from a binary array.\n     * @param bin - The script in binary array format.\n     * @returns A new Script instance.\n     * @example\n     * const script = Script.fromBinary([0x76, 0xa9, ...])\n     */\n    static fromBinary(bin) {\n        bin = [...bin];\n        const chunks = [];\n        let inConditionalBlock = 0;\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Reader(bin);\n        while (!br.eof()) {\n            const op = br.readUInt8();\n            // if OP_RETURN and not in a conditional block, do not parse the rest of the data,\n            // rather just return the last chunk as data without prefixing with data length.\n            if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_RETURN && inConditionalBlock === 0) {\n                chunks.push({\n                    op,\n                    data: br.read()\n                });\n                break;\n            }\n            if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_IF || op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_NOTIF || op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_VERIF || op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_VERNOTIF) {\n                inConditionalBlock++;\n            }\n            else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_ENDIF) {\n                inConditionalBlock--;\n            }\n            let len = 0;\n            // eslint-disable-next-line @typescript-eslint/no-shadow\n            let data = [];\n            if (op > 0 && op < _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n                len = op;\n                chunks.push({\n                    data: br.read(len),\n                    op\n                });\n            }\n            else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n                try {\n                    len = br.readUInt8();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA2) {\n                try {\n                    len = br.readUInt16LE();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA4) {\n                try {\n                    len = br.readUInt32LE();\n                    data = br.read(len);\n                }\n                catch {\n                    br.read();\n                }\n                chunks.push({\n                    data,\n                    op\n                });\n            }\n            else {\n                chunks.push({\n                    op\n                });\n            }\n        }\n        return new Script(chunks);\n    }\n    /**\n     * @constructor\n     * Constructs a new Script object.\n     * @param chunks=[] - An array of script chunks to directly initialize the script.\n     */\n    constructor(chunks = []) {\n        this.chunks = chunks;\n    }\n    /**\n     * @method toASM\n     * Serializes the script to an ASM formatted string.\n     * @returns The script in ASM string format.\n     */\n    toASM() {\n        let str = '';\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            str += this._chunkToString(chunk);\n        }\n        return str.slice(1);\n    }\n    /**\n     * @method toHex\n     * Serializes the script to a hexadecimal string.\n     * @returns The script in hexadecimal format.\n     */\n    toHex() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.encode)(this.toBinary(), 'hex');\n    }\n    /**\n     * @method toBinary\n     * Serializes the script to a binary array.\n     * @returns The script in binary array format.\n     */\n    toBinary() {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Writer();\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            const op = chunk.op;\n            writer.writeUInt8(op);\n            if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_RETURN && chunk.data != null) { // special case for unformatted data\n                writer.write(chunk.data);\n                break;\n            }\n            else if (chunk.data != null) {\n                if (op < _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n                    writer.write(chunk.data);\n                }\n                else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n                    writer.writeUInt8(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n                else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA2) {\n                    writer.writeUInt16LE(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n                else if (op === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA4) {\n                    writer.writeUInt32LE(chunk.data.length);\n                    writer.write(chunk.data);\n                }\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * @method writeScript\n     * Appends another script to this script.\n     * @param script - The script to append.\n     * @returns This script instance for chaining.\n     */\n    writeScript(script) {\n        this.chunks = this.chunks.concat(script.chunks);\n        return this;\n    }\n    /**\n     * @method writeOpCode\n     * Appends an opcode to the script.\n     * @param op - The opcode to append.\n     * @returns This script instance for chaining.\n     */\n    writeOpCode(op) {\n        this.chunks.push({ op });\n        return this;\n    }\n    /**\n     * @method setChunkOpCode\n     * Sets the opcode of a specific chunk in the script.\n     * @param i - The index of the chunk.\n     * @param op - The opcode to set.\n     * @returns This script instance for chaining.\n     */\n    setChunkOpCode(i, op) {\n        this.chunks[i] = { op };\n        return this;\n    }\n    /**\n     * @method writeBn\n     * Appends a BigNumber to the script as an opcode.\n     * @param bn - The BigNumber to append.\n     * @returns This script instance for chaining.\n     */\n    writeBn(bn) {\n        if (bn.cmpn(0) === _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_0) {\n            this.chunks.push({\n                op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_0\n            });\n        }\n        else if (bn.cmpn(-1) === 0) {\n            this.chunks.push({\n                op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_1NEGATE\n            });\n        }\n        else if (bn.cmpn(1) >= 0 && bn.cmpn(16) <= 0) {\n            // see OP_1 - OP_16\n            this.chunks.push({\n                op: bn.toNumber() + _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_1 - 1\n            });\n        }\n        else {\n            const buf = bn.toSm('little');\n            this.writeBin(buf);\n        }\n        return this;\n    }\n    /**\n     * @method writeBin\n     * Appends binary data to the script, determining the appropriate opcode based on length.\n     * @param bin - The binary data to append.\n     * @returns This script instance for chaining.\n     * @throws {Error} Throws an error if the data is too large to be pushed.\n     */\n    writeBin(bin) {\n        let op;\n        if (bin.length > 0 && bin.length < _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1) {\n            op = bin.length;\n        }\n        else if (bin.length === 0) {\n            op = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_0;\n        }\n        else if (bin.length < Math.pow(2, 8)) {\n            op = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA1;\n        }\n        else if (bin.length < Math.pow(2, 16)) {\n            op = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA2;\n        }\n        else if (bin.length < Math.pow(2, 32)) {\n            op = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_PUSHDATA4;\n        }\n        else {\n            throw new Error(\"You can't push that much data\");\n        }\n        this.chunks.push({\n            data: bin,\n            op\n        });\n        return this;\n    }\n    /**\n     * @method writeNumber\n     * Appends a number to the script.\n     * @param num - The number to append.\n     * @returns This script instance for chaining.\n     */\n    writeNumber(num) {\n        this.writeBn(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](num));\n        return this;\n    }\n    /**\n     * @method removeCodeseparators\n     * Removes all OP_CODESEPARATOR opcodes from the script.\n     * @returns This script instance for chaining.\n     */\n    removeCodeseparators() {\n        const chunks = [];\n        for (let i = 0; i < this.chunks.length; i++) {\n            if (this.chunks[i].op !== _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_CODESEPARATOR) {\n                chunks.push(this.chunks[i]);\n            }\n        }\n        this.chunks = chunks;\n        return this;\n    }\n    /**\n     * Deletes the given item wherever it appears in the current script.\n     *\n     * @param script - The script containing the item to delete from the current script.\n     *\n     * @returns This script instance for chaining.\n     */\n    findAndDelete(script) {\n        const buf = script.toHex();\n        for (let i = 0; i < this.chunks.length; i++) {\n            const script2 = new Script([this.chunks[i]]);\n            const buf2 = script2.toHex();\n            if (buf === buf2) {\n                this.chunks.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * @method isPushOnly\n     * Checks if the script contains only push data operations.\n     * @returns True if the script is push-only, otherwise false.\n     */\n    isPushOnly() {\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            const opCodeNum = chunk.op;\n            if (opCodeNum > _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_16) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns True if the script is a locking script, otherwise false.\n     */\n    isLockingScript() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns True if the script is an unlocking script, otherwise false.\n     */\n    isUnlockingScript() {\n        throw new Error('Not implemented');\n    }\n    /**\n     * @private\n     * @method _chunkToString\n     * Converts a script chunk to its string representation.\n     * @param chunk - The script chunk.\n     * @returns The string representation of the chunk.\n     */\n    _chunkToString(chunk) {\n        const op = chunk.op;\n        let str = '';\n        if (typeof chunk.data === 'undefined') {\n            const val = _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][op];\n            str = `${str} ${val}`;\n        }\n        else {\n            str = `${str} ${(0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(chunk.data)}`;\n        }\n        return str;\n    }\n}\n//# sourceMappingURL=Script.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/Script.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/ScriptEvaluationError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/ScriptEvaluationError.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ScriptEvaluationError)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\nclass ScriptEvaluationError extends Error {\n    txid;\n    outputIndex;\n    context;\n    programCounter;\n    stackState;\n    altStackState;\n    ifStackState;\n    stackMem;\n    altStackMem;\n    constructor(params) {\n        const stackHex = params.stackState.map(s => s != null && typeof s.length !== 'undefined' ? (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');\n        const altStackHex = params.altStackState.map(s => s != null && typeof s.length !== 'undefined' ? (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)(s) : (s === null || s === undefined ? 'null/undef' : 'INVALID_STACK_ITEM')).join(', ');\n        const pcInfo = `Context: ${params.context}, PC: ${params.programCounter}`;\n        const stackInfo = `Stack: [${stackHex}] (len: ${params.stackState.length}, mem: ${params.stackMem})`;\n        const altStackInfo = `AltStack: [${altStackHex}] (len: ${params.altStackState.length}, mem: ${params.altStackMem})`;\n        const ifStackInfo = `IfStack: [${params.ifStackState.join(', ')}]`;\n        const fullMessage = `Script evaluation error: ${params.message}\\nTXID: ${params.txid}, OutputIdx: ${params.outputIndex}\\n${pcInfo}\\n${stackInfo}\\n${altStackInfo}\\n${ifStackInfo}`;\n        super(fullMessage);\n        this.name = this.constructor.name;\n        this.txid = params.txid;\n        this.outputIndex = params.outputIndex;\n        this.context = params.context;\n        this.programCounter = params.programCounter;\n        this.stackState = params.stackState.map(s => s.slice());\n        this.altStackState = params.altStackState.map(s => s.slice());\n        this.ifStackState = params.ifStackState.slice();\n        this.stackMem = params.stackMem;\n        this.altStackMem = params.altStackMem;\n    }\n}\n//# sourceMappingURL=ScriptEvaluationError.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/ScriptEvaluationError.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/Spend.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/Spend.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Spend)\n/* harmony export */ });\n/* harmony import */ var _Script_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Script.js\");\n/* harmony import */ var _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n/* harmony import */ var _OP_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/OP.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _ScriptEvaluationError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ScriptEvaluationError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/ScriptEvaluationError.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js\");\n/* harmony import */ var _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../primitives/PublicKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PublicKey.js\");\n/* harmony import */ var _primitives_ECDSA_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../primitives/ECDSA.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/ECDSA.js\");\n\n\n\n\n\n\n\n\n\n// These constants control the current behavior of the interpreter.\nconst maxScriptElementSize = 1024 * 1024 * 1024;\nconst maxMultisigKeyCount = Math.pow(2, 31) - 1;\nconst requireMinimalPush = true;\nconst requirePushOnlyUnlockingScripts = true;\nconst requireLowSSignatures = true;\nconst requireCleanStack = true;\n// --- Optimization: Pre-computed script numbers ---\nconst SCRIPTNUM_NEG_1 = Object.freeze(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](-1).toScriptNum());\nconst SCRIPTNUMS_0_TO_16 = Object.freeze(Array.from({ length: 17 }, (_, i) => Object.freeze(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](i).toScriptNum())));\n// --- Helper functions ---\nfunction compareNumberArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\nfunction isMinimallyEncodedHelper(buf, maxNumSize = Number.MAX_SAFE_INTEGER) {\n    if (buf.length > maxNumSize) {\n        return false;\n    }\n    if (buf.length > 0) {\n        if ((buf[buf.length - 1] & 0x7f) === 0) {\n            if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction isChecksigFormatHelper(buf) {\n    // This is a simplified check. The full DER check is more complex and typically\n    // done by TransactionSignature.fromChecksigFormat which can throw.\n    // This helper is mostly for early bailout or non-throwing checks if needed.\n    if (buf.length < 9 || buf.length > 73)\n        return false;\n    if (buf[0] !== 0x30)\n        return false; // DER SEQUENCE\n    if (buf[1] !== buf.length - 3)\n        return false; // Total length (excluding type and length byte for sequence, and hash type)\n    const rMarker = buf[2];\n    const rLen = buf[3];\n    if (rMarker !== 0x02)\n        return false; // DER INTEGER\n    if (rLen === 0)\n        return false; // R length is zero\n    if (5 + rLen >= buf.length)\n        return false; // S length misplaced or R too long\n    const sMarkerOffset = 4 + rLen;\n    const sMarker = buf[sMarkerOffset];\n    const sLen = buf[sMarkerOffset + 1];\n    if (sMarker !== 0x02)\n        return false; // DER INTEGER\n    if (sLen === 0)\n        return false; // S length is zero\n    // Check R value negative or excessively padded\n    if ((buf[4] & 0x80) !== 0)\n        return false; // R value negative\n    if (rLen > 1 && buf[4] === 0x00 && (buf[5] & 0x80) === 0)\n        return false; // R value excessively padded\n    // Check S value negative or excessively padded\n    const sValueOffset = sMarkerOffset + 2;\n    if ((buf[sValueOffset] & 0x80) !== 0)\n        return false; // S value negative\n    if (sLen > 1 && buf[sValueOffset] === 0x00 && (buf[sValueOffset + 1] & 0x80) === 0)\n        return false; // S value excessively padded\n    if (rLen + sLen + 7 !== buf.length)\n        return false; // Final length check including hash type\n    return true;\n}\nfunction isOpcodeDisabledHelper(op) {\n    return (op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2MUL ||\n        op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2DIV ||\n        op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_VERIF ||\n        op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_VERNOTIF ||\n        op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_VER);\n}\nfunction isChunkMinimalPushHelper(chunk) {\n    const data = chunk.data;\n    const op = chunk.op;\n    if (!Array.isArray(data))\n        return true;\n    if (data.length === 0)\n        return op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_0;\n    if (data.length === 1 && data[0] >= 1 && data[0] <= 16)\n        return op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1 + (data[0] - 1);\n    if (data.length === 1 && data[0] === 0x81)\n        return op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1NEGATE;\n    if (data.length <= 75)\n        return op === data.length;\n    if (data.length <= 255)\n        return op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_PUSHDATA1;\n    if (data.length <= 65535)\n        return op === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_PUSHDATA2;\n    return true;\n}\n/**\n * The Spend class represents a spend action within a Bitcoin SV transaction.\n * It encapsulates all the necessary data required for spending a UTXO (Unspent Transaction Output)\n * and includes details about the source transaction, output, and the spending transaction itself.\n *\n * @property {string} sourceTXID - The transaction ID of the source UTXO.\n * @property {number} sourceOutputIndex - The index of the output in the source transaction.\n * @property {BigNumber} sourceSatoshis - The amount of satoshis in the source UTXO.\n * @property {LockingScript} lockingScript - The locking script associated with the UTXO.\n * @property {number} transactionVersion - The version of the current transaction.\n * @property {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} otherInputs -\n *           An array of other inputs in the transaction, each with a txid, outputIndex, and sequence number.\n * @property {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} outputs -\n *           An array of outputs of the current transaction, including the satoshi value and locking script for each.\n * @property {number} inputIndex - The index of this input in the current transaction.\n * @property {UnlockingScript} unlockingScript - The unlocking script that unlocks the UTXO for spending.\n * @property {number} inputSequence - The sequence number of this input.\n * @property {number} lockTime - The lock time of the transaction.\n */\nclass Spend {\n    sourceTXID;\n    sourceOutputIndex;\n    sourceSatoshis;\n    lockingScript;\n    transactionVersion;\n    otherInputs;\n    outputs;\n    inputIndex;\n    unlockingScript;\n    inputSequence;\n    lockTime;\n    context;\n    programCounter;\n    lastCodeSeparator;\n    stack;\n    altStack;\n    ifStack;\n    memoryLimit;\n    stackMem;\n    altStackMem;\n    /**\n     * @constructor\n     * Constructs the Spend object with necessary transaction details.\n     * @param {string} params.sourceTXID - The transaction ID of the source UTXO.\n     * @param {number} params.sourceOutputIndex - The index of the output in the source transaction.\n     * @param {BigNumber} params.sourceSatoshis - The amount of satoshis in the source UTXO.\n     * @param {LockingScript} params.lockingScript - The locking script associated with the UTXO.\n     * @param {number} params.transactionVersion - The version of the current transaction.\n     * @param {Array<{ sourceTXID: string, sourceOutputIndex: number, sequence: number }>} params.otherInputs -\n     *        An array of other inputs in the transaction.\n     * @param {Array<{ satoshis: BigNumber, lockingScript: LockingScript }>} params.outputs -\n     *        The outputs of the current transaction.\n     * @param {number} params.inputIndex - The index of this input in the current transaction.\n     * @param {UnlockingScript} params.unlockingScript - The unlocking script for this spend.\n     * @param {number} params.inputSequence - The sequence number of this input.\n     * @param {number} params.lockTime - The lock time of the transaction.\n     *\n     * @example\n     * const spend = new Spend({\n     *   sourceTXID: \"abcd1234\", // sourceTXID\n     *   sourceOutputIndex: 0, // sourceOutputIndex\n     *   sourceSatoshis: new BigNumber(1000), // sourceSatoshis\n     *   lockingScript: LockingScript.fromASM(\"OP_DUP OP_HASH160 abcd1234... OP_EQUALVERIFY OP_CHECKSIG\"),\n     *   transactionVersion: 1, // transactionVersion\n     *   otherInputs: [{ sourceTXID: \"abcd1234\", sourceOutputIndex: 1, sequence: 0xffffffff }], // otherInputs\n     *   outputs: [{ satoshis: new BigNumber(500), lockingScript: LockingScript.fromASM(\"OP_DUP...\") }], // outputs\n     *   inputIndex: 0, // inputIndex\n     *   unlockingScript: UnlockingScript.fromASM(\"3045... 02ab...\"),\n     *   inputSequence: 0xffffffff // inputSequence\n     *   memoryLimit: 100000 // memoryLimit\n     * });\n     */\n    constructor(params) {\n        this.sourceTXID = params.sourceTXID;\n        this.sourceOutputIndex = params.sourceOutputIndex;\n        this.sourceSatoshis = params.sourceSatoshis;\n        this.lockingScript = params.lockingScript;\n        this.transactionVersion = params.transactionVersion;\n        this.otherInputs = params.otherInputs;\n        this.outputs = params.outputs;\n        this.inputIndex = params.inputIndex;\n        this.unlockingScript = params.unlockingScript;\n        this.inputSequence = params.inputSequence;\n        this.lockTime = params.lockTime;\n        this.memoryLimit = params.memoryLimit ?? 32000000;\n        this.stack = [];\n        this.altStack = [];\n        this.ifStack = [];\n        this.stackMem = 0;\n        this.altStackMem = 0;\n        this.reset();\n    }\n    reset() {\n        this.context = 'UnlockingScript';\n        this.programCounter = 0;\n        this.lastCodeSeparator = null;\n        this.stack = [];\n        this.altStack = [];\n        this.ifStack = [];\n        this.stackMem = 0;\n        this.altStackMem = 0;\n    }\n    ensureStackMem(additional) {\n        if (this.stackMem + additional > this.memoryLimit) {\n            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n        }\n    }\n    ensureAltStackMem(additional) {\n        if (this.altStackMem + additional > this.memoryLimit) {\n            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n        }\n    }\n    pushStack(item) {\n        this.ensureStackMem(item.length);\n        this.stack.push(item);\n        this.stackMem += item.length;\n    }\n    pushStackCopy(item) {\n        this.ensureStackMem(item.length);\n        const copy = item.slice();\n        this.stack.push(copy);\n        this.stackMem += copy.length;\n    }\n    popStack() {\n        if (this.stack.length === 0) {\n            this.scriptEvaluationError('Attempted to pop from an empty stack.');\n        }\n        const item = this.stack.pop();\n        this.stackMem -= item.length;\n        return item;\n    }\n    stackTop(index = -1) {\n        // index = -1 for top, -2 for second top, etc.\n        // stack.length + index provides 0-based index from start\n        if (this.stack.length === 0 || this.stack.length < Math.abs(index) || (index >= 0 && index >= this.stack.length)) {\n            this.scriptEvaluationError(`Stack underflow accessing element at index ${index}. Stack length is ${this.stack.length}.`);\n        }\n        return this.stack[this.stack.length + index];\n    }\n    pushAltStack(item) {\n        this.ensureAltStackMem(item.length);\n        this.altStack.push(item);\n        this.altStackMem += item.length;\n    }\n    popAltStack() {\n        if (this.altStack.length === 0) {\n            this.scriptEvaluationError('Attempted to pop from an empty alt stack.');\n        }\n        const item = this.altStack.pop();\n        this.altStackMem -= item.length;\n        return item;\n    }\n    checkSignatureEncoding(buf) {\n        if (buf.length === 0)\n            return true;\n        if (!isChecksigFormatHelper(buf)) {\n            this.scriptEvaluationError('The signature format is invalid.'); // Generic message like original\n            return false;\n        }\n        try {\n            const sig = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromChecksigFormat(buf); // This can throw for stricter DER rules\n            if (requireLowSSignatures && !sig.hasLowS()) {\n                this.scriptEvaluationError('The signature must have a low S value.');\n                return false;\n            }\n            if ((sig.scope & _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].SIGHASH_FORKID) === 0) {\n                this.scriptEvaluationError('The signature must use SIGHASH_FORKID.');\n                return false;\n            }\n        }\n        catch (e) {\n            this.scriptEvaluationError('The signature format is invalid.');\n            return false;\n        }\n        return true;\n    }\n    checkPublicKeyEncoding(buf) {\n        if (buf.length === 0) {\n            this.scriptEvaluationError('Public key is empty.');\n            return false;\n        }\n        if (buf.length < 33) {\n            this.scriptEvaluationError('The public key is too short, it must be at least 33 bytes.');\n            return false;\n        }\n        if (buf[0] === 0x04) {\n            if (buf.length !== 65) {\n                this.scriptEvaluationError('The non-compressed public key must be 65 bytes.');\n                return false;\n            }\n        }\n        else if (buf[0] === 0x02 || buf[0] === 0x03) {\n            if (buf.length !== 33) {\n                this.scriptEvaluationError('The compressed public key must be 33 bytes.');\n                return false;\n            }\n        }\n        else {\n            this.scriptEvaluationError('The public key is in an unknown format.');\n            return false;\n        }\n        try {\n            _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromDER(buf); // This can throw for stricter DER rules\n        }\n        catch (e) {\n            this.scriptEvaluationError('The public key is in an unknown format.');\n            return false;\n        }\n        return true;\n    }\n    verifySignature(sig, pubkey, subscript) {\n        const preimage = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].format({\n            sourceTXID: this.sourceTXID,\n            sourceOutputIndex: this.sourceOutputIndex,\n            sourceSatoshis: this.sourceSatoshis,\n            transactionVersion: this.transactionVersion,\n            otherInputs: this.otherInputs,\n            outputs: this.outputs,\n            inputIndex: this.inputIndex,\n            subscript,\n            inputSequence: this.inputSequence,\n            lockTime: this.lockTime,\n            scope: sig.scope\n        });\n        const hash = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.hash256(preimage));\n        return (0,_primitives_ECDSA_js__WEBPACK_IMPORTED_MODULE_8__.verify)(hash, sig, pubkey);\n    }\n    step() {\n        if (this.stackMem > this.memoryLimit) {\n            this.scriptEvaluationError('Stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n            return false; // Error thrown\n        }\n        if (this.altStackMem > this.memoryLimit) {\n            this.scriptEvaluationError('Alt stack memory usage has exceeded ' + String(this.memoryLimit) + ' bytes');\n            return false; // Error thrown\n        }\n        if (this.context === 'UnlockingScript' &&\n            this.programCounter >= this.unlockingScript.chunks.length) {\n            this.context = 'LockingScript';\n            this.programCounter = 0;\n        }\n        const currentScript = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n        if (this.programCounter >= currentScript.chunks.length) {\n            return false;\n        }\n        const operation = currentScript.chunks[this.programCounter];\n        const currentOpcode = operation.op;\n        if (typeof currentOpcode === 'undefined') {\n            this.scriptEvaluationError(`Missing opcode in ${this.context} at pc=${this.programCounter}.`); // Error thrown\n        }\n        if (Array.isArray(operation.data) && operation.data.length > maxScriptElementSize) {\n            this.scriptEvaluationError(`Data push > ${maxScriptElementSize} bytes (pc=${this.programCounter}).`); // Error thrown\n        }\n        const isScriptExecuting = !this.ifStack.includes(false);\n        if (isScriptExecuting && isOpcodeDisabledHelper(currentOpcode)) {\n            this.scriptEvaluationError(`This opcode is currently disabled. (Opcode: ${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]}, PC: ${this.programCounter})`); // Error thrown\n        }\n        if (isScriptExecuting && currentOpcode >= 0 && currentOpcode <= _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_PUSHDATA4) {\n            if (requireMinimalPush && !isChunkMinimalPushHelper(operation)) {\n                this.scriptEvaluationError(`This data is not minimally-encoded. (PC: ${this.programCounter})`); // Error thrown\n            }\n            this.pushStack(Array.isArray(operation.data) ? operation.data : []);\n        }\n        else if (isScriptExecuting || (currentOpcode >= _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_IF && currentOpcode <= _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ENDIF)) {\n            let buf, buf1, buf2, buf3;\n            let x1, x2, x3;\n            let bn, bn1, bn2, bn3;\n            let n, size, fValue, fSuccess, subscript;\n            let bufSig, bufPubkey;\n            let sig, pubkey;\n            let i, ikey, isig, nKeysCount, nSigsCount, fOk;\n            switch (currentOpcode) {\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1NEGATE:\n                    this.pushStackCopy(SCRIPTNUM_NEG_1);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_0:\n                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[0]);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_3:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_4:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_5:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_6:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_7:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_8:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_9:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_10:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_11:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_12:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_13:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_14:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_15:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_16:\n                    n = currentOpcode - (_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1 - 1);\n                    this.pushStackCopy(SCRIPTNUMS_0_TO_16[n]);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP2: // Formerly CHECKLOCKTIMEVERIFY\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP3: // Formerly CHECKSEQUENCEVERIFY\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP1:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP4:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP5:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP6:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP7:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP8:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP9:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP10:\n                /* falls through */\n                // eslint-disable-next-line no-fallthrough\n                // eslint-disable-next-line no-fallthrough\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP11:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP12:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP13:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP14:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP15:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP16:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP17:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP18:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP19:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP20:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP21:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP22:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP23:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP24:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP25:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP26:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP27:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP28:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP29:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP30:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP31:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP32:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP33:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP34:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP35:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP36:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP37:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP38:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP39:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP40:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP41:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP42:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP43:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP44:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP45:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP46:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP47:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP48:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP49:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP50:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP51:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP52:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP53:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP54:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP55:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP56:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP57:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP58:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP59:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP60:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP61:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP62:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP63:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP64:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP65:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP66:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP67:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP68:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP69:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP70:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP71:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP72:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP73:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOP77:\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_IF:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOTIF:\n                    fValue = false;\n                    if (isScriptExecuting) {\n                        if (this.stack.length < 1)\n                            this.scriptEvaluationError('OP_IF and OP_NOTIF require at least one item on the stack when they are used!');\n                        buf = this.popStack();\n                        fValue = this.castToBool(buf);\n                        if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOTIF)\n                            fValue = !fValue;\n                    }\n                    this.ifStack.push(fValue);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ELSE:\n                    if (this.ifStack.length === 0)\n                        this.scriptEvaluationError('OP_ELSE requires a preceeding OP_IF.');\n                    this.ifStack[this.ifStack.length - 1] = !this.ifStack[this.ifStack.length - 1];\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ENDIF:\n                    if (this.ifStack.length === 0)\n                        this.scriptEvaluationError('OP_ENDIF requires a preceeding OP_IF.');\n                    this.ifStack.pop();\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_VERIFY:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_VERIFY requires at least one item to be on the stack.');\n                    buf1 = this.stackTop();\n                    fValue = this.castToBool(buf1);\n                    if (!fValue)\n                        this.scriptEvaluationError('OP_VERIFY requires the top stack value to be truthy.');\n                    this.popStack();\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_RETURN:\n                    if (this.context === 'UnlockingScript')\n                        this.programCounter = this.unlockingScript.chunks.length;\n                    else\n                        this.programCounter = this.lockingScript.chunks.length;\n                    this.ifStack = [];\n                    this.programCounter--; // To counteract the final increment and ensure loop termination\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_TOALTSTACK:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_TOALTSTACK requires at oeast one item to be on the stack.');\n                    this.pushAltStack(this.popStack());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_FROMALTSTACK:\n                    if (this.altStack.length < 1)\n                        this.scriptEvaluationError('OP_FROMALTSTACK requires at least one item to be on the stack.'); // \"stack\" here means altstack\n                    this.pushStack(this.popAltStack());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2DROP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_2DROP requires at least two items to be on the stack.');\n                    this.popStack();\n                    this.popStack();\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2DUP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_2DUP requires at least two items to be on the stack.');\n                    buf1 = this.stackTop(-2);\n                    buf2 = this.stackTop(-1);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_3DUP:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_3DUP requires at least three items to be on the stack.');\n                    buf1 = this.stackTop(-3);\n                    buf2 = this.stackTop(-2);\n                    buf3 = this.stackTop(-1);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    this.pushStackCopy(buf3);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2OVER:\n                    if (this.stack.length < 4)\n                        this.scriptEvaluationError('OP_2OVER requires at least four items to be on the stack.');\n                    buf1 = this.stackTop(-4);\n                    buf2 = this.stackTop(-3);\n                    this.pushStackCopy(buf1);\n                    this.pushStackCopy(buf2);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2ROT: {\n                    if (this.stack.length < 6)\n                        this.scriptEvaluationError('OP_2ROT requires at least six items to be on the stack.');\n                    const rot6 = this.popStack();\n                    const rot5 = this.popStack();\n                    const rot4 = this.popStack();\n                    const rot3 = this.popStack();\n                    const rot2 = this.popStack();\n                    const rot1 = this.popStack();\n                    this.pushStack(rot3);\n                    this.pushStack(rot4);\n                    this.pushStack(rot5);\n                    this.pushStack(rot6);\n                    this.pushStack(rot1);\n                    this.pushStack(rot2);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_2SWAP: {\n                    if (this.stack.length < 4)\n                        this.scriptEvaluationError('OP_2SWAP requires at least four items to be on the stack.');\n                    const swap4 = this.popStack();\n                    const swap3 = this.popStack();\n                    const swap2 = this.popStack();\n                    const swap1 = this.popStack();\n                    this.pushStack(swap3);\n                    this.pushStack(swap4);\n                    this.pushStack(swap1);\n                    this.pushStack(swap2);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_IFDUP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_IFDUP requires at least one item to be on the stack.');\n                    buf1 = this.stackTop();\n                    if (this.castToBool(buf1)) {\n                        this.pushStackCopy(buf1);\n                    }\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_DEPTH:\n                    this.pushStack(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.stack.length).toScriptNum());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_DROP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_DROP requires at least one item to be on the stack.');\n                    this.popStack();\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_DUP:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_DUP requires at least one item to be on the stack.');\n                    this.pushStackCopy(this.stackTop());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NIP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_NIP requires at least two items to be on the stack.');\n                    buf2 = this.popStack();\n                    this.popStack();\n                    this.pushStack(buf2);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_OVER:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_OVER requires at least two items to be on the stack.');\n                    this.pushStackCopy(this.stackTop(-2));\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_PICK:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ROLL: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items to be on the stack.`);\n                    bn = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush);\n                    n = bn.toNumber();\n                    if (n < 0 || n >= this.stack.length) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires the top stack element to be 0 or a positive number less than the current size of the stack.`);\n                    }\n                    const itemToMoveOrCopy = this.stack[this.stack.length - 1 - n];\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ROLL) {\n                        this.stack.splice(this.stack.length - 1 - n, 1);\n                        this.stackMem -= itemToMoveOrCopy.length;\n                        this.pushStack(itemToMoveOrCopy);\n                    }\n                    else { // OP_PICK\n                        this.pushStackCopy(itemToMoveOrCopy);\n                    }\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ROT:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_ROT requires at least three items to be on the stack.');\n                    x3 = this.popStack();\n                    x2 = this.popStack();\n                    x1 = this.popStack();\n                    this.pushStack(x2);\n                    this.pushStack(x3);\n                    this.pushStack(x1);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SWAP:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_SWAP requires at least two items to be on the stack.');\n                    x2 = this.popStack();\n                    x1 = this.popStack();\n                    this.pushStack(x2);\n                    this.pushStack(x1);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_TUCK:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_TUCK requires at least two items to be on the stack.');\n                    buf1 = this.stackTop(-1); // Top element (x2)\n                    // stack is [... rest, x1, x2]\n                    // We want [... rest, x2_copy, x1, x2]\n                    this.ensureStackMem(buf1.length);\n                    this.stack.splice(this.stack.length - 2, 0, buf1.slice()); // Insert copy of x2 before x1\n                    this.stackMem += buf1.length; // Account for the new copy\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SIZE:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_SIZE requires at least one item to be on the stack.');\n                    this.pushStack(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.stackTop().length).toScriptNum());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_AND:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_OR:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_XOR: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    if (buf1.length !== buf2.length)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires the top two stack items to be the same size.`);\n                    const resultBufBitwiseOp = new Array(buf1.length);\n                    for (let k = 0; k < buf1.length; k++) {\n                        if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_AND)\n                            resultBufBitwiseOp[k] = buf1[k] & buf2[k];\n                        else if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_OR)\n                            resultBufBitwiseOp[k] = buf1[k] | buf2[k];\n                        else\n                            resultBufBitwiseOp[k] = buf1[k] ^ buf2[k];\n                    }\n                    this.pushStack(resultBufBitwiseOp);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_INVERT: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_INVERT requires at least one item to be on the stack.');\n                    buf = this.popStack();\n                    const invertedBufOp = new Array(buf.length);\n                    for (let k = 0; k < buf.length; k++) {\n                        invertedBufOp[k] = (~buf[k]) & 0xff;\n                    }\n                    this.pushStack(invertedBufOp);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LSHIFT:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_RSHIFT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items to be on the stack.`);\n                    bn2 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush); // n (shift amount)\n                    buf1 = this.popStack(); // value to shift\n                    n = bn2.toNumber();\n                    if (n < 0)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires the top item on the stack not to be negative.`);\n                    if (buf1.length === 0) {\n                        this.pushStack([]);\n                        break;\n                    }\n                    bn1 = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](buf1);\n                    let shiftedBn;\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LSHIFT)\n                        shiftedBn = bn1.ushln(n);\n                    else\n                        shiftedBn = bn1.ushrn(n);\n                    const shiftedArr = shiftedBn.toArray('le', buf1.length);\n                    this.pushStack(shiftedArr);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_EQUAL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_EQUALVERIFY:\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items to be on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    fValue = compareNumberArrays(buf1, buf2);\n                    this.pushStack(fValue ? [1] : []);\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_EQUALVERIFY) {\n                        if (!fValue)\n                            this.scriptEvaluationError('OP_EQUALVERIFY requires the top two stack items to be equal.');\n                        this.popStack();\n                    }\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1ADD:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1SUB:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NEGATE:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ABS:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOT:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_0NOTEQUAL:\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least one item to be on the stack.`);\n                    bn = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush);\n                    switch (currentOpcode) {\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1ADD:\n                            bn = bn.add(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1));\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_1SUB:\n                            bn = bn.sub(new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](1));\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NEGATE:\n                            bn = bn.neg();\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ABS:\n                            if (bn.isNeg())\n                                bn = bn.neg();\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NOT:\n                            bn = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn.cmpn(0) === 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_0NOTEQUAL:\n                            bn = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn.cmpn(0) !== 0 ? 1 : 0);\n                            break;\n                    }\n                    this.pushStack(bn.toScriptNum());\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ADD:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SUB:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MUL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_DIV:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MOD:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_BOOLAND:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_BOOLOR:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMEQUAL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMEQUALVERIFY:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMNOTEQUAL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LESSTHAN:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_GREATERTHAN:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LESSTHANOREQUAL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_GREATERTHANOREQUAL:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MIN:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MAX: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items to be on the stack.`);\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    bn2 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(buf2, requireMinimalPush);\n                    bn1 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(buf1, requireMinimalPush);\n                    let predictedLen = 0;\n                    switch (currentOpcode) {\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MUL:\n                            predictedLen = bn1.byteLength() + bn2.byteLength();\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ADD:\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SUB:\n                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength()) + 1;\n                            break;\n                        default:\n                            predictedLen = Math.max(bn1.byteLength(), bn2.byteLength());\n                    }\n                    this.ensureStackMem(predictedLen);\n                    let resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](0);\n                    switch (currentOpcode) {\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_ADD:\n                            resultBnArithmetic = bn1.add(bn2);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SUB:\n                            resultBnArithmetic = bn1.sub(bn2);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MUL:\n                            resultBnArithmetic = bn1.mul(bn2);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_DIV:\n                            if (bn2.cmpn(0) === 0)\n                                this.scriptEvaluationError('OP_DIV cannot divide by zero!');\n                            resultBnArithmetic = bn1.div(bn2);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MOD:\n                            if (bn2.cmpn(0) === 0)\n                                this.scriptEvaluationError('OP_MOD cannot divide by zero!');\n                            resultBnArithmetic = bn1.mod(bn2);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_BOOLAND:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]((bn1.cmpn(0) !== 0 && bn2.cmpn(0) !== 0) ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_BOOLOR:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]((bn1.cmpn(0) !== 0 || bn2.cmpn(0) !== 0) ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMEQUAL:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) === 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMEQUALVERIFY:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) === 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMNOTEQUAL:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) !== 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LESSTHAN:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) < 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_GREATERTHAN:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) > 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_LESSTHANOREQUAL:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) <= 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_GREATERTHANOREQUAL:\n                            resultBnArithmetic = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](bn1.cmp(bn2) >= 0 ? 1 : 0);\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MIN:\n                            resultBnArithmetic = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n                            break;\n                        case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_MAX:\n                            resultBnArithmetic = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n                            break;\n                    }\n                    this.pushStack(resultBnArithmetic.toScriptNum());\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUMEQUALVERIFY) {\n                        if (!this.castToBool(this.stackTop()))\n                            this.scriptEvaluationError('OP_NUMEQUALVERIFY requires the top stack item to be truthy.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_WITHIN:\n                    if (this.stack.length < 3)\n                        this.scriptEvaluationError('OP_WITHIN requires at least three items to be on the stack.');\n                    bn3 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush); // max\n                    bn2 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush); // min\n                    bn1 = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush); // x\n                    fValue = bn1.cmp(bn2) >= 0 && bn1.cmp(bn3) < 0;\n                    this.pushStack(fValue ? [1] : []);\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_RIPEMD160:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SHA1:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SHA256:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_HASH160:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_HASH256: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least one item to be on the stack.`);\n                    buf = this.popStack();\n                    let hashResult = []; // Initialize to empty, to satisfy TS compiler\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_RIPEMD160)\n                        hashResult = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.ripemd160(buf);\n                    else if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SHA1)\n                        hashResult = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.sha1(buf);\n                    else if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SHA256)\n                        hashResult = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.sha256(buf);\n                    else if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_HASH160)\n                        hashResult = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.hash160(buf);\n                    else if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_HASH256)\n                        hashResult = _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.hash256(buf);\n                    this.pushStack(hashResult);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CODESEPARATOR:\n                    this.lastCodeSeparator = this.programCounter;\n                    break;\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKSIG:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKSIGVERIFY: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least two items to be on the stack.`);\n                    bufPubkey = this.popStack();\n                    bufSig = this.popStack();\n                    if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {\n                        // Error already thrown by helpers\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires correct encoding for the public key and signature.`); // Fallback, should be unreachable\n                    }\n                    const scriptForChecksig = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n                    const scriptCodeChunks = scriptForChecksig.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);\n                    subscript = new _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](scriptCodeChunks);\n                    subscript.findAndDelete(new _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().writeBin(bufSig));\n                    fSuccess = false;\n                    if (bufSig.length > 0) {\n                        try {\n                            sig = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromChecksigFormat(bufSig);\n                            pubkey = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromDER(bufPubkey);\n                            fSuccess = this.verifySignature(sig, pubkey, subscript);\n                        }\n                        catch (e) {\n                            fSuccess = false;\n                        }\n                    }\n                    this.pushStack(fSuccess ? [1] : []);\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKSIGVERIFY) {\n                        if (!fSuccess)\n                            this.scriptEvaluationError('OP_CHECKSIGVERIFY requires that a valid signature is provided.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKMULTISIG:\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKMULTISIGVERIFY: {\n                    i = 1;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires at least 1 item for nKeys.`);\n                    }\n                    nKeysCount = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();\n                    if (nKeysCount < 0 || nKeysCount > maxMultisigKeyCount) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires a key count between 0 and ${maxMultisigKeyCount}.`);\n                    }\n                    ikey = ++i;\n                    i += nKeysCount;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} stack too small for nKeys and keys. Need ${i}, have ${this.stack.length}.`);\n                    }\n                    nSigsCount = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.stackTop(-i), requireMinimalPush).toNumber();\n                    if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires the number of signatures to be no greater than the number of keys.`);\n                    }\n                    isig = ++i;\n                    i += nSigsCount;\n                    if (this.stack.length < i) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} stack too small for N, keys, M, sigs, and dummy. Need ${i}, have ${this.stack.length}.`);\n                    }\n                    const baseScriptCMS = this.context === 'UnlockingScript' ? this.unlockingScript : this.lockingScript;\n                    const subscriptChunksCMS = baseScriptCMS.chunks.slice(this.lastCodeSeparator === null ? 0 : this.lastCodeSeparator + 1);\n                    subscript = new _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](subscriptChunksCMS);\n                    for (let k = 0; k < nSigsCount; k++) {\n                        bufSig = this.stackTop(-isig - k); // Sigs are closer to top than keys\n                        subscript.findAndDelete(new _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]().writeBin(bufSig));\n                    }\n                    fSuccess = true;\n                    while (fSuccess && nSigsCount > 0) {\n                        if (nKeysCount === 0) { // No more keys to check against but still sigs left\n                            fSuccess = false;\n                            break;\n                        }\n                        bufSig = this.stackTop(-isig);\n                        bufPubkey = this.stackTop(-ikey);\n                        if (!this.checkSignatureEncoding(bufSig) || !this.checkPublicKeyEncoding(bufPubkey)) {\n                            this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires correct encoding for the public key and signature.`);\n                        }\n                        fOk = false;\n                        if (bufSig.length > 0) {\n                            try {\n                                sig = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fromChecksigFormat(bufSig);\n                                pubkey = _primitives_PublicKey_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fromDER(bufPubkey);\n                                fOk = this.verifySignature(sig, pubkey, subscript);\n                            }\n                            catch (e) {\n                                fOk = false;\n                            }\n                        }\n                        if (fOk) {\n                            isig++;\n                            nSigsCount--;\n                        }\n                        ikey++;\n                        nKeysCount--;\n                        if (nSigsCount > nKeysCount) {\n                            fSuccess = false;\n                        }\n                    }\n                    // Correct total items consumed by op (N_val, keys, M_val, sigs, dummy)\n                    const itemsConsumedByOp = 1 + // N_val\n                        _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.stackTop(-1), false).toNumber() + // keys\n                        1 + // M_val\n                        _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.stackTop(-(1 + _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.stackTop(-1), false).toNumber() + 1)), false).toNumber() + // sigs\n                        1; // dummy\n                    let popCount = itemsConsumedByOp - 1; // Pop all except dummy\n                    while (popCount > 0) {\n                        this.popStack();\n                        popCount--;\n                    }\n                    // Check and pop dummy\n                    if (this.stack.length < 1) {\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires an extra item (dummy) to be on the stack.`);\n                    }\n                    const dummyBuf = this.popStack();\n                    if (dummyBuf.length > 0) { // SCRIPT_VERIFY_NULLDUMMY\n                        this.scriptEvaluationError(`${_OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"][currentOpcode]} requires the extra stack item (dummy) to be empty.`);\n                    }\n                    this.pushStack(fSuccess ? [1] : []);\n                    if (currentOpcode === _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CHECKMULTISIGVERIFY) {\n                        if (!fSuccess)\n                            this.scriptEvaluationError('OP_CHECKMULTISIGVERIFY requires that a sufficient number of valid signatures are provided.');\n                        this.popStack();\n                    }\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_CAT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_CAT requires at least two items to be on the stack.');\n                    buf2 = this.popStack();\n                    buf1 = this.popStack();\n                    const catResult = (buf1).concat(buf2);\n                    if (catResult.length > maxScriptElementSize)\n                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes.`);\n                    this.pushStack(catResult);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_SPLIT: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_SPLIT requires at least two items to be on the stack.');\n                    const posBuf = this.popStack();\n                    const dataToSplit = this.popStack();\n                    n = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(posBuf, requireMinimalPush).toNumber();\n                    if (n < 0 || n > dataToSplit.length) {\n                        this.scriptEvaluationError('OP_SPLIT requires the first stack item to be a non-negative number less than or equal to the size of the second-from-top stack item.');\n                    }\n                    this.pushStack(dataToSplit.slice(0, n));\n                    this.pushStack(dataToSplit.slice(n));\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_NUM2BIN: {\n                    if (this.stack.length < 2)\n                        this.scriptEvaluationError('OP_NUM2BIN requires at least two items to be on the stack.');\n                    size = _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromScriptNum(this.popStack(), requireMinimalPush).toNumber();\n                    if (size > maxScriptElementSize || size < 0) { // size can be 0\n                        this.scriptEvaluationError(`It's not currently possible to push data larger than ${maxScriptElementSize} bytes or negative size.`);\n                    }\n                    let rawnum = this.popStack(); // This is the number to convert\n                    rawnum = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.minimallyEncode)(rawnum); // Get its minimal scriptnum form\n                    if (rawnum.length > size) {\n                        this.scriptEvaluationError('OP_NUM2BIN requires that the size expressed in the top stack item is large enough to hold the value expressed in the second-from-top stack item.');\n                    }\n                    if (rawnum.length === size) {\n                        this.pushStack(rawnum);\n                        break;\n                    }\n                    const resultN2B = new Array(size).fill(0x00);\n                    let signbit = 0x00;\n                    if (rawnum.length > 0) {\n                        signbit = rawnum[rawnum.length - 1] & 0x80; // Store sign bit\n                        rawnum[rawnum.length - 1] &= 0x7f; // Remove sign bit for padding\n                    }\n                    // Copy rawnum (now positive magnitude) into the result\n                    for (let k = 0; k < rawnum.length; k++) {\n                        resultN2B[k] = rawnum[k];\n                    }\n                    // If the original number was negative, the sign bit must be set on the new MSB\n                    if (signbit !== 0) {\n                        resultN2B[size - 1] |= 0x80;\n                    }\n                    this.pushStack(resultN2B);\n                    break;\n                }\n                case _OP_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].OP_BIN2NUM: {\n                    if (this.stack.length < 1)\n                        this.scriptEvaluationError('OP_BIN2NUM requires at least one item to be on the stack.');\n                    buf1 = this.popStack();\n                    const b2nResult = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_3__.minimallyEncode)(buf1);\n                    if (!isMinimallyEncodedHelper(b2nResult)) {\n                        this.scriptEvaluationError('OP_BIN2NUM requires that the resulting number is valid.');\n                    }\n                    this.pushStack(b2nResult);\n                    break;\n                }\n                default:\n                    this.scriptEvaluationError(`Invalid opcode ${currentOpcode} (pc=${this.programCounter}).`);\n            }\n        }\n        this.programCounter++;\n        return true;\n    }\n    /**\n     * @method validate\n     * Validates the spend action by interpreting the locking and unlocking scripts.\n     * @returns {boolean} Returns true if the scripts are valid and the spend is legitimate, otherwise false.\n     * @example\n     * if (spend.validate()) {\n     *   console.log(\"Spend is valid!\");\n     * } else {\n     *   console.log(\"Invalid spend!\");\n     * }\n     */\n    validate() {\n        if (requirePushOnlyUnlockingScripts && !this.unlockingScript.isPushOnly()) {\n            this.scriptEvaluationError('Unlocking scripts can only contain push operations, and no other opcodes.');\n        }\n        while (this.step()) {\n            if (this.context === 'LockingScript' &&\n                this.programCounter >= this.lockingScript.chunks.length) {\n                break;\n            }\n        }\n        if (this.ifStack.length > 0) {\n            this.scriptEvaluationError('Every OP_IF, OP_NOTIF, or OP_ELSE must be terminated with OP_ENDIF prior to the end of the script.');\n        }\n        if (requireCleanStack) {\n            if (this.stack.length !== 1) {\n                this.scriptEvaluationError(`The clean stack rule requires exactly one item to be on the stack after script execution, found ${this.stack.length}.`);\n            }\n        }\n        if (this.stack.length === 0) {\n            this.scriptEvaluationError('The top stack element must be truthy after script evaluation (stack is empty).');\n        }\n        else if (!this.castToBool(this.stackTop())) {\n            this.scriptEvaluationError('The top stack element must be truthy after script evaluation.');\n        }\n        return true;\n    }\n    castToBool(val) {\n        if (val.length === 0)\n            return false;\n        for (let i = 0; i < val.length; i++) {\n            if (val[i] !== 0) {\n                return !(i === val.length - 1 && val[i] === 0x80);\n            }\n        }\n        return false;\n    }\n    scriptEvaluationError(str) {\n        throw new _ScriptEvaluationError_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]({\n            message: str,\n            txid: this.sourceTXID,\n            outputIndex: this.sourceOutputIndex,\n            context: this.context,\n            programCounter: this.programCounter,\n            stackState: this.stack,\n            altStackState: this.altStack,\n            ifStackState: this.ifStack,\n            stackMem: this.stackMem,\n            altStackMem: this.altStackMem\n        });\n    }\n}\n//# sourceMappingURL=Spend.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/Spend.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UnlockingScript)\n/* harmony export */ });\n/* harmony import */ var _Script_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Script.js\");\n\n/**\n * The UnlockingScript class represents an unlocking script in a Bitcoin SV transaction.\n * It extends the Script class and is used specifically for input scripts that unlock funds.\n *\n * Inherits all properties and methods from the Script class.\n *\n * @extends {Script}\n * @see {@link Script} for more information on Script.\n */\nclass UnlockingScript extends _Script_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    /**\n     * @method isLockingScript\n     * Determines if the script is a locking script.\n     * @returns {boolean} Always returns false for an UnlockingScript instance.\n     */\n    isLockingScript() {\n        return false;\n    }\n    /**\n     * @method isUnlockingScript\n     * Determines if the script is an unlocking script.\n     * @returns {boolean} Always returns true for an UnlockingScript instance.\n     */\n    isUnlockingScript() {\n        return true;\n    }\n}\n//# sourceMappingURL=UnlockingScript.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LockingScript: () => (/* reexport safe */ _LockingScript_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   OP: () => (/* reexport safe */ _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   P2PKH: () => (/* reexport safe */ _templates_index_js__WEBPACK_IMPORTED_MODULE_6__.P2PKH),\n/* harmony export */   PushDrop: () => (/* reexport safe */ _templates_index_js__WEBPACK_IMPORTED_MODULE_6__.PushDrop),\n/* harmony export */   RPuzzle: () => (/* reexport safe */ _templates_index_js__WEBPACK_IMPORTED_MODULE_6__.RPuzzle),\n/* harmony export */   Script: () => (/* reexport safe */ _Script_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   ScriptEvaluationError: () => (/* reexport safe */ _ScriptEvaluationError_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   Spend: () => (/* reexport safe */ _Spend_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   UnlockingScript: () => (/* reexport safe */ _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _OP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OP.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/OP.js\");\n/* harmony import */ var _Script_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Script.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Script.js\");\n/* harmony import */ var _LockingScript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js\");\n/* harmony import */ var _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js\");\n/* harmony import */ var _Spend_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Spend.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Spend.js\");\n/* harmony import */ var _ScriptEvaluationError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ScriptEvaluationError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/ScriptEvaluationError.js\");\n/* harmony import */ var _templates_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./templates/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/index.js\");\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ P2PKH)\n/* harmony export */ });\n/* harmony import */ var _OP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OP.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/OP.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _LockingScript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../LockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js\");\n/* harmony import */ var _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js\");\n/* harmony import */ var _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n\n\n\n\n\n\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('must have value');\n    return v;\n}\n/**\n * P2PKH (Pay To Public Key Hash) class implementing ScriptTemplate.\n *\n * This class provides methods to create Pay To Public Key Hash locking and unlocking scripts, including the unlocking of P2PKH UTXOs with the private key.\n */\nclass P2PKH {\n    /**\n     * Creates a P2PKH locking script for a given public key hash or address string\n     *\n     * @param {number[] | string} pubkeyhash or address - An array or address representing the public key hash.\n     * @returns {LockingScript} - A P2PKH locking script.\n     */\n    lock(pubkeyhash) {\n        let data;\n        if (typeof pubkeyhash === 'string') {\n            const hash = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.fromBase58Check)(pubkeyhash);\n            if (hash.prefix[0] !== 0x00 && hash.prefix[0] !== 0x6f) {\n                throw new Error('only P2PKH is supported');\n            }\n            data = hash.data;\n        }\n        else {\n            data = pubkeyhash;\n        }\n        if (data.length !== 20) {\n            throw new Error('P2PKH hash length must be 20 bytes');\n        }\n        return new _LockingScript_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_DUP },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_HASH160 },\n            { op: data.length, data },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_EQUALVERIFY },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_CHECKSIG }\n        ]);\n    }\n    /**\n     * Creates a function that generates a P2PKH unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for a P2PKH locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {PrivateKey} privateKey - The private key used for signing the transaction.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @param {number} sourceSatoshis - Optional. The amount being unlocked. Otherwise the input.sourceTransaction is required.\n     * @param {Script} lockingScript - Optional. The lockinScript. Otherwise the input.sourceTransaction is required.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(privateKey, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');\n                if (sourceTXID == null || sourceTXID === undefined) {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                if (sourceTXID === '') {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                sourceSatoshis ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n                if (sourceSatoshis == null || sourceSatoshis === undefined) {\n                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');\n                }\n                lockingScript ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        .lockingScript;\n                if (lockingScript == null) {\n                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');\n                }\n                const preimage = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].format({\n                    sourceTXID,\n                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: verifyTruthy(input.sequence),\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const rawSignature = privateKey.sign((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.sha256)(preimage));\n                const sig = new _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rawSignature.r, rawSignature.s, signatureScope);\n                const sigForScript = sig.toChecksigFormat();\n                const pubkeyForScript = privateKey\n                    .toPublicKey()\n                    .encode(true);\n                return new _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]([\n                    { op: sigForScript.length, data: sigForScript },\n                    { op: pubkeyForScript.length, data: pubkeyForScript }\n                ]);\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 108;\n            }\n        };\n    }\n}\n//# sourceMappingURL=P2PKH.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PushDrop)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/index.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('must have value');\n    return v;\n}\n/**\n * For a given piece of data to push onto the stack in script, creates the correct minimally-encoded script chunk,\n * including the correct push operation.\n *\n * TODO: This should be made into a TS-SDK util (distinct from the `minimallyEncode` util)\n */\nconst createMinimallyEncodedScriptChunk = (data) => {\n    if (data.length === 0) {\n        // Could have used OP_0.\n        return { op: 0 };\n    }\n    if (data.length === 1 && data[0] === 0) {\n        // Could have used OP_0.\n        return { op: 0 };\n    }\n    if (data.length === 1 && data[0] > 0 && data[0] <= 16) {\n        // Could have used OP_0 .. OP_16.\n        return { op: 0x50 + data[0] };\n    }\n    if (data.length === 1 && data[0] === 0x81) {\n        // Could have used OP_1NEGATE.\n        return { op: 0x4f };\n    }\n    if (data.length <= 75) {\n        // Could have used a direct push (opcode indicating number of bytes\n        // pushed + those bytes).\n        return { op: data.length, data };\n    }\n    if (data.length <= 255) {\n        // Could have used OP_PUSHDATA.\n        return { op: 0x4c, data };\n    }\n    if (data.length <= 65535) {\n        // Could have used OP_PUSHDATA2.\n        return { op: 0x4d, data };\n    }\n    return { op: 0x4e, data };\n};\nclass PushDrop {\n    wallet;\n    originator;\n    /**\n     * Decodes a PushDrop script back into its token fields and the locking public key. If a signature was present, it will be the last field returned.\n     * Warning: Only works with a P2PK lock at the beginning of the script.\n     * @param script PushDrop script to decode back into token fields\n     * @returns An object containing PushDrop token fields and the locking public key. If a signature was included, it will be the last field.\n     */\n    static decode(script) {\n        const lockingPublicKey = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromString(_primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toHex(verifyTruthy(script.chunks[0].data)) //  Ensure not undefined\n        );\n        const fields = [];\n        for (let i = 2; i < script.chunks.length; i++) {\n            const nextOpcode = script.chunks[i + 1]?.op; //  Prevent accessing `op` from `undefined`\n            let chunk = script.chunks[i].data ?? []; //  Ensure `chunk` is always `number[]`\n            if (chunk.length === 0) {\n                //  Only modify `chunk` if it was empty\n                if (script.chunks[i].op >= 80 && script.chunks[i].op <= 95) {\n                    chunk = [script.chunks[i].op - 80];\n                }\n                else if (script.chunks[i].op === 0) {\n                    chunk = [0];\n                }\n                else if (script.chunks[i].op === 0x4f) {\n                    chunk = [0x81];\n                }\n            }\n            fields.push(chunk);\n            // If the next value is DROP or 2DROP then this is the final field\n            if (nextOpcode === _index_js__WEBPACK_IMPORTED_MODULE_0__.OP.OP_DROP || nextOpcode === _index_js__WEBPACK_IMPORTED_MODULE_0__.OP.OP_2DROP) {\n                break;\n            }\n        }\n        return {\n            fields,\n            lockingPublicKey\n        };\n    }\n    /**\n     * Constructs a new instance of the PushDrop class.\n     *\n     * @param {WalletInterface} wallet - The wallet interface used for creating signatures and accessing public keys.\n     * @param {string} originator  The originator to use with Wallet requests\n     */\n    constructor(wallet, originator) {\n        this.wallet = wallet;\n        this.originator = originator;\n    }\n    /**\n     * Creates a PushDrop locking script with arbitrary data fields and a public key lock.\n     *\n     * @param {number[][]} fields - The token fields to include in the locking script.\n     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.\n     * @param {string} keyID - The key ID to use.\n     * @param {string} counterparty - The counterparty involved in the transaction, \"self\" or \"anyone\".\n     * @param {boolean} [forSelf=false] - Flag indicating if the lock is for the creator (default no).\n     * @param {boolean} [includeSignature=true] - Flag indicating if a signature should be included in the script (default yes).\n     * @returns {Promise<LockingScript>} The generated PushDrop locking script.\n     */\n    async lock(fields, protocolID, keyID, counterparty, forSelf = false, includeSignature = true, lockPosition = 'before') {\n        const { publicKey } = await this.wallet.getPublicKey({\n            protocolID,\n            keyID,\n            counterparty,\n            forSelf\n        }, this.originator);\n        const lockChunks = [];\n        const pushDropChunks = [];\n        lockChunks.push({\n            op: publicKey.length / 2,\n            data: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Utils.toArray(publicKey, 'hex')\n        });\n        lockChunks.push({ op: _index_js__WEBPACK_IMPORTED_MODULE_0__.OP.OP_CHECKSIG });\n        if (includeSignature) {\n            const dataToSign = fields.reduce((a, e) => [...a, ...e], []);\n            const { signature } = await this.wallet.createSignature({\n                data: dataToSign,\n                protocolID,\n                keyID,\n                counterparty\n            }, this.originator);\n            fields.push(signature);\n        }\n        for (const field of fields) {\n            pushDropChunks.push(createMinimallyEncodedScriptChunk(field));\n        }\n        let notYetDropped = fields.length;\n        while (notYetDropped > 1) {\n            pushDropChunks.push({ op: _index_js__WEBPACK_IMPORTED_MODULE_0__.OP.OP_2DROP });\n            notYetDropped -= 2;\n        }\n        if (notYetDropped !== 0) {\n            pushDropChunks.push({ op: _index_js__WEBPACK_IMPORTED_MODULE_0__.OP.OP_DROP });\n        }\n        if (lockPosition === 'before') {\n            return new _index_js__WEBPACK_IMPORTED_MODULE_0__.LockingScript([...lockChunks, ...pushDropChunks]);\n        }\n        else {\n            return new _index_js__WEBPACK_IMPORTED_MODULE_0__.LockingScript([...pushDropChunks, ...lockChunks]);\n        }\n    }\n    /**\n     * Creates an unlocking script for spending a PushDrop token output.\n     *\n     * @param {[SecurityLevel, string]} protocolID - The protocol ID to use.\n     * @param {string} keyID - The key ID to use.\n     * @param {string} counterparty - The counterparty involved in the transaction, \"self\" or \"anyone\".\n     * @param {string} [sourceTXID] - The TXID of the source transaction.\n     * @param {number} [sourceSatoshis] - The number of satoshis in the source output.\n     * @param {LockingScript} [lockingScript] - The locking script of the source output.\n     * @param {'all' | 'none' | 'single'} [signOutputs='all'] - Specifies which outputs to sign.\n     * @param {boolean} [anyoneCanPay=false] - Specifies if the anyone-can-pay flag is set.\n     * @returns {Object} An object containing functions to sign the transaction and estimate the script length.\n     */\n    unlock(protocolID, keyID, counterparty, signOutputs = 'all', anyoneCanPay = false, sourceSatoshis, lockingScript) {\n        return {\n            sign: async (tx, inputIndex) => {\n                let signatureScope = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.SIGHASH_ANYONECANPAY;\n                }\n                const input = tx.inputs[inputIndex];\n                const otherInputs = tx.inputs.filter((_, index) => index !== inputIndex);\n                const sourceTXID = input.sourceTXID ?? input.sourceTransaction?.id('hex');\n                if (sourceTXID == null || sourceTXID === undefined) {\n                    throw new Error('The input sourceTXID or sourceTransaction is required for transaction signing.');\n                }\n                sourceSatoshis ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex].satoshis;\n                if (sourceSatoshis == null || sourceSatoshis === undefined) {\n                    throw new Error('The sourceSatoshis or input sourceTransaction is required for transaction signing.');\n                }\n                lockingScript ||=\n                    input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        .lockingScript;\n                if (lockingScript == null) {\n                    throw new Error('The lockingScript or input sourceTransaction is required for transaction signing.');\n                }\n                const preimage = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature.format({\n                    sourceTXID,\n                    sourceOutputIndex: verifyTruthy(input.sourceOutputIndex),\n                    sourceSatoshis,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence ?? 0xffffffff,\n                    subscript: lockingScript,\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const preimageHash = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Hash.sha256(preimage);\n                const { signature: bareSignature } = await this.wallet.createSignature({\n                    data: preimageHash,\n                    protocolID,\n                    keyID,\n                    counterparty\n                }, this.originator);\n                const signature = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.fromDER([...bareSignature]);\n                const txSignature = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.TransactionSignature(signature.r, signature.s, signatureScope);\n                const sigForScript = txSignature.toChecksigFormat();\n                return new _index_js__WEBPACK_IMPORTED_MODULE_0__.UnlockingScript([\n                    { op: sigForScript.length, data: sigForScript }\n                ]);\n            },\n            estimateLength: async () => 73\n        };\n    }\n}\n//# sourceMappingURL=PushDrop.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/templates/RPuzzle.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/templates/RPuzzle.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RPuzzle)\n/* harmony export */ });\n/* harmony import */ var _OP_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../OP.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/OP.js\");\n/* harmony import */ var _LockingScript_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../LockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js\");\n/* harmony import */ var _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js\");\n/* harmony import */ var _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../primitives/PrivateKey.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/PrivateKey.js\");\n/* harmony import */ var _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../primitives/TransactionSignature.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/TransactionSignature.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _Script_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Script.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Script.js\");\n\n\n\n\n\n\n\n/**\n * RPuzzle class implementing ScriptTemplate.\n *\n * This class provides methods to create R Puzzle and R Puzzle Hash locking and unlocking scripts, including the unlocking of UTXOs with the correct K value.\n */\nclass RPuzzle {\n    type = 'raw';\n    /**\n     * @constructor\n     * Constructs an R Puzzle template instance for a given puzzle type\n     *\n     * @param {'raw'|'SHA1'|'SHA256'|'HASH256'|'RIPEMD160'|'HASH160'} type Denotes the type of puzzle to create\n     */\n    constructor(type = 'raw') {\n        this.type = type;\n    }\n    /**\n     * Creates an R puzzle locking script for a given R value or R value hash.\n     *\n     * @param {number[]} value - An array representing the R value or its hash.\n     * @returns {LockingScript} - An R puzzle locking script.\n     */\n    lock(value) {\n        const chunks = [\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_OVER },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_3 },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_SPLIT },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_NIP },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_1 },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_SPLIT },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_SWAP },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_SPLIT },\n            { op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_DROP }\n        ];\n        if (this.type !== 'raw') {\n            chunks.push({\n                op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]['OP_' + this.type]\n            });\n        }\n        chunks.push({ op: value.length, data: value });\n        chunks.push({ op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_EQUALVERIFY });\n        chunks.push({ op: _OP_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].OP_CHECKSIG });\n        return new _LockingScript_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](chunks);\n    }\n    /**\n     * Creates a function that generates an R puzzle unlocking script along with its signature and length estimation.\n     *\n     * The returned object contains:\n     * 1. `sign` - A function that, when invoked with a transaction and an input index,\n     *    produces an unlocking script suitable for an R puzzle locked output.\n     * 2. `estimateLength` - A function that returns the estimated length of the unlocking script in bytes.\n     *\n     * @param {BigNumber} k  The K-value used to unlock the R-puzzle.\n     * @param {PrivateKey} privateKey - The private key used for signing the transaction. If not provided, a random key will be generated.\n     * @param {'all'|'none'|'single'} signOutputs - The signature scope for outputs.\n     * @param {boolean} anyoneCanPay - Flag indicating if the signature allows for other inputs to be added later.\n     * @returns {Object} - An object containing the `sign` and `estimateLength` functions.\n     */\n    unlock(k, privateKey, signOutputs = 'all', anyoneCanPay = false) {\n        return {\n            sign: async (tx, inputIndex) => {\n                if (typeof privateKey === 'undefined') {\n                    privateKey = _primitives_PrivateKey_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromRandom();\n                }\n                let signatureScope = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_FORKID;\n                if (signOutputs === 'all') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_ALL;\n                }\n                if (signOutputs === 'none') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_NONE;\n                }\n                if (signOutputs === 'single') {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_SINGLE;\n                }\n                if (anyoneCanPay) {\n                    signatureScope |= _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SIGHASH_ANYONECANPAY;\n                }\n                const otherInputs = [...tx.inputs];\n                const [input] = otherInputs.splice(inputIndex, 1);\n                if (typeof input.sourceTransaction !== 'object') {\n                    throw new Error('The source transaction is needed for transaction signing.');\n                }\n                const preimage = _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].format({\n                    sourceTXID: input.sourceTransaction?.id('hex') ?? '',\n                    sourceOutputIndex: input.sourceOutputIndex ?? 0,\n                    sourceSatoshis: input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        ?.satoshis ?? 0,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    inputIndex,\n                    outputs: tx.outputs,\n                    inputSequence: input.sequence ?? 0xffffffff,\n                    subscript: input.sourceTransaction?.outputs[input.sourceOutputIndex]\n                        ?.lockingScript ?? new _Script_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](),\n                    lockTime: tx.lockTime,\n                    scope: signatureScope\n                });\n                const rawSignature = privateKey.sign((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_5__.sha256)(preimage), undefined, true, k);\n                const sig = new _primitives_TransactionSignature_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](rawSignature.r, rawSignature.s, signatureScope);\n                const sigForScript = sig.toChecksigFormat();\n                const pubkeyForScript = privateKey\n                    .toPublicKey()\n                    .encode(true);\n                return new _UnlockingScript_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]([\n                    { op: sigForScript.length, data: sigForScript },\n                    { op: pubkeyForScript.length, data: pubkeyForScript }\n                ]);\n            },\n            estimateLength: async () => {\n                // public key (1+33) + signature (1+73)\n                // Note: We add 1 to each element's length because of the associated OP_PUSH\n                return 108;\n            }\n        };\n    }\n}\n//# sourceMappingURL=RPuzzle.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/templates/RPuzzle.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/script/templates/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/script/templates/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   P2PKH: () => (/* reexport safe */ _P2PKH_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   PushDrop: () => (/* reexport safe */ _PushDrop_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   RPuzzle: () => (/* reexport safe */ _RPuzzle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _P2PKH_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./P2PKH.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js\");\n/* harmony import */ var _RPuzzle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RPuzzle.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/RPuzzle.js\");\n/* harmony import */ var _PushDrop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PushDrop.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/script/templates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/storage/StorageDownloader.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/storage/StorageDownloader.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageDownloader: () => (/* binding */ StorageDownloader)\n/* harmony export */ });\n/* harmony import */ var _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../overlay-tools/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/overlay-tools/index.js\");\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/index.js\");\n/* harmony import */ var _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../script/templates/PushDrop.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/PushDrop.js\");\n/* harmony import */ var _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/Transaction.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n\n\n\n\nclass StorageDownloader {\n    networkPreset = 'mainnet';\n    constructor(config) {\n        this.networkPreset = config?.networkPreset;\n    }\n    /**\n     * Resolves the UHRP URL to a list of HTTP URLs where content can be downloaded.\n     * @param uhrpUrl The UHRP URL to resolve.\n     * @returns A promise that resolves to an array of HTTP URLs.\n     */\n    async resolve(uhrpUrl) {\n        // Use UHRP lookup service\n        const lookupResolver = new _overlay_tools_index_js__WEBPACK_IMPORTED_MODULE_0__.LookupResolver({ networkPreset: this.networkPreset });\n        const response = await lookupResolver.query({ service: 'ls_uhrp', query: { uhrpUrl } });\n        if (response.type !== 'output-list') {\n            throw new Error('Lookup answer must be an output list');\n        }\n        const decodedResults = [];\n        const currentTime = Math.floor(Date.now() / 1000);\n        for (let i = 0; i < response.outputs.length; i++) {\n            const tx = _transaction_Transaction_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fromBEEF(response.outputs[i].beef);\n            const { fields } = _script_templates_PushDrop_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].decode(tx.outputs[response.outputs[i].outputIndex].lockingScript);\n            const expiryTime = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_4__.Utils.Reader(fields[3]).readVarIntNum();\n            if (expiryTime < currentTime) {\n                continue;\n            }\n            decodedResults.push(_primitives_index_js__WEBPACK_IMPORTED_MODULE_4__.Utils.toUTF8(fields[2]));\n        }\n        return decodedResults;\n    }\n    /**\n     * Downloads the content from the UHRP URL after validating the hash for integrity.\n     * @param uhrpUrl The UHRP URL to download.\n     * @returns A promise that resolves to the downloaded content.\n     */\n    async download(uhrpUrl) {\n        if (!_index_js__WEBPACK_IMPORTED_MODULE_1__.StorageUtils.isValidURL(uhrpUrl)) {\n            throw new Error('Invalid parameter UHRP url');\n        }\n        const hash = _index_js__WEBPACK_IMPORTED_MODULE_1__.StorageUtils.getHashFromURL(uhrpUrl);\n        const downloadURLs = await this.resolve(uhrpUrl);\n        if (!Array.isArray(downloadURLs) || downloadURLs.length === 0) {\n            throw new Error('No one currently hosts this file!');\n        }\n        for (let i = 0; i < downloadURLs.length; i++) {\n            try {\n                // The url is fetched\n                const result = await fetch(downloadURLs[i], { method: 'GET' });\n                // If the request fails, continue to the next url\n                if (!result.ok || result.status >= 400) {\n                    continue;\n                }\n                const body = await result.arrayBuffer();\n                // The body is loaded into a number array\n                const content = [...new Uint8Array(body)];\n                const contentHash = _primitives_index_js__WEBPACK_IMPORTED_MODULE_4__.Hash.sha256(content);\n                for (let i = 0; i < contentHash.length; ++i) {\n                    if (contentHash[i] !== hash[i]) {\n                        throw new Error('Value of content does not match hash of the url given');\n                    }\n                }\n                return {\n                    data: content,\n                    mimeType: result.headers.get('Content-Type')\n                };\n            }\n            catch (error) {\n                continue;\n            }\n        }\n        throw new Error(`Unable to download content from ${uhrpUrl}`);\n    }\n}\n//# sourceMappingURL=StorageDownloader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/storage/StorageDownloader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUploader.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUploader.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageUploader: () => (/* binding */ StorageUploader)\n/* harmony export */ });\n/* harmony import */ var _auth_clients_AuthFetch_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../auth/clients/AuthFetch.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/clients/AuthFetch.js\");\n/* harmony import */ var _StorageUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StorageUtils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUtils.js\");\n\n\n/**\n * The StorageUploader class provides client-side methods for:\n * - Uploading files with a specified retention period\n * - Finding file metadata by UHRP URL\n * - Listing all user uploads\n * - Renewing an existing advertisement's expiry time\n */\nclass StorageUploader {\n    authFetch;\n    baseURL;\n    /**\n     * Creates a new StorageUploader instance.\n     * @param {UploaderConfig} config - An object containing the storage server's URL and a wallet interface\n     */\n    constructor(config) {\n        this.baseURL = config.storageURL;\n        this.authFetch = new _auth_clients_AuthFetch_js__WEBPACK_IMPORTED_MODULE_0__.AuthFetch(config.wallet);\n    }\n    /**\n     * Requests information from the server to upload a file (including presigned URL and headers).\n     * @private\n     * @param {number} fileSize - The size of the file, in bytes\n     * @param {number} retentionPeriod - The desired hosting time, in minutes\n     * @returns {Promise<{ uploadURL: string; requiredHeaders: Record<string, string>; amount?: number }>}\n     * @throws {Error} If the server returns a non-OK response or an error status\n     */\n    async getUploadInfo(fileSize, retentionPeriod) {\n        const url = `${this.baseURL}/upload`;\n        const body = { fileSize, retentionPeriod };\n        const response = await this.authFetch.fetch(url, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body)\n        });\n        if (!response.ok) {\n            throw new Error(`Upload info request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            throw new Error('Upload route returned an error.');\n        }\n        return {\n            uploadURL: data.uploadURL,\n            requiredHeaders: data.requiredHeaders,\n            amount: data.amount\n        };\n    }\n    /**\n     * Performs the actual file upload (HTTP PUT) to the presigned URL returned by the server.\n     * @private\n     * @param {string} uploadURL - The presigned URL where the file is to be uploaded\n     * @param {UploadableFile} file - The file to upload, including its raw data and MIME type\n     * @param {Record<string, string>} requiredHeaders - Additional headers required by the server (e.g. content-length)\n     * @returns {Promise<UploadFileResult>} An object indicating whether publishing was successful and the resulting UHRP URL\n     * @throws {Error} If the server returns a non-OK response\n     */\n    async uploadFile(uploadURL, file, requiredHeaders) {\n        const body = Uint8Array.from(file.data);\n        const response = await fetch(uploadURL, {\n            method: 'PUT',\n            body,\n            headers: {\n                'Content-Type': file.type,\n                ...requiredHeaders\n            }\n        });\n        if (!response.ok) {\n            throw new Error(`File upload failed: HTTP ${response.status}`);\n        }\n        const uhrpURL = await _StorageUtils_js__WEBPACK_IMPORTED_MODULE_1__.getURLForFile(file.data);\n        return {\n            published: true,\n            uhrpURL\n        };\n    }\n    /**\n     * Publishes a file to the storage server with the specified retention period.\n     *\n     * This will:\n     * 1. Request an upload URL from the server.\n     * 2. Perform an HTTP PUT to upload the files raw bytes.\n     * 3. Return a UHRP URL referencing the file once published.\n     *\n     * @param {Object} params\n     * @param {UploadableFile} params.file - The file data + type\n     * @param {number} params.retentionPeriod - Number of minutes to host the file\n     * @returns {Promise<UploadFileResult>} An object with the file's UHRP URL\n     * @throws {Error} If the server or upload step returns a non-OK response\n     */\n    async publishFile(params) {\n        const { file, retentionPeriod } = params;\n        const fileSize = file.data.length;\n        const { uploadURL, requiredHeaders } = await this.getUploadInfo(fileSize, retentionPeriod);\n        return await this.uploadFile(uploadURL, file, requiredHeaders);\n    }\n    /**\n     * Retrieves metadata for a file matching the given UHRP URL from the `/find` route.\n     * @param {string} uhrpUrl - The UHRP URL, e.g. \"uhrp://abcd...\"\n     * @returns {Promise<FindFileData>} An object with file name, size, MIME type, and expiry time\n     * @throws {Error} If the server or the route returns an error\n     */\n    async findFile(uhrpUrl) {\n        const url = new URL(`${this.baseURL}/find`);\n        url.searchParams.set('uhrpUrl', uhrpUrl);\n        const response = await this.authFetch.fetch(url.toString(), {\n            method: 'GET'\n        });\n        if (!response.ok) {\n            throw new Error(`findFile request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`findFile returned an error: ${errCode} - ${errDesc}`);\n        }\n        return data.data;\n    }\n    /**\n     * Lists all advertisements belonging to the user from the `/list` route.\n     * @returns {Promise<any>} The array of uploads returned by the server\n     * @throws {Error} If the server or the route returns an error\n     */\n    async listUploads() {\n        const url = `${this.baseURL}/list`;\n        const response = await this.authFetch.fetch(url, {\n            method: 'GET'\n        });\n        if (!response.ok) {\n            throw new Error(`listUploads request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`listUploads returned an error: ${errCode} - ${errDesc}`);\n        }\n        return data.uploads;\n    }\n    /**\n     * Renews the hosting time for an existing file advertisement identified by uhrpUrl.\n     * Calls the `/renew` route to add `additionalMinutes` to the GCS customTime\n     * and re-mint the advertisement token on-chain.\n     *\n     * @param {string} uhrpUrl - The UHRP URL of the file (e.g., \"uhrp://abcd1234...\")\n     * @param {number} additionalMinutes - The number of minutes to extend\n     * @returns {Promise<RenewFileResult>} An object with the new and previous expiry times, plus any cost\n     * @throws {Error} If the request fails or the server returns an error\n     */\n    async renewFile(uhrpUrl, additionalMinutes) {\n        const url = `${this.baseURL}/renew`;\n        const body = { uhrpUrl, additionalMinutes };\n        const response = await this.authFetch.fetch(url, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify(body)\n        });\n        if (!response.ok) {\n            throw new Error(`renewFile request failed: HTTP ${response.status}`);\n        }\n        const data = await response.json();\n        if (data.status === 'error') {\n            const errCode = data.code ?? 'unknown-code';\n            const errDesc = data.description ?? 'no-description';\n            throw new Error(`renewFile returned an error: ${errCode} - ${errDesc}`);\n        }\n        return {\n            status: data.status,\n            prevExpiryTime: data.prevExpiryTime,\n            newExpiryTime: data.newExpiryTime,\n            amount: data.amount\n        };\n    }\n}\n//# sourceMappingURL=StorageUploader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUploader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUtils.js":
/*!********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUtils.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getHashFromURL: () => (/* binding */ getHashFromURL),\n/* harmony export */   getURLForFile: () => (/* binding */ getURLForFile),\n/* harmony export */   getURLForHash: () => (/* binding */ getURLForHash),\n/* harmony export */   isValidURL: () => (/* binding */ isValidURL),\n/* harmony export */   normalizeURL: () => (/* binding */ normalizeURL)\n/* harmony export */ });\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n/**\n * Takes a UHRP URL and removes any prefixes.\n * @param {string} URL - The UHRP URL.\n * @returns {string} - Normalized URL.\n */\nconst normalizeURL = (URL) => {\n    if (URL.toLowerCase().startsWith('uhrp:'))\n        URL = URL.slice(5);\n    if (URL.startsWith('//'))\n        URL = URL.slice(2);\n    return URL;\n};\n/**\n * Generates a UHRP URL from a given SHA-256 hash.\n * @param {number[]} hash - 32-byte SHA-256 hash.\n * @returns {string} - Base58Check encoded URL.\n */\nconst getURLForHash = (hash) => {\n    if (hash.length !== 32) {\n        throw new Error('Hash length must be 32 bytes (sha256)');\n    }\n    return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase58Check)(hash, (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)('ce00', 'hex'));\n};\n/**\n * Generates a UHRP URL for a given file.\n * @param {number[] | string} file - File content as number array or string.\n * @returns {string} - Base58Check encoded URL.\n */\nconst getURLForFile = (file) => {\n    const hash = (0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__.sha256)(file);\n    return getURLForHash(hash);\n};\n/**\n * Extracts the hash from a UHRP URL.\n * @param {string} URL - UHRP URL.\n * @returns {number[]} - Extracted SHA-256 hash.\n */\nconst getHashFromURL = (URL) => {\n    URL = normalizeURL(URL);\n    const { data, prefix } = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.fromBase58Check)(URL, undefined, 2);\n    if (data.length !== 32) {\n        throw new Error('Invalid length!');\n    }\n    if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(prefix) !== 'ce00') {\n        throw new Error('Bad prefix');\n    }\n    return data;\n};\n/**\n * Checks if a URL is a valid UHRP URL.\n * @param {string} URL - The URL to validate.\n * @returns {boolean} - True if valid, false otherwise.\n */\nconst isValidURL = (URL) => {\n    try {\n        getHashFromURL(URL);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\n//# sourceMappingURL=StorageUtils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUtils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/storage/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/storage/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StorageDownloader: () => (/* reexport safe */ _StorageDownloader_js__WEBPACK_IMPORTED_MODULE_2__.StorageDownloader),\n/* harmony export */   StorageUploader: () => (/* reexport safe */ _StorageUploader_js__WEBPACK_IMPORTED_MODULE_1__.StorageUploader),\n/* harmony export */   StorageUtils: () => (/* reexport module object */ _StorageUtils_js__WEBPACK_IMPORTED_MODULE_0__)\n/* harmony export */ });\n/* harmony import */ var _StorageUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StorageUtils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUtils.js\");\n/* harmony import */ var _StorageUploader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./StorageUploader.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/StorageUploader.js\");\n/* harmony import */ var _StorageDownloader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StorageDownloader.js */ \"./node_modules/@bsv/sdk/dist/esm/src/storage/StorageDownloader.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/storage/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/totp/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/totp/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TOTP: () => (/* reexport safe */ _totp_js__WEBPACK_IMPORTED_MODULE_0__.TOTP)\n/* harmony export */ });\n/* harmony import */ var _totp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./totp.js */ \"./node_modules/@bsv/sdk/dist/esm/src/totp/totp.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/totp/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/totp/totp.js":
/*!*********************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/totp/totp.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TOTP: () => (/* binding */ TOTP)\n/* harmony export */ });\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/BigNumber.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/BigNumber.js\");\n\n\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass TOTP {\n    /**\n     * Generates a Time-based One-Time Password (TOTP).\n     * @param {number[]} secret - The secret key for TOTP.\n     * @param {TOTPOptions} options - Optional parameters for TOTP.\n     * @returns {string} The generated TOTP.\n     */\n    static generate(secret, options) {\n        const _options = this.withDefaultOptions(options);\n        const counter = this.getCounter(_options.timestamp, _options.period);\n        const otp = generateHOTP(secret, counter, _options);\n        return otp;\n    }\n    /**\n     * Validates a Time-based One-Time Password (TOTP).\n     * @param {number[]} secret - The secret key for TOTP.\n     * @param {string} passcode - The passcode to validate.\n     * @param {TOTPValidateOptions} options - Optional parameters for TOTP validation.\n     * @returns {boolean} A boolean indicating whether the passcode is valid.\n     */\n    static validate(secret, passcode, options) {\n        const _options = this.withDefaultValidateOptions(options);\n        passcode = passcode.trim();\n        if (passcode.length !== _options.digits) {\n            return false;\n        }\n        const counter = this.getCounter(_options.timestamp, _options.period);\n        const counters = [counter];\n        for (let i = 1; i <= _options.skew; i++) {\n            counters.push(counter + i);\n            counters.push(counter - i);\n        }\n        for (const c of counters) {\n            if (passcode === generateHOTP(secret, c, _options)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static getCounter(timestamp, period) {\n        const epochSeconds = Math.floor(timestamp / 1000);\n        const counter = Math.floor(epochSeconds / period);\n        return counter;\n    }\n    static withDefaultOptions(options) {\n        return {\n            digits: 2,\n            algorithm: 'SHA-1',\n            period: 30,\n            timestamp: Date.now(),\n            ...options\n        };\n    }\n    static withDefaultValidateOptions(options) {\n        return { skew: 1, ...this.withDefaultOptions(options) };\n    }\n}\nfunction generateHOTP(secret, counter, options) {\n    const timePad = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](counter).toArray('be', 8);\n    const hmac = calcHMAC(secret, timePad, options.algorithm);\n    const signature = hmac.digest();\n    // RFC 4226 https://datatracker.ietf.org/doc/html/rfc4226#section-5.4\n    const offset = signature[signature.length - 1] & 0x0f; // offset is the last byte in the hmac\n    const fourBytesRange = signature.slice(offset, offset + 4); // starting from offset, get 4 bytes\n    const mask = 0x7fffffff; // 32-bit number with a leading 0 followed by 31 ones [0111 (...) 1111]\n    const masked = new _primitives_BigNumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](fourBytesRange).toNumber() & mask;\n    const otp = masked.toString().slice(-options.digits);\n    return otp;\n}\nfunction calcHMAC(secret, timePad, algorithm) {\n    switch (algorithm) {\n        case 'SHA-1':\n            return new _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__.SHA1HMAC(secret).update(timePad);\n        case 'SHA-256':\n            return new _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__.SHA256HMAC(secret).update(timePad);\n        case 'SHA-512':\n            return new _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__.SHA512HMAC(secret).update(timePad);\n        default:\n            throw new Error('unsupported HMAC algorithm');\n    }\n}\n//# sourceMappingURL=totp.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/totp/totp.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js":
/*!****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATOMIC_BEEF: () => (/* binding */ ATOMIC_BEEF),\n/* harmony export */   BEEF_V1: () => (/* binding */ BEEF_V1),\n/* harmony export */   BEEF_V2: () => (/* binding */ BEEF_V2),\n/* harmony export */   Beef: () => (/* binding */ Beef),\n/* harmony export */   TX_DATA_FORMAT: () => (/* binding */ TX_DATA_FORMAT)\n/* harmony export */ });\n/* harmony import */ var _MerklePath_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MerklePath.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js\");\n/* harmony import */ var _BeefTx_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BeefTx.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefTx.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n\n\n\n\nfunction verifyTruthy(v) {\n    if (v == null)\n        throw new Error('Expected a valid value, but got undefined.');\n    return v;\n}\nconst BEEF_V1 = 4022206465; // 0100BEEF in LE order\nconst BEEF_V2 = 4022206466; // 0200BEEF in LE order\nconst ATOMIC_BEEF = 0x01010101; // 01010101\nvar TX_DATA_FORMAT;\n(function (TX_DATA_FORMAT) {\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"RAWTX\"] = 0] = \"RAWTX\";\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"RAWTX_AND_BUMP_INDEX\"] = 1] = \"RAWTX_AND_BUMP_INDEX\";\n    TX_DATA_FORMAT[TX_DATA_FORMAT[\"TXID_ONLY\"] = 2] = \"TXID_ONLY\";\n})(TX_DATA_FORMAT || (TX_DATA_FORMAT = {}));\n/*\n * BEEF standard: BRC-62: Background Evaluation Extended Format (BEEF) Transactions\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0062.md\n *\n * BUMP standard: BRC-74: BSV Unified Merkle Path (BUMP) Format\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0074.md\n *\n * BRC-95: Atomic BEEF Transactions\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0095.md\n *\n * The Atomic BEEF format is supported by the binary deserialization static method `fromBinary`.\n *\n * BRC-96: BEEF V2, Txid Only Extension\n * https://github.com/bsv-blockchain/BRCs/blob/master/transactions/0096.md\n *\n * A valid serialized BEEF is the cornerstone of Simplified Payment Validation (SPV)\n * where they are exchanged between two non-trusting parties to establish the\n * validity of a newly constructed bitcoin transaction and its inputs from prior\n * transactions.\n *\n * A `Beef` is fundamentally an list of `BUMP`s and a list of transactions.\n *\n * A `BUMP` is a partial merkle tree for a 'mined' bitcoin block.\n * It can therefore be used to prove the validity of transaction data\n * for each transaction txid whose merkle path is included in the tree.\n *\n * To be valid, the list of transactions must be sorted in dependency order:\n * oldest transaction first;\n * and each transaction must either\n * have a merkle path in one of the BUMPs, or\n * have all of its input transactions included in the list of transactions.\n *\n * The `Beef` class supports the construction of valid BEEFs by allowing BUMPs\n * (merkle paths) and transactions to be merged sequentially.\n *\n * The `Beef` class also extends the standard by supporting 'known' transactions.\n * A 'known' transaction is represented solely by its txid.\n * To become valid, all the 'known' transactions in a `Beef` must be replaced by full\n * transactions and merkle paths, if they are mined.\n *\n * The purpose of supporting 'known' transactions is that one or both parties\n * generating and exchanging BEEFs often possess partial knowledge of valid transactions\n * due to their history.\n *\n * A valid `Beef` is only required when sent to a party with no shared history,\n * such as a transaction processor.\n *\n * IMPORTANT NOTE:\n * It is fundamental to the BEEF value proposition that only valid transactions and valid\n * merkle path (BUMP) data be added to it. Merging invalid data breaks the `verify` and `isValid`\n * functions. There is no support for removing invalid data. A `Beef` that becomes invalid\n * must be discarded.\n */\nclass Beef {\n    bumps = [];\n    txs = [];\n    version = BEEF_V2;\n    atomicTxid = undefined;\n    constructor(version = BEEF_V2) {\n        this.version = version;\n    }\n    /**\n     * @param txid of `beefTx` to find\n     * @returns `BeefTx` in `txs` with `txid`.\n     */\n    findTxid(txid) {\n        return this.txs.find((tx) => tx.txid === txid);\n    }\n    /**\n     * Replaces `BeefTx` for this txid with txidOnly.\n     *\n     * Replacement is done so that a `clone()` can be\n     * updated by this method without affecting the\n     * original.\n     *\n     * @param txid\n     * @returns undefined if txid is unknown.\n     */\n    makeTxidOnly(txid) {\n        const i = this.txs.findIndex((tx) => tx.txid === txid);\n        if (i === -1)\n            return undefined;\n        let btx = this.txs[i];\n        if (btx.isTxidOnly) {\n            return btx;\n        }\n        this.txs.splice(i, 1);\n        btx = this.mergeTxidOnly(txid);\n        return btx;\n    }\n    /**\n     * @returns `MerklePath` with level zero hash equal to txid or undefined.\n     */\n    findBump(txid) {\n        return this.bumps.find((b) => b.path[0].some((leaf) => leaf.hash === txid) //  Ensure boolean return with `.some()`\n        );\n    }\n    /**\n     * Finds a Transaction in this `Beef`\n     * and adds any missing input SourceTransactions from this `Beef`.\n     *\n     * The result is suitable for signing.\n     *\n     * @param txid The id of the target transaction.\n     * @returns Transaction with all available input `SourceTransaction`s from this Beef.\n     */\n    findTransactionForSigning(txid) {\n        const beefTx = this.findTxid(txid);\n        if ((beefTx == null) || (beefTx.tx == null))\n            return undefined; // Ensure beefTx.tx exists before using it\n        for (const i of beefTx.tx.inputs) {\n            if (i.sourceTransaction == null) {\n                const itx = this.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid\n                if (itx != null) {\n                    i.sourceTransaction = itx.tx;\n                }\n            }\n        }\n        return beefTx.tx;\n    }\n    /**\n     * Builds the proof tree rooted at a specific `Transaction`.\n     *\n     * To succeed, the Beef must contain all the required transaction and merkle path data.\n     *\n     * @param txid The id of the target transaction.\n     * @returns Transaction with input `SourceTransaction` and `MerklePath` populated from this Beef.\n     */\n    findAtomicTransaction(txid) {\n        const beefTx = this.findTxid(txid);\n        if ((beefTx == null) || (beefTx.tx == null))\n            return undefined; // Ensure beefTx.tx exists before using it\n        const addInputProof = (beef, tx) => {\n            const mp = beef.findBump(tx.id('hex'));\n            if (mp != null) {\n                tx.merklePath = mp;\n            }\n            else {\n                for (const i of tx.inputs) {\n                    if (i.sourceTransaction == null) {\n                        const itx = beef.findTxid(verifyTruthy(i.sourceTXID)); // Ensure sourceTXID is valid\n                        if (itx != null) {\n                            i.sourceTransaction = itx.tx;\n                        }\n                    }\n                    if (i.sourceTransaction != null) {\n                        const mp = beef.findBump(i.sourceTransaction.id('hex'));\n                        if (mp != null) {\n                            i.sourceTransaction.merklePath = mp;\n                        }\n                        else {\n                            addInputProof(beef, i.sourceTransaction);\n                        }\n                    }\n                }\n            }\n        };\n        addInputProof(this, beefTx.tx); // Safe because we checked that beefTx.tx exists\n        return beefTx.tx;\n    }\n    /**\n     * Merge a MerklePath that is assumed to be fully valid.\n     * @param bump\n     * @returns index of merged bump\n     */\n    mergeBump(bump) {\n        let bumpIndex;\n        // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.\n        for (let i = 0; i < this.bumps.length; i++) {\n            const b = this.bumps[i];\n            if (b === bump) {\n                // Literally the same\n                return i;\n            }\n            if (b.blockHeight === bump.blockHeight) {\n                // Probably the same...\n                const rootA = b.computeRoot();\n                const rootB = bump.computeRoot();\n                if (rootA === rootB) {\n                    // Definitely the same... combine them to save space\n                    b.combine(bump);\n                    bumpIndex = i;\n                    break;\n                }\n            }\n        }\n        // if the proof is not yet added, add a new path.\n        if (bumpIndex === undefined) {\n            bumpIndex = this.bumps.length;\n            this.bumps.push(bump);\n        }\n        // Review if any transactions are proven by this bump\n        const b = this.bumps[bumpIndex];\n        for (const tx of this.txs) {\n            const txid = tx.txid;\n            if (tx.bumpIndex == null) { //  Explicitly check for null or undefined\n                for (const n of b.path[0]) {\n                    if (n.hash === txid) {\n                        tx.bumpIndex = bumpIndex;\n                        n.txid = true;\n                        break;\n                    }\n                }\n            }\n        }\n        return bumpIndex;\n    }\n    /**\n     * Merge a serialized transaction.\n     *\n     * Checks that a transaction with the same txid hasn't already been merged.\n     *\n     * Replaces existing transaction with same txid.\n     *\n     * @param rawTx\n     * @param bumpIndex Optional. If a number, must be valid index into bumps array.\n     * @returns txid of rawTx\n     */\n    mergeRawTx(rawTx, bumpIndex) {\n        const newTx = new _BeefTx_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](rawTx, bumpIndex);\n        this.removeExistingTxid(newTx.txid);\n        this.txs.push(newTx);\n        this.tryToValidateBumpIndex(newTx);\n        return newTx;\n    }\n    /**\n     * Merge a `Transaction` and any referenced `merklePath` and `sourceTransaction`, recursifely.\n     *\n     * Replaces existing transaction with same txid.\n     *\n     * Attempts to match an existing bump to the new transaction.\n     *\n     * @param tx\n     * @returns txid of tx\n     */\n    mergeTransaction(tx) {\n        const txid = tx.id('hex');\n        this.removeExistingTxid(txid);\n        let bumpIndex;\n        if (tx.merklePath != null) {\n            bumpIndex = this.mergeBump(tx.merklePath);\n        }\n        const newTx = new _BeefTx_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](tx, bumpIndex);\n        this.txs.push(newTx);\n        this.tryToValidateBumpIndex(newTx);\n        bumpIndex = newTx.bumpIndex;\n        if (bumpIndex === undefined) {\n            for (const input of tx.inputs) {\n                if (input.sourceTransaction != null) {\n                    this.mergeTransaction(input.sourceTransaction);\n                }\n            }\n        }\n        return newTx;\n    }\n    /**\n     * Removes an existing transaction from the BEEF, given its TXID\n     * @param txid TXID of the transaction to remove\n     */\n    removeExistingTxid(txid) {\n        const existingTxIndex = this.txs.findIndex((t) => t.txid === txid);\n        if (existingTxIndex >= 0) {\n            this.txs.splice(existingTxIndex, 1);\n        }\n    }\n    mergeTxidOnly(txid) {\n        let tx = this.txs.find((t) => t.txid === txid);\n        if (tx == null) {\n            tx = new _BeefTx_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](txid);\n            this.txs.push(tx);\n            this.tryToValidateBumpIndex(tx);\n        }\n        return tx;\n    }\n    mergeBeefTx(btx) {\n        let beefTx = this.findTxid(btx.txid);\n        if (btx.isTxidOnly && (beefTx == null)) {\n            beefTx = this.mergeTxidOnly(btx.txid);\n        }\n        else if ((btx._tx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {\n            beefTx = this.mergeTransaction(btx._tx);\n        }\n        else if ((btx._rawTx != null) && ((beefTx == null) || beefTx.isTxidOnly)) {\n            beefTx = this.mergeRawTx(btx._rawTx);\n        }\n        if (beefTx == null) {\n            throw new Error(`Failed to merge BeefTx for txid: ${btx.txid}`);\n        }\n        return beefTx;\n    }\n    mergeBeef(beef) {\n        const b = Array.isArray(beef) ? Beef.fromBinary(beef) : beef;\n        for (const bump of b.bumps) {\n            this.mergeBump(bump);\n        }\n        for (const tx of b.txs) {\n            this.mergeBeefTx(tx);\n        }\n    }\n    /**\n     * Sorts `txs` and checks structural validity of beef.\n     *\n     * Does NOT verify merkle roots.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param allowTxidOnly optional. If true, transaction txid only is assumed valid\n     */\n    isValid(allowTxidOnly) {\n        return this.verifyValid(allowTxidOnly).valid;\n    }\n    /**\n     * Sorts `txs` and confirms validity of transaction data contained in beef\n     * by validating structure of this beef and confirming computed merkle roots\n     * using `chainTracker`.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param chainTracker Used to verify computed merkle path roots for all bump txids.\n     * @param allowTxidOnly optional. If true, transaction txid is assumed valid\n     */\n    async verify(chainTracker, allowTxidOnly) {\n        const r = this.verifyValid(allowTxidOnly);\n        if (!r.valid)\n            return false;\n        for (const height of Object.keys(r.roots)) {\n            const isValid = await chainTracker.isValidRootForHeight(r.roots[height], Number(height));\n            if (!isValid) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Sorts `txs` and confirms validity of transaction data contained in beef\n     * by validating structure of this beef.\n     *\n     * Returns block heights and merkle root values to be confirmed by a chaintracker.\n     *\n     * Validity requirements:\n     * 1. No 'known' txids, unless `allowTxidOnly` is true.\n     * 2. All transactions have bumps or their inputs chain back to bumps (or are known).\n     * 3. Order of transactions satisfies dependencies before dependents.\n     * 4. No transactions with duplicate txids.\n     *\n     * @param allowTxidOnly optional. If true, transaction txid is assumed valid\n     * @returns {{valid: boolean, roots: Record<number, string>}}\n     * `valid` is true iff this Beef is structuraly valid.\n     * `roots` is a record where keys are block heights and values are the corresponding merkle roots to be validated.\n     */\n    verifyValid(allowTxidOnly) {\n        const r = {\n            valid: false,\n            roots: {}\n        };\n        const sr = this.sortTxs();\n        if (sr.missingInputs.length > 0 ||\n            sr.notValid.length > 0 ||\n            (sr.txidOnly.length > 0 && allowTxidOnly !== true) ||\n            sr.withMissingInputs.length > 0) {\n            return r;\n        }\n        // valid txids: only txids if allowed, bump txids, then txids with input's in txids\n        const txids = {};\n        for (const tx of this.txs) {\n            if (tx.isTxidOnly) {\n                if (allowTxidOnly !== true)\n                    return r; //  Explicit check for `true`\n                txids[tx.txid] = true;\n            }\n        }\n        const confirmComputedRoot = (b, txid) => {\n            const root = b.computeRoot(txid);\n            if (r.roots[b.blockHeight] === undefined || r.roots[b.blockHeight] === '') {\n                // accept the root as valid for this block and reuse for subsequent txids\n                r.roots[b.blockHeight] = root;\n            }\n            if (r.roots[b.blockHeight] !== root) {\n                return false;\n            }\n            return true;\n        };\n        for (const b of this.bumps) {\n            for (const n of b.path[0]) {\n                if (n.txid === true && typeof n.hash === 'string' && n.hash.length > 0) {\n                    txids[n.hash] = true;\n                    // All txid hashes in all bumps must agree on computed merkle path roots\n                    if (!confirmComputedRoot(b, n.hash)) {\n                        return r;\n                    }\n                }\n            }\n        }\n        // All txs with a bumpIndex have matching txid leaf at level zero of BUMP.\n        for (const t of this.txs) {\n            if (t.bumpIndex !== undefined) {\n                const leaf = this.bumps[t.bumpIndex].path[0].find(l => l.hash === t.txid);\n                if (leaf == null) {\n                    return r;\n                }\n            }\n        }\n        for (const t of this.txs) {\n            // all input txids must be included before they are referenced\n            for (const i of t.inputTxids) {\n                if (!txids[i])\n                    return r;\n            }\n            txids[t.txid] = true;\n        }\n        r.valid = true;\n        return r;\n    }\n    /**\n     * Serializes this data to `writer`\n     * @param writer\n     */\n    toWriter(writer) {\n        writer.writeUInt32LE(this.version);\n        writer.writeVarIntNum(this.bumps.length);\n        for (const b of this.bumps) {\n            writer.write(b.toBinary());\n        }\n        writer.writeVarIntNum(this.txs.length);\n        for (const tx of this.txs) {\n            tx.toWriter(writer, this.version);\n        }\n    }\n    /**\n     * Returns a binary array representing the serialized BEEF\n     * @returns A binary array representing the BEEF\n     */\n    toBinary() {\n        // Always serialize in dependency sorted order.\n        this.sortTxs();\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        this.toWriter(writer);\n        return writer.toArray();\n    }\n    /**\n     * Serialize this Beef as AtomicBEEF.\n     *\n     * `txid` must exist\n     *\n     * after sorting, if txid is not last txid, creates a clone and removes newer txs\n     *\n     * @param txid\n     * @returns serialized contents of this Beef with AtomicBEEF prefix.\n     */\n    toBinaryAtomic(txid) {\n        this.sortTxs();\n        const tx = this.findTxid(txid);\n        if (tx == null) {\n            throw new Error(`${txid} does not exist in this Beef`);\n        }\n        // If the transaction is not the last one, clone and modify\n        const beef = (this.txs[this.txs.length - 1] === tx) ? this : this.clone();\n        if (beef !== this) {\n            const i = this.txs.findIndex((t) => t.txid === txid);\n            beef.txs.splice(i + 1);\n        }\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        writer.writeUInt32LE(ATOMIC_BEEF);\n        writer.writeReverse((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(txid, 'hex'));\n        beef.toWriter(writer);\n        return writer.toArray();\n    }\n    /**\n     * Returns a hex string representing the serialized BEEF\n     * @returns A hex string representing the BEEF\n     */\n    toHex() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(this.toBinary());\n    }\n    static fromReader(br) {\n        let version = br.readUInt32LE();\n        let atomicTxid;\n        if (version === ATOMIC_BEEF) {\n            // Skip the txid and re-read the BEEF version\n            atomicTxid = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(br.readReverse(32));\n            version = br.readUInt32LE();\n        }\n        if (version !== BEEF_V1 && version !== BEEF_V2) {\n            throw new Error(`Serialized BEEF must start with ${BEEF_V1} or ${BEEF_V2} but starts with ${version}`);\n        }\n        const beef = new Beef(version);\n        const bumpsLength = br.readVarIntNum();\n        for (let i = 0; i < bumpsLength; i++) {\n            const bump = _MerklePath_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromReader(br, false);\n            beef.bumps.push(bump);\n        }\n        const txsLength = br.readVarIntNum();\n        for (let i = 0; i < txsLength; i++) {\n            const beefTx = _BeefTx_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromReader(br, version);\n            beef.txs.push(beefTx);\n        }\n        beef.atomicTxid = atomicTxid;\n        return beef;\n    }\n    /**\n     * Constructs an instance of the Beef class based on the provided binary array\n     * @param bin The binary array from which to construct BEEF\n     * @returns An instance of the Beef class constructed from the binary data\n     */\n    static fromBinary(bin) {\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(bin);\n        return Beef.fromReader(br);\n    }\n    /**\n     * Constructs an instance of the Beef class based on the provided string\n     * @param s The string value from which to construct BEEF\n     * @param enc The encoding of the string value from which BEEF should be constructed\n     * @returns An instance of the Beef class constructed from the string\n     */\n    static fromString(s, enc = 'hex') {\n        const bin = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(s, enc);\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(bin);\n        return Beef.fromReader(br);\n    }\n    /**\n     * Try to validate newTx.bumpIndex by looking for an existing bump\n     * that proves newTx.txid\n     *\n     * @param newTx A new `BeefTx` that has been added to this.txs\n     * @returns true if a bump was found, false otherwise\n     */\n    tryToValidateBumpIndex(newTx) {\n        if (newTx.bumpIndex !== undefined) {\n            return true;\n        }\n        const txid = newTx.txid;\n        for (let i = 0; i < this.bumps.length; i++) {\n            const j = this.bumps[i].path[0].findIndex((b) => b.hash === txid);\n            if (j >= 0) {\n                newTx.bumpIndex = i;\n                this.bumps[i].path[0][j].txid = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Sort the `txs` by input txid dependency order:\n     * - Oldest Tx Anchored by Path or txid only\n     * - Newer Txs depending on Older parents\n     * - Newest Tx\n     *\n     * with proof (MerklePath) last, longest chain of dependencies first\n     *\n     * @returns `{ missingInputs, notValid, valid, withMissingInputs }`\n     */\n    sortTxs() {\n        // Hashtable of valid txids (with proof or all inputs chain to proof)\n        const validTxids = {};\n        // Hashtable of all transaction txids to transaction\n        const txidToTx = {};\n        // queue of unsorted transactions ...\n        let queue = [];\n        // sorted transactions: hasProof to with longest dependency chain\n        const result = [];\n        const txidOnly = [];\n        for (const tx of this.txs) {\n            txidToTx[tx.txid] = tx;\n            tx.isValid = tx.hasProof;\n            if (tx.isValid) {\n                validTxids[tx.txid] = true;\n                result.push(tx);\n            }\n            else if (tx.isTxidOnly && tx.inputTxids.length === 0) {\n                validTxids[tx.txid] = true;\n                txidOnly.push(tx);\n            }\n            else {\n                queue.push(tx);\n            }\n        }\n        // Hashtable of unknown input txids used to fund transactions without their own proof.\n        const missingInputs = {};\n        // transactions with one or more missing inputs\n        const txsMissingInputs = [];\n        const possiblyMissingInputs = queue;\n        queue = [];\n        // all tx are isValid false, hasProof false.\n        // if isTxidOnly then has inputTxids\n        for (const tx of possiblyMissingInputs) {\n            let hasMissingInput = false;\n            // For all the unproven transactions,\n            // link their inputs that exist in this beef,\n            // make a note of missing inputs.\n            for (const inputTxid of tx.inputTxids) {\n                if (txidToTx[inputTxid] === undefined) { // Explicitly check for undefined\n                    missingInputs[inputTxid] = true;\n                    hasMissingInput = true;\n                }\n            }\n            if (hasMissingInput) {\n                txsMissingInputs.push(tx);\n            }\n            else {\n                queue.push(tx);\n            }\n        }\n        // As long as we have unsorted transactions...\n        while (queue.length > 0) {\n            const oldQueue = queue;\n            queue = [];\n            // all tx are isValid false, hasProof false.\n            // if isTxidOnly then has inputTxids\n            for (const tx of oldQueue) {\n                if (tx.inputTxids.every((txid) => validTxids[txid])) {\n                    validTxids[tx.txid] = true;\n                    result.push(tx);\n                }\n                else {\n                    queue.push(tx);\n                }\n            }\n            if (oldQueue.length === queue.length) {\n                break;\n            }\n        }\n        // transactions that don't have proofs and don't chain to proofs\n        const txsNotValid = queue;\n        // New order of txs is unsortable (missing inputs or depends on missing inputs), txidOnly, sorted (so newest sorted is last)\n        this.txs = txsMissingInputs\n            .concat(txsNotValid)\n            .concat(txidOnly)\n            .concat(result);\n        return {\n            missingInputs: Object.keys(missingInputs),\n            notValid: txsNotValid.map((tx) => tx.txid),\n            valid: Object.keys(validTxids),\n            withMissingInputs: txsMissingInputs.map((tx) => tx.txid),\n            txidOnly: txidOnly.map((tx) => tx.txid)\n        };\n    }\n    /**\n     * @returns a shallow copy of this beef\n     */\n    clone() {\n        const c = new Beef();\n        c.version = this.version;\n        c.bumps = Array.from(this.bumps);\n        c.txs = Array.from(this.txs);\n        return c;\n    }\n    /**\n     * Ensure that all the txids in `knownTxids` are txidOnly\n     * @param knownTxids\n     */\n    trimKnownTxids(knownTxids) {\n        for (let i = 0; i < this.txs.length;) {\n            const tx = this.txs[i];\n            if (tx.isTxidOnly && knownTxids.includes(tx.txid)) {\n                this.txs.splice(i, 1);\n            }\n            else {\n                i++;\n            }\n        }\n        // TODO: bumps could be trimmed to eliminate unreferenced proofs.\n    }\n    /**\n     * @returns array of transaction txids that either have a proof or whose inputs chain back to a proven transaction.\n     */\n    getValidTxids() {\n        const r = this.sortTxs();\n        return r.valid;\n    }\n    /**\n     * @returns Summary of `Beef` contents as multi-line string.\n     */\n    toLogString() {\n        let log = '';\n        log += `BEEF with ${this.bumps.length} BUMPS and ${this.txs.length} Transactions, isValid ${this.isValid().toString()}\\n`;\n        let i = -1;\n        for (const b of this.bumps) {\n            i++;\n            log += `  BUMP ${i}\\n    block: ${b.blockHeight}\\n    txids: [\\n${b.path[0]\n                .filter((n) => n.txid === true) //  Explicitly check if txid is `true`\n                .map((n) => `      '${n.hash ?? ''}'`)\n                .join(',\\n')}\\n    ]\\n`;\n        }\n        i = -1;\n        for (const t of this.txs) {\n            i++;\n            log += `  TX ${i}\\n    txid: ${t.txid}\\n`;\n            if (t.bumpIndex !== undefined) {\n                log += `    bumpIndex: ${t.bumpIndex}\\n`;\n            }\n            if (t.isTxidOnly) {\n                log += '    txidOnly\\n';\n            }\n            else {\n                log += `    rawTx length=${t.rawTx?.length ?? 0}\\n`; //  Fix applied here\n            }\n            if (t.inputTxids.length > 0) {\n                log += `    inputs: [\\n${t.inputTxids\n                    .map((it) => `      '${it}'`)\n                    .join(',\\n')}\\n    ]\\n`;\n            }\n        }\n        return log;\n    }\n    /**\n   * In some circumstances it may be helpful for the BUMP MerklePaths to include\n   * leaves that can be computed from row zero.\n   */\n    addComputedLeaves() {\n        const hash = (m) => (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash256)((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(m, 'hex').reverse()).reverse());\n        for (const bump of this.bumps) { //  Use `this` instead of `beef`\n            for (let row = 1; row < bump.path.length; row++) {\n                for (const leafL of bump.path[row - 1]) {\n                    if (typeof leafL.hash === 'string' && (leafL.offset & 1) === 0) {\n                        const leafR = bump.path[row - 1].find((l) => l.offset === leafL.offset + 1);\n                        const offsetOnRow = leafL.offset >> 1;\n                        if (leafR !== undefined &&\n                            typeof leafR.hash === 'string' &&\n                            bump.path[row].every((l) => l.offset !== offsetOnRow)) {\n                            // Computable leaf is missing... add it.\n                            bump.path[row].push({\n                                offset: offsetOnRow,\n                                // String concatenation puts the right leaf on the left of the left leaf hash\n                                hash: hash(leafR.hash + leafL.hash)\n                            });\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=Beef.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefParty.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefParty.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BeefParty: () => (/* binding */ BeefParty),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Beef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js\");\n\n/**\n * Extends `Beef` that is used to exchange transaction validity data with more than one external party.\n *\n * Use `addKnownTxidsForParty` to keep track of who knows what to reduce re-transmission of potentially large transactions.\n *\n * Use `getTrimmedBeefForParty` to obtain a `Beef` trimmed of transaction validity data known to a specific party.\n *\n * Typical usage scenario:\n *\n * 1. Query a wallet storage provider for spendable outputs.\n * 2. The provider replies with a Beef validating the returned outputs.\n * 3. Construct a new transaction using some of the queried outputs as inputs, including Beef validating all the inputs.\n * 4. Receive new valid raw transaction after processing and Beef validating change outputs added to original inputs.\n * 5. Return to step 1, continuing to build on old and new spendable outputs.\n *\n * By default, each Beef is required to be complete and valid: All transactions appear as full serialized bitcoin transactions and\n * each transaction either has a merkle path proof (it has been mined) or all of its input transactions are included.\n *\n * The size and redundancy of these Beefs becomes a problem when chained transaction creation out-paces the block mining rate.\n *\n */\nclass BeefParty extends _Beef_js__WEBPACK_IMPORTED_MODULE_0__.Beef {\n    /**\n     * keys are party identifiers.\n     * values are records of txids with truthy value for which the party already has validity proof.\n     */\n    knownTo = {};\n    /**\n     *\n     * @param parties Optional array of initial unique party identifiers.\n     */\n    constructor(parties) {\n        super();\n        if (parties != null) {\n            for (const party of parties) {\n                this.addParty(party);\n            }\n        }\n    }\n    /**\n     * @param party\n     * @returns `true` if `party` has already been added to this `BeefParty`.\n     */\n    isParty(party) {\n        const r = Object.keys(this.knownTo).includes(party);\n        return r;\n    }\n    /**\n     * Adds a new unique party identifier to this `BeefParty`.\n     * @param party\n     */\n    addParty(party) {\n        if (this.isParty(party)) {\n            throw new Error(`Party ${party} already exists.`);\n        }\n        this.knownTo[party] = {};\n    }\n    /**\n     * @param party\n     * @returns Array of txids \"known\" to `party`.\n     */\n    getKnownTxidsForParty(party) {\n        const knownTxids = this.knownTo[party];\n        if (knownTxids === undefined) { //  Explicitly check for undefined\n            throw new Error(`Party ${party} is unknown.`);\n        }\n        return Object.keys(knownTxids);\n    }\n    /**\n     * @param party\n     * @returns trimmed beef of unknown transactions and proofs for `party`\n     */\n    getTrimmedBeefForParty(party) {\n        const knownTxids = this.getKnownTxidsForParty(party);\n        const prunedBeef = this.clone();\n        prunedBeef.trimKnownTxids(knownTxids);\n        return prunedBeef;\n    }\n    /**\n     * Make note of additional txids \"known\" to `party`.\n     * @param party unique identifier, added if new.\n     * @param knownTxids\n     */\n    addKnownTxidsForParty(party, knownTxids) {\n        if (!this.isParty(party)) {\n            this.addParty(party);\n        }\n        const kts = this.knownTo[party];\n        for (const txid of knownTxids) {\n            kts[txid] = true;\n            this.mergeTxidOnly(txid);\n        }\n    }\n    /**\n     * Merge a `beef` received from a specific `party`.\n     *\n     * Updates this `BeefParty` to track all the txids\n     * corresponding to transactions for which `party`\n     * has raw transaction and validity proof data.\n     *\n     * @param party\n     * @param beef\n     */\n    mergeBeefFromParty(party, beef) {\n        const b = Array.isArray(beef) ? _Beef_js__WEBPACK_IMPORTED_MODULE_0__.Beef.fromBinary(beef) : beef;\n        const knownTxids = b.getValidTxids();\n        this.mergeBeef(b);\n        this.addKnownTxidsForParty(party, knownTxids);\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BeefParty);\n//# sourceMappingURL=BeefParty.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefParty.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefTx.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefTx.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ BeefTx)\n/* harmony export */ });\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Transaction.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js\");\n/* harmony import */ var _Beef_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js\");\n\n\n\n\n/**\n * A single bitcoin transaction associated with a `Beef` validity proof set.\n *\n * Simple case is transaction data included directly, either as raw bytes or fully parsed data, or both.\n *\n * Supports 'known' transactions which are represented by just their txid.\n * It is assumed that intended consumer of this beef already has validity proof for such a transaction,\n * which they can merge if necessary to create a valid beef.\n */\nclass BeefTx {\n    _bumpIndex;\n    _tx;\n    _rawTx;\n    _txid;\n    inputTxids = [];\n    /**\n     * true if `hasProof` or all inputs chain to `hasProof`.\n     *\n     * Typically set by sorting transactions by proven dependency chains.\n     */\n    isValid = undefined;\n    get bumpIndex() {\n        return this._bumpIndex;\n    }\n    set bumpIndex(v) {\n        this._bumpIndex = v;\n        this.updateInputTxids();\n    }\n    get hasProof() {\n        return this._bumpIndex !== undefined;\n    }\n    get isTxidOnly() {\n        return this._txid !== undefined && this._txid !== null && (this._rawTx == null) && (this._tx == null);\n    }\n    get txid() {\n        if (this._txid !== undefined && this._txid !== null && this._txid !== '')\n            return this._txid;\n        if (this._tx != null) {\n            this._txid = this._tx.id('hex');\n            return this._txid;\n        }\n        if (this._rawTx != null) {\n            this._txid = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toHex)((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_0__.hash256)(this._rawTx));\n            return this._txid;\n        }\n        throw new Error('Internal');\n    }\n    get tx() {\n        if (this._tx != null)\n            return this._tx;\n        if (this._rawTx != null) {\n            this._tx = _Transaction_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromBinary(this._rawTx);\n            return this._tx;\n        }\n        return undefined;\n    }\n    get rawTx() {\n        if (this._rawTx != null)\n            return this._rawTx;\n        if (this._tx != null) {\n            this._rawTx = this._tx.toBinary();\n            return this._rawTx;\n        }\n        return undefined;\n    }\n    /**\n     * @param tx If string, must be a valid txid. If `number[]` must be a valid serialized transaction.\n     * @param bumpIndex If transaction already has a proof in the beef to which it will be added.\n     */\n    constructor(tx, bumpIndex) {\n        if (typeof tx === 'string') {\n            this._txid = tx;\n        }\n        else if (Array.isArray(tx)) {\n            this._rawTx = tx;\n        }\n        else {\n            this._tx = tx;\n        }\n        this.bumpIndex = bumpIndex;\n        this.updateInputTxids();\n    }\n    static fromTx(tx, bumpIndex) {\n        return new BeefTx(tx, bumpIndex);\n    }\n    static fromRawTx(rawTx, bumpIndex) {\n        return new BeefTx(rawTx, bumpIndex);\n    }\n    static fromTxid(txid, bumpIndex) {\n        return new BeefTx(txid, bumpIndex);\n    }\n    updateInputTxids() {\n        if (this.hasProof || (this.tx == null)) {\n            // If we have a proof, or don't have a parsed transaction\n            this.inputTxids = [];\n        }\n        else {\n            const inputTxids = {}; //  Explicit object type\n            for (const input of this.tx.inputs) {\n                if (input.sourceTXID !== undefined && input.sourceTXID !== null && input.sourceTXID !== '') {\n                    //  Ensure sourceTXID is defined\n                    inputTxids[input.sourceTXID] = true;\n                }\n            }\n            this.inputTxids = Object.keys(inputTxids);\n        }\n    }\n    toWriter(writer, version) {\n        const writeByte = (bb) => {\n            writer.writeUInt8(bb);\n        };\n        const writeTxid = () => {\n            if (this._txid == null) {\n                throw new Error('Transaction ID (_txid) is undefined');\n            }\n            writer.writeReverse((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toArray)(this._txid, 'hex'));\n        };\n        const writeTx = () => {\n            if (this._rawTx != null) {\n                writer.write(this._rawTx);\n            }\n            else if (this._tx != null) {\n                writer.write(this._tx.toBinary());\n            }\n            else {\n                throw new Error('a valid serialized Transaction is expected');\n            }\n        };\n        const writeBumpIndex = () => {\n            if (this.bumpIndex === undefined) {\n                writeByte(_Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.RAWTX); // 0\n            }\n            else {\n                writeByte(_Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX); // 1\n                writer.writeVarIntNum(this.bumpIndex); // the index of the associated bump\n            }\n        };\n        if (version === _Beef_js__WEBPACK_IMPORTED_MODULE_3__.BEEF_V2) {\n            if (this.isTxidOnly) {\n                writeByte(_Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.TXID_ONLY);\n                writeTxid();\n            }\n            else if (this.bumpIndex !== undefined) {\n                writeByte(_Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX);\n                writer.writeVarIntNum(this.bumpIndex);\n                writeTx();\n            }\n            else {\n                writeByte(_Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.RAWTX);\n                writeTx();\n            }\n        }\n        else {\n            writeTx();\n            writeBumpIndex();\n        }\n    }\n    static fromReader(br, version) {\n        let data;\n        let bumpIndex;\n        let beefTx;\n        if (version === _Beef_js__WEBPACK_IMPORTED_MODULE_3__.BEEF_V2) {\n            // V2\n            const format = br.readUInt8();\n            if (format === _Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.TXID_ONLY) {\n                beefTx = BeefTx.fromTxid((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toHex)(br.readReverse(32)));\n            }\n            else {\n                if (format === _Beef_js__WEBPACK_IMPORTED_MODULE_3__.TX_DATA_FORMAT.RAWTX_AND_BUMP_INDEX) {\n                    bumpIndex = br.readVarIntNum();\n                }\n                data = _Transaction_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromReader(br);\n                beefTx = BeefTx.fromTx(data, bumpIndex);\n            }\n        }\n        else {\n            // V1\n            data = _Transaction_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromReader(br);\n            bumpIndex = br.readUInt8() !== 0 ? br.readVarIntNum() : undefined;\n            beefTx = BeefTx.fromTx(data, bumpIndex);\n        }\n        return beefTx;\n    }\n}\n//# sourceMappingURL=BeefTx.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefTx.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/Broadcaster.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/Broadcaster.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isBroadcastFailure: () => (/* binding */ isBroadcastFailure),\n/* harmony export */   isBroadcastResponse: () => (/* binding */ isBroadcastResponse)\n/* harmony export */ });\n/**\n * Convenience type guard for response from `Broadcaster.broadcast`\n */\nfunction isBroadcastResponse(r) {\n    return r.status === 'success';\n}\n/**\n * Convenience type guard for response from `Broadcaster.broadcast`\n */\nfunction isBroadcastFailure(r) {\n    return r.status === 'error';\n}\n//# sourceMappingURL=Broadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/Broadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MerklePath)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n\n\n/**\n * Represents a Merkle Path, which is used to provide a compact proof of inclusion for a\n * transaction in a block. This class encapsulates all the details required for creating\n * and verifying Merkle Proofs.\n *\n * @class MerklePath\n * @property {number} blockHeight - The height of the block in which the transaction is included.\n * @property {Array<Array<{offset: number, hash?: string, txid?: boolean, duplicate?: boolean}>>} path -\n *           A tree structure representing the Merkle Path, with each level containing information\n *           about the nodes involved in constructing the proof.\n *\n * @example\n * // Creating and verifying a Merkle Path\n * const merklePath = MerklePath.fromHex('...');\n * const isValid = merklePath.verify(txid, chainTracker);\n *\n * @description\n * The MerklePath class is useful for verifying transactions in a lightweight and efficient manner without\n * needing the entire block data. This class offers functionalities for creating, converting,\n * and verifying these proofs.\n */\nclass MerklePath {\n    blockHeight;\n    path;\n    /**\n     * Creates a MerklePath instance from a hexadecimal string.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the Merkle Path.\n     * @returns {MerklePath} - A new MerklePath instance.\n     */\n    static fromHex(hex) {\n        return MerklePath.fromBinary((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(hex, 'hex'));\n    }\n    static fromReader(reader, legalOffsetsOnly = true) {\n        const blockHeight = reader.readVarIntNum();\n        const treeHeight = reader.readUInt8();\n        // Explicitly define the type of path as an array of arrays of leaf objects\n        const path = Array(treeHeight)\n            .fill(null)\n            .map(() => []);\n        let flags, offset, nLeavesAtThisHeight;\n        for (let level = 0; level < treeHeight; level++) {\n            nLeavesAtThisHeight = reader.readVarIntNum();\n            while (nLeavesAtThisHeight > 0) {\n                offset = reader.readVarIntNum();\n                flags = reader.readUInt8();\n                const leaf = { offset };\n                if ((flags & 1) !== 0) {\n                    leaf.duplicate = true;\n                }\n                else {\n                    if ((flags & 2) !== 0) {\n                        leaf.txid = true;\n                    }\n                    leaf.hash = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)(reader.read(32).reverse());\n                }\n                // Ensure path[level] exists before pushing\n                if (!Array.isArray(path[level]) || path[level].length === 0) {\n                    path[level] = [];\n                }\n                path[level].push(leaf);\n                nLeavesAtThisHeight--;\n            }\n            // Sort the array based on the offset property\n            path[level].sort((a, b) => a.offset - b.offset);\n        }\n        return new MerklePath(blockHeight, path, legalOffsetsOnly);\n    }\n    /**\n     * Creates a MerklePath instance from a binary array.\n     *\n     * @static\n     * @param {number[]} bump - The binary array representation of the Merkle Path.\n     * @returns {MerklePath} - A new MerklePath instance.\n     */\n    static fromBinary(bump) {\n        const reader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(bump);\n        return MerklePath.fromReader(reader);\n    }\n    /**\n     *\n     * @static fromCoinbaseTxid\n     *\n     * Creates a MerklePath instance for a coinbase transaction in an empty block.\n     * This edge case is difficult to retrieve from standard APIs.\n     *\n     * @param {string} txid - The coinbase txid.\n     * @param {number} height - The height of the block.\n     * @returns {MerklePath} - A new MerklePath instance which assumes the tx is in a block with no other transactions.\n     */\n    static fromCoinbaseTxidAndHeight(txid, height) {\n        return new MerklePath(height, [[{ offset: 0, hash: txid, txid: true }]]);\n    }\n    constructor(blockHeight, path, legalOffsetsOnly = true) {\n        this.blockHeight = blockHeight;\n        this.path = path;\n        // store all of the legal offsets which we expect given the txid indices.\n        const legalOffsets = Array(this.path.length)\n            .fill(0)\n            .map(() => new Set());\n        this.path.forEach((leaves, height) => {\n            if (leaves.length === 0 && height === 0) {\n                throw new Error(`Empty level at height: ${height}`);\n            }\n            const offsetsAtThisHeight = new Set();\n            leaves.forEach((leaf) => {\n                if (offsetsAtThisHeight.has(leaf.offset)) {\n                    throw new Error(`Duplicate offset: ${leaf.offset}, at height: ${height}`);\n                }\n                offsetsAtThisHeight.add(leaf.offset);\n                if (height === 0) {\n                    if (leaf.duplicate !== true) {\n                        for (let h = 1; h < this.path.length; h++) {\n                            legalOffsets[h].add((leaf.offset >> h) ^ 1);\n                        }\n                    }\n                }\n                else {\n                    if (legalOffsetsOnly && !legalOffsets[height].has(leaf.offset)) {\n                        throw new Error(`Invalid offset: ${leaf.offset}, at height: ${height}, with legal offsets: ${Array.from(legalOffsets[height]).join(', ')}`);\n                    }\n                }\n            });\n        });\n        // every txid must calculate to the same root.\n        let root;\n        this.path[0].forEach((leaf, idx) => {\n            if (idx === 0)\n                root = this.computeRoot(leaf.hash);\n            if (root !== this.computeRoot(leaf.hash)) {\n                throw new Error('Mismatched roots');\n            }\n        });\n    }\n    /**\n     * Converts the MerklePath to a binary array format.\n     *\n     * @returns {number[]} - The binary array representation of the Merkle Path.\n     */\n    toBinary() {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n        writer.writeVarIntNum(this.blockHeight);\n        const treeHeight = this.path.length;\n        writer.writeUInt8(treeHeight);\n        for (let level = 0; level < treeHeight; level++) {\n            const nLeaves = Object.keys(this.path[level]).length;\n            writer.writeVarIntNum(nLeaves);\n            for (const leaf of this.path[level]) {\n                writer.writeVarIntNum(leaf.offset);\n                let flags = 0;\n                if (leaf?.duplicate === true) {\n                    flags |= 1;\n                }\n                if (leaf?.txid !== undefined && leaf.txid !== null) {\n                    flags |= 2;\n                }\n                writer.writeUInt8(flags);\n                if ((flags & 1) === 0) {\n                    writer.write((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(leaf.hash, 'hex').reverse());\n                }\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * Converts the MerklePath to a hexadecimal string format.\n     *\n     * @returns {string} - The hexadecimal string representation of the Merkle Path.\n     */\n    toHex() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)(this.toBinary());\n    }\n    //\n    indexOf(txid) {\n        const leaf = this.path[0].find((l) => l.hash === txid);\n        if (leaf === null || leaf === undefined) {\n            throw new Error(`Transaction ID ${txid} not found in the Merkle Path`);\n        }\n        return leaf.offset;\n    }\n    /**\n     * Computes the Merkle root from the provided transaction ID.\n     *\n     * @param {string} txid - The transaction ID to compute the Merkle root for. If not provided, the root will be computed from an unspecified branch, and not all branches will be validated!\n     * @returns {string} - The computed Merkle root as a hexadecimal string.\n     * @throws {Error} - If the transaction ID is not part of the Merkle Path.\n     */\n    computeRoot(txid) {\n        if (typeof txid !== 'string') {\n            const foundLeaf = this.path[0].find((leaf) => Boolean(leaf?.hash));\n            if (foundLeaf === null || foundLeaf === undefined) {\n                throw new Error('No valid leaf found in the Merkle Path');\n            }\n            txid = foundLeaf.hash;\n        }\n        // Find the index of the txid at the lowest level of the Merkle tree\n        if (typeof txid !== 'string') {\n            throw new Error('Transaction ID is undefined');\n        }\n        const index = this.indexOf(txid);\n        if (typeof index !== 'number') {\n            throw new Error(`This proof does not contain the txid: ${txid ?? 'undefined'}`);\n        }\n        // Calculate the root using the index as a way to determine which direction to concatenate.\n        const hash = (m) => (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.hash256)((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(m, 'hex').reverse()).reverse());\n        let workingHash = txid;\n        // special case for blocks with only one transaction\n        if (this.path.length === 1 && this.path[0].length === 1)\n            return workingHash;\n        for (let height = 0; height < this.path.length; height++) {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            const leaves = this.path[height];\n            const offset = (index >> height) ^ 1;\n            const leaf = this.findOrComputeLeaf(height, offset);\n            if (typeof leaf !== 'object') {\n                throw new Error(`Missing hash for index ${index} at height ${height}`);\n            }\n            if (leaf.duplicate === true) {\n                workingHash = hash((workingHash ?? '') + (workingHash ?? ''));\n            }\n            else if (offset % 2 !== 0) {\n                workingHash = hash((leaf.hash ?? '') + (workingHash ?? ''));\n            }\n            else {\n                workingHash = hash((workingHash ?? '') + (leaf.hash ?? ''));\n            }\n        }\n        return workingHash;\n    }\n    /**\n     * Find leaf with `offset` at `height` or compute from level below, recursively.\n     *\n     * Does not add computed leaves to path.\n     *\n     * @param height\n     * @param offset\n     */\n    findOrComputeLeaf(height, offset) {\n        const hash = (m) => (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex)((0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_1__.hash256)((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray)(m, 'hex').reverse()).reverse());\n        let leaf = this.path[height].find((l) => l.offset === offset);\n        if (leaf != null)\n            return leaf;\n        if (height === 0)\n            return undefined;\n        const h = height - 1;\n        const l = offset << 1;\n        const leaf0 = this.findOrComputeLeaf(h, l);\n        if (leaf0 == null || leaf0.hash == null || leaf0.hash === '')\n            return undefined;\n        const leaf1 = this.findOrComputeLeaf(h, l + 1);\n        if (leaf1 == null)\n            return undefined;\n        let workinghash;\n        if (leaf1.duplicate === true) {\n            workinghash = hash(leaf0.hash + leaf0.hash);\n        }\n        else {\n            workinghash = hash((leaf1.hash ?? '') + (leaf0.hash ?? ''));\n        }\n        leaf = {\n            offset,\n            hash: workinghash\n        };\n        return leaf;\n    }\n    /**\n     * Verifies if the given transaction ID is part of the Merkle tree at the specified block height.\n     *\n     * @param {string} txid - The transaction ID to verify.\n     * @param {ChainTracker} chainTracker - The ChainTracker instance used to verify the Merkle root.\n     * @returns {boolean} - True if the transaction ID is valid within the Merkle Path at the specified block height.\n     */\n    async verify(txid, chainTracker) {\n        const root = this.computeRoot(txid);\n        if (this.indexOf(txid) === 0) {\n            // Coinbase transaction outputs can only be spent once they're 100 blocks deep.\n            const height = await chainTracker.currentHeight();\n            if (this.blockHeight + 100 < height) {\n                return false;\n            }\n        }\n        // Use the chain tracker to determine whether this is a valid merkle root at the given block height\n        return await chainTracker.isValidRootForHeight(root, this.blockHeight);\n    }\n    /**\n     * Combines this MerklePath with another to create a compound proof.\n     *\n     * @param {MerklePath} other - Another MerklePath to combine with this path.\n     * @throws {Error} - If the paths have different block heights or roots.\n     */\n    combine(other) {\n        if (this.blockHeight !== other.blockHeight) {\n            throw new Error('You cannot combine paths which do not have the same block height.');\n        }\n        const root1 = this.computeRoot();\n        const root2 = other.computeRoot();\n        if (root1 !== root2) {\n            throw new Error('You cannot combine paths which do not have the same root.');\n        }\n        const combinedPath = [];\n        for (let h = 0; h < this.path.length; h++) {\n            combinedPath.push([]);\n            for (let l = 0; l < this.path[h].length; l++) {\n                combinedPath[h].push(this.path[h][l]);\n            }\n            for (let l = 0; l < other.path[h].length; l++) {\n                if (combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset) === undefined) {\n                    combinedPath[h].push(other.path[h][l]);\n                }\n                else {\n                    // Ensure that any elements which appear in both are not downgraded to a non txid.\n                    if (other.path[h][l]?.txid !== undefined && other.path[h][l]?.txid !== null) {\n                        const target = combinedPath[h].find((leaf) => leaf.offset === other.path[h][l].offset);\n                        if (target !== null && target !== undefined) {\n                            target.txid = true;\n                        }\n                    }\n                }\n            }\n        }\n        this.path = combinedPath;\n        this.trim();\n    }\n    /**\n     * Remove all internal nodes that are not required by level zero txid nodes.\n     * Assumes that at least all required nodes are present.\n     * Leaves all levels sorted by increasing offset.\n     */\n    trim() {\n        const pushIfNew = (v, a) => {\n            if (a.length === 0 || a.slice(-1)[0] !== v) {\n                a.push(v);\n            }\n        };\n        const dropOffsetsFromLevel = (dropOffsets, level) => {\n            for (let i = dropOffsets.length; i >= 0; i--) {\n                const l = this.path[level].findIndex((n) => n.offset === dropOffsets[i]);\n                if (l >= 0) {\n                    this.path[level].splice(l, 1);\n                }\n            }\n        };\n        const nextComputedOffsets = (cos) => {\n            const ncos = [];\n            for (const o of cos) {\n                pushIfNew(o >> 1, ncos);\n            }\n            return ncos;\n        };\n        let computedOffsets = []; // in next level\n        let dropOffsets = [];\n        for (let h = 0; h < this.path.length; h++) {\n            // Sort each level by increasing offset order\n            this.path[h].sort((a, b) => a.offset - b.offset);\n        }\n        for (let l = 0; l < this.path[0].length; l++) {\n            const n = this.path[0][l];\n            if (n.txid === true) {\n                // level 0 must enable computing level 1 for txid nodes\n                pushIfNew(n.offset >> 1, computedOffsets);\n            }\n            else {\n                const isOdd = n.offset % 2 === 1;\n                const peer = this.path[0][l + (isOdd ? -1 : 1)];\n                if (peer.txid === undefined || peer.txid === null || !peer.txid) {\n                    // drop non-txid level 0 nodes without a txid peer\n                    pushIfNew(peer.offset, dropOffsets);\n                }\n            }\n        }\n        dropOffsetsFromLevel(dropOffsets, 0);\n        for (let h = 1; h < this.path.length; h++) {\n            dropOffsets = computedOffsets;\n            computedOffsets = nextComputedOffsets(computedOffsets);\n            dropOffsetsFromLevel(dropOffsets, h);\n        }\n    }\n}\n//# sourceMappingURL=MerklePath.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Transaction)\n/* harmony export */ });\n/* harmony import */ var _script_UnlockingScript_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../script/UnlockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/UnlockingScript.js\");\n/* harmony import */ var _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../script/LockingScript.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/LockingScript.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../primitives/Hash.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Hash.js\");\n/* harmony import */ var _fee_models_SatoshisPerKilobyte_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fee-models/SatoshisPerKilobyte.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js\");\n/* harmony import */ var _script_Spend_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../script/Spend.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/Spend.js\");\n/* harmony import */ var _broadcasters_DefaultBroadcaster_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./broadcasters/DefaultBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js\");\n/* harmony import */ var _chaintrackers_DefaultChainTracker_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./chaintrackers/DefaultChainTracker.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js\");\n/* harmony import */ var _Beef_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js\");\n/* harmony import */ var _script_templates_P2PKH_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../script/templates/P2PKH.js */ \"./node_modules/@bsv/sdk/dist/esm/src/script/templates/P2PKH.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Represents a complete Bitcoin transaction. This class encapsulates all the details\n * required for creating, signing, and processing a Bitcoin transaction, including\n * inputs, outputs, and various transaction-related methods.\n *\n * @class Transaction\n * @property {number} version - The version number of the transaction. Used to specify\n *           which set of rules this transaction follows.\n * @property {TransactionInput[]} inputs - An array of TransactionInput objects, representing\n *           the inputs for the transaction. Each input references a previous transaction's output.\n * @property {TransactionOutput[]} outputs - An array of TransactionOutput objects, representing\n *           the outputs for the transaction. Each output specifies the amount of satoshis to be\n *           transferred and the conditions under which they can be spent.\n * @property {number} lockTime - The lock time of the transaction. If non-zero, it specifies the\n *           earliest time or block height at which the transaction can be added to the block chain.\n * @property {Record<string, any>} metadata - A key-value store for attaching additional data to\n *           the transaction object, not included in the transaction itself. Useful for adding descriptions, internal reference numbers, or other information.\n * @property {MerkleProof} [merklePath] - Optional. A merkle proof demonstrating the transaction's\n *           inclusion in a block. Useful for transaction verification using SPV.\n *\n * @example\n * // Creating a new transaction\n * let tx = new Transaction();\n * tx.addInput(...);\n * tx.addOutput(...);\n * await tx.fee();\n * await tx.sign();\n * await tx.broadcast();\n *\n * @description\n * The Transaction class provides comprehensive\n * functionality to handle various aspects of transaction creation, including\n * adding inputs and outputs, computing fees, signing the transaction, and\n * generating its binary or hexadecimal representation.\n */\nclass Transaction {\n    version;\n    inputs;\n    outputs;\n    lockTime;\n    metadata;\n    merklePath;\n    cachedHash;\n    // Recursive function for adding merkle proofs or input transactions\n    static addPathOrInputs(obj, transactions, BUMPs) {\n        if (typeof obj.pathIndex === 'number') {\n            const path = BUMPs[obj.pathIndex];\n            if (typeof path !== 'object') {\n                throw new Error('Invalid merkle path index found in BEEF!');\n            }\n            obj.tx.merklePath = path;\n        }\n        else {\n            for (const input of obj.tx.inputs) {\n                if (input.sourceTXID === undefined) {\n                    throw new Error('Input sourceTXID is undefined');\n                }\n                const sourceObj = transactions[input.sourceTXID];\n                if (typeof sourceObj !== 'object') {\n                    throw new Error(`Reference to unknown TXID in BEEF: ${input.sourceTXID ?? 'undefined'}`);\n                }\n                input.sourceTransaction = sourceObj.tx;\n                this.addPathOrInputs(sourceObj, transactions, BUMPs);\n            }\n        }\n    }\n    /**\n     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a BEEF V1, V2 or Atomic.\n     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.\n     * If the TXID is provided but not found in the BEEF data, an error will be thrown.\n     * If no TXID is provided, the last transaction in the BEEF data is returned, or the atomic txid.\n     * @param beef A binary representation of transactions in BEEF format.\n     * @param txid Optional TXID of the transaction to retrieve from the BEEF data.\n     * @returns An anchored transaction, linked to its associated inputs populated with merkle paths.\n     */\n    static fromBEEF(beef, txid) {\n        const { tx } = Transaction.fromAnyBeef(beef, txid);\n        return tx;\n    }\n    /**\n     * Creates a new transaction from an Atomic BEEF (BRC-95) structure.\n     * Extracts the subject transaction and supporting merkle path and source transactions contained in the BEEF data\n     *\n     * @param beef A binary representation of an Atomic BEEF structure.\n     * @returns The subject transaction, linked to its associated inputs populated with merkle paths.\n     */\n    static fromAtomicBEEF(beef) {\n        const { tx, txid, beef: b } = Transaction.fromAnyBeef(beef);\n        if (txid !== b.atomicTxid) {\n            if (b.atomicTxid != null) {\n                throw new Error(`Transaction with TXID ${b.atomicTxid} not found in BEEF data.`);\n            }\n            else {\n                throw new Error('beef must conform to BRC-95 and must contain the subject txid.');\n            }\n        }\n        return tx;\n    }\n    static fromAnyBeef(beef, txid) {\n        const b = _Beef_js__WEBPACK_IMPORTED_MODULE_8__.Beef.fromBinary(beef);\n        if (b.txs.length < 1) {\n            throw new Error('beef must include at least one transaction.');\n        }\n        const target = txid ?? b.atomicTxid ?? b.txs.slice(-1)[0].txid;\n        const tx = b.findAtomicTransaction(target);\n        if (tx == null) {\n            if (txid != null) {\n                throw new Error(`Transaction with TXID ${target} not found in BEEF data.`);\n            }\n            else {\n                throw new Error('beef does not contain transaction for atomic txid.');\n            }\n        }\n        return { tx, beef: b, txid: target };\n    }\n    /**\n     * Creates a new transaction, linked to its inputs and their associated merkle paths, from a EF (BRC-30) structure.\n     * @param ef A binary representation of a transaction in EF format.\n     * @returns An extended transaction, linked to its associated inputs by locking script and satoshis amounts only.\n     */\n    static fromEF(ef) {\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(ef);\n        const version = br.readUInt32LE();\n        if ((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(br.read(6)) !== '0000000000ef') {\n            throw new Error('Invalid EF marker');\n        }\n        const inputsLength = br.readVarIntNum();\n        const inputs = [];\n        for (let i = 0; i < inputsLength; i++) {\n            const sourceTXID = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(br.readReverse(32));\n            const sourceOutputIndex = br.readUInt32LE();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const unlockingScript = _script_UnlockingScript_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromBinary(scriptBin);\n            const sequence = br.readUInt32LE();\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const lockingScriptLength = br.readVarIntNum();\n            const lockingScriptBin = br.read(lockingScriptLength);\n            const lockingScript = _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(lockingScriptBin);\n            const sourceTransaction = new Transaction(undefined, [], [], undefined);\n            sourceTransaction.outputs = Array(sourceOutputIndex + 1).fill(null);\n            sourceTransaction.outputs[sourceOutputIndex] = {\n                satoshis,\n                lockingScript\n            };\n            inputs.push({\n                sourceTransaction,\n                sourceTXID,\n                sourceOutputIndex,\n                unlockingScript,\n                sequence\n            });\n        }\n        const outputsLength = br.readVarIntNum();\n        const outputs = [];\n        for (let i = 0; i < outputsLength; i++) {\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const lockingScript = _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(scriptBin);\n            outputs.push({\n                satoshis,\n                lockingScript\n            });\n        }\n        const lockTime = br.readUInt32LE();\n        return new Transaction(version, inputs, outputs, lockTime);\n    }\n    /**\n     * Since the validation of blockchain data is atomically transaction data validation,\n     * any application seeking to validate data in output scripts must store the entire transaction as well.\n     * Since the transaction data includes the output script data, saving a second copy of potentially\n     * large scripts can bloat application storage requirements.\n     *\n     * This function efficiently parses binary transaction data to determine the offsets and lengths of each script.\n     * This supports the efficient retreival of script data from transaction data.\n     *\n     * @param bin binary transaction data\n     * @returns {\n     *   inputs: { vin: number, offset: number, length: number }[]\n     *   outputs: { vout: number, offset: number, length: number }[]\n     * }\n     */\n    static parseScriptOffsets(bin) {\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(bin);\n        const inputs = [];\n        const outputs = [];\n        br.pos += 4; // version\n        const inputsLength = br.readVarIntNum();\n        for (let i = 0; i < inputsLength; i++) {\n            br.pos += 36; // txid and vout\n            const scriptLength = br.readVarIntNum();\n            inputs.push({ vin: i, offset: br.pos, length: scriptLength });\n            br.pos += scriptLength + 4; // script and sequence\n        }\n        const outputsLength = br.readVarIntNum();\n        for (let i = 0; i < outputsLength; i++) {\n            br.pos += 8; // satoshis\n            const scriptLength = br.readVarIntNum();\n            outputs.push({ vout: i, offset: br.pos, length: scriptLength });\n            br.pos += scriptLength;\n        }\n        return { inputs, outputs };\n    }\n    static fromReader(br) {\n        const version = br.readUInt32LE();\n        const inputsLength = br.readVarIntNum();\n        const inputs = [];\n        for (let i = 0; i < inputsLength; i++) {\n            const sourceTXID = (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(br.readReverse(32));\n            const sourceOutputIndex = br.readUInt32LE();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const unlockingScript = _script_UnlockingScript_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fromBinary(scriptBin);\n            const sequence = br.readUInt32LE();\n            inputs.push({\n                sourceTXID,\n                sourceOutputIndex,\n                unlockingScript,\n                sequence\n            });\n        }\n        const outputsLength = br.readVarIntNum();\n        const outputs = [];\n        for (let i = 0; i < outputsLength; i++) {\n            const satoshis = br.readUInt64LEBn().toNumber();\n            const scriptLength = br.readVarIntNum();\n            const scriptBin = br.read(scriptLength);\n            const lockingScript = _script_LockingScript_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(scriptBin);\n            outputs.push({\n                satoshis,\n                lockingScript\n            });\n        }\n        const lockTime = br.readUInt32LE();\n        return new Transaction(version, inputs, outputs, lockTime);\n    }\n    /**\n     * Creates a Transaction instance from a binary array.\n     *\n     * @static\n     * @param {number[]} bin - The binary array representation of the transaction.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromBinary(bin) {\n        const br = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(bin);\n        return Transaction.fromReader(br);\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHex(hex) {\n        return Transaction.fromBinary((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(hex, 'hex'));\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string encoded EF.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction EF.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHexEF(hex) {\n        return Transaction.fromEF((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(hex, 'hex'));\n    }\n    /**\n     * Creates a Transaction instance from a hexadecimal string encoded BEEF.\n     * Optionally, you can provide a specific TXID to retrieve a particular transaction from the BEEF data.\n     * If the TXID is provided but not found in the BEEF data, an error will be thrown.\n     * If no TXID is provided, the last transaction in the BEEF data is returned.\n     *\n     * @static\n     * @param {string} hex - The hexadecimal string representation of the transaction BEEF.\n     * @param {string} [txid] - Optional TXID of the transaction to retrieve from the BEEF data.\n     * @returns {Transaction} - A new Transaction instance.\n     */\n    static fromHexBEEF(hex, txid) {\n        return Transaction.fromBEEF((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(hex, 'hex'), txid);\n    }\n    constructor(version = 1, inputs = [], outputs = [], lockTime = 0, metadata = new Map(), merklePath) {\n        this.version = version;\n        this.inputs = inputs;\n        this.outputs = outputs;\n        this.lockTime = lockTime;\n        this.metadata = metadata;\n        this.merklePath = merklePath;\n    }\n    /**\n     * Adds a new input to the transaction.\n     *\n     * @param {TransactionInput} input - The TransactionInput object to add to the transaction.\n     * @throws {Error} - If the input does not have a sourceTXID or sourceTransaction defined.\n     */\n    addInput(input) {\n        if (typeof input.sourceTXID === 'undefined' &&\n            typeof input.sourceTransaction === 'undefined') {\n            throw new Error('A reference to an an input transaction is required. If the input transaction itself cannot be referenced, its TXID must still be provided.');\n        }\n        // If the input sequence number hasn't been set, the expectation is that it is final.\n        if (typeof input.sequence === 'undefined') {\n            input.sequence = 0xffffffff;\n        }\n        this.cachedHash = undefined;\n        this.inputs.push(input);\n    }\n    /**\n     * Adds a new output to the transaction.\n     *\n     * @param {TransactionOutput} output - The TransactionOutput object to add to the transaction.\n     */\n    addOutput(output) {\n        this.cachedHash = undefined;\n        if (output.change !== true) {\n            if (typeof output.satoshis === 'undefined') {\n                throw new Error('either satoshis must be defined or change must be set to true');\n            }\n            if (output.satoshis < 0) {\n                throw new Error('satoshis must be a positive integer or zero');\n            }\n        }\n        if (output.lockingScript == null)\n            throw new Error('lockingScript must be defined');\n        this.outputs.push(output);\n    }\n    /**\n     * Adds a new P2PKH output to the transaction.\n     *\n     * @param {number[] | string} address - The P2PKH address of the output.\n     * @param {number} [satoshis] - The number of satoshis to send to the address - if not provided, the output is considered a change output.\n     *\n     */\n    addP2PKHOutput(address, satoshis) {\n        const lockingScript = new _script_templates_P2PKH_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"]().lock(address);\n        if (typeof satoshis === 'undefined') {\n            return this.addOutput({ lockingScript, change: true });\n        }\n        this.addOutput({\n            lockingScript,\n            satoshis\n        });\n    }\n    /**\n     * Updates the transaction's metadata.\n     *\n     * @param {Record<string, any>} metadata - The metadata object to merge into the existing metadata.\n     */\n    updateMetadata(metadata) {\n        this.metadata = {\n            ...this.metadata,\n            ...metadata\n        };\n    }\n    /**\n     * Computes fees prior to signing.\n     * If no fee model is provided, uses a SatoshisPerKilobyte fee model that pays 1 sat/kb.\n     * If fee is a number, the transaction uses that value as fee.\n     *\n     * @param modelOrFee - The initialized fee model to use or fixed fee for the transaction\n     * @param changeDistribution - Specifies how the change should be distributed\n     * amongst the change outputs\n     *\n     */\n    async fee(modelOrFee = new _fee_models_SatoshisPerKilobyte_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](1), changeDistribution = 'equal') {\n        this.cachedHash = undefined;\n        if (typeof modelOrFee === 'number') {\n            const sats = modelOrFee;\n            modelOrFee = {\n                computeFee: async () => sats\n            };\n        }\n        const fee = await modelOrFee.computeFee(this);\n        const change = this.calculateChange(fee);\n        if (change <= 0) {\n            this.outputs = this.outputs.filter((output) => output.change !== true);\n            return;\n        }\n        this.distributeChange(change, changeDistribution);\n    }\n    calculateChange(fee) {\n        let change = 0;\n        for (const input of this.inputs) {\n            if (typeof input.sourceTransaction !== 'object') {\n                throw new Error('Source transactions are required for all inputs during fee computation');\n            }\n            change +=\n                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;\n        }\n        change -= fee;\n        for (const out of this.outputs) {\n            if (out.change !== true) {\n                if (out.satoshis !== undefined) {\n                    change -= out.satoshis;\n                }\n            }\n        }\n        return change;\n    }\n    distributeChange(change, changeDistribution) {\n        let distributedChange = 0;\n        const changeOutputs = this.outputs.filter((out) => out.change);\n        if (changeDistribution === 'random') {\n            distributedChange = this.distributeRandomChange(change, changeOutputs);\n        }\n        else if (changeDistribution === 'equal') {\n            distributedChange = this.distributeEqualChange(change, changeOutputs);\n        }\n        if (distributedChange < change) {\n            const lastOutput = this.outputs[this.outputs.length - 1];\n            if (lastOutput.satoshis !== undefined) {\n                lastOutput.satoshis += change - distributedChange;\n            }\n            else {\n                lastOutput.satoshis = change - distributedChange;\n            }\n        }\n    }\n    distributeRandomChange(change, changeOutputs) {\n        let distributedChange = 0;\n        let changeToUse = change;\n        const benfordNumbers = Array(changeOutputs.length).fill(1);\n        changeToUse -= changeOutputs.length;\n        distributedChange += changeOutputs.length;\n        for (let i = 0; i < changeOutputs.length - 1; i++) {\n            const portion = this.benfordNumber(0, changeToUse);\n            benfordNumbers[i] = benfordNumbers[i] + portion;\n            distributedChange += portion;\n            changeToUse -= portion;\n        }\n        for (const output of this.outputs) {\n            if (output.change === true)\n                output.satoshis = benfordNumbers.shift();\n        }\n        return distributedChange;\n    }\n    distributeEqualChange(change, changeOutputs) {\n        let distributedChange = 0;\n        const perOutput = Math.floor(change / changeOutputs.length);\n        for (const out of changeOutputs) {\n            distributedChange += perOutput;\n            out.satoshis = perOutput;\n        }\n        return distributedChange;\n    }\n    benfordNumber(min, max) {\n        const d = Math.floor(Math.random() * 9) + 1;\n        return Math.floor(min + ((max - min) * Math.log10(1 + 1 / d)) / Math.log10(10));\n    }\n    /**\n     * Utility method that returns the current fee based on inputs and outputs\n     *\n     * @returns The current transaction fee\n     */\n    getFee() {\n        let totalIn = 0;\n        for (const input of this.inputs) {\n            if (typeof input.sourceTransaction !== 'object') {\n                throw new Error('Source transactions or sourceSatoshis are required for all inputs to calculate fee');\n            }\n            totalIn +=\n                input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis ?? 0;\n        }\n        let totalOut = 0;\n        for (const output of this.outputs) {\n            totalOut += output.satoshis ?? 0;\n        }\n        return totalIn - totalOut;\n    }\n    /**\n     * Signs a transaction, hydrating all its unlocking scripts based on the provided script templates where they are available.\n     */\n    async sign() {\n        this.cachedHash = undefined;\n        for (const out of this.outputs) {\n            if (typeof out.satoshis === 'undefined') {\n                if (out.change === true) {\n                    throw new Error('There are still change outputs with uncomputed amounts. Use the fee() method to compute the change amounts and transaction fees prior to signing.');\n                }\n                else {\n                    throw new Error('One or more transaction outputs is missing an amount. Ensure all output amounts are provided before signing.');\n                }\n            }\n        }\n        const unlockingScripts = await Promise.all(this.inputs.map(async (x, i) => {\n            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {\n                return await this.inputs[i]?.unlockingScriptTemplate?.sign(this, i);\n            }\n            else {\n                return await Promise.resolve(undefined);\n            }\n        }));\n        for (let i = 0, l = this.inputs.length; i < l; i++) {\n            if (typeof this.inputs[i].unlockingScriptTemplate === 'object') {\n                this.inputs[i].unlockingScript = unlockingScripts[i];\n            }\n        }\n    }\n    /**\n     * Broadcasts a transaction.\n     *\n     * @param broadcaster The Broadcaster instance wwhere the transaction will be sent\n     * @returns A BroadcastResponse or BroadcastFailure from the Broadcaster\n     */\n    async broadcast(broadcaster = (0,_broadcasters_DefaultBroadcaster_js__WEBPACK_IMPORTED_MODULE_6__.defaultBroadcaster)()) {\n        return await broadcaster.broadcast(this);\n    }\n    /**\n     * Converts the transaction to a binary array format.\n     *\n     * @returns {number[]} - The binary array representation of the transaction.\n     */\n    toBinary() {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        writer.writeUInt32LE(this.version);\n        writer.writeVarIntNum(this.inputs.length);\n        for (const i of this.inputs) {\n            if (typeof i.sourceTXID === 'undefined') {\n                if (i.sourceTransaction != null) {\n                    writer.write(i.sourceTransaction.hash());\n                }\n                else {\n                    throw new Error('sourceTransaction is undefined');\n                }\n            }\n            else {\n                writer.writeReverse((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(i.sourceTXID, 'hex'));\n            }\n            writer.writeUInt32LE(i.sourceOutputIndex);\n            if (i.unlockingScript == null) {\n                throw new Error('unlockingScript is undefined');\n            }\n            const scriptBin = i.unlockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n            writer.writeUInt32LE(i.sequence ?? 0);\n        }\n        writer.writeVarIntNum(this.outputs.length);\n        for (const o of this.outputs) {\n            writer.writeUInt64LE(o.satoshis ?? 0);\n            const scriptBin = o.lockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n        }\n        writer.writeUInt32LE(this.lockTime);\n        return writer.toArray();\n    }\n    /**\n     * Converts the transaction to a BRC-30 EF format.\n     *\n     * @returns {number[]} - The BRC-30 EF representation of the transaction.\n     */\n    toEF() {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        writer.writeUInt32LE(this.version);\n        writer.write([0, 0, 0, 0, 0, 0xef]);\n        writer.writeVarIntNum(this.inputs.length);\n        for (const i of this.inputs) {\n            if (typeof i.sourceTransaction === 'undefined') {\n                throw new Error('All inputs must have source transactions when serializing to EF format');\n            }\n            if (typeof i.sourceTXID === 'undefined') {\n                writer.write(i.sourceTransaction.hash());\n            }\n            else {\n                writer.write((0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray)(i.sourceTXID, 'hex').reverse());\n            }\n            writer.writeUInt32LE(i.sourceOutputIndex);\n            if (i.unlockingScript == null) {\n                throw new Error('unlockingScript is undefined');\n            }\n            const scriptBin = i.unlockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n            writer.writeUInt32LE(i.sequence ?? 0);\n            writer.writeUInt64LE(i.sourceTransaction.outputs[i.sourceOutputIndex].satoshis ?? 0);\n            const lockingScriptBin = i.sourceTransaction.outputs[i.sourceOutputIndex].lockingScript.toBinary();\n            writer.writeVarIntNum(lockingScriptBin.length);\n            writer.write(lockingScriptBin);\n        }\n        writer.writeVarIntNum(this.outputs.length);\n        for (const o of this.outputs) {\n            writer.writeUInt64LE(o.satoshis ?? 0);\n            const scriptBin = o.lockingScript.toBinary();\n            writer.writeVarIntNum(scriptBin.length);\n            writer.write(scriptBin);\n        }\n        writer.writeUInt32LE(this.lockTime);\n        return writer.toArray();\n    }\n    /**\n     * Converts the transaction to a hexadecimal string EF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction EF.\n     */\n    toHexEF() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(this.toEF());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string format.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction.\n     */\n    toHex() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(this.toBinary());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string BEEF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction BEEF.\n     */\n    toHexBEEF() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(this.toBEEF());\n    }\n    /**\n     * Converts the transaction to a hexadecimal string Atomic BEEF.\n     *\n     * @returns {string} - The hexadecimal string representation of the transaction Atomic BEEF.\n     */\n    toHexAtomicBEEF() {\n        return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(this.toAtomicBEEF());\n    }\n    /**\n     * Calculates the transaction's hash.\n     *\n     * @param {'hex' | undefined} enc - The encoding to use for the hash. If 'hex', returns a hexadecimal string; otherwise returns a binary array.\n     * @returns {string | number[]} - The hash of the transaction in the specified format.\n     */\n    hash(enc) {\n        let hash;\n        if (this.cachedHash != null) {\n            hash = this.cachedHash;\n        }\n        else {\n            hash = (0,_primitives_Hash_js__WEBPACK_IMPORTED_MODULE_3__.hash256)(this.toBinary());\n            this.cachedHash = hash;\n        }\n        if (enc === 'hex') {\n            return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(hash);\n        }\n        return hash;\n    }\n    /**\n     * Calculates the transaction's ID.\n     *\n     * @param {'hex' | undefined} enc - The encoding to use for the ID. If 'hex', returns a hexadecimal string; otherwise returns a binary array.\n     * @returns {string | number[]} - The ID of the transaction in the specified format.\n     */\n    id(enc) {\n        const id = [...this.hash()];\n        id.reverse();\n        if (enc === 'hex') {\n            return (0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)(id);\n        }\n        return id;\n    }\n    /**\n     * Verifies the legitimacy of the Bitcoin transaction according to the rules of SPV by ensuring all the input transactions link back to valid block headers, the chain of spends for all inputs are valid, and the sum of inputs is not less than the sum of outputs.\n     *\n     * @param chainTracker - An instance of ChainTracker, a Bitcoin block header tracker. If the value is set to 'scripts only', headers will not be verified. If not provided then the default chain tracker will be used.\n     * @param feeModel - An instance of FeeModel, a fee model to use for fee calculation. If not provided then the default fee model will be used.\n     * @param memoryLimit - The maximum memory in bytes usage allowed for script evaluation. If not provided then the default memory limit will be used.\n     *\n     * @returns Whether the transaction is valid according to the rules of SPV.\n     *\n     * @example tx.verify(new WhatsOnChain(), new SatoshisPerKilobyte(1))\n     */\n    async verify(chainTracker = (0,_chaintrackers_DefaultChainTracker_js__WEBPACK_IMPORTED_MODULE_7__.defaultChainTracker)(), feeModel, memoryLimit) {\n        const verifiedTxids = new Set();\n        const txQueue = [this];\n        while (txQueue.length > 0) {\n            const tx = txQueue.shift();\n            const txid = tx?.id('hex') ?? '';\n            if (txid != null && txid !== '' && verifiedTxids.has(txid)) {\n                continue;\n            }\n            // If the transaction has a valid merkle path, verification is complete.\n            if (typeof tx?.merklePath === 'object') {\n                if (chainTracker === 'scripts only') {\n                    if (txid != null) {\n                        verifiedTxids.add(txid);\n                    }\n                    continue;\n                }\n                else {\n                    const proofValid = await tx.merklePath.verify(txid, chainTracker);\n                    // If the proof is valid, no need to verify inputs.\n                    if (proofValid) {\n                        verifiedTxids.add(txid);\n                        continue;\n                    }\n                }\n            }\n            // Verify fee if feeModel is provided\n            if (typeof feeModel !== 'undefined') {\n                if (tx === undefined) {\n                    throw new Error('Transaction is undefined');\n                }\n                const cpTx = Transaction.fromEF(tx.toEF());\n                delete cpTx.outputs[0].satoshis;\n                cpTx.outputs[0].change = true;\n                await cpTx.fee(feeModel);\n                if (tx.getFee() < cpTx.getFee()) {\n                    throw new Error(`Verification failed because the transaction ${txid} has an insufficient fee and has not been mined.`);\n                }\n            }\n            // Verify each input transaction and evaluate the spend events.\n            // Also, keep a total of the input amounts for later.\n            let inputTotal = 0;\n            if (tx === undefined) {\n                throw new Error('Transaction is undefined');\n            }\n            for (let i = 0; i < tx.inputs.length; i++) {\n                const input = tx.inputs[i];\n                if (typeof input.sourceTransaction !== 'object') {\n                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated source transaction. This source transaction is required for transaction verification because there is no merkle proof for the transaction spending a UTXO it contains.`);\n                }\n                if (typeof input.unlockingScript !== 'object') {\n                    throw new Error(`Verification failed because the input at index ${i} of transaction ${txid} is missing an associated unlocking script. This script is required for transaction verification because there is no merkle proof for the transaction spending the UTXO.`);\n                }\n                const sourceOutput = input.sourceTransaction.outputs[input.sourceOutputIndex];\n                inputTotal += sourceOutput.satoshis ?? 0;\n                const sourceTxid = input.sourceTransaction.id('hex');\n                if (!verifiedTxids.has(sourceTxid)) {\n                    txQueue.push(input.sourceTransaction);\n                }\n                const otherInputs = tx.inputs.filter((_, idx) => idx !== i);\n                if (typeof input.sourceTXID === 'undefined') {\n                    input.sourceTXID = sourceTxid;\n                }\n                const spend = new _script_Spend_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n                    sourceTXID: input.sourceTXID,\n                    sourceOutputIndex: input.sourceOutputIndex,\n                    lockingScript: sourceOutput.lockingScript,\n                    sourceSatoshis: sourceOutput.satoshis ?? 0,\n                    transactionVersion: tx.version,\n                    otherInputs,\n                    unlockingScript: input.unlockingScript,\n                    inputSequence: input.sequence ?? 0,\n                    inputIndex: i,\n                    outputs: tx.outputs,\n                    lockTime: tx.lockTime,\n                    memoryLimit\n                });\n                const spendValid = spend.validate();\n                if (!spendValid) {\n                    return false;\n                }\n            }\n            // Total the outputs to ensure they don't amount to more than the inputs\n            let outputTotal = 0;\n            for (const out of tx.outputs) {\n                if (typeof out.satoshis !== 'number') {\n                    throw new Error('Every output must have a defined amount during transaction verification.');\n                }\n                outputTotal += out.satoshis;\n            }\n            if (outputTotal > inputTotal) {\n                return false;\n            }\n            verifiedTxids.add(txid);\n        }\n        return true;\n    }\n    /**\n     * Serializes this transaction, together with its inputs and the respective merkle proofs, into the BEEF (BRC-62) format. This enables efficient verification of its compliance with the rules of SPV.\n     *\n     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.\n     *\n     * @returns The serialized BEEF structure\n     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.\n     */\n    toBEEF(allowPartial) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        writer.writeUInt32LE(_Beef_js__WEBPACK_IMPORTED_MODULE_8__.BEEF_V1);\n        const BUMPs = [];\n        const txs = [];\n        // Recursive function to add paths and input transactions for a TX\n        const addPathsAndInputs = (tx) => {\n            const obj = { tx };\n            const hasProof = typeof tx.merklePath === 'object';\n            if (hasProof) {\n                let added = false;\n                // If this proof is identical to another one previously added, we use that first. Otherwise, we try to merge it with proofs from the same block.\n                for (let i = 0; i < BUMPs.length; i++) {\n                    if (BUMPs[i] === tx.merklePath) {\n                        // Literally the same\n                        obj.pathIndex = i;\n                        added = true;\n                        break;\n                    }\n                    if (tx.merklePath !== null && tx.merklePath !== undefined && BUMPs[i].blockHeight === tx.merklePath.blockHeight) {\n                        // Probably the same...\n                        const rootA = BUMPs[i].computeRoot();\n                        const rootB = tx.merklePath.computeRoot();\n                        if (rootA === rootB) {\n                            // Definitely the same... combine them to save space\n                            BUMPs[i].combine(tx.merklePath);\n                            obj.pathIndex = i;\n                            added = true;\n                            break;\n                        }\n                    }\n                }\n                // Finally, if the proof is not yet added, add a new path.\n                if (!added) {\n                    obj.pathIndex = BUMPs.length;\n                    if (tx.merklePath !== null && tx.merklePath !== undefined) {\n                        BUMPs.push(tx.merklePath);\n                    }\n                }\n            }\n            const duplicate = txs.some((x) => x.tx.id('hex') === tx.id('hex'));\n            if (!duplicate) {\n                txs.unshift(obj);\n            }\n            if (!hasProof) {\n                for (let i = 0; i < tx.inputs.length; i++) {\n                    const input = tx.inputs[i];\n                    if (typeof input.sourceTransaction === 'object') {\n                        addPathsAndInputs(input.sourceTransaction);\n                    }\n                    else if (allowPartial === false) {\n                        throw new Error('A required source transaction is missing!');\n                    }\n                }\n            }\n        };\n        addPathsAndInputs(this);\n        writer.writeVarIntNum(BUMPs.length);\n        for (const b of BUMPs) {\n            writer.write(b.toBinary());\n        }\n        writer.writeVarIntNum(txs.length);\n        for (const t of txs) {\n            writer.write(t.tx.toBinary());\n            if (typeof t.pathIndex === 'number') {\n                writer.writeUInt8(1);\n                writer.writeVarIntNum(t.pathIndex);\n            }\n            else {\n                writer.writeUInt8(0);\n            }\n        }\n        return writer.toArray();\n    }\n    /**\n     * Serializes this transaction and its inputs into the Atomic BEEF (BRC-95) format.\n     * The Atomic BEEF format starts with a 4-byte prefix `0x01010101`, followed by the TXID of the subject transaction,\n     * and then the BEEF data containing only the subject transaction and its dependencies.\n     * This format ensures that the BEEF structure is atomic and contains no unrelated transactions.\n     *\n     * @param allowPartial If true, error will not be thrown if there are any missing sourceTransactions.\n     *\n     * @returns {number[]} - The serialized Atomic BEEF structure.\n     * @throws Error if there are any missing sourceTransactions unless `allowPartial` is true.\n     */\n    toAtomicBEEF(allowPartial) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        // Write the Atomic BEEF prefix\n        writer.writeUInt32LE(0x01010101);\n        // Write the subject TXID (big-endian)\n        writer.write(this.hash());\n        // Append the BEEF data\n        const beefData = this.toBEEF(allowPartial);\n        writer.write(beefData);\n        return writer.toArray();\n    }\n}\n//# sourceMappingURL=Transaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ARC)\n/* harmony export */ });\n/* harmony import */ var _http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js\");\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\n\nfunction defaultDeploymentId() {\n    return `ts-sdk-${(0,_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex)((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(16))}`;\n}\n/**\n * Represents an ARC transaction broadcaster.\n */\nclass ARC {\n    URL;\n    apiKey;\n    deploymentId;\n    callbackUrl;\n    callbackToken;\n    headers;\n    httpClient;\n    constructor(URL, config) {\n        this.URL = URL;\n        if (typeof config === 'string') {\n            this.apiKey = config;\n            this.httpClient = (0,_http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)();\n            this.deploymentId = defaultDeploymentId();\n            this.callbackToken = undefined;\n            this.callbackUrl = undefined;\n        }\n        else {\n            const configObj = config ?? {};\n            const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = configObj;\n            this.apiKey = apiKey;\n            this.httpClient = httpClient ?? (0,_http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)();\n            this.deploymentId = deploymentId ?? defaultDeploymentId();\n            this.callbackToken = callbackToken;\n            this.callbackUrl = callbackUrl;\n            this.headers = headers;\n        }\n    }\n    /**\n     * Constructs a dictionary of the default & supplied request headers.\n     */\n    requestHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'XDeployment-ID': this.deploymentId\n        };\n        if (this.apiKey != null && this.apiKey !== '') {\n            headers.Authorization = `Bearer ${this.apiKey}`;\n        }\n        if (this.callbackUrl != null && this.callbackUrl !== '') {\n            headers['X-CallbackUrl'] = this.callbackUrl;\n        }\n        if (this.callbackToken != null && this.callbackToken !== '') {\n            headers['X-CallbackToken'] = this.callbackToken;\n        }\n        if (this.headers != null) {\n            for (const key in this.headers) {\n                headers[key] = this.headers[key];\n            }\n        }\n        return headers;\n    }\n    /**\n     * Broadcasts a transaction via ARC.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        let rawTx;\n        try {\n            rawTx = tx.toHexEF();\n        }\n        catch (error) {\n            if (error.message ===\n                'All inputs must have source transactions when serializing to EF format') {\n                rawTx = tx.toHex();\n            }\n            else {\n                throw error;\n            }\n        }\n        const requestOptions = {\n            method: 'POST',\n            headers: this.requestHeaders(),\n            data: { rawTx }\n        };\n        try {\n            const response = await this.httpClient.request(`${this.URL}/v1/tx`, requestOptions);\n            if (response.ok) {\n                const { txid, extraInfo, txStatus, competingTxs } = response.data;\n                const broadcastRes = {\n                    status: 'success',\n                    txid,\n                    message: `${txStatus} ${extraInfo}`\n                };\n                if (competingTxs != null) {\n                    broadcastRes.competingTxs = competingTxs;\n                }\n                return broadcastRes;\n            }\n            else {\n                const st = typeof response.status;\n                const r = {\n                    status: 'error',\n                    code: st === 'number' || st === 'string'\n                        ? response.status.toString()\n                        : 'ERR_UNKNOWN',\n                    description: 'Unknown error'\n                };\n                let d = response.data;\n                if (typeof d === 'string') {\n                    try {\n                        d = JSON.parse(response.data);\n                    }\n                    catch {\n                        // Intentionally left empty\n                    }\n                }\n                if (typeof d === 'object') {\n                    if (d !== null) {\n                        r.more = d;\n                    }\n                    if ((d != null) && typeof d.txid === 'string') {\n                        r.txid = d.txid;\n                    }\n                    if ((d != null) && 'detail' in d && typeof d.detail === 'string') {\n                        r.description = d.detail;\n                    }\n                }\n                return r;\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n    /**\n     * Broadcasts multiple transactions via ARC.\n     * Handles mixed responses where some transactions succeed and others fail.\n     *\n     * @param {Transaction[]} txs - Array of transactions to be broadcasted.\n     * @returns {Promise<Array<object>>} A promise that resolves to an array of objects.\n     */\n    async broadcastMany(txs) {\n        const rawTxs = txs.map((tx) => {\n            try {\n                return { rawTx: tx.toHexEF() };\n            }\n            catch (error) {\n                if (error.message ===\n                    'All inputs must have source transactions when serializing to EF format') {\n                    return { rawTx: tx.toHex() };\n                }\n                throw error;\n            }\n        });\n        const requestOptions = {\n            method: 'POST',\n            headers: this.requestHeaders(),\n            data: rawTxs\n        };\n        try {\n            const response = await this.httpClient.request(`${this.URL}/v1/txs`, requestOptions);\n            return response.data;\n        }\n        catch (error) {\n            const errorResponse = {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string' ? error.message : 'Internal Server Error'\n            };\n            return txs.map(() => errorResponse);\n        }\n    }\n}\n//# sourceMappingURL=ARC.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultBroadcaster: () => (/* binding */ defaultBroadcaster)\n/* harmony export */ });\n/* harmony import */ var _ARC_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ARC.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js\");\n\nfunction defaultBroadcaster(isTestnet = false, config = {}) {\n    return new _ARC_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](isTestnet ? 'https://testnet.arc.gorillapool.io' : 'https://arc.gorillapool.io', config);\n}\n//# sourceMappingURL=DefaultBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/Teranode.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/Teranode.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Teranode)\n/* harmony export */ });\n/* harmony import */ var _http_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../http/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/index.js\");\n\n/**\n * Represents an Teranode transaction broadcaster.\n */\nclass Teranode {\n    URL;\n    httpClient;\n    /**\n     * Constructs an instance of the Teranode broadcaster.\n     *\n     * @param {string} URL - The URL endpoint for the Teranode API.\n     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API, binaryHttpClient by default.\n     */\n    constructor(URL, httpClient = (0,_http_index_js__WEBPACK_IMPORTED_MODULE_0__.binaryHttpClient)()) {\n        this.URL = URL;\n        this.httpClient = httpClient;\n    }\n    /**\n     * Broadcasts a transaction via Teranode.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        const rawTx = tx.toEF();\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/octet-stream'\n            },\n            data: new Blob([new Uint8Array(rawTx)])\n        };\n        try {\n            const response = await this.httpClient.request(this.URL, requestOptions);\n            if (response.ok) {\n                const txid = tx.id('hex');\n                return {\n                    status: 'success',\n                    txid,\n                    message: 'broadcast successful'\n                };\n            }\n            else {\n                return {\n                    status: 'error',\n                    code: response.status.toString() ?? 'ERR_UNKNOWN',\n                    description: response.data ?? 'Unknown error'\n                };\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n}\n//# sourceMappingURL=Teranode.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/Teranode.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/WhatsOnChainBroadcaster.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/WhatsOnChainBroadcaster.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WhatsOnChainBroadcaster)\n/* harmony export */ });\n/* harmony import */ var _http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js\");\n\n/**\n * Represents an WhatsOnChain transaction broadcaster.\n */\nclass WhatsOnChainBroadcaster {\n    network;\n    URL;\n    httpClient;\n    /**\n     * Constructs an instance of the WhatsOnChain broadcaster.\n     *\n     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.\n     * @param {HttpClient} httpClient - The HTTP client used to make requests to the API.\n     */\n    constructor(network = 'main', httpClient = (0,_http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)()) {\n        this.network = network;\n        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}/tx/raw`;\n        this.httpClient = httpClient;\n    }\n    /**\n     * Broadcasts a transaction via WhatsOnChain.\n     *\n     * @param {Transaction} tx - The transaction to be broadcasted.\n     * @returns {Promise<BroadcastResponse | BroadcastFailure>} A promise that resolves to either a success or failure response.\n     */\n    async broadcast(tx) {\n        const rawTx = tx.toHex();\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                Accept: 'text/plain'\n            },\n            data: { txhex: rawTx }\n        };\n        try {\n            const response = await this.httpClient.request(this.URL, requestOptions);\n            if (response.ok) {\n                const txid = response.data;\n                return {\n                    status: 'success',\n                    txid,\n                    message: 'broadcast successful'\n                };\n            }\n            else {\n                return {\n                    status: 'error',\n                    code: response.status.toString() ?? 'ERR_UNKNOWN',\n                    description: response.data ?? 'Unknown error'\n                };\n            }\n        }\n        catch (error) {\n            return {\n                status: 'error',\n                code: '500',\n                description: typeof error.message === 'string'\n                    ? error.message\n                    : 'Internal Server Error'\n            };\n        }\n    }\n}\n//# sourceMappingURL=WhatsOnChainBroadcaster.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/WhatsOnChainBroadcaster.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ARC: () => (/* reexport safe */ _ARC_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   Teranode: () => (/* reexport safe */ _Teranode_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   WhatsOnChainBroadcaster: () => (/* reexport safe */ _WhatsOnChainBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   defaultBroadcaster: () => (/* reexport safe */ _DefaultBroadcaster_js__WEBPACK_IMPORTED_MODULE_3__.defaultBroadcaster)\n/* harmony export */ });\n/* harmony import */ var _ARC_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ARC.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/ARC.js\");\n/* harmony import */ var _WhatsOnChainBroadcaster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WhatsOnChainBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/WhatsOnChainBroadcaster.js\");\n/* harmony import */ var _Teranode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Teranode.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/Teranode.js\");\n/* harmony import */ var _DefaultBroadcaster_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DefaultBroadcaster.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/DefaultBroadcaster.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/broadcasters/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/BlockHeadersService.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/BlockHeadersService.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockHeadersService: () => (/* binding */ BlockHeadersService)\n/* harmony export */ });\n/* harmony import */ var _http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js\");\n\n/**\n * Represents a chain tracker based on a BlockHeadersService API.\n *\n * @example\n * ```typescript\n * const chainTracker = new BlockHeadersService('https://headers.spv.money', {\n *   apiKey: '17JxRHcJerGBEbusx56W8o1m8Js73TFGo'\n * })\n * ```\n */\nclass BlockHeadersService {\n    baseUrl;\n    httpClient;\n    apiKey;\n    /**\n     * Constructs an instance of the BlockHeadersService ChainTracker.\n     *\n     * @param {string} baseUrl - The base URL for the BlockHeadersService API (e.g. https://headers.spv.money)\n     * @param {BlockHeadersServiceConfig} config - Configuration options for the BlockHeadersService ChainTracker.\n     */\n    constructor(baseUrl, config = {}) {\n        const { httpClient, apiKey } = config;\n        this.baseUrl = baseUrl;\n        this.httpClient = httpClient ?? (0,_http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)();\n        this.apiKey = apiKey ?? '';\n    }\n    /**\n     * Verifies if a given merkle root is valid for a specific block height.\n     *\n     * @param {string} root - The merkle root to verify.\n     * @param {number} height - The block height to check against.\n     * @returns {Promise<boolean>} - A promise that resolves to true if the merkle root is valid for the specified block height, false otherwise.\n     */\n    async isValidRootForHeight(root, height) {\n        const requestOptions = {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`\n            },\n            data: [\n                {\n                    blockHeight: height,\n                    merkleRoot: root\n                }\n            ]\n        };\n        try {\n            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/merkleroot/verify`, requestOptions);\n            if (response.ok) {\n                return response.data.confirmationState === 'CONFIRMED';\n            }\n            else {\n                throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    /**\n     * Gets the current block height from the BlockHeadersService API.\n     *\n     * @returns {Promise<number>} - A promise that resolves to the current block height.\n     */\n    async currentHeight() {\n        const requestOptions = {\n            method: 'GET',\n            headers: {\n                'Accept': 'application/json',\n                'Authorization': `Bearer ${this.apiKey}`\n            }\n        };\n        try {\n            const response = await this.httpClient.request(`${this.baseUrl}/api/v1/chain/tip/longest`, requestOptions);\n            if (response.ok && response.data && typeof response.data.height === 'number') {\n                return response.data.height;\n            }\n            else {\n                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)}`);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n}\n//# sourceMappingURL=BlockHeadersService.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/BlockHeadersService.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultChainTracker: () => (/* binding */ defaultChainTracker)\n/* harmony export */ });\n/* harmony import */ var _WhatsOnChain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WhatsOnChain.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js\");\n\nfunction defaultChainTracker() {\n    return new _WhatsOnChain_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n}\n//# sourceMappingURL=DefaultChainTracker.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WhatsOnChain)\n/* harmony export */ });\n/* harmony import */ var _http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../http/DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js\");\n\n/**\n * Represents a chain tracker based on What's On Chain .\n */\nclass WhatsOnChain {\n    network;\n    apiKey;\n    URL;\n    httpClient;\n    /**\n     * Constructs an instance of the WhatsOnChain ChainTracker.\n     *\n     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.\n     * @param {WhatsOnChainConfig} config - Configuration options for the WhatsOnChain ChainTracker.\n     */\n    constructor(network = 'main', config = {}) {\n        const { apiKey, httpClient } = config;\n        this.network = network;\n        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}`;\n        this.httpClient = httpClient ?? (0,_http_DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)();\n        this.apiKey = apiKey ?? '';\n    }\n    async isValidRootForHeight(root, height) {\n        const requestOptions = {\n            method: 'GET',\n            headers: this.getHttpHeaders()\n        };\n        const response = await this.httpClient.request(`${this.URL}/block/${height}/header`, requestOptions);\n        if (response.ok) {\n            const { merkleroot } = response.data;\n            return merkleroot === root;\n        }\n        else if (response.status === 404) {\n            return false;\n        }\n        else {\n            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)} `);\n        }\n    }\n    async currentHeight() {\n        try {\n            const requestOptions = {\n                method: 'GET',\n                headers: this.getHttpHeaders()\n            };\n            const response = await this.httpClient.request(`${this.URL}/block/headers`, requestOptions);\n            if (response.ok) {\n                return response.data[0].height;\n            }\n            else {\n                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)} `);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    getHttpHeaders() {\n        const headers = {\n            Accept: 'application/json'\n        };\n        if (typeof this.apiKey === 'string' && this.apiKey.trim() !== '') {\n            headers.Authorization = this.apiKey;\n        }\n        return headers;\n    }\n}\n//# sourceMappingURL=WhatsOnChain.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/index.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BlockHeadersService: () => (/* reexport safe */ _BlockHeadersService_js__WEBPACK_IMPORTED_MODULE_1__.BlockHeadersService),\n/* harmony export */   WhatsOnChain: () => (/* reexport safe */ _WhatsOnChain_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   defaultChainTracker: () => (/* reexport safe */ _DefaultChainTracker_js__WEBPACK_IMPORTED_MODULE_2__.defaultChainTracker)\n/* harmony export */ });\n/* harmony import */ var _WhatsOnChain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WhatsOnChain.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/WhatsOnChain.js\");\n/* harmony import */ var _BlockHeadersService_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BlockHeadersService.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/BlockHeadersService.js\");\n/* harmony import */ var _DefaultChainTracker_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DefaultChainTracker.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/DefaultChainTracker.js\");\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/chaintrackers/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SatoshisPerKilobyte)\n/* harmony export */ });\n/**\n * Represents the \"satoshis per kilobyte\" transaction fee model.\n */\nclass SatoshisPerKilobyte {\n    /**\n     * @property\n     * Denotes the number of satoshis paid per kilobyte of transaction size.\n     */\n    value;\n    /**\n     * Constructs an instance of the sat/kb fee model.\n     *\n     * @param {number} value - The number of satoshis per kilobyte to charge as a fee.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n    /**\n     * Computes the fee for a given transaction.\n     *\n     * @param tx The transaction for which a fee is to be computed.\n     * @returns The fee in satoshis for the transaction, as a BigNumber.\n     */\n    async computeFee(tx) {\n        const getVarIntSize = (i) => {\n            if (i > 2 ** 32) {\n                return 9;\n            }\n            else if (i > 2 ** 16) {\n                return 5;\n            }\n            else if (i > 253) {\n                return 3;\n            }\n            else {\n                return 1;\n            }\n        };\n        // Compute the (potentially estimated) size of the transaction\n        let size = 4; // version\n        size += getVarIntSize(tx.inputs.length); // number of inputs\n        for (let i = 0; i < tx.inputs.length; i++) {\n            const input = tx.inputs[i];\n            size += 40; // txid, output index, sequence number\n            let scriptLength;\n            if (typeof input.unlockingScript === 'object') {\n                scriptLength = input.unlockingScript.toBinary().length;\n            }\n            else if (typeof input.unlockingScriptTemplate === 'object') {\n                scriptLength = await input.unlockingScriptTemplate.estimateLength(tx, i);\n            }\n            else {\n                throw new Error('All inputs must have an unlocking script or an unlocking script template for sat/kb fee computation.');\n            }\n            size += getVarIntSize(scriptLength); // unlocking script length\n            size += scriptLength; // unlocking script\n        }\n        size += getVarIntSize(tx.outputs.length); // number of outputs\n        for (const out of tx.outputs) {\n            size += 8; // satoshis\n            const length = out.lockingScript.toBinary().length;\n            size += getVarIntSize(length); // script length\n            size += length; // script\n        }\n        size += 4; // lock time\n        // We'll use Math.ceil to ensure the miners get the extra satoshi.\n        const fee = Math.ceil((size / 1000) * this.value);\n        return fee;\n    }\n}\n//# sourceMappingURL=SatoshisPerKilobyte.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SatoshisPerKilobyte: () => (/* reexport safe */ _SatoshisPerKilobyte_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _SatoshisPerKilobyte_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SatoshisPerKilobyte.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/SatoshisPerKilobyte.js\");\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/fee-models/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/http/BinaryFetchClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/http/BinaryFetchClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BinaryFetchClient: () => (/* binding */ BinaryFetchClient),\n/* harmony export */   BinaryNodejsHttpClient: () => (/* binding */ BinaryNodejsHttpClient),\n/* harmony export */   binaryHttpClient: () => (/* binding */ binaryHttpClient)\n/* harmony export */ });\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass BinaryNodejsHttpClient {\n    https;\n    constructor(https) {\n        this.https = https;\n    }\n    async request(url, requestOptions) {\n        return await new Promise((resolve, reject) => {\n            const req = this.https.request(url, requestOptions, (res) => {\n                let body = '';\n                res.on('data', (chunk) => {\n                    body += chunk;\n                });\n                res.on('end', () => {\n                    const ok = res.statusCode >= 200 && res.statusCode <= 299;\n                    const mediaType = res.headers['content-type'];\n                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')\n                        ? JSON.parse(body)\n                        : body;\n                    resolve({\n                        status: res.statusCode,\n                        statusText: res.statusMessage,\n                        ok,\n                        data\n                    });\n                });\n            });\n            req.on('error', (error) => {\n                reject(error);\n            });\n            if (requestOptions.data !== null && requestOptions.data !== undefined) {\n                req.write(Buffer.from(requestOptions.data));\n            }\n            req.end();\n        });\n    }\n}\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass BinaryFetchClient {\n    fetch;\n    constructor(fetch) {\n        this.fetch = fetch;\n    }\n    async request(url, options) {\n        const fetchOptions = {\n            method: options.method,\n            headers: options.headers,\n            body: options.data\n        };\n        const res = await this.fetch(url, fetchOptions);\n        const data = await res.text();\n        return {\n            ok: res.ok,\n            status: res.status,\n            statusText: res.statusText,\n            data: data\n        };\n    }\n}\nfunction binaryHttpClient() {\n    const noHttpClient = {\n        async request(..._) {\n            throw new Error('No method available to perform HTTP request');\n        }\n    };\n    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {\n        // Use fetch in a browser environment\n        return new BinaryFetchClient(window.fetch.bind(window));\n    }\n    else if (typeof require !== 'undefined') {\n        // Use Node https module\n        // eslint-disable-next-line\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const https = require('https');\n            return new BinaryNodejsHttpClient(https);\n        }\n        catch (e) {\n            return noHttpClient;\n        }\n    }\n    else {\n        return noHttpClient;\n    }\n}\n//# sourceMappingURL=BinaryFetchClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/http/BinaryFetchClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultHttpClient: () => (/* binding */ defaultHttpClient)\n/* harmony export */ });\n/* harmony import */ var _NodejsHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NodejsHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js\");\n/* harmony import */ var _FetchHttpClient_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FetchHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js\");\n\n\n/**\n * Returns a default HttpClient implementation based on the environment that it is run on.\n * This method will attempt to use `window.fetch` if available (in browser environments).\n * If running in a Node environment, it falls back to using the Node `https` module\n */\nfunction defaultHttpClient() {\n    const noHttpClient = {\n        async request(..._) {\n            throw new Error('No method available to perform HTTP request');\n        }\n    };\n    if (typeof window !== 'undefined' && typeof window.fetch === 'function') {\n        // Use fetch in a browser environment\n        return new _FetchHttpClient_js__WEBPACK_IMPORTED_MODULE_1__.FetchHttpClient(window.fetch.bind(window));\n    }\n    else if (typeof require !== 'undefined') {\n        // Use Node https module\n        // eslint-disable-next-line\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-var-requires\n            const https = require('https');\n            return new _NodejsHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.NodejsHttpClient(https);\n        }\n        catch (e) {\n            return noHttpClient;\n        }\n    }\n    else {\n        return noHttpClient;\n    }\n}\n//# sourceMappingURL=DefaultHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchHttpClient: () => (/* binding */ FetchHttpClient)\n/* harmony export */ });\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass FetchHttpClient {\n    fetch;\n    constructor(fetch) {\n        this.fetch = fetch;\n    }\n    async request(url, options) {\n        const fetchOptions = {\n            method: options.method,\n            headers: options.headers,\n            body: JSON.stringify(options.data)\n        };\n        const res = await this.fetch(url, fetchOptions);\n        const mediaType = res.headers.get('Content-Type');\n        const data = mediaType?.startsWith('application/json') ?? false\n            ? await res.json()\n            : await res.text();\n        return {\n            ok: res.ok,\n            status: res.status,\n            statusText: res.statusText,\n            data: data\n        };\n    }\n}\n//# sourceMappingURL=FetchHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodejsHttpClient: () => (/* binding */ NodejsHttpClient)\n/* harmony export */ });\n/**\n * Adapter for Node Https module to be used as HttpClient\n */\nclass NodejsHttpClient {\n    https;\n    constructor(https) {\n        this.https = https;\n    }\n    async request(url, requestOptions) {\n        return await new Promise((resolve, reject) => {\n            const req = this.https.request(url, requestOptions, (res) => {\n                let body = '';\n                res.on('data', (chunk) => {\n                    body += chunk;\n                });\n                res.on('end', () => {\n                    const ok = res.statusCode >= 200 && res.statusCode <= 299;\n                    const mediaType = res.headers['content-type'];\n                    const data = body !== '' && typeof mediaType === 'string' && mediaType.startsWith('application/json')\n                        ? JSON.parse(body)\n                        : body;\n                    resolve({\n                        status: res.statusCode,\n                        statusText: res.statusMessage,\n                        ok,\n                        data\n                    });\n                });\n            });\n            req.on('error', (error) => {\n                reject(error);\n            });\n            if (requestOptions.data !== null && requestOptions.data !== undefined) {\n                req.write(JSON.stringify(requestOptions.data));\n            }\n            req.end();\n        });\n    }\n}\n//# sourceMappingURL=NodejsHttpClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/http/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/http/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FetchHttpClient: () => (/* reexport safe */ _FetchHttpClient_js__WEBPACK_IMPORTED_MODULE_3__.FetchHttpClient),\n/* harmony export */   NodejsHttpClient: () => (/* reexport safe */ _NodejsHttpClient_js__WEBPACK_IMPORTED_MODULE_2__.NodejsHttpClient),\n/* harmony export */   binaryHttpClient: () => (/* reexport safe */ _BinaryFetchClient_js__WEBPACK_IMPORTED_MODULE_1__.binaryHttpClient),\n/* harmony export */   defaultHttpClient: () => (/* reexport safe */ _DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__.defaultHttpClient)\n/* harmony export */ });\n/* harmony import */ var _DefaultHttpClient_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DefaultHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/DefaultHttpClient.js\");\n/* harmony import */ var _BinaryFetchClient_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BinaryFetchClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/BinaryFetchClient.js\");\n/* harmony import */ var _NodejsHttpClient_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NodejsHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/NodejsHttpClient.js\");\n/* harmony import */ var _FetchHttpClient_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./FetchHttpClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/http/FetchHttpClient.js\");\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/http/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ATOMIC_BEEF: () => (/* reexport safe */ _Beef_js__WEBPACK_IMPORTED_MODULE_4__.ATOMIC_BEEF),\n/* harmony export */   BEEF_V1: () => (/* reexport safe */ _Beef_js__WEBPACK_IMPORTED_MODULE_4__.BEEF_V1),\n/* harmony export */   BEEF_V2: () => (/* reexport safe */ _Beef_js__WEBPACK_IMPORTED_MODULE_4__.BEEF_V2),\n/* harmony export */   Beef: () => (/* reexport safe */ _Beef_js__WEBPACK_IMPORTED_MODULE_4__.Beef),\n/* harmony export */   BeefParty: () => (/* reexport safe */ _BeefParty_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   BeefTx: () => (/* reexport safe */ _BeefTx_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   MerklePath: () => (/* reexport safe */ _MerklePath_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   TX_DATA_FORMAT: () => (/* reexport safe */ _Beef_js__WEBPACK_IMPORTED_MODULE_4__.TX_DATA_FORMAT),\n/* harmony export */   Transaction: () => (/* reexport safe */ _Transaction_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   isBroadcastFailure: () => (/* reexport safe */ _Broadcaster_js__WEBPACK_IMPORTED_MODULE_2__.isBroadcastFailure),\n/* harmony export */   isBroadcastResponse: () => (/* reexport safe */ _Broadcaster_js__WEBPACK_IMPORTED_MODULE_2__.isBroadcastResponse)\n/* harmony export */ });\n/* harmony import */ var _Transaction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Transaction.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Transaction.js\");\n/* harmony import */ var _MerklePath_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MerklePath.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/MerklePath.js\");\n/* harmony import */ var _Broadcaster_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Broadcaster.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Broadcaster.js\");\n/* harmony import */ var _BeefTx_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BeefTx.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefTx.js\");\n/* harmony import */ var _Beef_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Beef.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/Beef.js\");\n/* harmony import */ var _BeefParty_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./BeefParty.js */ \"./node_modules/@bsv/sdk/dist/esm/src/transaction/BeefParty.js\");\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/transaction/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/CachedKeyDeriver.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/CachedKeyDeriver.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CachedKeyDeriver)\n/* harmony export */ });\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n/* harmony import */ var _KeyDeriver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/KeyDeriver.js\");\n\n\n/**\n * A cached version of KeyDeriver that caches the results of key derivation methods.\n * This is useful for optimizing performance when the same keys are derived multiple times.\n * It supports configurable cache size with sane defaults and maintains cache entries using LRU (Least Recently Used) eviction policy.\n */\nclass CachedKeyDeriver {\n    keyDeriver;\n    cache;\n    maxCacheSize;\n    /**\n     * The root key from which all other keys are derived.\n     */\n    rootKey;\n    /**\n     * The identity of this key deriver which is normally the public key associated with the `rootKey`\n     */\n    identityKey;\n    /**\n     * Initializes the CachedKeyDeriver instance with a root private key and optional cache settings.\n     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.\n     * @param {Object} [options] - Optional settings for the cache.\n     * @param {number} [options.maxCacheSize=1000] - The maximum number of entries to store in the cache.\n     */\n    constructor(rootKey, options) {\n        if (rootKey === 'anyone') {\n            this.rootKey = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(1);\n        }\n        else {\n            this.rootKey = rootKey;\n        }\n        this.keyDeriver = new _KeyDeriver_js__WEBPACK_IMPORTED_MODULE_1__.KeyDeriver(this.rootKey, (priv, pub, point) => {\n            this.cacheSet(`${priv.toString()}-${pub.toString()}`, point);\n        }, (priv, pub) => {\n            return this.cacheGet(`${priv.toString()}-${pub.toString()}`);\n        });\n        this.identityKey = this.rootKey.toPublicKey().toString();\n        this.cache = new Map();\n        const maxCacheSize = options?.maxCacheSize;\n        this.maxCacheSize = (maxCacheSize != null && !isNaN(maxCacheSize) && maxCacheSize > 0) ? maxCacheSize : 1000;\n    }\n    /**\n     * Derives a public key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {boolean} [forSelf=false] - Whether deriving for self.\n     * @returns {PublicKey} - The derived public key.\n     */\n    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {\n        const cacheKey = this.generateCacheKey('derivePublicKey', protocolID, keyID, counterparty, forSelf);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.derivePublicKey(protocolID, keyID, counterparty, forSelf);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Derives a private key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PrivateKey} - The derived private key.\n     */\n    derivePrivateKey(protocolID, keyID, counterparty) {\n        const cacheKey = this.generateCacheKey('derivePrivateKey', protocolID, keyID, counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.derivePrivateKey(protocolID, keyID, counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Derives a symmetric key based on protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {SymmetricKey} - The derived symmetric key.\n     * @throws {Error} - Throws an error if attempting to derive a symmetric key for 'anyone'.\n     */\n    deriveSymmetricKey(protocolID, keyID, counterparty) {\n        const cacheKey = this.generateCacheKey('deriveSymmetricKey', protocolID, keyID, counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.deriveSymmetricKey(protocolID, keyID, counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Reveals the shared secret between the root key and the counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {number[]} - The shared secret as a number array.\n     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.\n     */\n    revealCounterpartySecret(counterparty) {\n        const cacheKey = this.generateCacheKey('revealCounterpartySecret', counterparty);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.revealCounterpartySecret(counterparty);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.\n     * Caches the result for future calls with the same parameters.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {number[]} - The specific key association as a number array.\n     */\n    revealSpecificSecret(counterparty, protocolID, keyID) {\n        const cacheKey = this.generateCacheKey('revealSpecificSecret', counterparty, protocolID, keyID);\n        if (this.cache.has(cacheKey)) {\n            const cachedValue = this.cacheGet(cacheKey);\n            if (cachedValue === undefined) {\n                throw new Error('Cached value is undefined');\n            }\n            return cachedValue;\n        }\n        else {\n            const result = this.keyDeriver.revealSpecificSecret(counterparty, protocolID, keyID);\n            this.cacheSet(cacheKey, result);\n            return result;\n        }\n    }\n    /**\n     * Generates a unique cache key based on the method name and input parameters.\n     * @param {string} methodName - The name of the method.\n     * @param {...any} args - The arguments passed to the method.\n     * @returns {string} - The generated cache key.\n     */\n    generateCacheKey(methodName, ...args) {\n        const serializedArgs = args\n            .map((arg) => this.serializeArgument(arg))\n            .join('|');\n        return `${methodName}|${serializedArgs}`;\n    }\n    /**\n     * Serializes an argument to a string for use in a cache key.\n     * @param {any} arg - The argument to serialize.\n     * @returns {string} - The serialized argument.\n     */\n    serializeArgument(arg) {\n        if (arg instanceof _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey || arg instanceof _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey) {\n            return arg.toString();\n        }\n        else if (Array.isArray(arg)) {\n            return arg.map((item) => this.serializeArgument(item)).join(',');\n        }\n        else if (typeof arg === 'object' && arg !== null) {\n            return JSON.stringify(arg);\n        }\n        else {\n            return String(arg);\n        }\n    }\n    /**\n     * Retrieves an item from the cache and updates its position to reflect recent use.\n     * @param {string} cacheKey - The key of the cached item.\n     * @returns {any} - The cached value.\n     */\n    cacheGet(cacheKey) {\n        const value = this.cache.get(cacheKey);\n        // Update the entry to reflect recent use\n        this.cache.delete(cacheKey);\n        if (value !== undefined) {\n            this.cache.set(cacheKey, value);\n        }\n        return value;\n    }\n    /**\n     * Adds an item to the cache and evicts the least recently used item if necessary.\n     * @param {string} cacheKey - The key of the item to cache.\n     * @param {any} value - The value to cache.\n     */\n    cacheSet(cacheKey, value) {\n        if (this.cache.size >= this.maxCacheSize) {\n            // Evict the least recently used item (first item in Map)\n            const firstKey = this.cache.keys().next().value;\n            this.cache.delete(firstKey);\n        }\n        this.cache.set(cacheKey, value);\n    }\n}\n//# sourceMappingURL=CachedKeyDeriver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/CachedKeyDeriver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/KeyDeriver.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/KeyDeriver.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyDeriver: () => (/* binding */ KeyDeriver),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n/**\n * Class responsible for deriving various types of keys using a root private key.\n * It supports deriving public and private keys, symmetric keys, and revealing key linkages.\n */\nclass KeyDeriver {\n    cacheSharedSecret;\n    retrieveCachedSharedSecret;\n    rootKey;\n    identityKey;\n    anyone;\n    /**\n     * Initializes the KeyDeriver instance with a root private key.\n     * @param {PrivateKey | 'anyone'} rootKey - The root private key or the string 'anyone'.\n     */\n    constructor(rootKey, cacheSharedSecret, retrieveCachedSharedSecret) {\n        this.cacheSharedSecret = cacheSharedSecret;\n        this.retrieveCachedSharedSecret = retrieveCachedSharedSecret;\n        this.anyone = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(1).toPublicKey();\n        if (rootKey === 'anyone') {\n            this.rootKey = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(1);\n        }\n        else {\n            this.rootKey = rootKey;\n        }\n        this.identityKey = this.rootKey.toPublicKey().toString();\n    }\n    /**\n     * Derives a public key based on protocol ID, key ID, and counterparty.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {boolean} [forSelf=false] - Whether deriving for self.\n     * @returns {PublicKey} - The derived public key.\n     */\n    derivePublicKey(protocolID, keyID, counterparty, forSelf = false) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        if (forSelf) {\n            return this.rootKey\n                .deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret)\n                .toPublicKey();\n        }\n        else {\n            return counterparty.deriveChild(this.rootKey, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);\n        }\n    }\n    /**\n     * Derives a private key based on protocol ID, key ID, and counterparty.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PrivateKey} - The derived private key.\n     */\n    derivePrivateKey(protocolID, keyID, counterparty) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        return this.rootKey.deriveChild(counterparty, this.computeInvoiceNumber(protocolID, keyID), this.cacheSharedSecret, this.retrieveCachedSharedSecret);\n    }\n    /**\n     * Derives a symmetric key based on protocol ID, key ID, and counterparty.\n     * Note: Symmetric keys should not be derivable by everyone due to security risks.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {SymmetricKey} - The derived symmetric key.\n     */\n    deriveSymmetricKey(protocolID, keyID, counterparty) {\n        // If counterparty is 'anyone', we use 1*G as the public key.\n        // This is a publicly derivable key and should only be used in scenarios where public disclosure is intended.\n        if (counterparty === 'anyone') {\n            counterparty = this.anyone;\n        }\n        else {\n            counterparty = this.normalizeCounterparty(counterparty);\n        }\n        const derivedPublicKey = this.derivePublicKey(protocolID, keyID, counterparty);\n        const derivedPrivateKey = this.derivePrivateKey(protocolID, keyID, counterparty);\n        return new _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.SymmetricKey(derivedPrivateKey.deriveSharedSecret(derivedPublicKey)?.x?.toArray() ?? []);\n    }\n    /**\n     * Reveals the shared secret between the root key and the counterparty.\n     * Note: This should not be used for 'self'.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {number[]} - The shared secret as a number array.\n     * @throws {Error} - Throws an error if attempting to reveal a shared secret for 'self'.\n     */\n    revealCounterpartySecret(counterparty) {\n        if (counterparty === 'self') {\n            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');\n        }\n        counterparty = this.normalizeCounterparty(counterparty);\n        // Double-check to ensure not revealing the secret for 'self'\n        const self = this.rootKey.toPublicKey();\n        const keyDerivedBySelf = this.rootKey.deriveChild(self, 'test').toHex();\n        const keyDerivedByCounterparty = this.rootKey\n            .deriveChild(counterparty, 'test')\n            .toHex();\n        if (keyDerivedBySelf === keyDerivedByCounterparty) {\n            throw new Error('Counterparty secrets cannot be revealed for counterparty=self.');\n        }\n        return this.rootKey\n            .deriveSharedSecret(counterparty)\n            .encode(true);\n    }\n    /**\n     * Reveals the specific key association for a given protocol ID, key ID, and counterparty.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {number[]} - The specific key association as a number array.\n     */\n    revealSpecificSecret(counterparty, protocolID, keyID) {\n        counterparty = this.normalizeCounterparty(counterparty);\n        const sharedSecret = this.rootKey.deriveSharedSecret(counterparty);\n        const invoiceNumberBin = _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Utils.toArray(this.computeInvoiceNumber(protocolID, keyID), 'utf8');\n        return _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.Hash.sha256hmac(sharedSecret.encode(true), invoiceNumberBin);\n    }\n    /**\n     * Normalizes the counterparty to a public key.\n     * @param {Counterparty} counterparty - The counterparty's public key or a predefined value ('self' or 'anyone').\n     * @returns {PublicKey} - The normalized counterparty public key.\n     * @throws {Error} - Throws an error if the counterparty is invalid.\n     */\n    normalizeCounterparty(counterparty) {\n        if (counterparty === null || counterparty === undefined) {\n            throw new Error('counterparty must be self, anyone or a public key!');\n        }\n        else if (counterparty === 'self') {\n            return this.rootKey.toPublicKey();\n        }\n        else if (counterparty === 'anyone') {\n            return new _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(1).toPublicKey();\n        }\n        else if (typeof counterparty === 'string') {\n            return _primitives_index_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey.fromString(counterparty);\n        }\n        else {\n            return counterparty;\n        }\n    }\n    /**\n     * Computes the invoice number based on the protocol ID and key ID.\n     * @param {WalletProtocol} protocolID - The protocol ID including a security level and protocol name.\n     * @param {string} keyID - The key identifier.\n     * @returns {string} - The computed invoice number.\n     * @throws {Error} - Throws an error if protocol ID or key ID are invalid.\n     */\n    computeInvoiceNumber(protocolID, keyID) {\n        const securityLevel = protocolID[0];\n        if (!Number.isInteger(securityLevel) ||\n            securityLevel < 0 ||\n            securityLevel > 2) {\n            throw new Error('Protocol security level must be 0, 1, or 2');\n        }\n        const protocolName = protocolID[1].toLowerCase().trim();\n        if (keyID.length > 800) {\n            throw new Error('Key IDs must be 800 characters or less');\n        }\n        if (keyID.length < 1) {\n            throw new Error('Key IDs must be 1 character or more');\n        }\n        if (protocolName.length > 400) {\n            // Specific linkage revelation is the only protocol ID that can contain another protocol ID.\n            // Therefore, we allow it to be long enough to encapsulate the target protocol\n            if (protocolName.startsWith('specific linkage revelation ')) {\n                // The format is: 'specific linkage revelation x YYYYY'\n                // Where: x is the security level and YYYYY is the target protocol\n                // Thus, the max acceptable length is 30 + 400 = 430 bytes\n                if (protocolName.length > 430) {\n                    throw new Error('Specific linkage revelation protocol names must be 430 characters or less');\n                }\n            }\n            else {\n                throw new Error('Protocol names must be 400 characters or less');\n            }\n        }\n        if (protocolName.length < 5) {\n            throw new Error('Protocol names must be 5 characters or more');\n        }\n        if (protocolName.includes('  ')) {\n            throw new Error('Protocol names cannot contain multiple consecutive spaces (\"  \")');\n        }\n        if (!/^[a-z0-9 ]+$/g.test(protocolName)) {\n            throw new Error('Protocol names can only contain letters, numbers and spaces');\n        }\n        if (protocolName.endsWith(' protocol')) {\n            throw new Error('No need to end your protocol name with \" protocol\"');\n        }\n        return `${securityLevel}-${protocolName}-${keyID}`;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (KeyDeriver);\n//# sourceMappingURL=KeyDeriver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/KeyDeriver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/ProtoWallet.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/ProtoWallet.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProtoWallet: () => (/* binding */ ProtoWallet),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _CachedKeyDeriver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CachedKeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/CachedKeyDeriver.js\");\n/* harmony import */ var _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../primitives/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/index.js\");\n\n\n/**\n * A ProtoWallet is precursor to a full wallet, capable of performing all foundational cryptographic operations.\n * It can derive keys, create signatures, facilitate encryption and HMAC operations, and reveal key linkages.\n *\n * However, ProtoWallet does not create transactions, manage outputs, interact with the blockchain,\n * enable the management of identity certificates, or store any data. It is also not concerned with privileged keys.\n */\nclass ProtoWallet {\n    keyDeriver;\n    constructor(rootKeyOrKeyDeriver) {\n        if (typeof rootKeyOrKeyDeriver.identityKey !== 'string') {\n            rootKeyOrKeyDeriver = new _CachedKeyDeriver_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](rootKeyOrKeyDeriver);\n        }\n        this.keyDeriver = rootKeyOrKeyDeriver;\n    }\n    async getPublicKey(args) {\n        if (args.identityKey) {\n            if (this.keyDeriver == null) {\n                throw new Error('keyDeriver is undefined');\n            }\n            return { publicKey: this.keyDeriver.rootKey.toPublicKey().toString() };\n        }\n        else {\n            if (args.protocolID == null || args.keyID == null || args.keyID === '') {\n                throw new Error('protocolID and keyID are required if identityKey is false or undefined.');\n            }\n            const keyDeriver = this.keyDeriver ??\n                (() => {\n                    throw new Error('keyDeriver is undefined');\n                })();\n            return {\n                publicKey: keyDeriver\n                    .derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf)\n                    .toString()\n            };\n        }\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        const { publicKey: identityKey } = await this.getPublicKey({\n            identityKey: true\n        });\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const linkage = this.keyDeriver.revealCounterpartySecret(args.counterparty);\n        const linkageProof = new _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Schnorr().generateProof(this.keyDeriver.rootKey, this.keyDeriver.rootKey.toPublicKey(), _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.PublicKey.fromString(args.counterparty), _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Point.fromDER(linkage));\n        const linkageProofBin = [\n            ...linkageProof.R.encode(true),\n            ...linkageProof.SPrime.encode(true),\n            ...linkageProof.z.toArray()\n        ];\n        const revelationTime = new Date().toISOString();\n        const { ciphertext: encryptedLinkage } = await this.encrypt({\n            plaintext: linkage,\n            protocolID: [2, 'counterparty linkage revelation'],\n            keyID: revelationTime,\n            counterparty: args.verifier\n        });\n        const { ciphertext: encryptedLinkageProof } = await this.encrypt({\n            plaintext: linkageProofBin,\n            protocolID: [2, 'counterparty linkage revelation'],\n            keyID: revelationTime,\n            counterparty: args.verifier\n        });\n        return {\n            prover: identityKey,\n            verifier: args.verifier,\n            counterparty: args.counterparty,\n            revelationTime,\n            encryptedLinkage,\n            encryptedLinkageProof\n        };\n    }\n    async revealSpecificKeyLinkage(args) {\n        const { publicKey: identityKey } = await this.getPublicKey({\n            identityKey: true\n        });\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const linkage = this.keyDeriver.revealSpecificSecret(args.counterparty, args.protocolID, args.keyID);\n        const { ciphertext: encryptedLinkage } = await this.encrypt({\n            plaintext: linkage,\n            protocolID: [\n                2,\n                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`\n            ],\n            keyID: args.keyID,\n            counterparty: args.verifier\n        });\n        const { ciphertext: encryptedLinkageProof } = await this.encrypt({\n            plaintext: [0],\n            protocolID: [\n                2,\n                `specific linkage revelation ${args.protocolID[0]} ${args.protocolID[1]}`\n            ],\n            keyID: args.keyID,\n            counterparty: args.verifier\n        });\n        return {\n            prover: identityKey,\n            verifier: args.verifier,\n            counterparty: args.counterparty,\n            protocolID: args.protocolID,\n            keyID: args.keyID,\n            encryptedLinkage,\n            encryptedLinkageProof,\n            proofType: 0\n        };\n    }\n    async encrypt(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { ciphertext: key.encrypt(args.plaintext) };\n    }\n    async decrypt(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { plaintext: key.decrypt(args.ciphertext) };\n    }\n    async createHmac(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        return { hmac: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Hash.sha256hmac(key.toArray(), args.data) };\n    }\n    async verifyHmac(args) {\n        if (this.keyDeriver == null) {\n            throw new Error('keyDeriver is undefined');\n        }\n        const key = this.keyDeriver.deriveSymmetricKey(args.protocolID, args.keyID, args.counterparty ?? 'self');\n        const valid = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Hash.sha256hmac(key.toArray(), args.data).toString() ===\n            args.hmac.toString();\n        if (!valid) {\n            const e = new Error('HMAC is not valid');\n            e.code = 'ERR_INVALID_HMAC';\n            throw e;\n        }\n        return { valid };\n    }\n    async createSignature(args) {\n        if ((args.hashToDirectlySign == null) && (args.data == null)) {\n            throw new Error('args.data or args.hashToDirectlySign must be valid');\n        }\n        const hash = args.hashToDirectlySign ?? _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Hash.sha256(args.data ?? []);\n        const keyDeriver = this.keyDeriver ??\n            (() => {\n                throw new Error('keyDeriver is undefined');\n            })();\n        const key = keyDeriver.derivePrivateKey(args.protocolID, args.keyID, args.counterparty ?? 'anyone');\n        return {\n            signature: _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.ECDSA.sign(new _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.BigNumber(hash), key, true).toDER()\n        };\n    }\n    async verifySignature(args) {\n        if ((args.hashToDirectlyVerify == null) && (args.data == null)) {\n            throw new Error('args.data or args.hashToDirectlyVerify must be valid');\n        }\n        const hash = args.hashToDirectlyVerify ?? _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Hash.sha256(args.data ?? []);\n        const keyDeriver = this.keyDeriver ??\n            (() => {\n                throw new Error('keyDeriver is undefined');\n            })();\n        const key = keyDeriver.derivePublicKey(args.protocolID, args.keyID, args.counterparty ?? 'self', args.forSelf);\n        const valid = _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.ECDSA.verify(new _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.BigNumber(hash), _primitives_index_js__WEBPACK_IMPORTED_MODULE_1__.Signature.fromDER(args.signature), key);\n        if (!valid) {\n            const e = new Error('Signature is not valid');\n            e.code = 'ERR_INVALID_SIGNATURE';\n            throw e;\n        }\n        return { valid };\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ProtoWallet);\n//# sourceMappingURL=ProtoWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/ProtoWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/WERR_REVIEW_ACTIONS.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/WERR_REVIEW_ACTIONS.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WERR_REVIEW_ACTIONS: () => (/* binding */ WERR_REVIEW_ACTIONS),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**\n * When a `createAction` or `signAction` is completed in undelayed mode (`acceptDelayedBroadcast`: false),\n * any unsucccessful result will return the results by way of this exception to ensure attention is\n * paid to processing errors.\n */\nclass WERR_REVIEW_ACTIONS extends Error {\n    reviewActionResults;\n    sendWithResults;\n    txid;\n    tx;\n    noSendChange;\n    code;\n    isError = true;\n    /**\n     * All parameters correspond to their comparable `createAction` or `signSction` results\n     * with the exception of `reviewActionResults`;\n     * which contains more details, particularly for double spend results.\n     */\n    constructor(reviewActionResults, sendWithResults, txid, tx, noSendChange) {\n        super('Undelayed createAction or signAction results require review.');\n        this.reviewActionResults = reviewActionResults;\n        this.sendWithResults = sendWithResults;\n        this.txid = txid;\n        this.tx = tx;\n        this.noSendChange = noSendChange;\n        this.code = 5;\n        this.name = this.constructor.name;\n    }\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WERR_REVIEW_ACTIONS);\n//# sourceMappingURL=WERR_REVIEW_ACTIONS.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/WERR_REVIEW_ACTIONS.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/Wallet.interfaces.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/Wallet.interfaces.js ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SecurityLevels: () => (/* binding */ SecurityLevels)\n/* harmony export */ });\n/**\n * @enum {number} SecurityLevels\n *\n * Silent = 0 Silently grants the request with no user interation.\n * App = 1 Requires user approval for every application.\n * Counterparty = 2 Requires user approval per counterparty per application.\n */\nvar SecurityLevels;\n(function (SecurityLevels) {\n    SecurityLevels[SecurityLevels[\"Silent\"] = 0] = \"Silent\";\n    SecurityLevels[SecurityLevels[\"App\"] = 1] = \"App\";\n    SecurityLevels[SecurityLevels[\"Counterparty\"] = 2] = \"Counterparty\";\n})(SecurityLevels || (SecurityLevels = {}));\n//# sourceMappingURL=Wallet.interfaces.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/Wallet.interfaces.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletClient.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletClient.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WalletClient)\n/* harmony export */ });\n/* harmony import */ var _substrates_window_CWI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./substrates/window.CWI.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/window.CWI.js\");\n/* harmony import */ var _substrates_XDM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./substrates/XDM.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/XDM.js\");\n/* harmony import */ var _substrates_WalletWireTransceiver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./substrates/WalletWireTransceiver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireTransceiver.js\");\n/* harmony import */ var _substrates_HTTPWalletWire_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./substrates/HTTPWalletWire.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletWire.js\");\n/* harmony import */ var _substrates_HTTPWalletJSON_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./substrates/HTTPWalletJSON.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletJSON.js\");\n/* harmony import */ var _substrates_ReactNativeWebView_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./substrates/ReactNativeWebView.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/ReactNativeWebView.js\");\n\n\n\n\n\n\nconst MAX_XDM_RESPONSE_WAIT = 200;\n/**\n * The SDK is how applications communicate with wallets over a communications substrate.\n */\nclass WalletClient {\n    substrate;\n    originator;\n    constructor(substrate = 'auto', originator) {\n        if (substrate === 'Cicada') {\n            substrate = new _substrates_WalletWireTransceiver_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new _substrates_HTTPWalletWire_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](originator));\n        }\n        if (substrate === 'window.CWI')\n            substrate = new _substrates_window_CWI_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        if (substrate === 'XDM')\n            substrate = new _substrates_XDM_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n        if (substrate === 'json-api')\n            substrate = new _substrates_HTTPWalletJSON_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](originator);\n        if (substrate === 'react-native')\n            substrate = new _substrates_ReactNativeWebView_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](originator);\n        this.substrate = substrate;\n        this.originator = originator;\n    }\n    async connectToSubstrate() {\n        if (typeof this.substrate === 'object') {\n            return; // substrate is already connected\n        }\n        let sub;\n        const checkSub = async (timeout) => {\n            let result;\n            if (typeof timeout === 'number') {\n                result = await Promise.race([\n                    sub.getVersion({}),\n                    new Promise((_resolve, reject) => setTimeout(() => reject(new Error('Timed out.')), timeout))\n                ]);\n            }\n            else {\n                result = await sub.getVersion({});\n            }\n            if (typeof result !== 'object' || typeof result.version !== 'string') {\n                throw new Error('Failed to use substrate.');\n            }\n        };\n        try {\n            sub = new _substrates_window_CWI_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n            await checkSub();\n            this.substrate = sub;\n        }\n        catch (e) {\n            // XDM failed, try the next one...\n            try {\n                sub = new _substrates_XDM_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n                await checkSub(MAX_XDM_RESPONSE_WAIT);\n                this.substrate = sub;\n            }\n            catch (e) {\n                // HTTP wire failed, move on...\n                try {\n                    sub = new _substrates_WalletWireTransceiver_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](new _substrates_HTTPWalletWire_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.originator));\n                    await checkSub();\n                    this.substrate = sub;\n                }\n                catch (e) {\n                    // HTTP Wire failed, attempt the next...\n                    try {\n                        sub = new _substrates_HTTPWalletJSON_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this.originator);\n                        await checkSub();\n                        this.substrate = sub;\n                    }\n                    catch (e) {\n                        // HTTP JSON failed, attempt the next...\n                        try {\n                            sub = new _substrates_ReactNativeWebView_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.originator);\n                            await checkSub();\n                            this.substrate = sub;\n                        }\n                        catch (e) {\n                            // No comms. Tell the user to install a BSV wallet.\n                            throw new Error('No wallet available over any communication substrate. Install a BSV wallet today!');\n                        }\n                    }\n                }\n            }\n        }\n    }\n    async createAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createAction(args, this.originator);\n    }\n    async signAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.signAction(args, this.originator);\n    }\n    async abortAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.abortAction(args, this.originator);\n    }\n    async listActions(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listActions(args, this.originator);\n    }\n    async internalizeAction(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.internalizeAction(args, this.originator);\n    }\n    async listOutputs(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listOutputs(args, this.originator);\n    }\n    async relinquishOutput(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.relinquishOutput(args, this.originator);\n    }\n    async getPublicKey(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.getPublicKey(args, this.originator);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.revealCounterpartyKeyLinkage(args, this.originator);\n    }\n    async revealSpecificKeyLinkage(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.revealSpecificKeyLinkage(args, this.originator);\n    }\n    async encrypt(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.encrypt(args, this.originator);\n    }\n    async decrypt(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.decrypt(args, this.originator);\n    }\n    async createHmac(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createHmac(args, this.originator);\n    }\n    async verifyHmac(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.verifyHmac(args, this.originator);\n    }\n    async createSignature(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.createSignature(args, this.originator);\n    }\n    async verifySignature(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.verifySignature(args, this.originator);\n    }\n    async acquireCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.acquireCertificate(args, this.originator);\n    }\n    async listCertificates(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.listCertificates(args, this.originator);\n    }\n    async proveCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.proveCertificate(args, this.originator);\n    }\n    async relinquishCertificate(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.relinquishCertificate(args, this.originator);\n    }\n    async discoverByIdentityKey(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.discoverByIdentityKey(args, this.originator);\n    }\n    async discoverByAttributes(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.discoverByAttributes(args, this.originator);\n    }\n    async isAuthenticated(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.isAuthenticated(args, this.originator);\n    }\n    async waitForAuthentication(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.waitForAuthentication(args, this.originator);\n    }\n    async getHeight(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getHeight(args, this.originator);\n    }\n    async getHeaderForHeight(args) {\n        await this.connectToSubstrate();\n        return await this.substrate.getHeaderForHeight(args, this.originator);\n    }\n    async getNetwork(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getNetwork(args, this.originator);\n    }\n    async getVersion(args = {}) {\n        await this.connectToSubstrate();\n        return await this.substrate.getVersion(args, this.originator);\n    }\n}\n//# sourceMappingURL=WalletClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js":
/*!******************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletError: () => (/* binding */ WalletError),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   walletErrors: () => (/* binding */ walletErrors)\n/* harmony export */ });\nclass WalletError extends Error {\n    code;\n    isError = true;\n    constructor(message, code = 1, stack) {\n        super(message);\n        this.code = code;\n        this.name = this.constructor.name;\n        if (stack !== undefined && stack !== null && stack !== '') {\n            this.stack = stack;\n        }\n        else {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    }\n}\n// NOTE: Enum values must not exceed the UInt8 range (0255)\nvar walletErrors;\n(function (walletErrors) {\n    walletErrors[walletErrors[\"unknownError\"] = 1] = \"unknownError\";\n    walletErrors[walletErrors[\"unsupportedAction\"] = 2] = \"unsupportedAction\";\n    walletErrors[walletErrors[\"invalidHmac\"] = 3] = \"invalidHmac\";\n    walletErrors[walletErrors[\"invalidSignature\"] = 4] = \"invalidSignature\";\n    walletErrors[walletErrors[\"reviewActions\"] = 5] = \"reviewActions\";\n})(walletErrors || (walletErrors = {}));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WalletError);\n//# sourceMappingURL=WalletError.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CachedKeyDeriver: () => (/* reexport safe */ _CachedKeyDeriver_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   HTTPWalletJSON: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.HTTPWalletJSON),\n/* harmony export */   HTTPWalletWire: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.HTTPWalletWire),\n/* harmony export */   KeyDeriver: () => (/* reexport safe */ _KeyDeriver_js__WEBPACK_IMPORTED_MODULE_1__.KeyDeriver),\n/* harmony export */   ProtoWallet: () => (/* reexport safe */ _ProtoWallet_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   ReactNativeWebView: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.ReactNativeWebView),\n/* harmony export */   SecurityLevels: () => (/* reexport safe */ _Wallet_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.SecurityLevels),\n/* harmony export */   WERR_REVIEW_ACTIONS: () => (/* reexport safe */ _WERR_REVIEW_ACTIONS_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   WalletClient: () => (/* reexport safe */ _WalletClient_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   WalletError: () => (/* reexport safe */ _WalletError_js__WEBPACK_IMPORTED_MODULE_5__.WalletError),\n/* harmony export */   WalletErrors: () => (/* reexport safe */ _WalletError_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   WalletWireProcessor: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.WalletWireProcessor),\n/* harmony export */   WalletWireTransceiver: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.WalletWireTransceiver),\n/* harmony export */   WindowCWISubstrate: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.WindowCWISubstrate),\n/* harmony export */   XDM: () => (/* reexport safe */ _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__.XDM),\n/* harmony export */   walletErrors: () => (/* reexport safe */ _WalletError_js__WEBPACK_IMPORTED_MODULE_5__.walletErrors)\n/* harmony export */ });\n/* harmony import */ var _Wallet_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wallet.interfaces.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/Wallet.interfaces.js\");\n/* harmony import */ var _KeyDeriver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/KeyDeriver.js\");\n/* harmony import */ var _CachedKeyDeriver_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CachedKeyDeriver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/CachedKeyDeriver.js\");\n/* harmony import */ var _ProtoWallet_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ProtoWallet.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/ProtoWallet.js\");\n/* harmony import */ var _WalletClient_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WalletClient.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletClient.js\");\n/* harmony import */ var _WalletError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WalletError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js\");\n/* harmony import */ var _WERR_REVIEW_ACTIONS_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WERR_REVIEW_ACTIONS.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WERR_REVIEW_ACTIONS.js\");\n/* harmony import */ var _substrates_index_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./substrates/index.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/index.js\");\n\n\n\n\n\n// Is this an error? should it be 'walletErrors', the enum not the class?\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletJSON.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletJSON.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTTPWalletJSON)\n/* harmony export */ });\n/* harmony import */ var _WERR_REVIEW_ACTIONS_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../WERR_REVIEW_ACTIONS.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WERR_REVIEW_ACTIONS.js\");\n/* harmony import */ var _utils_toOriginHeader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/toOriginHeader.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/utils/toOriginHeader.js\");\n\n\nclass HTTPWalletJSON {\n    baseUrl;\n    httpClient;\n    originator;\n    api; // Fixed `any` types\n    constructor(originator, baseUrl = 'http://localhost:3321', httpClient = fetch) {\n        this.baseUrl = baseUrl;\n        this.originator = originator;\n        this.httpClient = httpClient;\n        // Detect if we're in a browser environment\n        const isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window?.origin !== 'file://';\n        this.api = async (call, args) => {\n            // In browser environments, let the browser handle Origin header automatically\n            // In Node.js environments, we need to set it manually if originator is provided\n            const origin = !isBrowser && this.originator\n                ? (0,_utils_toOriginHeader_js__WEBPACK_IMPORTED_MODULE_1__.toOriginHeader)(this.originator, 'http')\n                : undefined;\n            if (!isBrowser && origin === undefined) {\n                console.error('Originator is required in Node.js environments');\n            }\n            const res = await (await httpClient(`${this.baseUrl}/${call}`, {\n                method: 'POST',\n                headers: {\n                    Accept: 'application/json',\n                    'Content-Type': 'application/json',\n                    ...(origin ? { Origin: origin } : {}),\n                    ...(origin ? { Originator: origin } : {}),\n                },\n                body: JSON.stringify(args)\n            }));\n            const data = await res.json();\n            // Check the HTTP status on the original response\n            if (!res.ok) {\n                if (res.status === 400 && data.isError && data.code === 5) {\n                    const err = new _WERR_REVIEW_ACTIONS_js__WEBPACK_IMPORTED_MODULE_0__.WERR_REVIEW_ACTIONS(data.reviewActionResults, data.sendWithResults, data.txid, data.tx, data.noSendChange);\n                    throw err;\n                }\n                else {\n                    const err = {\n                        call,\n                        args,\n                        message: data.message ?? `HTTP Client error ${res.status}`\n                    };\n                    throw new Error(JSON.stringify(err));\n                }\n            }\n            return data;\n        };\n    }\n    async createAction(args) {\n        return await this.api('createAction', args);\n    }\n    async signAction(args) {\n        return await this.api('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.api('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.api('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.api('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.api('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.api('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.api('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.api('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.api('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.api('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.api('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.api('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.api('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.api('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.api('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.api('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.api('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.api('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.api('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.api('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.api('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.api('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.api('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.api('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.api('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.api('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.api('getVersion', args);\n    }\n}\n//# sourceMappingURL=HTTPWalletJSON.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletJSON.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletWire.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletWire.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ HTTPWalletWire)\n/* harmony export */ });\n/* harmony import */ var _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n\n\nclass HTTPWalletWire {\n    baseUrl;\n    httpClient;\n    originator;\n    constructor(originator, baseUrl = 'http://localhost:3301', httpClient = fetch) {\n        this.baseUrl = baseUrl;\n        this.httpClient = httpClient;\n        this.originator = originator;\n    }\n    async transmitToWallet(message) {\n        const messageReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.Reader(message);\n        // Read call code\n        const callCode = messageReader.readUInt8();\n        // Map call code to call name\n        const callName = _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"][callCode]; // calls is enum\n        if (callName === undefined || callName === '') {\n            // Invalid call code\n            throw new Error(`Invalid call code: ${callCode}`);\n        }\n        // Read originator length\n        const originatorLength = messageReader.readUInt8();\n        let originator;\n        if (originatorLength > 0) {\n            const originatorBytes = messageReader.read(originatorLength);\n            originator = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toUTF8(originatorBytes);\n        }\n        const payload = messageReader.read();\n        const response = await fetch(`${this.baseUrl}/${callName}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/octet-stream',\n                Origin: originator ?? '' //  Explicitly handle null/undefined cases\n            },\n            body: new Uint8Array(payload)\n        });\n        const responseBuffer = await response.arrayBuffer();\n        return Array.from(new Uint8Array(responseBuffer));\n    }\n}\n//# sourceMappingURL=HTTPWalletWire.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletWire.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/ReactNativeWebView.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/ReactNativeWebView.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactNativeWebView)\n/* harmony export */ });\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _WalletError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js\");\n\n\n\n/**\n * Facilitates wallet operations over cross-document messaging.\n */\nclass ReactNativeWebView {\n    domain;\n    constructor(domain = '*') {\n        if (typeof window !== 'object') {\n            throw new Error('The XDM substrate requires a global window object.');\n        }\n        if (!window.hasOwnProperty(\"ReactNativeWebView\")) {\n            throw new Error('The window object does not have a ReactNativeWebView property.');\n        }\n        if (typeof window.ReactNativeWebView.postMessage !== 'function') {\n            throw new Error('The window.ReactNativeWebView property does not seem to support postMessage calls.');\n        }\n        this.domain = domain;\n    }\n    async invoke(call, args) {\n        return await new Promise((resolve, reject) => {\n            const id = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(12));\n            const listener = (e) => {\n                const data = JSON.parse(e.data);\n                if (data.type !== 'CWI' ||\n                    data.id !== id ||\n                    data.isInvocation === true) {\n                    return;\n                }\n                if (typeof window.removeEventListener === 'function') {\n                    window.removeEventListener('message', listener);\n                }\n                if (data.status === 'error') {\n                    const err = new _WalletError_js__WEBPACK_IMPORTED_MODULE_2__.WalletError(data.description, data.code);\n                    reject(err);\n                }\n                else {\n                    resolve(data.result);\n                }\n            };\n            window.addEventListener('message', listener);\n            window.ReactNativeWebView.postMessage(JSON.stringify({\n                type: 'CWI',\n                isInvocation: true,\n                id,\n                call,\n                args\n            }));\n        });\n    }\n    async createAction(args) {\n        return await this.invoke('createAction', args);\n    }\n    async signAction(args) {\n        return await this.invoke('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.invoke('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.invoke('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.invoke('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.invoke('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.invoke('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.invoke('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.invoke('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.invoke('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.invoke('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.invoke('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.invoke('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.invoke('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.invoke('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.invoke('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.invoke('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.invoke('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.invoke('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.invoke('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.invoke('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.invoke('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.invoke('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.invoke('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.invoke('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.invoke('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.invoke('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.invoke('getVersion', args);\n    }\n}\n//# sourceMappingURL=ReactNativeWebView.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/ReactNativeWebView.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWire.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWire.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=WalletWire.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWire.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// NOTE: Enum values must not exceed the UInt8 range (0255)\nvar calls;\n(function (calls) {\n    calls[calls[\"createAction\"] = 1] = \"createAction\";\n    calls[calls[\"signAction\"] = 2] = \"signAction\";\n    calls[calls[\"abortAction\"] = 3] = \"abortAction\";\n    calls[calls[\"listActions\"] = 4] = \"listActions\";\n    calls[calls[\"internalizeAction\"] = 5] = \"internalizeAction\";\n    calls[calls[\"listOutputs\"] = 6] = \"listOutputs\";\n    calls[calls[\"relinquishOutput\"] = 7] = \"relinquishOutput\";\n    calls[calls[\"getPublicKey\"] = 8] = \"getPublicKey\";\n    calls[calls[\"revealCounterpartyKeyLinkage\"] = 9] = \"revealCounterpartyKeyLinkage\";\n    calls[calls[\"revealSpecificKeyLinkage\"] = 10] = \"revealSpecificKeyLinkage\";\n    calls[calls[\"encrypt\"] = 11] = \"encrypt\";\n    calls[calls[\"decrypt\"] = 12] = \"decrypt\";\n    calls[calls[\"createHmac\"] = 13] = \"createHmac\";\n    calls[calls[\"verifyHmac\"] = 14] = \"verifyHmac\";\n    calls[calls[\"createSignature\"] = 15] = \"createSignature\";\n    calls[calls[\"verifySignature\"] = 16] = \"verifySignature\";\n    calls[calls[\"acquireCertificate\"] = 17] = \"acquireCertificate\";\n    calls[calls[\"listCertificates\"] = 18] = \"listCertificates\";\n    calls[calls[\"proveCertificate\"] = 19] = \"proveCertificate\";\n    calls[calls[\"relinquishCertificate\"] = 20] = \"relinquishCertificate\";\n    calls[calls[\"discoverByIdentityKey\"] = 21] = \"discoverByIdentityKey\";\n    calls[calls[\"discoverByAttributes\"] = 22] = \"discoverByAttributes\";\n    calls[calls[\"isAuthenticated\"] = 23] = \"isAuthenticated\";\n    calls[calls[\"waitForAuthentication\"] = 24] = \"waitForAuthentication\";\n    calls[calls[\"getHeight\"] = 25] = \"getHeight\";\n    calls[calls[\"getHeaderForHeight\"] = 26] = \"getHeaderForHeight\";\n    calls[calls[\"getNetwork\"] = 27] = \"getNetwork\";\n    calls[calls[\"getVersion\"] = 28] = \"getVersion\";\n})(calls || (calls = {}));\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (calls);\n//# sourceMappingURL=WalletWireCalls.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireProcessor.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireProcessor.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WalletWireProcessor)\n/* harmony export */ });\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js\");\n/* harmony import */ var _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n\n\n\n/**\n * Processes incoming wallet calls received over a wallet wire, with a given wallet.\n */\nclass WalletWireProcessor {\n    wallet;\n    constructor(wallet) {\n        this.wallet = wallet;\n    }\n    decodeOutpoint(reader) {\n        const txidBytes = reader.read(32);\n        const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(txidBytes);\n        const index = reader.readVarIntNum();\n        return `${txid}.${index}`;\n    }\n    encodeOutpoint(outpoint) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n        const [txid, index] = outpoint.split('.');\n        writer.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(txid, 'hex'));\n        writer.writeVarIntNum(Number(index));\n        return writer.toArray();\n    }\n    async transmitToWallet(message) {\n        const messageReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Reader(message);\n        try {\n            // Read call code\n            const callCode = messageReader.readUInt8();\n            // Map call code to call name\n            const callName = _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"][callCode]; // calls is enum\n            if (callName === undefined || callName === '') {\n                // Invalid call code\n                throw new Error(`Invalid call code: ${callCode}`);\n            }\n            // Read originator length\n            const originatorLength = messageReader.readUInt8();\n            const originatorBytes = messageReader.read(originatorLength);\n            const originator = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(originatorBytes);\n            // Read parameters\n            const paramsReader = messageReader; // Remaining bytes\n            switch (callName) {\n                case 'createAction': {\n                    // Deserialize parameters from paramsReader\n                    const args = {};\n                    // Read description\n                    const descriptionLength = paramsReader.readVarIntNum();\n                    const descriptionBytes = paramsReader.read(descriptionLength);\n                    args.description = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(descriptionBytes);\n                    // tx\n                    const inputBeefLength = paramsReader.readVarIntNum();\n                    if (inputBeefLength >= 0) {\n                        args.inputBEEF = paramsReader.read(inputBeefLength); // BEEF (Byte[])\n                    }\n                    else {\n                        args.inputBEEF = undefined;\n                    }\n                    // Read inputs\n                    const inputsLength = paramsReader.readVarIntNum();\n                    if (inputsLength >= 0) {\n                        args.inputs = [];\n                        for (let i = 0; i < inputsLength; i++) {\n                            const input = {};\n                            // outpoint\n                            input.outpoint = this.decodeOutpoint(paramsReader);\n                            // unlockingScript / unlockingScriptLength\n                            const unlockingScriptLength = paramsReader.readVarIntNum();\n                            if (unlockingScriptLength >= 0) {\n                                const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);\n                                input.unlockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(unlockingScriptBytes);\n                            }\n                            else {\n                                input.unlockingScript = undefined;\n                                const unlockingScriptLengthValue = paramsReader.readVarIntNum();\n                                input.unlockingScriptLength = unlockingScriptLengthValue;\n                            }\n                            // inputDescription\n                            const inputDescriptionLength = paramsReader.readVarIntNum();\n                            const inputDescriptionBytes = paramsReader.read(inputDescriptionLength);\n                            input.inputDescription = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(inputDescriptionBytes);\n                            // sequenceNumber\n                            const sequenceNumber = paramsReader.readVarIntNum();\n                            if (sequenceNumber >= 0) {\n                                input.sequenceNumber = sequenceNumber;\n                            }\n                            else {\n                                input.sequenceNumber = undefined;\n                            }\n                            args.inputs.push(input);\n                        }\n                    }\n                    else {\n                        args.inputs = undefined;\n                    }\n                    // Read outputs\n                    const outputsLength = paramsReader.readVarIntNum();\n                    if (outputsLength >= 0) {\n                        args.outputs = [];\n                        for (let i = 0; i < outputsLength; i++) {\n                            const output = {};\n                            // lockingScript\n                            const lockingScriptLength = paramsReader.readVarIntNum();\n                            const lockingScriptBytes = paramsReader.read(lockingScriptLength);\n                            output.lockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(lockingScriptBytes);\n                            // satoshis\n                            output.satoshis = paramsReader.readVarIntNum();\n                            // outputDescription\n                            const outputDescriptionLength = paramsReader.readVarIntNum();\n                            const outputDescriptionBytes = paramsReader.read(outputDescriptionLength);\n                            output.outputDescription = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(outputDescriptionBytes);\n                            // basket\n                            const basketLength = paramsReader.readVarIntNum();\n                            if (basketLength >= 0) {\n                                const basketBytes = paramsReader.read(basketLength);\n                                output.basket = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(basketBytes);\n                            }\n                            else {\n                                output.basket = undefined;\n                            }\n                            // customInstructions\n                            const customInstructionsLength = paramsReader.readVarIntNum();\n                            if (customInstructionsLength >= 0) {\n                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);\n                                output.customInstructions = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(customInstructionsBytes);\n                            }\n                            else {\n                                output.customInstructions = undefined;\n                            }\n                            // tags\n                            const tagsLength = paramsReader.readVarIntNum();\n                            if (tagsLength >= 0) {\n                                output.tags = [];\n                                for (let j = 0; j < tagsLength; j++) {\n                                    const tagLength = paramsReader.readVarIntNum();\n                                    const tagBytes = paramsReader.read(tagLength);\n                                    const tag = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(tagBytes);\n                                    output.tags.push(tag);\n                                }\n                            }\n                            else {\n                                output.tags = undefined;\n                            }\n                            args.outputs.push(output);\n                        }\n                    }\n                    else {\n                        args.outputs = undefined;\n                    }\n                    // lockTime\n                    const lockTime = paramsReader.readVarIntNum();\n                    if (lockTime >= 0) {\n                        args.lockTime = lockTime;\n                    }\n                    else {\n                        args.lockTime = undefined;\n                    }\n                    // version\n                    const version = paramsReader.readVarIntNum();\n                    if (version >= 0) {\n                        args.version = version;\n                    }\n                    else {\n                        args.version = undefined;\n                    }\n                    // labels\n                    const labelsLength = paramsReader.readVarIntNum();\n                    if (labelsLength >= 0) {\n                        args.labels = [];\n                        for (let i = 0; i < labelsLength; i++) {\n                            const labelLength = paramsReader.readVarIntNum();\n                            const labelBytes = paramsReader.read(labelLength);\n                            const label = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(labelBytes);\n                            args.labels.push(label);\n                        }\n                    }\n                    else {\n                        args.labels = undefined;\n                    }\n                    // options\n                    const optionsPresent = paramsReader.readInt8();\n                    if (optionsPresent === 1) {\n                        args.options = {};\n                        // signAndProcess\n                        const signAndProcessFlag = paramsReader.readInt8();\n                        if (signAndProcessFlag === -1) {\n                            args.options.signAndProcess = undefined;\n                        }\n                        else {\n                            args.options.signAndProcess = signAndProcessFlag === 1;\n                        }\n                        // acceptDelayedBroadcast\n                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();\n                        if (acceptDelayedBroadcastFlag === -1) {\n                            args.options.acceptDelayedBroadcast = undefined;\n                        }\n                        else {\n                            args.options.acceptDelayedBroadcast =\n                                acceptDelayedBroadcastFlag === 1;\n                        }\n                        // trustSelf\n                        const trustSelfFlag = paramsReader.readInt8();\n                        if (trustSelfFlag === -1) {\n                            args.options.trustSelf = undefined;\n                        }\n                        else if (trustSelfFlag === 1) {\n                            args.options.trustSelf = 'known';\n                        }\n                        // knownTxids\n                        const knownTxidsLength = paramsReader.readVarIntNum();\n                        if (knownTxidsLength >= 0) {\n                            args.options.knownTxids = [];\n                            for (let i = 0; i < knownTxidsLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(txidBytes);\n                                args.options.knownTxids.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.knownTxids = undefined;\n                        }\n                        // returnTXIDOnly\n                        const returnTXIDOnlyFlag = paramsReader.readInt8();\n                        if (returnTXIDOnlyFlag === -1) {\n                            args.options.returnTXIDOnly = undefined;\n                        }\n                        else {\n                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;\n                        }\n                        // noSend\n                        const noSendFlag = paramsReader.readInt8();\n                        if (noSendFlag === -1) {\n                            args.options.noSend = undefined;\n                        }\n                        else {\n                            args.options.noSend = noSendFlag === 1;\n                        }\n                        // noSendChange\n                        const noSendChangeLength = paramsReader.readVarIntNum();\n                        if (noSendChangeLength >= 0) {\n                            args.options.noSendChange = [];\n                            for (let i = 0; i < noSendChangeLength; i++) {\n                                const outpoint = this.decodeOutpoint(paramsReader);\n                                args.options.noSendChange.push(outpoint);\n                            }\n                        }\n                        else {\n                            args.options.noSendChange = undefined;\n                        }\n                        // sendWith\n                        const sendWithLength = paramsReader.readVarIntNum();\n                        if (sendWithLength >= 0) {\n                            args.options.sendWith = [];\n                            for (let i = 0; i < sendWithLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(txidBytes);\n                                args.options.sendWith.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.sendWith = undefined;\n                        }\n                        // randomizeOutputs\n                        const randomizeOutputsFlag = paramsReader.readInt8();\n                        if (randomizeOutputsFlag === -1) {\n                            args.options.randomizeOutputs = undefined;\n                        }\n                        else {\n                            args.options.randomizeOutputs = randomizeOutputsFlag === 1;\n                        }\n                    }\n                    else {\n                        args.options = undefined;\n                    }\n                    // Call the method\n                    const createActionResult = await this.wallet.createAction(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // txid\n                    if (createActionResult.txid != null && createActionResult.txid !== '') {\n                        resultWriter.writeInt8(1);\n                        resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(createActionResult.txid, 'hex'));\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // tx\n                    if (createActionResult.tx != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(createActionResult.tx.length);\n                        resultWriter.write(createActionResult.tx);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // noSendChange\n                    if (createActionResult.noSendChange != null) {\n                        resultWriter.writeVarIntNum(createActionResult.noSendChange.length);\n                        for (const outpoint of createActionResult.noSendChange) {\n                            resultWriter.write(this.encodeOutpoint(outpoint));\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // sendWithResults\n                    if (createActionResult.sendWithResults != null) {\n                        resultWriter.writeVarIntNum(createActionResult.sendWithResults.length);\n                        for (const result of createActionResult.sendWithResults) {\n                            resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(result.txid, 'hex'));\n                            let statusCode;\n                            if (result.status === 'unproven')\n                                statusCode = 1;\n                            else if (result.status === 'sending')\n                                statusCode = 2;\n                            else if (result.status === 'failed')\n                                statusCode = 3;\n                            resultWriter.writeInt8(statusCode);\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // signableTransaction\n                    if (createActionResult.signableTransaction != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(createActionResult.signableTransaction.tx.length);\n                        resultWriter.write(createActionResult.signableTransaction.tx);\n                        const referenceBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(createActionResult.signableTransaction.reference, 'base64');\n                        resultWriter.writeVarIntNum(referenceBytes.length);\n                        resultWriter.write(referenceBytes);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'signAction': {\n                    const args = {};\n                    // Deserialize spends\n                    const spendCount = paramsReader.readVarIntNum();\n                    args.spends = {};\n                    for (let i = 0; i < spendCount; i++) {\n                        const inputIndex = paramsReader.readVarIntNum();\n                        const spend = {};\n                        // unlockingScript\n                        const unlockingScriptLength = paramsReader.readVarIntNum();\n                        const unlockingScriptBytes = paramsReader.read(unlockingScriptLength);\n                        spend.unlockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(unlockingScriptBytes);\n                        // sequenceNumber\n                        const sequenceNumber = paramsReader.readVarIntNum();\n                        if (sequenceNumber >= 0) {\n                            spend.sequenceNumber = sequenceNumber;\n                        }\n                        else {\n                            spend.sequenceNumber = undefined;\n                        }\n                        args.spends[inputIndex] = spend;\n                    }\n                    // Deserialize reference\n                    const referenceLength = paramsReader.readVarIntNum();\n                    const referenceBytes = paramsReader.read(referenceLength);\n                    args.reference = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(referenceBytes);\n                    // Deserialize options\n                    const optionsPresent = paramsReader.readInt8();\n                    if (optionsPresent === 1) {\n                        args.options = {};\n                        // acceptDelayedBroadcast\n                        const acceptDelayedBroadcastFlag = paramsReader.readInt8();\n                        if (acceptDelayedBroadcastFlag === -1) {\n                            args.options.acceptDelayedBroadcast = undefined;\n                        }\n                        else {\n                            args.options.acceptDelayedBroadcast =\n                                acceptDelayedBroadcastFlag === 1;\n                        }\n                        // returnTXIDOnly\n                        const returnTXIDOnlyFlag = paramsReader.readInt8();\n                        if (returnTXIDOnlyFlag === -1) {\n                            args.options.returnTXIDOnly = undefined;\n                        }\n                        else {\n                            args.options.returnTXIDOnly = returnTXIDOnlyFlag === 1;\n                        }\n                        // noSend\n                        const noSendFlag = paramsReader.readInt8();\n                        if (noSendFlag === -1) {\n                            args.options.noSend = undefined;\n                        }\n                        else {\n                            args.options.noSend = noSendFlag === 1;\n                        }\n                        // sendWith\n                        const sendWithLength = paramsReader.readVarIntNum();\n                        if (sendWithLength >= 0) {\n                            args.options.sendWith = [];\n                            for (let i = 0; i < sendWithLength; i++) {\n                                const txidBytes = paramsReader.read(32);\n                                const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(txidBytes);\n                                args.options.sendWith.push(txid);\n                            }\n                        }\n                        else {\n                            args.options.sendWith = undefined;\n                        }\n                    }\n                    else {\n                        args.options = undefined;\n                    }\n                    // Call the method\n                    const signActionResult = await this.wallet.signAction(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // txid\n                    if (signActionResult.txid != null && signActionResult.txid !== '') {\n                        resultWriter.writeInt8(1);\n                        resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(signActionResult.txid, 'hex'));\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // tx\n                    if (signActionResult.tx != null) {\n                        resultWriter.writeInt8(1);\n                        resultWriter.writeVarIntNum(signActionResult.tx.length);\n                        resultWriter.write(signActionResult.tx);\n                    }\n                    else {\n                        resultWriter.writeInt8(0);\n                    }\n                    // sendWithResults\n                    if (signActionResult.sendWithResults != null) {\n                        resultWriter.writeVarIntNum(signActionResult.sendWithResults.length);\n                        for (const result of signActionResult.sendWithResults) {\n                            resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(result.txid, 'hex'));\n                            let statusCode;\n                            if (result.status === 'unproven')\n                                statusCode = 1;\n                            else if (result.status === 'sending')\n                                statusCode = 2;\n                            else if (result.status === 'failed')\n                                statusCode = 3;\n                            resultWriter.writeInt8(statusCode);\n                        }\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'abortAction': {\n                    // Deserialize reference\n                    const referenceBytes = paramsReader.read();\n                    const reference = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(referenceBytes);\n                    // Call the method\n                    await this.wallet.abortAction({ reference }, originator);\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'listActions': {\n                    const args = {};\n                    // Deserialize labels\n                    const labelsLength = paramsReader.readVarIntNum();\n                    args.labels = [];\n                    for (let i = 0; i < labelsLength; i++) {\n                        const labelLength = paramsReader.readVarIntNum();\n                        const labelBytes = paramsReader.read(labelLength);\n                        args.labels.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(labelBytes));\n                    }\n                    // Deserialize labelQueryMode\n                    const labelQueryModeFlag = paramsReader.readInt8();\n                    if (labelQueryModeFlag === -1) {\n                        args.labelQueryMode = undefined;\n                    }\n                    else if (labelQueryModeFlag === 1) {\n                        args.labelQueryMode = 'any';\n                    }\n                    else if (labelQueryModeFlag === 2) {\n                        args.labelQueryMode = 'all';\n                    }\n                    // Deserialize include options\n                    const includeOptionsNames = [\n                        'includeLabels',\n                        'includeInputs',\n                        'includeInputSourceLockingScripts',\n                        'includeInputUnlockingScripts',\n                        'includeOutputs',\n                        'includeOutputLockingScripts'\n                    ];\n                    for (const optionName of includeOptionsNames) {\n                        const optionFlag = paramsReader.readInt8();\n                        if (optionFlag === -1) {\n                            args[optionName] = undefined;\n                        }\n                        else {\n                            args[optionName] = optionFlag === 1;\n                        }\n                    }\n                    // Deserialize limit\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    // Deserialize offset\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const listActionsResult = await this.wallet.listActions(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // totalActions\n                    resultWriter.writeVarIntNum(listActionsResult.totalActions);\n                    // actions\n                    for (const action of listActionsResult.actions) {\n                        // txid\n                        resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(action.txid, 'hex'));\n                        // satoshis\n                        resultWriter.writeVarIntNum(action.satoshis);\n                        // status\n                        let statusCode;\n                        switch (action.status) {\n                            case 'completed':\n                                statusCode = 1;\n                                break;\n                            case 'unprocessed':\n                                statusCode = 2;\n                                break;\n                            case 'sending':\n                                statusCode = 3;\n                                break;\n                            case 'unproven':\n                                statusCode = 4;\n                                break;\n                            case 'unsigned':\n                                statusCode = 5;\n                                break;\n                            case 'nosend':\n                                statusCode = 6;\n                                break;\n                            case 'nonfinal':\n                                statusCode = 7;\n                                break;\n                            case 'failed':\n                                statusCode = 8;\n                                break;\n                            default:\n                                statusCode = -1;\n                                break;\n                        }\n                        resultWriter.writeInt8(statusCode);\n                        // isOutgoing\n                        resultWriter.writeInt8(action.isOutgoing ? 1 : 0);\n                        // description\n                        const descriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(action.description, 'utf8');\n                        resultWriter.writeVarIntNum(descriptionBytes.length);\n                        resultWriter.write(descriptionBytes);\n                        // labels\n                        if (action.labels !== undefined) {\n                            resultWriter.writeVarIntNum(action.labels.length);\n                            for (const label of action.labels) {\n                                const labelBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(label, 'utf8');\n                                resultWriter.writeVarIntNum(labelBytes.length);\n                                resultWriter.write(labelBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // version\n                        resultWriter.writeVarIntNum(action.version);\n                        // lockTime\n                        resultWriter.writeVarIntNum(action.lockTime);\n                        // inputs\n                        if (action.inputs !== undefined) {\n                            resultWriter.writeVarIntNum(action.inputs.length);\n                            for (const input of action.inputs) {\n                                // sourceOutpoint\n                                resultWriter.write(this.encodeOutpoint(input.sourceOutpoint));\n                                // sourceSatoshis\n                                resultWriter.writeVarIntNum(input.sourceSatoshis);\n                                // sourceLockingScript\n                                if (input.sourceLockingScript !== undefined) {\n                                    const sourceLockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(input.sourceLockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(sourceLockingScriptBytes.length);\n                                    resultWriter.write(sourceLockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // unlockingScript\n                                if (input.unlockingScript !== undefined) {\n                                    const unlockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(input.unlockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(unlockingScriptBytes.length);\n                                    resultWriter.write(unlockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // inputDescription\n                                const inputDescriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(input.inputDescription, 'utf8');\n                                resultWriter.writeVarIntNum(inputDescriptionBytes.length);\n                                resultWriter.write(inputDescriptionBytes);\n                                // sequenceNumber\n                                resultWriter.writeVarIntNum(input.sequenceNumber);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // outputs\n                        if (action.outputs !== undefined) {\n                            resultWriter.writeVarIntNum(action.outputs.length);\n                            for (const output of action.outputs) {\n                                // outputIndex\n                                resultWriter.writeVarIntNum(output.outputIndex);\n                                // satoshis\n                                resultWriter.writeVarIntNum(output.satoshis);\n                                // lockingScript\n                                if (output.lockingScript !== undefined) {\n                                    const lockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.lockingScript, 'hex');\n                                    resultWriter.writeVarIntNum(lockingScriptBytes.length);\n                                    resultWriter.write(lockingScriptBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // spendable\n                                resultWriter.writeInt8(output.spendable ? 1 : 0);\n                                // outputDescription\n                                const outputDescriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.outputDescription, 'utf8');\n                                resultWriter.writeVarIntNum(outputDescriptionBytes.length);\n                                resultWriter.write(outputDescriptionBytes);\n                                // basket\n                                if (output.basket !== undefined) {\n                                    const basketBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.basket, 'utf8');\n                                    resultWriter.writeVarIntNum(basketBytes.length);\n                                    resultWriter.write(basketBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // tags\n                                if (output.tags !== undefined) {\n                                    resultWriter.writeVarIntNum(output.tags.length);\n                                    for (const tag of output.tags) {\n                                        const tagBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(tag, 'utf8');\n                                        resultWriter.writeVarIntNum(tagBytes.length);\n                                        resultWriter.write(tagBytes);\n                                    }\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                                // customInstructions\n                                if (output.customInstructions !== undefined) {\n                                    const customInstructionsBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.customInstructions, 'utf8');\n                                    resultWriter.writeVarIntNum(customInstructionsBytes.length);\n                                    resultWriter.write(customInstructionsBytes);\n                                }\n                                else {\n                                    resultWriter.writeVarIntNum(-1);\n                                }\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                    }\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'internalizeAction': {\n                    const args = {};\n                    // Read tx\n                    const txLength = paramsReader.readVarIntNum();\n                    args.tx = paramsReader.read(txLength);\n                    // Read outputs\n                    const outputsLength = paramsReader.readVarIntNum();\n                    args.outputs = [];\n                    for (let i = 0; i < outputsLength; i++) {\n                        const output = {};\n                        // outputIndex\n                        output.outputIndex = paramsReader.readVarIntNum();\n                        // protocol\n                        const protocolFlag = paramsReader.readUInt8();\n                        if (protocolFlag === 1) {\n                            output.protocol = 'wallet payment';\n                            output.paymentRemittance = {};\n                            // senderIdentityKey\n                            const senderIdentityKeyBytes = paramsReader.read(33);\n                            output.paymentRemittance.senderIdentityKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(senderIdentityKeyBytes);\n                            // derivationPrefix\n                            const derivationPrefixLength = paramsReader.readVarIntNum();\n                            const derivationPrefixBytes = paramsReader.read(derivationPrefixLength);\n                            output.paymentRemittance.derivationPrefix = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(derivationPrefixBytes);\n                            // derivationSuffix\n                            const derivationSuffixLength = paramsReader.readVarIntNum();\n                            const derivationSuffixBytes = paramsReader.read(derivationSuffixLength);\n                            output.paymentRemittance.derivationSuffix = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(derivationSuffixBytes);\n                        }\n                        else if (protocolFlag === 2) {\n                            output.protocol = 'basket insertion';\n                            output.insertionRemittance = {};\n                            // basket\n                            const basketLength = paramsReader.readVarIntNum();\n                            const basketBytes = paramsReader.read(basketLength);\n                            output.insertionRemittance.basket = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(basketBytes);\n                            // customInstructions\n                            const customInstructionsLength = paramsReader.readVarIntNum();\n                            if (customInstructionsLength >= 0) {\n                                const customInstructionsBytes = paramsReader.read(customInstructionsLength);\n                                output.insertionRemittance.customInstructions = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(customInstructionsBytes);\n                            }\n                            // tags\n                            const tagsLength = paramsReader.readVarIntNum();\n                            if (tagsLength > 0) {\n                                output.insertionRemittance.tags = [];\n                                for (let j = 0; j < tagsLength; j++) {\n                                    const tagLength = paramsReader.readVarIntNum();\n                                    const tagBytes = paramsReader.read(tagLength);\n                                    output.insertionRemittance.tags.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(tagBytes));\n                                }\n                            }\n                            else {\n                                output.insertionRemittance.tags = [];\n                            }\n                        }\n                        args.outputs.push(output);\n                    }\n                    const numberOfLabels = paramsReader.readVarIntNum();\n                    if (numberOfLabels >= 0) {\n                        args.labels = [];\n                        for (let i = 0; i < numberOfLabels; i++) {\n                            const labelLength = paramsReader.readVarIntNum();\n                            args.labels.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(paramsReader.read(labelLength)));\n                        }\n                    }\n                    const descriptionLength = paramsReader.readVarIntNum();\n                    args.description = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(paramsReader.read(descriptionLength));\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.internalizeAction(args, originator);\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'listOutputs': {\n                    const args = {};\n                    // Deserialize basket\n                    const basketLength = paramsReader.readVarIntNum();\n                    const basketBytes = paramsReader.read(basketLength);\n                    args.basket = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(basketBytes);\n                    // Deserialize tags\n                    const tagsLength = paramsReader.readVarIntNum();\n                    if (tagsLength > 0) {\n                        args.tags = [];\n                        for (let i = 0; i < tagsLength; i++) {\n                            const tagLength = paramsReader.readVarIntNum();\n                            const tagBytes = paramsReader.read(tagLength);\n                            args.tags.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(tagBytes));\n                        }\n                    }\n                    else {\n                        args.tags = undefined;\n                    }\n                    // Deserialize tagQueryMode\n                    const tagQueryModeFlag = paramsReader.readInt8();\n                    if (tagQueryModeFlag === 1) {\n                        args.tagQueryMode = 'all';\n                    }\n                    else if (tagQueryModeFlag === 2) {\n                        args.tagQueryMode = 'any';\n                    }\n                    else {\n                        args.tagQueryMode = undefined;\n                    }\n                    // Deserialize include\n                    const includeFlag = paramsReader.readInt8();\n                    if (includeFlag === 1) {\n                        args.include = 'locking scripts';\n                    }\n                    else if (includeFlag === 2) {\n                        args.include = 'entire transactions';\n                    }\n                    else {\n                        args.include = undefined;\n                    }\n                    // Deserialize includeCustomInstructions\n                    const includeCustomInstructionsFlag = paramsReader.readInt8();\n                    if (includeCustomInstructionsFlag === -1) {\n                        args.includeCustomInstructions = undefined;\n                    }\n                    else {\n                        args.includeCustomInstructions =\n                            includeCustomInstructionsFlag === 1;\n                    }\n                    // Deserialize includeTags\n                    const includeTagsFlag = paramsReader.readInt8();\n                    if (includeTagsFlag === -1) {\n                        args.includeTags = undefined;\n                    }\n                    else {\n                        args.includeTags = includeTagsFlag === 1;\n                    }\n                    // Deserialize includeLabels\n                    const includeLabelsFlag = paramsReader.readInt8();\n                    if (includeLabelsFlag === -1) {\n                        args.includeLabels = undefined;\n                    }\n                    else {\n                        args.includeLabels = includeLabelsFlag === 1;\n                    }\n                    // Deserialize limit\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    // Deserialize offset\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const listOutputsResult = await this.wallet.listOutputs(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // totalOutputs\n                    resultWriter.writeVarIntNum(listOutputsResult.totalOutputs);\n                    // BEEF length and BEEF or -1\n                    if (listOutputsResult.BEEF != null) {\n                        resultWriter.writeVarIntNum(listOutputsResult.BEEF.length);\n                        resultWriter.write(listOutputsResult.BEEF);\n                    }\n                    else {\n                        resultWriter.writeVarIntNum(-1);\n                    }\n                    // outputs\n                    for (const output of listOutputsResult.outputs) {\n                        // outpoint\n                        resultWriter.write(this.encodeOutpoint(output.outpoint));\n                        // satoshis\n                        resultWriter.writeVarIntNum(output.satoshis);\n                        // lockingScript\n                        if (output.lockingScript !== undefined) {\n                            const lockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.lockingScript, 'hex');\n                            resultWriter.writeVarIntNum(lockingScriptBytes.length);\n                            resultWriter.write(lockingScriptBytes);\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // customInstructions\n                        if (output.customInstructions !== undefined) {\n                            const customInstructionsBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(output.customInstructions, 'utf8');\n                            resultWriter.writeVarIntNum(customInstructionsBytes.length);\n                            resultWriter.write(customInstructionsBytes);\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // tags\n                        if (output.tags !== undefined) {\n                            resultWriter.writeVarIntNum(output.tags.length);\n                            for (const tag of output.tags) {\n                                const tagBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(tag, 'utf8');\n                                resultWriter.writeVarIntNum(tagBytes.length);\n                                resultWriter.write(tagBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                        // labels\n                        if (output.labels !== undefined) {\n                            resultWriter.writeVarIntNum(output.labels.length);\n                            for (const label of output.labels) {\n                                const labelBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(label, 'utf8');\n                                resultWriter.writeVarIntNum(labelBytes.length);\n                                resultWriter.write(labelBytes);\n                            }\n                        }\n                        else {\n                            resultWriter.writeVarIntNum(-1);\n                        }\n                    }\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'relinquishOutput': {\n                    const args = {};\n                    // Deserialize basket\n                    const basketLength = paramsReader.readVarIntNum();\n                    const basketBytes = paramsReader.read(basketLength);\n                    args.basket = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(basketBytes);\n                    // Deserialize outpoint\n                    args.output = this.decodeOutpoint(paramsReader);\n                    // Call the method\n                    await this.wallet.relinquishOutput(args, originator);\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'getPublicKey': {\n                    const args = {};\n                    // Deserialize identityKey flag\n                    const identityKeyFlag = paramsReader.readUInt8();\n                    args.identityKey = identityKeyFlag === 1;\n                    if (args.identityKey !== true) {\n                        // Deserialize protocolID\n                        args.protocolID = this.decodeProtocolID(paramsReader);\n                        // Deserialize keyID\n                        args.keyID = this.decodeString(paramsReader);\n                        // Deserialize counterparty\n                        args.counterparty = this.decodeCounterparty(paramsReader);\n                        // Deserialize privilege parameters\n                        const privilegedFlag = paramsReader.readInt8();\n                        if (privilegedFlag === -1) {\n                            args.privileged = undefined;\n                        }\n                        else {\n                            args.privileged = privilegedFlag === 1;\n                        }\n                        const privilegedReasonLength = paramsReader.readInt8();\n                        if (privilegedReasonLength !== -1) {\n                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                            args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                        }\n                        else {\n                            args.privilegedReason = undefined;\n                        }\n                        // Deserialize forSelf\n                        const forSelfFlag = paramsReader.readInt8();\n                        if (forSelfFlag === -1) {\n                            args.forSelf = undefined;\n                        }\n                        else {\n                            args.forSelf = forSelfFlag === 1;\n                        }\n                    }\n                    else {\n                        // Deserialize privilege parameters\n                        const privilegedFlag = paramsReader.readInt8();\n                        if (privilegedFlag === -1) {\n                            args.privileged = undefined;\n                        }\n                        else {\n                            args.privileged = privilegedFlag === 1;\n                        }\n                        const privilegedReasonLength = paramsReader.readInt8();\n                        if (privilegedReasonLength !== -1) {\n                            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                            args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                        }\n                        else {\n                            args.privilegedReason = undefined;\n                        }\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const getPublicKeyResult = await this.wallet.getPublicKey(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const publicKeyBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(getPublicKeyResult.publicKey, 'hex');\n                    responseWriter.write(publicKeyBytes);\n                    return responseWriter.toArray();\n                }\n                case 'encrypt': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize plaintext\n                    const plaintextLength = paramsReader.readVarIntNum();\n                    args.plaintext = paramsReader.read(plaintextLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const encryptResult = await this.wallet.encrypt(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(encryptResult.ciphertext);\n                    return responseWriter.toArray();\n                }\n                case 'decrypt': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize ciphertext\n                    const ciphertextLength = paramsReader.readVarIntNum();\n                    args.ciphertext = paramsReader.read(ciphertextLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const decryptResult = await this.wallet.decrypt(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(decryptResult.plaintext);\n                    return responseWriter.toArray();\n                }\n                case 'createHmac': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize data\n                    const dataLength = paramsReader.readVarIntNum();\n                    args.data = paramsReader.read(dataLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const createHmacResult = await this.wallet.createHmac(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(createHmacResult.hmac);\n                    return responseWriter.toArray();\n                }\n                case 'verifyHmac': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize hmac\n                    args.hmac = paramsReader.read(32);\n                    // Deserialize data\n                    const dataLength = paramsReader.readVarIntNum();\n                    args.data = paramsReader.read(dataLength);\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.verifyHmac(args, originator);\n                    // Serialize the result (no data to return)\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'createSignature': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize data or hashToDirectlySign\n                    const dataTypeFlag = paramsReader.readUInt8();\n                    if (dataTypeFlag === 1) {\n                        const dataLength = paramsReader.readVarIntNum();\n                        args.data = paramsReader.read(dataLength);\n                    }\n                    else if (dataTypeFlag === 2) {\n                        args.hashToDirectlySign = paramsReader.read(32);\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const createSignatureResult = await this.wallet.createSignature(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(createSignatureResult.signature);\n                    return responseWriter.toArray();\n                }\n                case 'verifySignature': {\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Deserialize forSelf\n                    const forSelfFlag = paramsReader.readInt8();\n                    if (forSelfFlag === -1) {\n                        args.forSelf = undefined;\n                    }\n                    else {\n                        args.forSelf = forSelfFlag === 1;\n                    }\n                    // Deserialize signature\n                    const signatureLength = paramsReader.readVarIntNum();\n                    args.signature = paramsReader.read(signatureLength);\n                    // Deserialize data or hashToDirectlyVerify\n                    const dataTypeFlag = paramsReader.readUInt8();\n                    if (dataTypeFlag === 1) {\n                        const dataLength = paramsReader.readVarIntNum();\n                        args.data = paramsReader.read(dataLength);\n                    }\n                    else if (dataTypeFlag === 2) {\n                        args.hashToDirectlyVerify = paramsReader.read(32);\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    await this.wallet.verifySignature(args, originator);\n                    // Serialize the result (no data to return)\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'isAuthenticated': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const isAuthenticatedResult = await this.wallet.isAuthenticated({}, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeUInt8(isAuthenticatedResult.authenticated ? 1 : 0);\n                    return responseWriter.toArray();\n                }\n                case 'waitForAuthentication': {\n                    // No parameters to deserialize\n                    // Call the method\n                    await this.wallet.waitForAuthentication({}, originator);\n                    // Serialize the result (authenticated is always true)\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'getHeight': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getHeightResult = await this.wallet.getHeight({}, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeVarIntNum(getHeightResult.height);\n                    return responseWriter.toArray();\n                }\n                case 'getHeaderForHeight': {\n                    const args = {};\n                    // Deserialize height\n                    args.height = paramsReader.readVarIntNum();\n                    // Call the method\n                    const getHeaderResult = await this.wallet.getHeaderForHeight(args, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const headerBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(getHeaderResult.header, 'hex');\n                    responseWriter.write(headerBytes);\n                    return responseWriter.toArray();\n                }\n                case 'getNetwork': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getNetworkResult = await this.wallet.getNetwork({}, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.writeUInt8(getNetworkResult.network === 'mainnet' ? 0 : 1);\n                    return responseWriter.toArray();\n                }\n                case 'getVersion': {\n                    // No parameters to deserialize\n                    // Call the method\n                    const getVersionResult = await this.wallet.getVersion({}, originator);\n                    // Serialize the result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    const versionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(getVersionResult.version, 'utf8');\n                    responseWriter.write(versionBytes);\n                    return responseWriter.toArray();\n                }\n                case 'revealCounterpartyKeyLinkage': {\n                    const args = {};\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                    }\n                    // Read counterparty public key\n                    const counterpartyBytes = paramsReader.read(33);\n                    args.counterparty = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(counterpartyBytes);\n                    // Read verifier public key\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(verifierBytes);\n                    // Call the method\n                    const revealResult = await this.wallet.revealCounterpartyKeyLinkage(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // Write prover\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.prover, 'hex'));\n                    // Write verifier\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.verifier, 'hex'));\n                    // Write counterparty\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.counterparty, 'hex'));\n                    // Write revelationTime\n                    const revelationTimeBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.revelationTime, 'utf8');\n                    resultWriter.writeVarIntNum(revelationTimeBytes.length);\n                    resultWriter.write(revelationTimeBytes);\n                    // Write encryptedLinkage\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);\n                    resultWriter.write(revealResult.encryptedLinkage);\n                    // Write encryptedLinkageProof\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);\n                    resultWriter.write(revealResult.encryptedLinkageProof);\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'revealSpecificKeyLinkage': {\n                    // Deserialize key-related parameters and privileged parameters\n                    const args = this.decodeKeyRelatedParams(paramsReader);\n                    // Read verifier public key\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(verifierBytes);\n                    // Call the method\n                    const revealResult = await this.wallet.revealSpecificKeyLinkage(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // Write prover\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.prover, 'hex'));\n                    // Write verifier\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.verifier, 'hex'));\n                    // Write counterparty\n                    resultWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.counterparty, 'hex'));\n                    // Write securityLevel\n                    resultWriter.writeUInt8(revealResult.protocolID[0]);\n                    // Write protocol string\n                    const protocolBytesOut = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.protocolID[1], 'utf8');\n                    resultWriter.writeVarIntNum(protocolBytesOut.length);\n                    resultWriter.write(protocolBytesOut);\n                    // Write keyID\n                    const keyIDBytesOut = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(revealResult.keyID, 'utf8');\n                    resultWriter.writeVarIntNum(keyIDBytesOut.length);\n                    resultWriter.write(keyIDBytesOut);\n                    // Write encryptedLinkage\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkage.length);\n                    resultWriter.write(revealResult.encryptedLinkage);\n                    // Write encryptedLinkageProof\n                    resultWriter.writeVarIntNum(revealResult.encryptedLinkageProof.length);\n                    resultWriter.write(revealResult.encryptedLinkageProof);\n                    // Write proofType\n                    resultWriter.writeUInt8(revealResult.proofType);\n                    // Return success code and result\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'acquireCertificate': {\n                    const args = {};\n                    // Read args.type\n                    const typeBytes = paramsReader.read(32);\n                    args.type = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(typeBytes);\n                    // args.certifier\n                    const certifierBytes = paramsReader.read(33);\n                    args.certifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(certifierBytes);\n                    // Read fields\n                    const fieldsLength = paramsReader.readVarIntNum();\n                    args.fields = {};\n                    for (let i = 0; i < fieldsLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldNameBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldValueBytes);\n                        args.fields[fieldName] = fieldValue;\n                    }\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                    }\n                    // Read acquisitionProtocol\n                    const acquisitionProtocolFlag = paramsReader.readUInt8();\n                    args.acquisitionProtocol =\n                        acquisitionProtocolFlag === 1 ? 'direct' : 'issuance';\n                    if (args.acquisitionProtocol === 'direct') {\n                        // args.serialNumber\n                        const serialNumberBytes = paramsReader.read(32);\n                        args.serialNumber = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(serialNumberBytes);\n                        // args.revocationOutpoint\n                        args.revocationOutpoint = this.decodeOutpoint(paramsReader);\n                        // args.signature\n                        const signatureLength = paramsReader.readVarIntNum();\n                        const signatureBytes = paramsReader.read(signatureLength);\n                        args.signature = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(signatureBytes);\n                        // args.keyringRevealer\n                        const keyringRevealerIdentifier = paramsReader.readUInt8();\n                        if (keyringRevealerIdentifier === 11) {\n                            args.keyringRevealer = 'certifier';\n                        }\n                        else {\n                            const keyringRevealerBytes = [keyringRevealerIdentifier].concat(paramsReader.read(32));\n                            args.keyringRevealer = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(keyringRevealerBytes);\n                        }\n                        // args.keyringForSubject\n                        const keyringEntriesLength = paramsReader.readVarIntNum();\n                        args.keyringForSubject = {};\n                        for (let i = 0; i < keyringEntriesLength; i++) {\n                            const fieldKeyLength = paramsReader.readVarIntNum();\n                            const fieldKeyBytes = paramsReader.read(fieldKeyLength);\n                            const fieldKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldKeyBytes);\n                            const fieldValueLength = paramsReader.readVarIntNum();\n                            const fieldValueBytes = paramsReader.read(fieldValueLength);\n                            const fieldValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(fieldValueBytes);\n                            args.keyringForSubject[fieldKey] = fieldValue;\n                        }\n                    }\n                    else {\n                        // args.certifierUrl\n                        const certifierUrlLength = paramsReader.readVarIntNum();\n                        const certifierUrlBytes = paramsReader.read(certifierUrlLength);\n                        args.certifierUrl = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(certifierUrlBytes);\n                    }\n                    // Call the method\n                    const acquireResult = await this.wallet.acquireCertificate(args, originator);\n                    // Serialize the certificate (assuming Certificate class is available)\n                    const cert = new _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](acquireResult.type, acquireResult.serialNumber, acquireResult.subject, acquireResult.certifier, acquireResult.revocationOutpoint, acquireResult.fields, acquireResult.signature);\n                    const certBin = cert.toBinary();\n                    // Return success code and certificate binary\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(certBin);\n                    return responseWriter.toArray();\n                }\n                case 'listCertificates': {\n                    const args = {};\n                    // Read certifiers\n                    const certifiersLength = paramsReader.readVarIntNum();\n                    args.certifiers = [];\n                    for (let i = 0; i < certifiersLength; i++) {\n                        const certifierBytes = paramsReader.read(33);\n                        args.certifiers.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(certifierBytes));\n                    }\n                    // Read types\n                    const typesLength = paramsReader.readVarIntNum();\n                    args.types = [];\n                    for (let i = 0; i < typesLength; i++) {\n                        const typeBytes = paramsReader.read(32);\n                        args.types.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(typeBytes));\n                    }\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                    }\n                    // Call the method\n                    const listResult = await this.wallet.listCertificates(args, originator);\n                    // Serialize the result\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    // totalCertificates\n                    resultWriter.writeVarIntNum(listResult.totalCertificates);\n                    // certificates\n                    for (const cert of listResult.certificates) {\n                        const certificate = new _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);\n                        const certBin = certificate.toBinary();\n                        // Write certificate binary length and data\n                        resultWriter.writeVarIntNum(certBin.length);\n                        resultWriter.write(certBin);\n                    }\n                    // Return the response\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'proveCertificate': {\n                    const args = {};\n                    // Read certificate\n                    const cert = {};\n                    // Read type\n                    const typeBytes = paramsReader.read(32);\n                    cert.type = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(typeBytes);\n                    // Read subject\n                    const subjectBytes = paramsReader.read(33);\n                    cert.subject = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(subjectBytes);\n                    // Read serialNumber\n                    const serialNumberBytes = paramsReader.read(32);\n                    cert.serialNumber = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(serialNumberBytes);\n                    // Read certifier\n                    const certifierBytes = paramsReader.read(33);\n                    cert.certifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(certifierBytes);\n                    // Read revocationOutpoint\n                    cert.revocationOutpoint = this.decodeOutpoint(paramsReader);\n                    // Read signature\n                    const signatureLength = paramsReader.readVarIntNum();\n                    const signatureBytes = paramsReader.read(signatureLength);\n                    cert.signature = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(signatureBytes);\n                    // Read fields\n                    const fieldsLength = paramsReader.readVarIntNum();\n                    cert.fields = {};\n                    for (let i = 0; i < fieldsLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldNameBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldValueBytes);\n                        cert.fields[fieldName] = fieldValue;\n                    }\n                    args.certificate = cert;\n                    // Read fields to reveal\n                    const fieldsToRevealLength = paramsReader.readVarIntNum();\n                    args.fieldsToReveal = [];\n                    for (let i = 0; i < fieldsToRevealLength; i++) {\n                        const fieldNameLength = paramsReader.readVarIntNum();\n                        const fieldNameBytes = paramsReader.read(fieldNameLength);\n                        const fieldName = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldNameBytes);\n                        args.fieldsToReveal.push(fieldName);\n                    }\n                    // Read verifier\n                    const verifierBytes = paramsReader.read(33);\n                    args.verifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(verifierBytes);\n                    // Read privileged parameters\n                    const privilegedFlag = paramsReader.readInt8();\n                    if (privilegedFlag === -1) {\n                        args.privileged = undefined;\n                    }\n                    else {\n                        args.privileged = privilegedFlag === 1;\n                    }\n                    const privilegedReasonLength = paramsReader.readInt8();\n                    if (privilegedReasonLength === -1) {\n                        args.privilegedReason = undefined;\n                    }\n                    else {\n                        const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n                        args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n                    }\n                    // Call the method\n                    const proveResult = await this.wallet.proveCertificate(args, originator);\n                    // Serialize keyringForVerifier\n                    const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    const keyringEntries = Object.entries(proveResult.keyringForVerifier);\n                    resultWriter.writeVarIntNum(keyringEntries.length);\n                    for (const [fieldName, fieldValue] of keyringEntries) {\n                        const fieldNameBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldName, 'utf8');\n                        resultWriter.writeVarIntNum(fieldNameBytes.length);\n                        resultWriter.write(fieldNameBytes);\n                        const fieldValueBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldValue, 'base64');\n                        resultWriter.writeVarIntNum(fieldValueBytes.length);\n                        resultWriter.write(fieldValueBytes);\n                    }\n                    // Return the response\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(resultWriter.toArray());\n                    return responseWriter.toArray();\n                }\n                case 'relinquishCertificate': {\n                    const args = {};\n                    // Read type\n                    const typeBytes = paramsReader.read(32);\n                    args.type = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(typeBytes);\n                    // Read serialNumber\n                    const serialNumberBytes = paramsReader.read(32);\n                    args.serialNumber = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBase64(serialNumberBytes);\n                    // Read certifier\n                    const certifierBytes = paramsReader.read(33);\n                    args.certifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(certifierBytes);\n                    // Call the method\n                    await this.wallet.relinquishCertificate(args, originator);\n                    // Return success code\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    return responseWriter.toArray();\n                }\n                case 'discoverByIdentityKey': {\n                    const args = {};\n                    // Read identityKey\n                    const identityKeyBytes = paramsReader.read(33);\n                    args.identityKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex(identityKeyBytes);\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const discoverResult = await this.wallet.discoverByIdentityKey(args, originator);\n                    // Serialize the result\n                    const result = this.serializeDiscoveryResult(discoverResult);\n                    // Return the response\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(result);\n                    return responseWriter.toArray();\n                }\n                case 'discoverByAttributes': {\n                    const args = {};\n                    // Read attributes\n                    const attributesLength = paramsReader.readVarIntNum();\n                    args.attributes = {};\n                    for (let i = 0; i < attributesLength; i++) {\n                        const fieldKeyLength = paramsReader.readVarIntNum();\n                        const fieldKeyBytes = paramsReader.read(fieldKeyLength);\n                        const fieldKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldKeyBytes);\n                        const fieldValueLength = paramsReader.readVarIntNum();\n                        const fieldValueBytes = paramsReader.read(fieldValueLength);\n                        const fieldValue = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(fieldValueBytes);\n                        args.attributes[fieldKey] = fieldValue;\n                    }\n                    // Read limit and offset\n                    const limit = paramsReader.readVarIntNum();\n                    if (limit >= 0) {\n                        args.limit = limit;\n                    }\n                    else {\n                        args.limit = undefined;\n                    }\n                    const offset = paramsReader.readVarIntNum();\n                    if (offset >= 0) {\n                        args.offset = offset;\n                    }\n                    else {\n                        args.offset = undefined;\n                    }\n                    // Deserialize seekPermission\n                    const seekPermission = paramsReader.readInt8();\n                    if (seekPermission >= 0) {\n                        args.seekPermission = seekPermission === 1;\n                    }\n                    else {\n                        args.seekPermission = undefined;\n                    }\n                    // Call the method\n                    const discoverResult = await this.wallet.discoverByAttributes(args, originator);\n                    // Serialize the result\n                    const result = this.serializeDiscoveryResult(discoverResult);\n                    // Return the response\n                    const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n                    responseWriter.writeUInt8(0); // errorByte = 0\n                    responseWriter.write(result);\n                    return responseWriter.toArray();\n                }\n                default:\n                    throw new Error(`Method ${callName} not implemented`);\n            }\n        }\n        catch (err) {\n            const responseWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n            responseWriter.writeUInt8(typeof err.code === 'number' ? err.code : 1); // errorCode = 1 (generic error)\n            // Serialize the error message\n            const errorMessage = typeof err.message === 'string' ? err.message : 'Unknown error';\n            const errorMessageBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(errorMessage, 'utf8');\n            responseWriter.writeVarIntNum(errorMessageBytes.length);\n            responseWriter.write(errorMessageBytes);\n            // Serialize the stack trace\n            const stackTrace = typeof err.stack === 'string' ? err.stack : '';\n            const stackTraceBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(stackTrace, 'utf8');\n            responseWriter.writeVarIntNum(stackTraceBytes.length);\n            responseWriter.write(stackTraceBytes);\n            return responseWriter.toArray();\n        }\n    }\n    decodeProtocolID(reader) {\n        const securityLevel = reader.readUInt8();\n        const protocolLength = reader.readVarIntNum();\n        const protocolBytes = reader.read(protocolLength);\n        const protocolString = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(protocolBytes);\n        return [securityLevel, protocolString];\n    }\n    decodeString(reader) {\n        const length = reader.readVarIntNum();\n        const bytes = reader.read(length);\n        return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(bytes);\n    }\n    decodeCounterparty(reader) {\n        const counterpartyFlag = reader.readUInt8();\n        if (counterpartyFlag === 11) {\n            return 'self';\n        }\n        else if (counterpartyFlag === 12) {\n            return 'anyone';\n        }\n        else if (counterpartyFlag === 0) {\n            return undefined;\n        }\n        else {\n            const counterpartyRemainingBytes = reader.read(32);\n            return _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toHex([counterpartyFlag, ...counterpartyRemainingBytes]);\n        }\n    }\n    serializeDiscoveryResult(discoverResult) {\n        const resultWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.Writer();\n        // totalCertificates\n        resultWriter.writeVarIntNum(discoverResult.totalCertificates);\n        // certificates\n        for (const cert of discoverResult.certificates) {\n            // Serialize certificate binary\n            const certificate = new _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](cert.type, cert.serialNumber, cert.subject, cert.certifier, cert.revocationOutpoint, cert.fields, cert.signature);\n            const certBin = certificate.toBinary();\n            // Write certificate binary length and data\n            resultWriter.writeVarIntNum(certBin.length);\n            resultWriter.write(certBin);\n            // Serialize certifierInfo\n            const nameBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(cert.certifierInfo.name, 'utf8');\n            resultWriter.writeVarIntNum(nameBytes.length);\n            resultWriter.write(nameBytes);\n            const iconUrlBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(cert.certifierInfo.iconUrl, 'utf8');\n            resultWriter.writeVarIntNum(iconUrlBytes.length);\n            resultWriter.write(iconUrlBytes);\n            const descriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(cert.certifierInfo.description, 'utf8');\n            resultWriter.writeVarIntNum(descriptionBytes.length);\n            resultWriter.write(descriptionBytes);\n            resultWriter.writeUInt8(cert.certifierInfo.trust);\n            // Serialize publiclyRevealedKeyring\n            const publicKeyringEntries = Object.entries(cert.publiclyRevealedKeyring);\n            resultWriter.writeVarIntNum(publicKeyringEntries.length);\n            for (const [fieldName, fieldValue] of publicKeyringEntries) {\n                const fieldNameBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldName, 'utf8');\n                resultWriter.writeVarIntNum(fieldNameBytes.length);\n                resultWriter.write(fieldNameBytes);\n                const fieldValueBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldValue, 'base64');\n                resultWriter.writeVarIntNum(fieldValueBytes.length);\n                resultWriter.write(fieldValueBytes);\n            }\n            // Serialize decryptedFields\n            const decryptedFieldEntries = Object.entries(cert.decryptedFields);\n            resultWriter.writeVarIntNum(decryptedFieldEntries.length);\n            for (const [fieldName, fieldValue] of decryptedFieldEntries) {\n                const fieldNameBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldName, 'utf8');\n                resultWriter.writeVarIntNum(fieldNameBytes.length);\n                resultWriter.write(fieldNameBytes);\n                const fieldValueBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toArray(fieldValue, 'utf8');\n                resultWriter.writeVarIntNum(fieldValueBytes.length);\n                resultWriter.write(fieldValueBytes);\n            }\n        }\n        return resultWriter.toArray();\n    }\n    decodeKeyRelatedParams(paramsReader) {\n        const args = {};\n        // Read protocolID\n        args.protocolID = this.decodeProtocolID(paramsReader);\n        // Read keyID\n        const keyIDLength = paramsReader.readVarIntNum();\n        const keyIDBytes = paramsReader.read(keyIDLength);\n        args.keyID = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(keyIDBytes);\n        // Read counterparty\n        args.counterparty = this.decodeCounterparty(paramsReader);\n        // Read privileged parameters\n        const privilegedFlag = paramsReader.readInt8();\n        if (privilegedFlag === -1) {\n            args.privileged = undefined;\n        }\n        else {\n            args.privileged = privilegedFlag === 1;\n        }\n        const privilegedReasonLength = paramsReader.readInt8();\n        if (privilegedReasonLength === -1) {\n            args.privilegedReason = undefined;\n        }\n        else {\n            const privilegedReasonBytes = paramsReader.read(privilegedReasonLength);\n            args.privilegedReason = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_0__.toUTF8(privilegedReasonBytes);\n        }\n        return args;\n    }\n}\n//# sourceMappingURL=WalletWireProcessor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireProcessor.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireTransceiver.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireTransceiver.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WalletWireTransceiver)\n/* harmony export */ });\n/* harmony import */ var _Wallet_interfaces_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Wallet.interfaces.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/Wallet.interfaces.js\");\n/* harmony import */ var _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../auth/certificates/Certificate.js */ \"./node_modules/@bsv/sdk/dist/esm/src/auth/certificates/Certificate.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js\");\n/* harmony import */ var _WalletError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js\");\n\n\n\n\n\n/**\n * A way to make remote calls to a wallet over a wallet wire.\n */\nclass WalletWireTransceiver {\n    wire;\n    constructor(wire) {\n        this.wire = wire;\n    }\n    async transmit(call, originator = '', params = []) {\n        const frameWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        frameWriter.writeUInt8(_WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"][call]);\n        const originatorArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(originator, 'utf8');\n        frameWriter.writeUInt8(originatorArray.length);\n        frameWriter.write(originatorArray);\n        if (params.length > 0) {\n            frameWriter.write(params);\n        }\n        const frame = frameWriter.toArray();\n        const result = await this.wire.transmitToWallet(frame);\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const errorByte = resultReader.readUInt8();\n        if (errorByte === 0) {\n            const resultFrame = resultReader.read();\n            return resultFrame;\n        }\n        else {\n            // Deserialize the error message length\n            const errorMessageLength = resultReader.readVarIntNum();\n            const errorMessageBytes = resultReader.read(errorMessageLength);\n            const errorMessage = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(errorMessageBytes);\n            // Deserialize the stack trace length\n            const stackTraceLength = resultReader.readVarIntNum();\n            const stackTraceBytes = resultReader.read(stackTraceLength);\n            const stackTrace = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(stackTraceBytes);\n            // Construct a custom wallet error\n            const e = new _WalletError_js__WEBPACK_IMPORTED_MODULE_4__.WalletError(errorMessage, errorByte, stackTrace);\n            throw e;\n        }\n    }\n    async createAction(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        // Serialize description\n        const descriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.description, 'utf8');\n        paramWriter.writeVarIntNum(descriptionBytes.length);\n        paramWriter.write(descriptionBytes);\n        // input BEEF\n        if (args.inputBEEF != null) {\n            paramWriter.writeVarIntNum(args.inputBEEF.length);\n            paramWriter.write(args.inputBEEF);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize inputs\n        if (args.inputs != null) {\n            paramWriter.writeVarIntNum(args.inputs.length);\n            for (const input of args.inputs) {\n                // outpoint\n                paramWriter.write(this.encodeOutpoint(input.outpoint));\n                // unlockingScript / unlockingScriptLength\n                if (input.unlockingScript != null && input.unlockingScript !== '') {\n                    const unlockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(input.unlockingScript, 'hex');\n                    paramWriter.writeVarIntNum(unlockingScriptBytes.length);\n                    paramWriter.write(unlockingScriptBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                    paramWriter.writeVarIntNum(input.unlockingScriptLength ?? 0);\n                }\n                // inputDescription\n                const inputDescriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(input.inputDescription, 'utf8');\n                paramWriter.writeVarIntNum(inputDescriptionBytes.length);\n                paramWriter.write(inputDescriptionBytes);\n                // sequenceNumber\n                if (typeof input.sequenceNumber === 'number') {\n                    paramWriter.writeVarIntNum(input.sequenceNumber);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize outputs\n        if (args.outputs != null) {\n            paramWriter.writeVarIntNum(args.outputs.length);\n            for (const output of args.outputs) {\n                // lockingScript\n                const lockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(output.lockingScript, 'hex');\n                paramWriter.writeVarIntNum(lockingScriptBytes.length);\n                paramWriter.write(lockingScriptBytes);\n                // satoshis\n                paramWriter.writeVarIntNum(output.satoshis);\n                // outputDescription\n                const outputDescriptionBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(output.outputDescription, 'utf8');\n                paramWriter.writeVarIntNum(outputDescriptionBytes.length);\n                paramWriter.write(outputDescriptionBytes);\n                // basket\n                if (output.basket != null && output.basket !== '') {\n                    const basketBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(output.basket, 'utf8');\n                    paramWriter.writeVarIntNum(basketBytes.length);\n                    paramWriter.write(basketBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                // customInstructions\n                if (output.customInstructions != null && output.customInstructions !== '') {\n                    const customInstructionsBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(output.customInstructions, 'utf8');\n                    paramWriter.writeVarIntNum(customInstructionsBytes.length);\n                    paramWriter.write(customInstructionsBytes);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                // tags\n                if (output.tags != null) {\n                    paramWriter.writeVarIntNum(output.tags.length);\n                    for (const tag of output.tags) {\n                        const tagBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(tag, 'utf8');\n                        paramWriter.writeVarIntNum(tagBytes.length);\n                        paramWriter.write(tagBytes);\n                    }\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize lockTime\n        if (typeof args.lockTime === 'number') {\n            paramWriter.writeVarIntNum(args.lockTime);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize version\n        if (typeof args.version === 'number') {\n            paramWriter.writeVarIntNum(args.version);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize labels\n        if (args.labels != null) {\n            paramWriter.writeVarIntNum(args.labels.length);\n            for (const label of args.labels) {\n                const labelBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(label, 'utf8');\n                paramWriter.writeVarIntNum(labelBytes.length);\n                paramWriter.write(labelBytes);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize options\n        if (args.options != null) {\n            paramWriter.writeInt8(1); // options present\n            // signAndProcess\n            if (typeof args.options.signAndProcess === 'boolean') {\n                paramWriter.writeInt8(args.options.signAndProcess ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // acceptDelayedBroadcast\n            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {\n                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // trustSelf\n            if (args.options.trustSelf === 'known') {\n                paramWriter.writeInt8(1);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // knownTxids\n            if (args.options.knownTxids != null) {\n                paramWriter.writeVarIntNum(args.options.knownTxids.length);\n                for (const txid of args.options.knownTxids) {\n                    const txidBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // returnTXIDOnly\n            if (typeof args.options.returnTXIDOnly === 'boolean') {\n                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSend\n            if (typeof args.options.noSend === 'boolean') {\n                paramWriter.writeInt8(args.options.noSend ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSendChange\n            if (args.options.noSendChange != null) {\n                paramWriter.writeVarIntNum(args.options.noSendChange.length);\n                for (const outpoint of args.options.noSendChange) {\n                    paramWriter.write(this.encodeOutpoint(outpoint));\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // sendWith\n            if (args.options.sendWith != null) {\n                paramWriter.writeVarIntNum(args.options.sendWith.length);\n                for (const txid of args.options.sendWith) {\n                    const txidBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n            // randomizeOutputs\n            if (typeof args.options.randomizeOutputs === 'boolean') {\n                paramWriter.writeInt8(args.options.randomizeOutputs ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        else {\n            paramWriter.writeInt8(0); // options not present\n        }\n        // Transmit and parse response\n        const result = await this.transmit('createAction', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const response = {};\n        // Parse txid\n        const txidFlag = resultReader.readInt8();\n        if (txidFlag === 1) {\n            const txidBytes = resultReader.read(32);\n            response.txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(txidBytes);\n        }\n        // Parse tx\n        const txFlag = resultReader.readInt8();\n        if (txFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            response.tx = resultReader.read(txLength);\n        }\n        // Parse noSendChange\n        const noSendChangeLength = resultReader.readVarIntNum();\n        if (noSendChangeLength >= 0) {\n            response.noSendChange = [];\n            for (let i = 0; i < noSendChangeLength; i++) {\n                const outpoint = this.readOutpoint(resultReader);\n                response.noSendChange.push(outpoint);\n            }\n        }\n        // Parse sendWithResults\n        const sendWithResultsLength = resultReader.readVarIntNum();\n        if (sendWithResultsLength >= 0) {\n            response.sendWithResults = [];\n            for (let i = 0; i < sendWithResultsLength; i++) {\n                const txidBytes = resultReader.read(32);\n                const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(txidBytes);\n                const statusCode = resultReader.readInt8();\n                let status = 'unproven';\n                if (statusCode === 1)\n                    status = 'unproven';\n                else if (statusCode === 2)\n                    status = 'sending';\n                else if (statusCode === 3)\n                    status = 'failed';\n                response.sendWithResults.push({ txid, status });\n            }\n        }\n        // Parse signableTransaction\n        const signableTransactionFlag = resultReader.readInt8();\n        if (signableTransactionFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            const tx = resultReader.read(txLength);\n            const referenceLength = resultReader.readVarIntNum();\n            const referenceBytes = resultReader.read(referenceLength);\n            response.signableTransaction = {\n                tx,\n                reference: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBase64(referenceBytes)\n            };\n        }\n        return response;\n    }\n    async signAction(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        // Serialize spends\n        const spendIndexes = Object.keys(args.spends);\n        paramWriter.writeVarIntNum(spendIndexes.length);\n        for (const index of spendIndexes) {\n            paramWriter.writeVarIntNum(Number(index));\n            const spend = args.spends[Number(index)];\n            // unlockingScript\n            const unlockingScriptBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(spend.unlockingScript, 'hex');\n            paramWriter.writeVarIntNum(unlockingScriptBytes.length);\n            paramWriter.write(unlockingScriptBytes);\n            // sequenceNumber\n            if (typeof spend.sequenceNumber === 'number') {\n                paramWriter.writeVarIntNum(spend.sequenceNumber);\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n        }\n        // Serialize reference\n        const referenceBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.reference, 'base64');\n        paramWriter.writeVarIntNum(referenceBytes.length);\n        paramWriter.write(referenceBytes);\n        // Serialize options\n        if (args.options != null) {\n            paramWriter.writeInt8(1); // options present\n            // acceptDelayedBroadcast\n            if (typeof args.options.acceptDelayedBroadcast === 'boolean') {\n                paramWriter.writeInt8(args.options.acceptDelayedBroadcast ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // returnTXIDOnly\n            if (typeof args.options.returnTXIDOnly === 'boolean') {\n                paramWriter.writeInt8(args.options.returnTXIDOnly ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // noSend\n            if (typeof args.options.noSend === 'boolean') {\n                paramWriter.writeInt8(args.options.noSend ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n            // sendWith\n            if (args.options.sendWith != null) {\n                paramWriter.writeVarIntNum(args.options.sendWith.length);\n                for (const txid of args.options.sendWith) {\n                    const txidBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(txid, 'hex');\n                    paramWriter.write(txidBytes);\n                }\n            }\n            else {\n                paramWriter.writeVarIntNum(-1);\n            }\n        }\n        else {\n            paramWriter.writeInt8(0); // options not present\n        }\n        // Transmit and parse response\n        const result = await this.transmit('signAction', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const response = {};\n        // Parse txid\n        const txidFlag = resultReader.readInt8();\n        if (txidFlag === 1) {\n            const txidBytes = resultReader.read(32);\n            response.txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(txidBytes);\n        }\n        // Parse tx\n        const txFlag = resultReader.readInt8();\n        if (txFlag === 1) {\n            const txLength = resultReader.readVarIntNum();\n            response.tx = resultReader.read(txLength);\n        }\n        // Parse sendWithResults\n        const sendWithResultsLength = resultReader.readVarIntNum();\n        if (sendWithResultsLength >= 0) {\n            response.sendWithResults = [];\n            for (let i = 0; i < sendWithResultsLength; i++) {\n                const txidBytes = resultReader.read(32);\n                const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(txidBytes);\n                const statusCode = resultReader.readInt8();\n                let status = 'unproven';\n                if (statusCode === 1)\n                    status = 'unproven';\n                else if (statusCode === 2)\n                    status = 'sending';\n                else if (statusCode === 3)\n                    status = 'failed';\n                response.sendWithResults.push({ txid, status });\n            }\n        }\n        return response;\n    }\n    async abortAction(args, originator) {\n        await this.transmit('abortAction', originator, _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.reference, 'base64'));\n        return { aborted: true };\n    }\n    async listActions(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        // Serialize labels\n        paramWriter.writeVarIntNum(args.labels.length);\n        for (const label of args.labels) {\n            const labelBytes = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(label, 'utf8');\n            paramWriter.writeVarIntNum(labelBytes.length);\n            paramWriter.write(labelBytes);\n        }\n        // Serialize labelQueryMode\n        if (args.labelQueryMode === 'any') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.labelQueryMode === 'all') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        // Serialize include options\n        const includeOptions = [\n            args.includeLabels,\n            args.includeInputs,\n            args.includeInputSourceLockingScripts,\n            args.includeInputUnlockingScripts,\n            args.includeOutputs,\n            args.includeOutputLockingScripts\n        ];\n        for (const option of includeOptions) {\n            if (typeof option === 'boolean') {\n                paramWriter.writeInt8(option ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        // Serialize limit and offset\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        // Transmit and parse response\n        const result = await this.transmit('listActions', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const totalActions = resultReader.readVarIntNum();\n        const actions = [];\n        for (let i = 0; i < totalActions; i++) {\n            // Parse action fields\n            const txidBytes = resultReader.read(32);\n            const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(txidBytes);\n            const satoshis = resultReader.readVarIntNum();\n            const statusCode = resultReader.readInt8();\n            let status;\n            switch (statusCode) {\n                case 1:\n                    status = 'completed';\n                    break;\n                case 2:\n                    status = 'unprocessed';\n                    break;\n                case 3:\n                    status = 'sending';\n                    break;\n                case 4:\n                    status = 'unproven';\n                    break;\n                case 5:\n                    status = 'unsigned';\n                    break;\n                case 6:\n                    status = 'nosend';\n                    break;\n                case 7:\n                    status = 'nonfinal';\n                    break;\n                case 8:\n                    status = 'failed';\n                    break;\n                default:\n                    throw new Error(`Unknown status code: ${statusCode}`);\n            }\n            const isOutgoing = resultReader.readInt8() === 1;\n            const descriptionLength = resultReader.readVarIntNum();\n            const descriptionBytes = resultReader.read(descriptionLength);\n            const description = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(descriptionBytes);\n            const action = {\n                txid,\n                satoshis,\n                status,\n                isOutgoing,\n                description,\n                version: 0,\n                lockTime: 0\n            };\n            // Parse labels\n            const labelsLength = resultReader.readVarIntNum();\n            if (labelsLength >= 0) {\n                action.labels = [];\n                for (let j = 0; j < labelsLength; j++) {\n                    const labelLength = resultReader.readVarIntNum();\n                    const labelBytes = resultReader.read(labelLength);\n                    action.labels.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(labelBytes));\n                }\n            }\n            // Parse version and lockTime\n            action.version = resultReader.readVarIntNum();\n            action.lockTime = resultReader.readVarIntNum();\n            // Parse inputs\n            const inputsLength = resultReader.readVarIntNum();\n            if (inputsLength >= 0) {\n                action.inputs = [];\n                for (let k = 0; k < inputsLength; k++) {\n                    const sourceOutpoint = this.readOutpoint(resultReader);\n                    const sourceSatoshis = resultReader.readVarIntNum();\n                    // sourceLockingScript\n                    const sourceLockingScriptLength = resultReader.readVarIntNum();\n                    let sourceLockingScript;\n                    if (sourceLockingScriptLength >= 0) {\n                        const sourceLockingScriptBytes = resultReader.read(sourceLockingScriptLength);\n                        sourceLockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(sourceLockingScriptBytes);\n                    }\n                    // unlockingScript\n                    const unlockingScriptLength = resultReader.readVarIntNum();\n                    let unlockingScript;\n                    if (unlockingScriptLength >= 0) {\n                        const unlockingScriptBytes = resultReader.read(unlockingScriptLength);\n                        unlockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(unlockingScriptBytes);\n                    }\n                    // inputDescription\n                    const inputDescriptionLength = resultReader.readVarIntNum();\n                    const inputDescriptionBytes = resultReader.read(inputDescriptionLength);\n                    const inputDescription = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(inputDescriptionBytes);\n                    // sequenceNumber\n                    const sequenceNumber = resultReader.readVarIntNum();\n                    action.inputs.push({\n                        sourceOutpoint,\n                        sourceSatoshis,\n                        sourceLockingScript,\n                        unlockingScript,\n                        inputDescription,\n                        sequenceNumber\n                    });\n                }\n            }\n            // Parse outputs\n            const outputsLength = resultReader.readVarIntNum();\n            if (outputsLength >= 0) {\n                action.outputs = [];\n                for (let l = 0; l < outputsLength; l++) {\n                    const outputIndex = resultReader.readVarIntNum();\n                    const satoshis = resultReader.readVarIntNum();\n                    // lockingScript\n                    const lockingScriptLength = resultReader.readVarIntNum();\n                    let lockingScript;\n                    if (lockingScriptLength >= 0) {\n                        const lockingScriptBytes = resultReader.read(lockingScriptLength);\n                        lockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(lockingScriptBytes);\n                    }\n                    const spendable = resultReader.readInt8() === 1;\n                    // outputDescription\n                    const outputDescriptionLength = resultReader.readVarIntNum();\n                    const outputDescriptionBytes = resultReader.read(outputDescriptionLength);\n                    const outputDescription = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(outputDescriptionBytes);\n                    // basket\n                    const basketLength = resultReader.readVarIntNum();\n                    let basket;\n                    if (basketLength >= 0) {\n                        const basketBytes = resultReader.read(basketLength);\n                        basket = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(basketBytes);\n                    }\n                    // tags\n                    const tagsLength = resultReader.readVarIntNum();\n                    const tags = [];\n                    if (tagsLength >= 0) {\n                        for (let m = 0; m < tagsLength; m++) {\n                            const tagLength = resultReader.readVarIntNum();\n                            const tagBytes = resultReader.read(tagLength);\n                            tags.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(tagBytes));\n                        }\n                    }\n                    // customInstructions\n                    const customInstructionsLength = resultReader.readVarIntNum();\n                    let customInstructions;\n                    if (customInstructionsLength >= 0) {\n                        const customInstructionsBytes = resultReader.read(customInstructionsLength);\n                        customInstructions = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(customInstructionsBytes);\n                    }\n                    action.outputs.push({\n                        outputIndex,\n                        satoshis,\n                        lockingScript,\n                        spendable,\n                        outputDescription,\n                        basket,\n                        tags,\n                        customInstructions\n                    });\n                }\n            }\n            actions.push(action);\n        }\n        return {\n            totalActions,\n            actions\n        };\n    }\n    async internalizeAction(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.writeVarIntNum(args.tx.length);\n        paramWriter.write(args.tx);\n        paramWriter.writeVarIntNum(args.outputs.length);\n        for (const out of args.outputs) {\n            paramWriter.writeVarIntNum(out.outputIndex);\n            if (out.protocol === 'wallet payment') {\n                if (out.paymentRemittance == null) {\n                    throw new Error('Payment remittance is required for wallet payment');\n                }\n                paramWriter.writeUInt8(1);\n                paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(out.paymentRemittance.senderIdentityKey, 'hex'));\n                const derivationPrefixAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(out.paymentRemittance.derivationPrefix, 'base64');\n                paramWriter.writeVarIntNum(derivationPrefixAsArray.length);\n                paramWriter.write(derivationPrefixAsArray);\n                const derivationSuffixAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(out.paymentRemittance.derivationSuffix, 'base64');\n                paramWriter.writeVarIntNum(derivationSuffixAsArray.length);\n                paramWriter.write(derivationSuffixAsArray);\n            }\n            else {\n                paramWriter.writeUInt8(2);\n                const basketAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(out.insertionRemittance?.basket, 'utf8');\n                paramWriter.writeVarIntNum(basketAsArray.length);\n                paramWriter.write(basketAsArray);\n                if (typeof out.insertionRemittance?.customInstructions === 'string' && out.insertionRemittance.customInstructions !== '') {\n                    const customInstructionsAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(out.insertionRemittance.customInstructions, 'utf8');\n                    paramWriter.writeVarIntNum(customInstructionsAsArray.length);\n                    paramWriter.write(customInstructionsAsArray);\n                }\n                else {\n                    paramWriter.writeVarIntNum(-1);\n                }\n                if (typeof out.insertionRemittance?.tags === 'object') {\n                    paramWriter.writeVarIntNum(out.insertionRemittance.tags.length);\n                    for (const tag of out.insertionRemittance.tags) {\n                        const tagAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(tag, 'utf8');\n                        paramWriter.writeVarIntNum(tagAsArray.length);\n                        paramWriter.write(tagAsArray);\n                    }\n                }\n                else {\n                    paramWriter.writeVarIntNum(0);\n                }\n            }\n        }\n        if (typeof args.labels === 'object') {\n            paramWriter.writeVarIntNum(args.labels.length);\n            for (const l of args.labels) {\n                const labelAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(l, 'utf8');\n                paramWriter.writeVarIntNum(labelAsArray.length);\n                paramWriter.write(labelAsArray);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        const descriptionAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.description);\n        paramWriter.writeVarIntNum(descriptionAsArray.length);\n        paramWriter.write(descriptionAsArray);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('internalizeAction', originator, paramWriter.toArray());\n        return { accepted: true };\n    }\n    async listOutputs(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const basketAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.basket, 'utf8');\n        paramWriter.writeVarIntNum(basketAsArray.length);\n        paramWriter.write(basketAsArray);\n        if (typeof args.tags === 'object') {\n            paramWriter.writeVarIntNum(args.tags.length);\n            for (const tag of args.tags) {\n                const tagAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(tag, 'utf8');\n                paramWriter.writeVarIntNum(tagAsArray.length);\n                paramWriter.write(tagAsArray);\n            }\n        }\n        else {\n            paramWriter.writeVarIntNum(0);\n        }\n        if (args.tagQueryMode === 'all') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.tagQueryMode === 'any') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (args.include === 'locking scripts') {\n            paramWriter.writeInt8(1);\n        }\n        else if (args.include === 'entire transactions') {\n            paramWriter.writeInt8(2);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeCustomInstructions === 'boolean') {\n            paramWriter.writeInt8(args.includeCustomInstructions ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeTags === 'boolean') {\n            paramWriter.writeInt8(args.includeTags ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.includeLabels === 'boolean') {\n            paramWriter.writeInt8(args.includeLabels ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('listOutputs', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const totalOutputs = resultReader.readVarIntNum();\n        const beefLength = resultReader.readVarIntNum();\n        let BEEF;\n        if (beefLength >= 0) {\n            BEEF = resultReader.read(beefLength);\n        }\n        const outputs = [];\n        for (let i = 0; i < totalOutputs; i++) {\n            const outpoint = this.readOutpoint(resultReader);\n            const satoshis = resultReader.readVarIntNum();\n            const output = {\n                spendable: true,\n                outpoint,\n                satoshis\n            };\n            const scriptLength = resultReader.readVarIntNum();\n            if (scriptLength >= 0) {\n                output.lockingScript = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(scriptLength));\n            }\n            const customInstructionsLength = resultReader.readVarIntNum();\n            if (customInstructionsLength >= 0) {\n                output.customInstructions = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(customInstructionsLength));\n            }\n            const tagsLength = resultReader.readVarIntNum();\n            if (tagsLength !== -1) {\n                const tags = [];\n                for (let i = 0; i < tagsLength; i++) {\n                    const tagLength = resultReader.readVarIntNum();\n                    tags.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(tagLength)));\n                }\n                output.tags = tags;\n            }\n            const labelsLength = resultReader.readVarIntNum();\n            if (labelsLength !== -1) {\n                const labels = [];\n                for (let i = 0; i < labelsLength; i++) {\n                    const labelLength = resultReader.readVarIntNum();\n                    labels.push(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(labelLength)));\n                }\n                output.labels = labels;\n            }\n            outputs.push(output);\n        }\n        return {\n            totalOutputs,\n            BEEF,\n            outputs\n        };\n    }\n    async relinquishOutput(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const basketAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.basket, 'utf8');\n        paramWriter.writeVarIntNum(basketAsArray.length);\n        paramWriter.write(basketAsArray);\n        paramWriter.write(this.encodeOutpoint(args.output));\n        await this.transmit('relinquishOutput', originator, paramWriter.toArray());\n        return { relinquished: true };\n    }\n    encodeOutpoint(outpoint) {\n        const writer = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const [txid, index] = outpoint.split('.');\n        writer.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(txid, 'hex'));\n        writer.writeVarIntNum(Number(index));\n        return writer.toArray();\n    }\n    readOutpoint(reader) {\n        const txid = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(reader.read(32));\n        const index = reader.readVarIntNum();\n        return `${txid}.${index}`;\n    }\n    async getPublicKey(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.writeUInt8(args.identityKey ? 1 : 0);\n        if (!args.identityKey) {\n            paramWriter.write(this.encodeKeyRelatedParams(args.protocolID ??= [_Wallet_interfaces_js__WEBPACK_IMPORTED_MODULE_0__.SecurityLevels.Silent, 'default'], args.keyID ??= '', args.counterparty, args.privileged, args.privilegedReason));\n            if (typeof args.forSelf === 'boolean') {\n                paramWriter.writeInt8(args.forSelf ? 1 : 0);\n            }\n            else {\n                paramWriter.writeInt8(-1);\n            }\n        }\n        else {\n            paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('getPublicKey', originator, paramWriter.toArray());\n        return {\n            publicKey: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(result)\n        };\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.counterparty, 'hex'));\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.verifier, 'hex'));\n        const result = await this.transmit('revealCounterpartyKeyLinkage', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const prover = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const verifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const counterparty = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const revelationTimeLength = resultReader.readVarIntNum();\n        const revelationTime = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(revelationTimeLength));\n        const encryptedLinkageLength = resultReader.readVarIntNum();\n        const encryptedLinkage = resultReader.read(encryptedLinkageLength);\n        const encryptedLinkageProofLength = resultReader.readVarIntNum();\n        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);\n        return {\n            prover,\n            verifier,\n            counterparty,\n            revelationTime,\n            encryptedLinkage,\n            encryptedLinkageProof\n        };\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.verifier, 'hex'));\n        const result = await this.transmit('revealSpecificKeyLinkage', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const prover = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const verifier = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const counterparty = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(resultReader.read(33));\n        const securityLevel = resultReader.readUInt8();\n        const protocolLength = resultReader.readVarIntNum();\n        const protocol = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(protocolLength));\n        const keyIDLength = resultReader.readVarIntNum();\n        const keyID = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(keyIDLength));\n        const encryptedLinkageLength = resultReader.readVarIntNum();\n        const encryptedLinkage = resultReader.read(encryptedLinkageLength);\n        const encryptedLinkageProofLength = resultReader.readVarIntNum();\n        const encryptedLinkageProof = resultReader.read(encryptedLinkageProofLength);\n        const proofType = resultReader.readUInt8();\n        return {\n            prover,\n            verifier,\n            counterparty,\n            protocolID: [securityLevel, protocol],\n            keyID,\n            encryptedLinkage,\n            encryptedLinkageProof,\n            proofType\n        };\n    }\n    async encrypt(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.plaintext.length);\n        paramWriter.write(args.plaintext);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            ciphertext: await this.transmit('encrypt', originator, paramWriter.toArray())\n        };\n    }\n    async decrypt(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.ciphertext.length);\n        paramWriter.write(args.ciphertext);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            plaintext: await this.transmit('decrypt', originator, paramWriter.toArray())\n        };\n    }\n    async createHmac(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.writeVarIntNum(args.data.length);\n        paramWriter.write(args.data);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            hmac: await this.transmit('createHmac', originator, paramWriter.toArray())\n        };\n    }\n    async verifyHmac(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        paramWriter.write(args.hmac);\n        paramWriter.writeVarIntNum(args.data.length);\n        paramWriter.write(args.data);\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('verifyHmac', originator, paramWriter.toArray());\n        return { valid: true };\n    }\n    async createSignature(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        if (typeof args.data === 'object') {\n            paramWriter.writeUInt8(1);\n            paramWriter.writeVarIntNum(args.data.length);\n            paramWriter.write(args.data);\n        }\n        else {\n            paramWriter.writeUInt8(2);\n            paramWriter.write(args.hashToDirectlySign ??= []);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        return {\n            signature: await this.transmit('createSignature', originator, paramWriter.toArray())\n        };\n    }\n    async verifySignature(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(this.encodeKeyRelatedParams(args.protocolID, args.keyID, args.counterparty, args.privileged, args.privilegedReason));\n        if (typeof args.forSelf === 'boolean') {\n            paramWriter.writeInt8(args.forSelf ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        paramWriter.writeVarIntNum(args.signature.length);\n        paramWriter.write(args.signature);\n        if (typeof args.data === 'object') {\n            paramWriter.writeUInt8(1);\n            paramWriter.writeVarIntNum(args.data.length);\n            paramWriter.write(args.data);\n        }\n        else {\n            paramWriter.writeUInt8(2);\n            paramWriter.write(args.hashToDirectlyVerify ?? []);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        await this.transmit('verifySignature', originator, paramWriter.toArray());\n        return { valid: true };\n    }\n    encodeKeyRelatedParams(protocolID, keyID, counterparty, privileged, privilegedReason) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.writeUInt8(protocolID[0]);\n        const protocolAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(protocolID[1], 'utf8');\n        paramWriter.writeVarIntNum(protocolAsArray.length);\n        paramWriter.write(protocolAsArray);\n        const keyIDAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(keyID, 'utf8');\n        paramWriter.writeVarIntNum(keyIDAsArray.length);\n        paramWriter.write(keyIDAsArray);\n        if (typeof counterparty !== 'string') {\n            paramWriter.writeUInt8(0);\n        }\n        else if (counterparty === 'self') {\n            paramWriter.writeUInt8(11);\n        }\n        else if (counterparty === 'anyone') {\n            paramWriter.writeUInt8(12);\n        }\n        else {\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(counterparty, 'hex'));\n        }\n        paramWriter.write(this.encodePrivilegedParams(privileged, privilegedReason));\n        return paramWriter.toArray();\n    }\n    async acquireCertificate(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.type, 'base64'));\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certifier, 'hex'));\n        const fieldEntries = Object.entries(args.fields);\n        paramWriter.writeVarIntNum(fieldEntries.length);\n        for (const [key, value] of fieldEntries) {\n            const keyAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(key, 'utf8');\n            const valueAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(value, 'utf8');\n            paramWriter.writeVarIntNum(keyAsArray.length);\n            paramWriter.write(keyAsArray);\n            paramWriter.writeVarIntNum(valueAsArray.length);\n            paramWriter.write(valueAsArray);\n        }\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        paramWriter.writeUInt8(args.acquisitionProtocol === 'direct' ? 1 : 2);\n        if (args.acquisitionProtocol === 'direct') {\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.serialNumber, 'base64'));\n            paramWriter.write(this.encodeOutpoint(args.revocationOutpoint ?? ''));\n            const signatureAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.signature, 'hex');\n            paramWriter.writeVarIntNum(signatureAsArray.length);\n            paramWriter.write(signatureAsArray);\n            const keyringRevealerAsArray = args.keyringRevealer !== 'certifier'\n                ? _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.keyringRevealer, 'hex')\n                : [11];\n            paramWriter.write(keyringRevealerAsArray);\n            const keyringKeys = Object.keys(args.keyringForSubject ?? {});\n            paramWriter.writeVarIntNum(keyringKeys.length);\n            for (let i = 0; i < keyringKeys.length; i++) {\n                const keyringKeysAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(keyringKeys[i], 'utf8');\n                paramWriter.writeVarIntNum(keyringKeysAsArray.length);\n                paramWriter.write(keyringKeysAsArray);\n                const keyringForSubjectAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.keyringForSubject?.[keyringKeys[i]], 'base64');\n                paramWriter.writeVarIntNum(keyringForSubjectAsArray.length);\n                paramWriter.write(keyringForSubjectAsArray);\n            }\n        }\n        else {\n            const certifierUrlAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certifierUrl, 'utf8');\n            paramWriter.writeVarIntNum(certifierUrlAsArray.length);\n            paramWriter.write(certifierUrlAsArray);\n        }\n        const result = await this.transmit('acquireCertificate', originator, paramWriter.toArray());\n        const cert = _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(result);\n        return {\n            ...cert,\n            signature: cert.signature\n        };\n    }\n    encodePrivilegedParams(privileged, privilegedReason) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        if (typeof privileged === 'boolean') {\n            paramWriter.writeInt8(privileged ? 1 : 0);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        if (typeof privilegedReason === 'string') {\n            const privilegedReasonAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(privilegedReason, 'utf8');\n            paramWriter.writeInt8(privilegedReasonAsArray.length);\n            paramWriter.write(privilegedReasonAsArray);\n        }\n        else {\n            paramWriter.writeInt8(-1);\n        }\n        return paramWriter.toArray();\n    }\n    async listCertificates(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.writeVarIntNum(args.certifiers.length);\n        for (let i = 0; i < args.certifiers.length; i++) {\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certifiers[i], 'hex'));\n        }\n        paramWriter.writeVarIntNum(args.types.length);\n        for (let i = 0; i < args.types.length; i++) {\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.types[i], 'base64'));\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        const result = await this.transmit('listCertificates', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const totalCertificates = resultReader.readVarIntNum();\n        const certificates = [];\n        for (let i = 0; i < totalCertificates; i++) {\n            const certificateLength = resultReader.readVarIntNum();\n            const certificateBin = resultReader.read(certificateLength);\n            const cert = _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(certificateBin);\n            certificates.push({\n                ...cert,\n                signature: cert.signature\n            });\n        }\n        return {\n            totalCertificates,\n            certificates\n        };\n    }\n    async proveCertificate(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const typeAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certificate.type, 'base64');\n        paramWriter.write(typeAsArray);\n        const subjectAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certificate.subject, 'hex');\n        paramWriter.write(subjectAsArray);\n        const serialNumberAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certificate.serialNumber, 'base64');\n        paramWriter.write(serialNumberAsArray);\n        const certifierAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certificate.certifier, 'hex');\n        paramWriter.write(certifierAsArray);\n        const revocationOutpointAsArray = this.encodeOutpoint(args.certificate.revocationOutpoint ?? '');\n        paramWriter.write(revocationOutpointAsArray);\n        const signatureAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certificate.signature, 'hex');\n        paramWriter.writeVarIntNum(signatureAsArray.length);\n        paramWriter.write(signatureAsArray);\n        const fieldEntries = Object.entries(args.certificate.fields ?? {});\n        paramWriter.writeVarIntNum(fieldEntries.length);\n        for (const [key, value] of fieldEntries) {\n            const keyAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(key, 'utf8');\n            const valueAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(value, 'utf8');\n            paramWriter.writeVarIntNum(keyAsArray.length);\n            paramWriter.write(keyAsArray);\n            paramWriter.writeVarIntNum(valueAsArray.length);\n            paramWriter.write(valueAsArray);\n        }\n        paramWriter.writeVarIntNum(args.fieldsToReveal.length);\n        for (const field of args.fieldsToReveal) {\n            const fieldAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(field, 'utf8');\n            paramWriter.writeVarIntNum(fieldAsArray.length);\n            paramWriter.write(fieldAsArray);\n        }\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.verifier, 'hex'));\n        paramWriter.write(this.encodePrivilegedParams(args.privileged, args.privilegedReason));\n        const result = await this.transmit('proveCertificate', originator, paramWriter.toArray());\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const numFields = resultReader.readVarIntNum();\n        const keyringForVerifier = {};\n        for (let i = 0; i < numFields; i++) {\n            const fieldKeyLength = resultReader.readVarIntNum();\n            const fieldKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(fieldKeyLength));\n            const fieldValueLength = resultReader.readVarIntNum();\n            keyringForVerifier[fieldKey] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBase64(resultReader.read(fieldValueLength));\n        }\n        return {\n            keyringForVerifier\n        };\n    }\n    async relinquishCertificate(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const typeAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.type, 'base64');\n        paramWriter.write(typeAsArray);\n        const serialNumberAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.serialNumber, 'base64');\n        paramWriter.write(serialNumberAsArray);\n        const certifierAsArray = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.certifier, 'hex');\n        paramWriter.write(certifierAsArray);\n        await this.transmit('relinquishCertificate', originator, paramWriter.toArray());\n        return { relinquished: true };\n    }\n    parseDiscoveryResult(result) {\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        const totalCertificates = resultReader.readVarIntNum();\n        const certificates = [];\n        for (let i = 0; i < totalCertificates; i++) {\n            const certBinLen = resultReader.readVarIntNum();\n            const certBin = resultReader.read(certBinLen);\n            const cert = _auth_certificates_Certificate_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromBinary(certBin);\n            const nameLength = resultReader.readVarIntNum();\n            const name = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(nameLength));\n            const iconUrlLength = resultReader.readVarIntNum();\n            const iconUrl = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(iconUrlLength));\n            const descriptionLength = resultReader.readVarIntNum();\n            const description = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(descriptionLength));\n            const trust = resultReader.readUInt8();\n            const publiclyRevealedKeyring = {};\n            const numPublicKeyringEntries = resultReader.readVarIntNum();\n            for (let j = 0; j < numPublicKeyringEntries; j++) {\n                const fieldKeyLen = resultReader.readVarIntNum();\n                const fieldKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(fieldKeyLen));\n                const fieldValueLen = resultReader.readVarIntNum();\n                publiclyRevealedKeyring[fieldKey] = resultReader.read(fieldValueLen);\n            }\n            const decryptedFields = {};\n            const numDecryptedFields = resultReader.readVarIntNum();\n            for (let k = 0; k < numDecryptedFields; k++) {\n                const fieldKeyLen = resultReader.readVarIntNum();\n                const fieldKey = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(fieldKeyLen));\n                const fieldValueLen = resultReader.readVarIntNum();\n                decryptedFields[fieldKey] = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(resultReader.read(fieldValueLen));\n            }\n            certificates.push({\n                ...cert,\n                signature: cert.signature,\n                certifierInfo: { iconUrl, name, description, trust },\n                publiclyRevealedKeyring,\n                decryptedFields\n            });\n        }\n        return {\n            totalCertificates,\n            certificates\n        };\n    }\n    async discoverByIdentityKey(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.identityKey, 'hex'));\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('discoverByIdentityKey', originator, paramWriter.toArray());\n        return this.parseDiscoveryResult(result);\n    }\n    async discoverByAttributes(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        const attributeKeys = Object.keys(args.attributes);\n        paramWriter.writeVarIntNum(attributeKeys.length);\n        for (let i = 0; i < attributeKeys.length; i++) {\n            paramWriter.writeVarIntNum(attributeKeys[i].length);\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(attributeKeys[i], 'utf8'));\n            paramWriter.writeVarIntNum(args.attributes[attributeKeys[i]].length);\n            paramWriter.write(_primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toArray(args.attributes[attributeKeys[i]], 'utf8'));\n        }\n        if (typeof args.limit === 'number') {\n            paramWriter.writeVarIntNum(args.limit);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        if (typeof args.offset === 'number') {\n            paramWriter.writeVarIntNum(args.offset);\n        }\n        else {\n            paramWriter.writeVarIntNum(-1);\n        }\n        // Serialize seekPermission\n        paramWriter.writeInt8(typeof args.seekPermission === 'boolean'\n            ? args.seekPermission\n                ? 1\n                : 0\n            : -1);\n        const result = await this.transmit('discoverByAttributes', originator, paramWriter.toArray());\n        return this.parseDiscoveryResult(result);\n    }\n    async isAuthenticated(args, originator) {\n        const result = await this.transmit('isAuthenticated', originator);\n        // @ts-expect-error\n        return { authenticated: result[0] === 1 };\n    }\n    async waitForAuthentication(args, originator) {\n        await this.transmit('waitForAuthentication', originator);\n        return { authenticated: true };\n    }\n    async getHeight(args, originator) {\n        const result = await this.transmit('getHeight', originator);\n        const resultReader = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Reader(result);\n        return {\n            height: resultReader.readVarIntNum()\n        };\n    }\n    async getHeaderForHeight(args, originator) {\n        const paramWriter = new _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.Writer();\n        paramWriter.writeVarIntNum(args.height);\n        const header = await this.transmit('getHeaderForHeight', originator, paramWriter.toArray());\n        return {\n            header: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toHex(header)\n        };\n    }\n    async getNetwork(args, originator) {\n        const net = await this.transmit('getNetwork', originator);\n        return {\n            network: net[0] === 0 ? 'mainnet' : 'testnet'\n        };\n    }\n    async getVersion(args, originator) {\n        const version = await this.transmit('getVersion', originator);\n        return {\n            version: _primitives_utils_js__WEBPACK_IMPORTED_MODULE_2__.toUTF8(version)\n        };\n    }\n}\n//# sourceMappingURL=WalletWireTransceiver.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireTransceiver.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/XDM.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/XDM.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ XDMSubstrate)\n/* harmony export */ });\n/* harmony import */ var _primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../primitives/Random.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/Random.js\");\n/* harmony import */ var _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../primitives/utils.js */ \"./node_modules/@bsv/sdk/dist/esm/src/primitives/utils.js\");\n/* harmony import */ var _WalletError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../WalletError.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/WalletError.js\");\n\n\n\n/**\n * Facilitates wallet operations over cross-document messaging.\n */\nclass XDMSubstrate {\n    domain;\n    constructor(domain = '*') {\n        if (typeof window !== 'object') {\n            throw new Error('The XDM substrate requires a global window object.');\n        }\n        if (typeof window.postMessage !== 'function') {\n            throw new Error('The window object does not seem to support postMessage calls.');\n        }\n        this.domain = domain;\n    }\n    async invoke(call, args) {\n        return await new Promise((resolve, reject) => {\n            const id = _primitives_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBase64((0,_primitives_Random_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(12));\n            const listener = (e) => {\n                if (e.data.type !== 'CWI' ||\n                    !e.isTrusted ||\n                    e.data.id !== id ||\n                    e.data.isInvocation === true) {\n                    return;\n                }\n                if (typeof window.removeEventListener === 'function') {\n                    window.removeEventListener('message', listener);\n                }\n                if (e.data.status === 'error') {\n                    const err = new _WalletError_js__WEBPACK_IMPORTED_MODULE_2__.WalletError(e.data.description, e.data.code);\n                    reject(err);\n                }\n                else {\n                    resolve(e.data.result);\n                }\n            };\n            window.addEventListener('message', listener);\n            window.parent.postMessage({\n                type: 'CWI',\n                isInvocation: true,\n                id,\n                call,\n                args\n            }, this.domain);\n        });\n    }\n    async createAction(args) {\n        return await this.invoke('createAction', args);\n    }\n    async signAction(args) {\n        return await this.invoke('signAction', args);\n    }\n    async abortAction(args) {\n        return await this.invoke('abortAction', args);\n    }\n    async listActions(args) {\n        return await this.invoke('listActions', args);\n    }\n    async internalizeAction(args) {\n        return await this.invoke('internalizeAction', args);\n    }\n    async listOutputs(args) {\n        return await this.invoke('listOutputs', args);\n    }\n    async relinquishOutput(args) {\n        return await this.invoke('relinquishOutput', args);\n    }\n    async getPublicKey(args) {\n        return await this.invoke('getPublicKey', args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return await this.invoke('revealCounterpartyKeyLinkage', args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return await this.invoke('revealSpecificKeyLinkage', args);\n    }\n    async encrypt(args) {\n        return await this.invoke('encrypt', args);\n    }\n    async decrypt(args) {\n        return await this.invoke('decrypt', args);\n    }\n    async createHmac(args) {\n        return await this.invoke('createHmac', args);\n    }\n    async verifyHmac(args) {\n        return await this.invoke('verifyHmac', args);\n    }\n    async createSignature(args) {\n        return await this.invoke('createSignature', args);\n    }\n    async verifySignature(args) {\n        return await this.invoke('verifySignature', args);\n    }\n    async acquireCertificate(args) {\n        return await this.invoke('acquireCertificate', args);\n    }\n    async listCertificates(args) {\n        return await this.invoke('listCertificates', args);\n    }\n    async proveCertificate(args) {\n        return await this.invoke('proveCertificate', args);\n    }\n    async relinquishCertificate(args) {\n        return await this.invoke('relinquishCertificate', args);\n    }\n    async discoverByIdentityKey(args) {\n        return await this.invoke('discoverByIdentityKey', args);\n    }\n    async discoverByAttributes(args) {\n        return await this.invoke('discoverByAttributes', args);\n    }\n    async isAuthenticated(args) {\n        return await this.invoke('isAuthenticated', args);\n    }\n    async waitForAuthentication(args) {\n        return await this.invoke('waitForAuthentication', args);\n    }\n    async getHeight(args) {\n        return await this.invoke('getHeight', args);\n    }\n    async getHeaderForHeight(args) {\n        return await this.invoke('getHeaderForHeight', args);\n    }\n    async getNetwork(args) {\n        return await this.invoke('getNetwork', args);\n    }\n    async getVersion(args) {\n        return await this.invoke('getVersion', args);\n    }\n}\n//# sourceMappingURL=XDM.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/XDM.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/index.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTPWalletJSON: () => (/* reexport safe */ _HTTPWalletJSON_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   HTTPWalletWire: () => (/* reexport safe */ _HTTPWalletWire_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   ReactNativeWebView: () => (/* reexport safe */ _ReactNativeWebView_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   WalletWireProcessor: () => (/* reexport safe */ _WalletWireProcessor_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]),\n/* harmony export */   WalletWireTransceiver: () => (/* reexport safe */ _WalletWireTransceiver_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   WindowCWISubstrate: () => (/* reexport safe */ _window_CWI_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   XDM: () => (/* reexport safe */ _XDM_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _window_CWI_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./window.CWI.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/window.CWI.js\");\n/* harmony import */ var _XDM_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./XDM.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/XDM.js\");\n/* harmony import */ var _WalletWire_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletWire.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWire.js\");\n/* harmony import */ var _WalletWireCalls_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WalletWireCalls.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireCalls.js\");\n/* harmony import */ var _WalletWireTransceiver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WalletWireTransceiver.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireTransceiver.js\");\n/* harmony import */ var _WalletWireProcessor_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WalletWireProcessor.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/WalletWireProcessor.js\");\n/* harmony import */ var _HTTPWalletWire_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HTTPWalletWire.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletWire.js\");\n/* harmony import */ var _HTTPWalletJSON_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HTTPWalletJSON.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/HTTPWalletJSON.js\");\n/* harmony import */ var _ReactNativeWebView_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ReactNativeWebView.js */ \"./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/ReactNativeWebView.js\");\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/utils/toOriginHeader.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/utils/toOriginHeader.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toOriginHeader: () => (/* binding */ toOriginHeader)\n/* harmony export */ });\nfunction toOriginHeader(originator, fallbackScheme = 'http') {\n    // If the caller already gave us a scheme, assume its fine\n    if (/^[a-z][a-z0-9+.-]*:\\/\\//i.test(originator)) {\n        try {\n            return new URL(originator).origin; // trims any path/query\n        }\n        catch { /* fall through to fix-up */ }\n    }\n    // Otherwise, prepend the fallback scheme and validate\n    try {\n        return new URL(`${fallbackScheme}://${originator}`).origin;\n    }\n    catch {\n        throw new Error(`Invalid originator value: ${originator}`);\n    }\n}\n//# sourceMappingURL=toOriginHeader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/utils/toOriginHeader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/window.CWI.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/window.CWI.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WindowCWISubstrate)\n/* harmony export */ });\n/**\n * Facilitates wallet operations over the window.CWI interface.\n */\nclass WindowCWISubstrate {\n    CWI;\n    constructor() {\n        if (typeof window !== 'object') {\n            throw new Error('The window.CWI substrate requires a global window object.');\n        }\n        if (typeof window.CWI !== 'object') {\n            throw new Error('The window.CWI interface does not appear to be bound to the window object.');\n        }\n        this.CWI = window.CWI; // Binding CWI to prevent changes\n    }\n    async createAction(args, originator) {\n        return await this.CWI.createAction(args, originator);\n    }\n    async signAction(args, originator) {\n        return await this.CWI.signAction(args, originator);\n    }\n    async abortAction(args, originator) {\n        return await this.CWI.abortAction(args, originator);\n    }\n    async listActions(args, originator) {\n        return await this.CWI.listActions(args, originator);\n    }\n    async internalizeAction(args, originator) {\n        return await this.CWI.internalizeAction(args, originator);\n    }\n    async listOutputs(args, originator) {\n        return await this.CWI.listOutputs(args, originator);\n    }\n    async relinquishOutput(args, originator) {\n        return await this.CWI.relinquishOutput(args, originator);\n    }\n    async getPublicKey(args, originator) {\n        return await this.CWI.getPublicKey(args, originator);\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        return await this.CWI.revealCounterpartyKeyLinkage(args, originator);\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        return await this.CWI.revealSpecificKeyLinkage(args, originator);\n    }\n    async encrypt(args, originator) {\n        return await this.CWI.encrypt(args, originator);\n    }\n    async decrypt(args, originator) {\n        return await this.CWI.decrypt(args, originator);\n    }\n    async createHmac(args, originator) {\n        return await this.CWI.createHmac(args, originator);\n    }\n    async verifyHmac(args, originator) {\n        return await this.CWI.verifyHmac(args, originator);\n    }\n    async createSignature(args, originator) {\n        return await this.CWI.createSignature(args, originator);\n    }\n    async verifySignature(args, originator) {\n        return await this.CWI.verifySignature(args, originator);\n    }\n    async acquireCertificate(args, originator) {\n        return await this.CWI.acquireCertificate(args, originator);\n    }\n    async listCertificates(args, originator) {\n        return await this.CWI.listCertificates(args, originator);\n    }\n    async proveCertificate(args, originator) {\n        return await this.CWI.proveCertificate(args, originator);\n    }\n    async relinquishCertificate(args, originator) {\n        return await this.CWI.relinquishCertificate(args, originator);\n    }\n    async discoverByIdentityKey(args, originator) {\n        return await this.CWI.discoverByIdentityKey(args, originator);\n    }\n    async discoverByAttributes(args, originator) {\n        return await this.CWI.discoverByAttributes(args, originator);\n    }\n    async isAuthenticated(args, originator) {\n        return await this.CWI.isAuthenticated(args, originator);\n    }\n    async waitForAuthentication(args, originator) {\n        return await this.CWI.waitForAuthentication(args, originator);\n    }\n    async getHeight(args, originator) {\n        return await this.CWI.getHeight(args, originator);\n    }\n    async getHeaderForHeight(args, originator) {\n        return await this.CWI.getHeaderForHeight(args, originator);\n    }\n    async getNetwork(args, originator) {\n        return await this.CWI.getNetwork(args, originator);\n    }\n    async getVersion(args, originator) {\n        return await this.CWI.getVersion(args, originator);\n    }\n}\n//# sourceMappingURL=window.CWI.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/sdk/dist/esm/src/wallet/substrates/window.CWI.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CWIStyleWalletManager = exports.OverlayUMPTokenInteractor = exports.DEFAULT_PROFILE_ID = exports.PBKDF2_NUM_ROUNDS = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst PrivilegedKeyManager_1 = __webpack_require__(/*! ./sdk/PrivilegedKeyManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js\");\n/**\n * Number of rounds used in PBKDF2 for deriving password keys.\n */\nexports.PBKDF2_NUM_ROUNDS = 7777;\n/**\n * PBKDF-2 that prefers the browser / Node 20+ WebCrypto implementation and\n * silently falls back to the existing JS code.\n *\n * @param passwordBytes   Raw password bytes.\n * @param salt            Salt bytes.\n * @param iterations      Number of rounds.\n * @param keyLen          Desired key length in bytes.\n * @param hash            Digest algorithm (default \"sha512\").\n * @returns               Derived key bytes.\n */\nasync function pbkdf2NativeOrJs(passwordBytes, salt, iterations, keyLen, hash = 'sha512') {\n    var _a;\n    // ----- fast-path: WebCrypto (both browser & recent Node expose globalThis.crypto.subtle)\n    const subtle = (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.crypto) === null || _a === void 0 ? void 0 : _a.subtle;\n    if (subtle) {\n        try {\n            const baseKey = await subtle.importKey('raw', new Uint8Array(passwordBytes), { name: 'PBKDF2' }, \n            /*extractable*/ false, ['deriveBits']);\n            const bits = await subtle.deriveBits({\n                name: 'PBKDF2',\n                salt: new Uint8Array(salt),\n                iterations,\n                hash: hash.toUpperCase()\n            }, baseKey, keyLen * 8);\n            return Array.from(new Uint8Array(bits));\n        }\n        catch (err) {\n            console.warn('[pbkdf2] WebCrypto path failed  falling back to JS implementation', err);\n            /* fall through */\n        }\n    }\n    // ----- slow-path: old JavaScript implementation\n    return sdk_1.Hash.pbkdf2(passwordBytes, salt, iterations, keyLen, hash);\n}\n/**\n * Unique Identifier for the default profile (16 zero bytes).\n */\nexports.DEFAULT_PROFILE_ID = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n/**\n * @class OverlayUMPTokenInteractor\n *\n * A concrete implementation of the UMPTokenInteractor interface that interacts\n * with Overlay Services and the UMP (User Management Protocol) topic. This class\n * is responsible for:\n *\n * 1) Locating UMP tokens via overlay lookups (ls_users).\n * 2) Creating and publishing new or updated UMP token outputs on-chain under\n *    the \"tm_users\" topic.\n * 3) Consuming (spending) an old token if provided.\n */\nclass OverlayUMPTokenInteractor {\n    /**\n     * Construct a new OverlayUMPTokenInteractor.\n     *\n     * @param resolver     A LookupResolver instance for performing overlay queries (ls_users).\n     * @param broadcaster  A SHIPBroadcaster instance for sharing new or updated tokens across the `tm_users` overlay.\n     */\n    constructor(resolver = new sdk_1.LookupResolver(), broadcaster = new sdk_1.SHIPBroadcaster(['tm_users'])) {\n        this.resolver = resolver;\n        this.broadcaster = broadcaster;\n    }\n    /**\n     * Finds a UMP token on-chain by the given presentation key hash, if it exists.\n     * Uses the ls_users overlay service to perform the lookup.\n     *\n     * @param hash The 32-byte SHA-256 hash of the presentation key.\n     * @returns A UMPToken object (including currentOutpoint) if found, otherwise undefined.\n     */\n    async findByPresentationKeyHash(hash) {\n        // Query ls_users for the given presentationHash\n        const question = {\n            service: 'ls_users',\n            query: { presentationHash: sdk_1.Utils.toHex(hash) }\n        };\n        const answer = await this.resolver.query(question);\n        return this.parseLookupAnswer(answer);\n    }\n    /**\n     * Finds a UMP token on-chain by the given recovery key hash, if it exists.\n     * Uses the ls_users overlay service to perform the lookup.\n     *\n     * @param hash The 32-byte SHA-256 hash of the recovery key.\n     * @returns A UMPToken object (including currentOutpoint) if found, otherwise undefined.\n     */\n    async findByRecoveryKeyHash(hash) {\n        const question = {\n            service: 'ls_users',\n            query: { recoveryHash: sdk_1.Utils.toHex(hash) }\n        };\n        const answer = await this.resolver.query(question);\n        return this.parseLookupAnswer(answer);\n    }\n    /**\n     * Creates or updates (replaces) a UMP token on-chain. If `oldTokenToConsume` is provided,\n     * it is spent in the same transaction that creates the new token output. The new token is\n     * then broadcast and published under the `tm_users` topic using a SHIP broadcast, ensuring\n     * overlay participants see the updated token.\n     *\n     * @param wallet            The wallet used to build and sign the transaction (MUST be operating under the DEFAULT profile).\n     * @param adminOriginator   The domain/FQDN of the administrative originator (wallet operator).\n     * @param token             The new UMPToken to create on-chain.\n     * @param oldTokenToConsume Optionally, an existing token to consume/spend in the same transaction.\n     * @returns The outpoint of the newly created UMP token (e.g. \"abcd1234...ef.0\").\n     */\n    async buildAndSend(wallet, // This wallet MUST be the one built for the default profile\n    adminOriginator, token, oldTokenToConsume) {\n        // 1) Construct the data fields for the new UMP token.\n        const fields = [];\n        fields[0] = token.passwordSalt;\n        fields[1] = token.passwordPresentationPrimary;\n        fields[2] = token.passwordRecoveryPrimary;\n        fields[3] = token.presentationRecoveryPrimary;\n        fields[4] = token.passwordPrimaryPrivileged;\n        fields[5] = token.presentationRecoveryPrivileged;\n        fields[6] = token.presentationHash;\n        fields[7] = token.recoveryHash;\n        fields[8] = token.presentationKeyEncrypted;\n        fields[9] = token.passwordKeyEncrypted;\n        fields[10] = token.recoveryKeyEncrypted;\n        // Optional field (11) for encrypted profiles\n        if (token.profilesEncrypted) {\n            fields[11] = token.profilesEncrypted;\n        }\n        // 2) Create a PushDrop script referencing these fields, locked with the admin key.\n        const script = await new sdk_1.PushDrop(wallet, adminOriginator).lock(fields, [2, 'admin user management token'], // protocolID\n        '1', // keyID\n        'self', // counterparty\n        /*forSelf=*/ true, \n        /*includeSignature=*/ true);\n        // 3) Prepare the createAction call. If oldTokenToConsume is provided, gather the outpoint.\n        const inputs = [];\n        let inputToken;\n        if (oldTokenToConsume === null || oldTokenToConsume === void 0 ? void 0 : oldTokenToConsume.currentOutpoint) {\n            inputToken = await this.findByOutpoint(oldTokenToConsume.currentOutpoint);\n            // If there is no token on the overlay, we can't consume it. Just start over with a new token.\n            if (!inputToken) {\n                oldTokenToConsume = undefined;\n                // Otherwise, add the input\n            }\n            else {\n                inputs.push({\n                    outpoint: oldTokenToConsume.currentOutpoint,\n                    unlockingScriptLength: 73, // typical signature length\n                    inputDescription: 'Consume old UMP token'\n                });\n            }\n        }\n        const outputs = [\n            {\n                lockingScript: script.toHex(),\n                satoshis: 1,\n                outputDescription: 'New UMP token output'\n            }\n        ];\n        // 4) Build the partial transaction via createAction.\n        let createResult;\n        try {\n            createResult = await wallet.createAction({\n                description: oldTokenToConsume ? 'Renew UMP token (consume old, create new)' : 'Create new UMP token',\n                inputs,\n                outputs,\n                inputBEEF: inputToken === null || inputToken === void 0 ? void 0 : inputToken.beef,\n                options: {\n                    randomizeOutputs: false,\n                    acceptDelayedBroadcast: false\n                }\n            }, adminOriginator);\n        }\n        catch (e) {\n            console.error('Error with UMP token update. Attempting a last-ditch effort to get a new one', e);\n            createResult = await wallet.createAction({\n                description: 'Recover UMP token',\n                outputs,\n                options: {\n                    randomizeOutputs: false,\n                    acceptDelayedBroadcast: false\n                }\n            }, adminOriginator);\n        }\n        // If the transaction is fully processed by the wallet\n        if (!createResult.signableTransaction) {\n            const finalTxid = createResult.txid || (createResult.tx ? sdk_1.Transaction.fromAtomicBEEF(createResult.tx).id('hex') : undefined);\n            if (!finalTxid) {\n                throw new Error('No signableTransaction and no final TX found.');\n            }\n            // Now broadcast to `tm_users` using SHIP\n            const broadcastTx = sdk_1.Transaction.fromAtomicBEEF(createResult.tx);\n            const result = await this.broadcaster.broadcast(broadcastTx);\n            console.log('BROADCAST RESULT', result);\n            return `${finalTxid}.0`;\n        }\n        // 5) If oldTokenToConsume is present, we must sign the input referencing it.\n        //    (If there's no old token, there's nothing to sign for the input.)\n        let finalTxid = '';\n        const reference = createResult.signableTransaction.reference;\n        const partialTx = sdk_1.Transaction.fromBEEF(createResult.signableTransaction.tx);\n        if (oldTokenToConsume === null || oldTokenToConsume === void 0 ? void 0 : oldTokenToConsume.currentOutpoint) {\n            // Unlock the old token with a matching PushDrop unlocker\n            const unlocker = new sdk_1.PushDrop(wallet, adminOriginator).unlock([2, 'admin user management token'], '1', 'self');\n            const unlockingScript = await unlocker.sign(partialTx, 0);\n            // Provide it to the wallet\n            const signResult = await wallet.signAction({\n                reference,\n                spends: {\n                    0: {\n                        unlockingScript: unlockingScript.toHex()\n                    }\n                }\n            }, adminOriginator);\n            finalTxid = signResult.txid || (signResult.tx ? sdk_1.Transaction.fromAtomicBEEF(signResult.tx).id('hex') : '');\n            if (!finalTxid) {\n                throw new Error('Could not finalize transaction for renewed UMP token.');\n            }\n            // 6) Broadcast to `tm_users`\n            const finalAtomicTx = signResult.tx;\n            if (!finalAtomicTx) {\n                throw new Error('Final transaction data missing after signing renewed UMP token.');\n            }\n            const broadcastTx = sdk_1.Transaction.fromAtomicBEEF(finalAtomicTx);\n            const result = await this.broadcaster.broadcast(broadcastTx);\n            console.log('BROADCAST RESULT', result);\n            return `${finalTxid}.0`;\n        }\n        else {\n            // Fallback for creating a new token (no input spending)\n            const signResult = await wallet.signAction({ reference, spends: {} }, adminOriginator);\n            finalTxid = signResult.txid || (signResult.tx ? sdk_1.Transaction.fromAtomicBEEF(signResult.tx).id('hex') : '');\n            if (!finalTxid) {\n                throw new Error('Failed to finalize new UMP token transaction.');\n            }\n            const finalAtomicTx = signResult.tx;\n            if (!finalAtomicTx) {\n                throw new Error('Final transaction data missing after signing new UMP token.');\n            }\n            const broadcastTx = sdk_1.Transaction.fromAtomicBEEF(finalAtomicTx);\n            const result = await this.broadcaster.broadcast(broadcastTx);\n            console.log('BROADCAST RESULT', result);\n            return `${finalTxid}.0`;\n        }\n    }\n    /**\n     * Attempts to parse a LookupAnswer from the UMP lookup service. If successful,\n     * extracts the token fields from the resulting transaction and constructs\n     * a UMPToken object.\n     *\n     * @param answer The LookupAnswer returned by a query to ls_users.\n     * @returns The parsed UMPToken or `undefined` if none found/decodable.\n     */\n    parseLookupAnswer(answer) {\n        var _a;\n        if (answer.type !== 'output-list') {\n            return undefined;\n        }\n        if (!answer.outputs || answer.outputs.length === 0) {\n            return undefined;\n        }\n        const { beef, outputIndex } = answer.outputs[0];\n        try {\n            const tx = sdk_1.Transaction.fromBEEF(beef);\n            const outpoint = `${tx.id('hex')}.${outputIndex}`;\n            const decoded = sdk_1.PushDrop.decode(tx.outputs[outputIndex].lockingScript);\n            // Expecting 11 or more fields for UMP\n            if (!decoded.fields || decoded.fields.length < 11) {\n                console.warn(`Unexpected number of fields in UMP token: ${(_a = decoded.fields) === null || _a === void 0 ? void 0 : _a.length}`);\n                return undefined;\n            }\n            // Build the UMP token from these fields, preserving outpoint\n            const t = {\n                // Order matches buildAndSend and serialize/deserialize\n                passwordSalt: decoded.fields[0],\n                passwordPresentationPrimary: decoded.fields[1],\n                passwordRecoveryPrimary: decoded.fields[2],\n                presentationRecoveryPrimary: decoded.fields[3],\n                passwordPrimaryPrivileged: decoded.fields[4],\n                presentationRecoveryPrivileged: decoded.fields[5],\n                presentationHash: decoded.fields[6],\n                recoveryHash: decoded.fields[7],\n                presentationKeyEncrypted: decoded.fields[8],\n                passwordKeyEncrypted: decoded.fields[9],\n                recoveryKeyEncrypted: decoded.fields[10],\n                profilesEncrypted: decoded.fields[12] ? decoded.fields[11] : undefined, // If there's a signature in field 12, use field 11\n                currentOutpoint: outpoint\n            };\n            return t;\n        }\n        catch (e) {\n            console.error('Failed to parse or decode UMP token:', e);\n            return undefined;\n        }\n    }\n    /**\n     * Finds by outpoint for unlocking / spending previous tokens.\n     * @param outpoint The outpoint we are searching by\n     * @returns The result so that we can use it to unlock the transaction\n     */\n    async findByOutpoint(outpoint) {\n        const results = await this.resolver.query({\n            service: 'ls_users',\n            query: {\n                outpoint\n            }\n        });\n        if (results.type !== 'output-list') {\n            return undefined;\n        }\n        if (!results.outputs || !results.outputs.length) {\n            return undefined;\n        }\n        return results.outputs[0];\n    }\n}\nexports.OverlayUMPTokenInteractor = OverlayUMPTokenInteractor;\n/**\n * Manages a \"CWI-style\" wallet that uses a UMP token and a\n * multi-key authentication scheme (password, presentation key, and recovery key),\n * supporting multiple user profiles under a single account.\n */\nclass CWIStyleWalletManager {\n    /**\n     * Constructs a new CWIStyleWalletManager.\n     *\n     * @param adminOriginator   The domain name of the administrative originator.\n     * @param walletBuilder     A function that can build an underlying wallet instance for a profile.\n     * @param interactor        An instance of UMPTokenInteractor.\n     * @param recoveryKeySaver  A function to persist a new recovery key.\n     * @param passwordRetriever A function to request the user's password.\n     * @param newWalletFunder   Optional function to fund a new wallet.\n     * @param stateSnapshot     Optional previously saved state snapshot.\n     */\n    constructor(adminOriginator, walletBuilder, interactor = new OverlayUMPTokenInteractor(), recoveryKeySaver, passwordRetriever, newWalletFunder, stateSnapshot) {\n        /**\n         * Current mode of authentication.\n         */\n        this.authenticationMode = 'presentation-key-and-password';\n        /**\n         * Indicates new user or existing user flow.\n         */\n        this.authenticationFlow = 'new-user';\n        /**\n         * The currently active profile ID (null or DEFAULT_PROFILE_ID means default profile).\n         */\n        this.activeProfileId = exports.DEFAULT_PROFILE_ID;\n        /**\n         * List of loaded non-default profiles.\n         */\n        this.profiles = [];\n        this.adminOriginator = adminOriginator;\n        this.walletBuilder = walletBuilder;\n        this.UMPTokenInteractor = interactor;\n        this.recoveryKeySaver = recoveryKeySaver;\n        this.passwordRetriever = passwordRetriever;\n        this.authenticated = false;\n        this.newWalletFunder = newWalletFunder;\n        // If a saved snapshot is provided, attempt to load it.\n        // Note: loadSnapshot now returns a promise. We don't await it here,\n        // as the constructor must be synchronous. The caller should check\n        // `this.authenticated` after construction if a snapshot was provided.\n        if (stateSnapshot) {\n            this.loadSnapshot(stateSnapshot).catch(err => {\n                console.error('Failed to load snapshot during construction:', err);\n                // Clear potentially partially loaded state\n                this.destroy();\n            });\n        }\n    }\n    // --- Authentication Methods ---\n    /**\n     * Provides the presentation key.\n     */\n    async providePresentationKey(key) {\n        if (this.authenticated) {\n            throw new Error('User is already authenticated');\n        }\n        if (this.authenticationMode === 'recovery-key-and-password') {\n            throw new Error('Presentation key is not needed in this mode');\n        }\n        const hash = sdk_1.Hash.sha256(key);\n        const token = await this.UMPTokenInteractor.findByPresentationKeyHash(hash);\n        if (!token) {\n            // No token found -> New user\n            this.authenticationFlow = 'new-user';\n            this.presentationKey = key;\n        }\n        else {\n            // Found token -> existing user\n            this.authenticationFlow = 'existing-user';\n            this.presentationKey = key;\n            this.currentUMPToken = token;\n        }\n    }\n    /**\n     * Provides the password.\n     */\n    async providePassword(password) {\n        if (this.authenticated) {\n            throw new Error('User is already authenticated');\n        }\n        if (this.authenticationMode === 'presentation-key-and-recovery-key') {\n            throw new Error('Password is not needed in this mode');\n        }\n        if (this.authenticationFlow === 'existing-user') {\n            // Existing user flow\n            if (!this.currentUMPToken) {\n                throw new Error('Provide presentation or recovery key first.');\n            }\n            const derivedPasswordKey = await pbkdf2NativeOrJs(sdk_1.Utils.toArray(password, 'utf8'), this.currentUMPToken.passwordSalt, exports.PBKDF2_NUM_ROUNDS, 32, 'sha512');\n            let rootPrimaryKey;\n            let rootPrivilegedKey; // Only needed for recovery mode\n            if (this.authenticationMode === 'presentation-key-and-password') {\n                if (!this.presentationKey)\n                    throw new Error('No presentation key found!');\n                const xorKey = this.XOR(this.presentationKey, derivedPasswordKey);\n                rootPrimaryKey = new sdk_1.SymmetricKey(xorKey).decrypt(this.currentUMPToken.passwordPresentationPrimary);\n            }\n            else {\n                // 'recovery-key-and-password'\n                if (!this.recoveryKey)\n                    throw new Error('No recovery key found!');\n                const primaryDecryptionKey = this.XOR(this.recoveryKey, derivedPasswordKey);\n                rootPrimaryKey = new sdk_1.SymmetricKey(primaryDecryptionKey).decrypt(this.currentUMPToken.passwordRecoveryPrimary);\n                const privilegedDecryptionKey = this.XOR(rootPrimaryKey, derivedPasswordKey);\n                rootPrivilegedKey = new sdk_1.SymmetricKey(privilegedDecryptionKey).decrypt(this.currentUMPToken.passwordPrimaryPrivileged);\n            }\n            // Build root infrastructure, load profiles, and switch to default profile initially\n            await this.setupRootInfrastructure(rootPrimaryKey, rootPrivilegedKey);\n            await this.switchProfile(this.activeProfileId);\n        }\n        else {\n            // New user flow (only 'presentation-key-and-password')\n            if (this.authenticationMode !== 'presentation-key-and-password') {\n                throw new Error('New-user flow requires presentation key and password mode.');\n            }\n            if (!this.presentationKey) {\n                throw new Error('No presentation key provided for new-user flow.');\n            }\n            // Generate new keys/salt\n            const recoveryKey = (0, sdk_1.Random)(32);\n            await this.recoveryKeySaver(recoveryKey);\n            const passwordSalt = (0, sdk_1.Random)(32);\n            const passwordKey = await pbkdf2NativeOrJs(sdk_1.Utils.toArray(password, 'utf8'), passwordSalt, exports.PBKDF2_NUM_ROUNDS, 32, 'sha512');\n            const rootPrimaryKey = (0, sdk_1.Random)(32);\n            const rootPrivilegedKey = (0, sdk_1.Random)(32);\n            // Build XOR keys\n            const presentationPassword = new sdk_1.SymmetricKey(this.XOR(this.presentationKey, passwordKey));\n            const presentationRecovery = new sdk_1.SymmetricKey(this.XOR(this.presentationKey, recoveryKey));\n            const recoveryPassword = new sdk_1.SymmetricKey(this.XOR(recoveryKey, passwordKey));\n            const primaryPassword = new sdk_1.SymmetricKey(this.XOR(rootPrimaryKey, passwordKey));\n            // Temp manager for encryption\n            const tempPrivilegedKeyManager = new PrivilegedKeyManager_1.PrivilegedKeyManager(async () => new sdk_1.PrivateKey(rootPrivilegedKey));\n            // Build new UMP token (no profiles initially)\n            const newToken = {\n                passwordSalt,\n                passwordPresentationPrimary: presentationPassword.encrypt(rootPrimaryKey),\n                passwordRecoveryPrimary: recoveryPassword.encrypt(rootPrimaryKey),\n                presentationRecoveryPrimary: presentationRecovery.encrypt(rootPrimaryKey),\n                passwordPrimaryPrivileged: primaryPassword.encrypt(rootPrivilegedKey),\n                presentationRecoveryPrivileged: presentationRecovery.encrypt(rootPrivilegedKey),\n                presentationHash: sdk_1.Hash.sha256(this.presentationKey),\n                recoveryHash: sdk_1.Hash.sha256(recoveryKey),\n                presentationKeyEncrypted: (await tempPrivilegedKeyManager.encrypt({\n                    plaintext: this.presentationKey,\n                    protocolID: [2, 'admin key wrapping'],\n                    keyID: '1'\n                })).ciphertext,\n                passwordKeyEncrypted: (await tempPrivilegedKeyManager.encrypt({\n                    plaintext: passwordKey,\n                    protocolID: [2, 'admin key wrapping'],\n                    keyID: '1'\n                })).ciphertext,\n                recoveryKeyEncrypted: (await tempPrivilegedKeyManager.encrypt({\n                    plaintext: recoveryKey,\n                    protocolID: [2, 'admin key wrapping'],\n                    keyID: '1'\n                })).ciphertext,\n                profilesEncrypted: undefined // No profiles yet\n            };\n            this.currentUMPToken = newToken;\n            // Setup root infrastructure and switch to default profile\n            await this.setupRootInfrastructure(rootPrimaryKey);\n            await this.switchProfile(exports.DEFAULT_PROFILE_ID);\n            // Fund the *default* wallet if funder provided\n            if (this.newWalletFunder && this.underlying) {\n                try {\n                    await this.newWalletFunder(this.presentationKey, this.underlying, this.adminOriginator);\n                }\n                catch (e) {\n                    console.error('Error funding new wallet:', e);\n                    // Decide if this should halt the process or just log\n                }\n            }\n            // Publish the new UMP token *after* potentially funding\n            // We need the default profile wallet to sign the UMP creation TX\n            if (!this.underlying) {\n                throw new Error('Default profile wallet not built before attempting to publish UMP token.');\n            }\n            this.currentUMPToken.currentOutpoint = await this.UMPTokenInteractor.buildAndSend(this.underlying, // Use the default profile wallet\n            this.adminOriginator, newToken);\n        }\n    }\n    /**\n     * Provides the recovery key.\n     */\n    async provideRecoveryKey(recoveryKey) {\n        if (this.authenticated) {\n            throw new Error('Already authenticated');\n        }\n        if (this.authenticationFlow === 'new-user') {\n            throw new Error('Do not submit recovery key in new-user flow');\n        }\n        if (this.authenticationMode === 'presentation-key-and-password') {\n            throw new Error('No recovery key required in this mode');\n        }\n        else if (this.authenticationMode === 'recovery-key-and-password') {\n            // Wait for password\n            const hash = sdk_1.Hash.sha256(recoveryKey);\n            const token = await this.UMPTokenInteractor.findByRecoveryKeyHash(hash);\n            if (!token)\n                throw new Error('No user found with this recovery key');\n            this.recoveryKey = recoveryKey;\n            this.currentUMPToken = token;\n        }\n        else {\n            // 'presentation-key-and-recovery-key'\n            if (!this.presentationKey)\n                throw new Error('Provide the presentation key first');\n            if (!this.currentUMPToken)\n                throw new Error('Current UMP token not found');\n            const xorKey = this.XOR(this.presentationKey, recoveryKey);\n            const rootPrimaryKey = new sdk_1.SymmetricKey(xorKey).decrypt(this.currentUMPToken.presentationRecoveryPrimary);\n            const rootPrivilegedKey = new sdk_1.SymmetricKey(xorKey).decrypt(this.currentUMPToken.presentationRecoveryPrivileged);\n            // Build root infrastructure, load profiles, switch to default\n            await this.setupRootInfrastructure(rootPrimaryKey, rootPrivilegedKey);\n            await this.switchProfile(this.activeProfileId);\n        }\n    }\n    // --- State Management Methods ---\n    /**\n     * Saves the current wallet state (root key, UMP token, active profile) into an encrypted snapshot.\n     * Version 2 format: [1 byte version=2] + [32 byte snapshot key] + [16 byte activeProfileId] + [encrypted payload]\n     * Encrypted Payload: [32 byte rootPrimaryKey] + [varint token length + serialized UMP token]\n     *\n     * @returns Encrypted snapshot bytes.\n     */\n    saveSnapshot() {\n        if (!this.rootPrimaryKey || !this.currentUMPToken) {\n            throw new Error('No root primary key or current UMP token set');\n        }\n        const snapshotKey = (0, sdk_1.Random)(32);\n        const snapshotPreimageWriter = new sdk_1.Utils.Writer();\n        // Write root primary key\n        snapshotPreimageWriter.write(this.rootPrimaryKey);\n        // Write serialized UMP token (must have outpoint)\n        if (!this.currentUMPToken.currentOutpoint) {\n            throw new Error('UMP token cannot be saved without a current outpoint.');\n        }\n        const serializedToken = this.serializeUMPToken(this.currentUMPToken);\n        snapshotPreimageWriter.writeVarIntNum(serializedToken.length);\n        snapshotPreimageWriter.write(serializedToken);\n        // Encrypt the payload\n        const snapshotPreimage = snapshotPreimageWriter.toArray();\n        const snapshotPayload = new sdk_1.SymmetricKey(snapshotKey).encrypt(snapshotPreimage);\n        // Build final snapshot (Version 2)\n        const snapshotWriter = new sdk_1.Utils.Writer();\n        snapshotWriter.writeUInt8(2); // Version\n        snapshotWriter.write(snapshotKey);\n        snapshotWriter.write(this.activeProfileId); // Active profile ID\n        snapshotWriter.write(snapshotPayload); // Encrypted data\n        return snapshotWriter.toArray();\n    }\n    /**\n     * Loads a previously saved state snapshot. Restores root key, UMP token, profiles, and active profile.\n     * Handles Version 1 (legacy) and Version 2 formats.\n     *\n     * @param snapshot Encrypted snapshot bytes.\n     */\n    async loadSnapshot(snapshot) {\n        try {\n            const reader = new sdk_1.Utils.Reader(snapshot);\n            const version = reader.readUInt8();\n            let snapshotKey;\n            let encryptedPayload;\n            let activeProfileId = exports.DEFAULT_PROFILE_ID; // Default for V1\n            if (version === 1) {\n                snapshotKey = reader.read(32);\n                encryptedPayload = reader.read();\n            }\n            else if (version === 2) {\n                snapshotKey = reader.read(32);\n                activeProfileId = reader.read(16); // Read active profile ID\n                encryptedPayload = reader.read();\n            }\n            else {\n                throw new Error(`Unsupported snapshot version: ${version}`);\n            }\n            // Decrypt payload\n            const decryptedPayload = new sdk_1.SymmetricKey(snapshotKey).decrypt(encryptedPayload);\n            const payloadReader = new sdk_1.Utils.Reader(decryptedPayload);\n            // Read root primary key\n            const rootPrimaryKey = payloadReader.read(32);\n            // Read serialized UMP token\n            const tokenLen = payloadReader.readVarIntNum();\n            const tokenBytes = payloadReader.read(tokenLen);\n            const token = this.deserializeUMPToken(tokenBytes);\n            // Assign loaded data\n            this.currentUMPToken = token;\n            // Setup root infrastructure, load profiles, and switch to the loaded active profile\n            await this.setupRootInfrastructure(rootPrimaryKey); // Will automatically load profiles\n            await this.switchProfile(activeProfileId); // Switch to the profile saved in the snapshot\n            this.authenticationFlow = 'existing-user'; // Loading implies existing user\n        }\n        catch (error) {\n            this.destroy(); // Clear state on error\n            throw new Error(`Failed to load snapshot: ${error.message}`);\n        }\n    }\n    /**\n     * Destroys the wallet state, clearing keys, tokens, and profiles.\n     */\n    destroy() {\n        this.underlying = undefined;\n        this.rootPrivilegedKeyManager = undefined;\n        this.authenticated = false;\n        this.rootPrimaryKey = undefined;\n        this.currentUMPToken = undefined;\n        this.presentationKey = undefined;\n        this.recoveryKey = undefined;\n        this.profiles = [];\n        this.activeProfileId = exports.DEFAULT_PROFILE_ID;\n        this.authenticationMode = 'presentation-key-and-password';\n        this.authenticationFlow = 'new-user';\n    }\n    // --- Profile Management Methods ---\n    /**\n     * Lists all available profiles, including the default profile.\n     * @returns Array of profile info objects, including an 'active' flag.\n     */\n    listProfiles() {\n        if (!this.authenticated) {\n            throw new Error('Not authenticated.');\n        }\n        const profileList = [\n            // Default profile\n            {\n                id: exports.DEFAULT_PROFILE_ID,\n                name: 'default',\n                createdAt: null, // Default profile doesn't have a creation timestamp in the same way\n                active: this.activeProfileId.every(x => x === 0)\n            },\n            // Other profiles\n            ...this.profiles.map(p => ({\n                id: p.id,\n                name: p.name,\n                createdAt: p.createdAt,\n                active: this.activeProfileId.every((x, i) => x === p.id[i])\n            }))\n        ];\n        return profileList;\n    }\n    /**\n     * Adds a new profile with the given name.\n     * Generates necessary pads and updates the UMP token.\n     * Does not switch to the new profile automatically.\n     *\n     * @param name The desired name for the new profile.\n     * @returns The ID of the newly created profile.\n     */\n    async addProfile(name) {\n        if (!this.authenticated || !this.rootPrimaryKey || !this.currentUMPToken || !this.rootPrivilegedKeyManager) {\n            throw new Error('Wallet not fully initialized or authenticated.');\n        }\n        // Ensure name is unique (including 'default')\n        if (name === 'default' || this.profiles.some(p => p.name.toLowerCase() === name.toLowerCase())) {\n            throw new Error(`Profile name \"${name}\" is already in use.`);\n        }\n        const newProfile = {\n            name,\n            id: (0, sdk_1.Random)(16),\n            primaryPad: (0, sdk_1.Random)(32),\n            privilegedPad: (0, sdk_1.Random)(32),\n            createdAt: Math.floor(Date.now() / 1000)\n        };\n        this.profiles.push(newProfile);\n        // Update the UMP token with the new profile list\n        await this.updateAuthFactors(this.currentUMPToken.passwordSalt, \n        // Need to re-derive/decrypt factors needed for re-encryption\n        await this.getFactor('passwordKey'), await this.getFactor('presentationKey'), await this.getFactor('recoveryKey'), this.rootPrimaryKey, await this.getFactor('privilegedKey'), // Get ROOT privileged key\n        this.profiles // Pass the updated profile list\n        );\n        return newProfile.id;\n    }\n    /**\n     * Deletes a profile by its ID.\n     * Cannot delete the default profile. If the active profile is deleted,\n     * it switches back to the default profile.\n     *\n     * @param profileId The 16-byte ID of the profile to delete.\n     */\n    async deleteProfile(profileId) {\n        if (!this.authenticated || !this.rootPrimaryKey || !this.currentUMPToken || !this.rootPrivilegedKeyManager) {\n            throw new Error('Wallet not fully initialized or authenticated.');\n        }\n        if (profileId.every(x => x === 0)) {\n            throw new Error('Cannot delete the default profile.');\n        }\n        const profileIndex = this.profiles.findIndex(p => p.id.every((x, i) => x === profileId[i]));\n        if (profileIndex === -1) {\n            throw new Error('Profile not found.');\n        }\n        // Remove the profile\n        this.profiles.splice(profileIndex, 1);\n        // If the deleted profile was active, switch to default\n        if (this.activeProfileId.every((x, i) => x === profileId[i])) {\n            await this.switchProfile(exports.DEFAULT_PROFILE_ID); // This rebuilds the wallet\n        }\n        // Update the UMP token\n        await this.updateAuthFactors(this.currentUMPToken.passwordSalt, await this.getFactor('passwordKey'), await this.getFactor('presentationKey'), await this.getFactor('recoveryKey'), this.rootPrimaryKey, await this.getFactor('privilegedKey'), // Get ROOT privileged key\n        this.profiles // Pass updated list\n        );\n    }\n    /**\n     * Switches the active profile. This re-derives keys and rebuilds the underlying wallet.\n     *\n     * @param profileId The 16-byte ID of the profile to switch to (use DEFAULT_PROFILE_ID for default).\n     */\n    async switchProfile(profileId) {\n        if (!this.authenticated || !this.rootPrimaryKey || !this.rootPrivilegedKeyManager) {\n            throw new Error('Cannot switch profile: Wallet not authenticated or root keys missing.');\n        }\n        let profilePrimaryKey;\n        let profilePrivilegedPad; // Pad for the target profile\n        if (profileId.every(x => x === 0)) {\n            // Switching to default profile\n            profilePrimaryKey = this.rootPrimaryKey;\n            profilePrivilegedPad = undefined; // No pad for default\n            this.activeProfileId = exports.DEFAULT_PROFILE_ID;\n        }\n        else {\n            // Switching to a non-default profile\n            const profile = this.profiles.find(p => p.id.every((x, i) => x === profileId[i]));\n            if (!profile) {\n                throw new Error('Profile not found.');\n            }\n            profilePrimaryKey = this.XOR(this.rootPrimaryKey, profile.primaryPad);\n            profilePrivilegedPad = profile.privilegedPad;\n            this.activeProfileId = profileId;\n        }\n        // Create a *profile-specific* PrivilegedKeyManager.\n        // It uses the ROOT manager internally but applies the profile's pad.\n        const profilePrivilegedKeyManager = new PrivilegedKeyManager_1.PrivilegedKeyManager(async (reason) => {\n            // Request the ROOT privileged key using the root manager\n            const rootPrivileged = await this.rootPrivilegedKeyManager.getPrivilegedKey(reason);\n            const rootPrivilegedBytes = rootPrivileged.toArray();\n            // Apply the profile's pad if applicable\n            const profilePrivilegedBytes = profilePrivilegedPad\n                ? this.XOR(rootPrivilegedBytes, profilePrivilegedPad)\n                : rootPrivilegedBytes;\n            return new sdk_1.PrivateKey(profilePrivilegedBytes);\n        });\n        // Build the underlying wallet for the specific profile\n        this.underlying = await this.walletBuilder(profilePrimaryKey, profilePrivilegedKeyManager, // Pass the profile-specific manager\n        this.activeProfileId // Pass the ID of the profile being activated\n        );\n    }\n    // --- Key Management Methods ---\n    /**\n     * Changes the user's password. Re-wraps keys and updates the UMP token.\n     */\n    async changePassword(newPassword) {\n        if (!this.authenticated || !this.currentUMPToken || !this.rootPrimaryKey || !this.rootPrivilegedKeyManager) {\n            throw new Error('Not authenticated or missing required data.');\n        }\n        const passwordSalt = (0, sdk_1.Random)(32);\n        const newPasswordKey = await pbkdf2NativeOrJs(sdk_1.Utils.toArray(newPassword, 'utf8'), passwordSalt, exports.PBKDF2_NUM_ROUNDS, 32, 'sha512');\n        // Decrypt existing factors needed for re-encryption, using the *root* privileged key manager\n        const recoveryKey = await this.getFactor('recoveryKey');\n        const presentationKey = await this.getFactor('presentationKey');\n        const rootPrivilegedKey = await this.getFactor('privilegedKey'); // Get ROOT privileged key\n        await this.updateAuthFactors(passwordSalt, newPasswordKey, presentationKey, recoveryKey, this.rootPrimaryKey, rootPrivilegedKey, // Pass the explicitly fetched root key\n        this.profiles // Preserve existing profiles\n        );\n    }\n    /**\n     * Retrieves the current recovery key. Requires privileged access.\n     */\n    async getRecoveryKey() {\n        if (!this.authenticated || !this.currentUMPToken || !this.rootPrivilegedKeyManager) {\n            throw new Error('Not authenticated or missing required data.');\n        }\n        return this.getFactor('recoveryKey');\n    }\n    /**\n     * Changes the user's recovery key. Prompts user to save the new key.\n     */\n    async changeRecoveryKey() {\n        if (!this.authenticated || !this.currentUMPToken || !this.rootPrimaryKey || !this.rootPrivilegedKeyManager) {\n            throw new Error('Not authenticated or missing required data.');\n        }\n        // Decrypt existing factors needed\n        const passwordKey = await this.getFactor('passwordKey');\n        const presentationKey = await this.getFactor('presentationKey');\n        const rootPrivilegedKey = await this.getFactor('privilegedKey'); // Get ROOT privileged key\n        // Generate and save new recovery key\n        const newRecoveryKey = (0, sdk_1.Random)(32);\n        await this.recoveryKeySaver(newRecoveryKey);\n        await this.updateAuthFactors(this.currentUMPToken.passwordSalt, passwordKey, presentationKey, newRecoveryKey, // Use the new key\n        this.rootPrimaryKey, rootPrivilegedKey, this.profiles // Preserve profiles\n        );\n    }\n    /**\n     * Changes the user's presentation key.\n     */\n    async changePresentationKey(newPresentationKey) {\n        if (!this.authenticated || !this.currentUMPToken || !this.rootPrimaryKey || !this.rootPrivilegedKeyManager) {\n            throw new Error('Not authenticated or missing required data.');\n        }\n        if (newPresentationKey.length !== 32) {\n            throw new Error('Presentation key must be 32 bytes.');\n        }\n        // Decrypt existing factors\n        const recoveryKey = await this.getFactor('recoveryKey');\n        const passwordKey = await this.getFactor('passwordKey');\n        const rootPrivilegedKey = await this.getFactor('privilegedKey'); // Get ROOT privileged key\n        await this.updateAuthFactors(this.currentUMPToken.passwordSalt, passwordKey, newPresentationKey, // Use the new key\n        recoveryKey, this.rootPrimaryKey, rootPrivilegedKey, this.profiles // Preserve profiles\n        );\n        // Update the temporarily stored key if it was set\n        if (this.presentationKey) {\n            this.presentationKey = newPresentationKey;\n        }\n    }\n    // --- Internal Helper Methods ---\n    /**\n     * Performs XOR operation on two byte arrays.\n     */\n    XOR(n1, n2) {\n        if (n1.length !== n2.length) {\n            // Provide more context in error\n            throw new Error(`XOR length mismatch: ${n1.length} vs ${n2.length}`);\n        }\n        const r = new Array(n1.length);\n        for (let i = 0; i < n1.length; i++) {\n            r[i] = n1[i] ^ n2[i];\n        }\n        return r;\n    }\n    /**\n     * Helper to decrypt a specific factor (key) stored encrypted in the UMP token.\n     * Requires the root privileged key manager.\n     * @param factorName Name of the factor to decrypt ('passwordKey', 'presentationKey', 'recoveryKey', 'privilegedKey').\n     * @param getRoot If true and factorName is 'privilegedKey', returns the root privileged key bytes directly.\n     * @returns The decrypted key bytes.\n     */\n    async getFactor(factorName) {\n        if (!this.authenticated || !this.currentUMPToken || !this.rootPrivilegedKeyManager) {\n            throw new Error(`Cannot get factor \"${factorName}\": Wallet not ready.`);\n        }\n        const protocolID = [2, 'admin key wrapping']; // Protocol used for encrypting factors\n        const keyID = '1'; // Key ID used\n        try {\n            switch (factorName) {\n                case 'passwordKey':\n                    return (await this.rootPrivilegedKeyManager.decrypt({\n                        ciphertext: this.currentUMPToken.passwordKeyEncrypted,\n                        protocolID,\n                        keyID\n                    })).plaintext;\n                case 'presentationKey':\n                    return (await this.rootPrivilegedKeyManager.decrypt({\n                        ciphertext: this.currentUMPToken.presentationKeyEncrypted,\n                        protocolID,\n                        keyID\n                    })).plaintext;\n                case 'recoveryKey':\n                    return (await this.rootPrivilegedKeyManager.decrypt({\n                        ciphertext: this.currentUMPToken.recoveryKeyEncrypted,\n                        protocolID,\n                        keyID\n                    })).plaintext;\n                case 'privilegedKey': {\n                    // This needs careful handling based on whether the ROOT or PROFILE key is needed.\n                    // This helper is mostly used for UMP updates, which need the ROOT key.\n                    // We retrieve the PrivateKey object first.\n                    const pk = await this.rootPrivilegedKeyManager.getPrivilegedKey('UMP token update', true); // Force retrieval of root key\n                    return pk.toArray(); // Return bytes\n                }\n                default:\n                    throw new Error(`Unknown factor name: ${factorName}`);\n            }\n        }\n        catch (error) {\n            console.error(`Error decrypting factor ${factorName}:`, error);\n            throw new Error(`Failed to decrypt factor \"${factorName}\": ${error.message}`);\n        }\n    }\n    /**\n     * Recomputes UMP token fields with updated factors and profiles, then publishes the update.\n     * This operation requires the *root* privileged key and the *default* profile wallet.\n     */\n    async updateAuthFactors(passwordSalt, passwordKey, presentationKey, recoveryKey, rootPrimaryKey, rootPrivilegedKey, // Explicitly pass the root key bytes\n    profiles // Pass current/new profiles list\n    ) {\n        if (!this.authenticated || !this.rootPrimaryKey || !this.currentUMPToken) {\n            throw new Error('Wallet is not properly authenticated or missing data for update.');\n        }\n        // Ensure we have the OLD token to consume\n        const oldTokenToConsume = { ...this.currentUMPToken };\n        if (!oldTokenToConsume.currentOutpoint) {\n            throw new Error('Cannot update UMP token: Old token has no outpoint.');\n        }\n        // Derive symmetrical encryption keys using XOR for the *root* keys\n        const presentationPassword = new sdk_1.SymmetricKey(this.XOR(presentationKey, passwordKey));\n        const presentationRecovery = new sdk_1.SymmetricKey(this.XOR(presentationKey, recoveryKey));\n        const recoveryPassword = new sdk_1.SymmetricKey(this.XOR(recoveryKey, passwordKey));\n        const primaryPassword = new sdk_1.SymmetricKey(this.XOR(rootPrimaryKey, passwordKey)); // Use rootPrimaryKey\n        // Build a temporary privileged key manager using the explicit ROOT privileged key\n        const tempRootPrivilegedKeyManager = new PrivilegedKeyManager_1.PrivilegedKeyManager(async () => new sdk_1.PrivateKey(rootPrivilegedKey));\n        // Encrypt profiles if provided\n        let profilesEncrypted;\n        if (profiles && profiles.length > 0) {\n            const profilesJson = JSON.stringify(profiles);\n            const profilesBytes = sdk_1.Utils.toArray(profilesJson, 'utf8');\n            profilesEncrypted = new sdk_1.SymmetricKey(rootPrimaryKey).encrypt(profilesBytes);\n        }\n        // Construct the new UMP token data\n        const newTokenData = {\n            passwordSalt,\n            passwordPresentationPrimary: presentationPassword.encrypt(rootPrimaryKey),\n            passwordRecoveryPrimary: recoveryPassword.encrypt(rootPrimaryKey),\n            presentationRecoveryPrimary: presentationRecovery.encrypt(rootPrimaryKey),\n            passwordPrimaryPrivileged: primaryPassword.encrypt(rootPrivilegedKey),\n            presentationRecoveryPrivileged: presentationRecovery.encrypt(rootPrivilegedKey),\n            presentationHash: sdk_1.Hash.sha256(presentationKey),\n            recoveryHash: sdk_1.Hash.sha256(recoveryKey),\n            presentationKeyEncrypted: (await tempRootPrivilegedKeyManager.encrypt({\n                plaintext: presentationKey,\n                protocolID: [2, 'admin key wrapping'],\n                keyID: '1'\n            })).ciphertext,\n            passwordKeyEncrypted: (await tempRootPrivilegedKeyManager.encrypt({\n                plaintext: passwordKey,\n                protocolID: [2, 'admin key wrapping'],\n                keyID: '1'\n            })).ciphertext,\n            recoveryKeyEncrypted: (await tempRootPrivilegedKeyManager.encrypt({\n                plaintext: recoveryKey,\n                protocolID: [2, 'admin key wrapping'],\n                keyID: '1'\n            })).ciphertext,\n            profilesEncrypted // Add encrypted profiles\n            // currentOutpoint will be set after publishing\n        };\n        // We need the wallet built for the DEFAULT profile to publish the UMP token.\n        // If the current active profile is not default, temporarily switch, publish, then switch back.\n        const currentActiveId = this.activeProfileId;\n        let walletToUse = this.underlying;\n        if (!currentActiveId.every(x => x === 0)) {\n            console.log('Temporarily switching to default profile to update UMP token...');\n            await this.switchProfile(exports.DEFAULT_PROFILE_ID); // This rebuilds this.underlying\n            walletToUse = this.underlying;\n        }\n        if (!walletToUse) {\n            throw new Error('Default profile wallet could not be activated for UMP token update.');\n        }\n        // Publish the new token on-chain, consuming the old one\n        try {\n            newTokenData.currentOutpoint = await this.UMPTokenInteractor.buildAndSend(walletToUse, this.adminOriginator, newTokenData, oldTokenToConsume // Consume the previous token\n            );\n            // Update the manager's state\n            this.currentUMPToken = newTokenData;\n            // Profiles are already updated in this.profiles if they were passed in\n        }\n        finally {\n            // Switch back if we temporarily switched\n            if (!currentActiveId.every(x => x === 0)) {\n                console.log('Switching back to original profile...');\n                await this.switchProfile(currentActiveId);\n            }\n        }\n    }\n    /**\n     * Serializes a UMP token to binary format (Version 2 with optional profiles).\n     * Layout: [1 byte version=2] + [11 * (varint len + bytes) for standard fields] + [1 byte profile_flag] + [IF flag=1 THEN varint len + profile bytes] + [varint len + outpoint bytes]\n     */\n    serializeUMPToken(token) {\n        if (!token.currentOutpoint) {\n            throw new Error('Token must have outpoint for serialization');\n        }\n        const writer = new sdk_1.Utils.Writer();\n        writer.writeUInt8(2); // Version 2\n        const writeArray = (arr) => {\n            writer.writeVarIntNum(arr.length);\n            writer.write(arr);\n        };\n        // Write standard fields in specific order\n        writeArray(token.passwordSalt); // 0\n        writeArray(token.passwordPresentationPrimary); // 1\n        writeArray(token.passwordRecoveryPrimary); // 2\n        writeArray(token.presentationRecoveryPrimary); // 3\n        writeArray(token.passwordPrimaryPrivileged); // 4\n        writeArray(token.presentationRecoveryPrivileged); // 5\n        writeArray(token.presentationHash); // 6\n        writeArray(token.recoveryHash); // 7\n        writeArray(token.presentationKeyEncrypted); // 8\n        writeArray(token.passwordKeyEncrypted); // 9 - Swapped order vs original doc comment\n        writeArray(token.recoveryKeyEncrypted); // 10\n        // Write optional profiles field\n        if (token.profilesEncrypted && token.profilesEncrypted.length > 0) {\n            writer.writeUInt8(1); // Flag indicating profiles present\n            writeArray(token.profilesEncrypted);\n        }\n        else {\n            writer.writeUInt8(0); // Flag indicating no profiles\n        }\n        // Write outpoint string\n        const outpointBytes = sdk_1.Utils.toArray(token.currentOutpoint, 'utf8');\n        writer.writeVarIntNum(outpointBytes.length);\n        writer.write(outpointBytes);\n        return writer.toArray();\n    }\n    /**\n     * Deserializes a UMP token from binary format (Handles Version 1 and 2).\n     */\n    deserializeUMPToken(bin) {\n        const reader = new sdk_1.Utils.Reader(bin);\n        const version = reader.readUInt8();\n        if (version !== 1 && version !== 2) {\n            throw new Error(`Unsupported UMP token serialization version: ${version}`);\n        }\n        const readArray = () => {\n            const length = reader.readVarIntNum();\n            return reader.read(length);\n        };\n        // Read standard fields (order matches serialization V2)\n        const passwordSalt = readArray(); // 0\n        const passwordPresentationPrimary = readArray(); // 1\n        const passwordRecoveryPrimary = readArray(); // 2\n        const presentationRecoveryPrimary = readArray(); // 3\n        const passwordPrimaryPrivileged = readArray(); // 4\n        const presentationRecoveryPrivileged = readArray(); // 5\n        const presentationHash = readArray(); // 6\n        const recoveryHash = readArray(); // 7\n        const presentationKeyEncrypted = readArray(); // 8\n        const passwordKeyEncrypted = readArray(); // 9\n        const recoveryKeyEncrypted = readArray(); // 10\n        // Read optional profiles (only in V2)\n        let profilesEncrypted;\n        if (version === 2) {\n            const profilesFlag = reader.readUInt8();\n            if (profilesFlag === 1) {\n                profilesEncrypted = readArray();\n            }\n        }\n        // Read outpoint string\n        const outpointLen = reader.readVarIntNum();\n        const outpointBytes = reader.read(outpointLen);\n        const currentOutpoint = sdk_1.Utils.toUTF8(outpointBytes);\n        const token = {\n            passwordSalt,\n            passwordPresentationPrimary,\n            passwordRecoveryPrimary,\n            presentationRecoveryPrimary,\n            passwordPrimaryPrivileged,\n            presentationRecoveryPrivileged,\n            presentationHash,\n            recoveryHash,\n            presentationKeyEncrypted,\n            passwordKeyEncrypted, // Corrected order\n            recoveryKeyEncrypted,\n            profilesEncrypted, // May be undefined\n            currentOutpoint\n        };\n        return token;\n    }\n    /**\n     * Sets up the root key infrastructure after authentication or loading from snapshot.\n     * Initializes the root primary key, root privileged key manager, loads profiles,\n     * and sets the authenticated flag. Does NOT switch profile initially.\n     *\n     * @param rootPrimaryKey      The user's root primary key (32 bytes).\n     * @param ephemeralRootPrivilegedKey Optional root privileged key (e.g., during recovery flows).\n     */\n    async setupRootInfrastructure(rootPrimaryKey, ephemeralRootPrivilegedKey) {\n        if (!this.currentUMPToken) {\n            throw new Error('A UMP token must exist before setting up root infrastructure!');\n        }\n        this.rootPrimaryKey = rootPrimaryKey;\n        // Store ephemeral key if provided, for one-time use by the manager\n        let oneTimePrivilegedKey = ephemeralRootPrivilegedKey\n            ? new sdk_1.PrivateKey(ephemeralRootPrivilegedKey)\n            : undefined;\n        // Create the ROOT PrivilegedKeyManager\n        this.rootPrivilegedKeyManager = new PrivilegedKeyManager_1.PrivilegedKeyManager(async (reason) => {\n            // 1. Use one-time key if available (for recovery)\n            if (oneTimePrivilegedKey) {\n                const tempKey = oneTimePrivilegedKey;\n                oneTimePrivilegedKey = undefined; // Consume it\n                return tempKey;\n            }\n            // 2. Otherwise, derive from password\n            const password = await this.passwordRetriever(reason, (passwordCandidate) => {\n                try {\n                    const derivedPasswordKey = sdk_1.Hash.pbkdf2(sdk_1.Utils.toArray(passwordCandidate, 'utf8'), this.currentUMPToken.passwordSalt, exports.PBKDF2_NUM_ROUNDS, 32, 'sha512');\n                    const privilegedDecryptor = this.XOR(this.rootPrimaryKey, derivedPasswordKey);\n                    const decryptedPrivileged = new sdk_1.SymmetricKey(privilegedDecryptor).decrypt(this.currentUMPToken.passwordPrimaryPrivileged);\n                    return !!decryptedPrivileged; // Test passes if decryption works\n                }\n                catch (e) {\n                    return false;\n                }\n            });\n            // Decrypt the root privileged key using the confirmed password\n            const derivedPasswordKey = await pbkdf2NativeOrJs(sdk_1.Utils.toArray(password, 'utf8'), this.currentUMPToken.passwordSalt, exports.PBKDF2_NUM_ROUNDS, 32, 'sha512');\n            const privilegedDecryptor = this.XOR(this.rootPrimaryKey, derivedPasswordKey);\n            const rootPrivilegedBytes = new sdk_1.SymmetricKey(privilegedDecryptor).decrypt(this.currentUMPToken.passwordPrimaryPrivileged);\n            return new sdk_1.PrivateKey(rootPrivilegedBytes); // Return the ROOT key object\n        });\n        // Decrypt and load profiles if present in the token\n        this.profiles = []; // Clear existing profiles before loading\n        if (this.currentUMPToken.profilesEncrypted && this.currentUMPToken.profilesEncrypted.length > 0) {\n            try {\n                const decryptedProfileBytes = new sdk_1.SymmetricKey(rootPrimaryKey).decrypt(this.currentUMPToken.profilesEncrypted);\n                const profilesJson = sdk_1.Utils.toUTF8(decryptedProfileBytes);\n                this.profiles = JSON.parse(profilesJson);\n            }\n            catch (error) {\n                console.error('Failed to decrypt or parse profiles:', error);\n                // Decide if this should be fatal or just log and continue without profiles\n                this.profiles = []; // Ensure profiles are empty on error\n                // Optionally re-throw or handle more gracefully\n                throw new Error(`Failed to load profiles: ${error.message}`);\n            }\n        }\n        this.authenticated = true;\n        // Note: We don't call switchProfile here anymore.\n        // It's called by the auth methods (providePassword/provideRecoveryKey) or loadSnapshot after this.\n    }\n    /*\n     * ---------------------------------------------------------------------------------------\n     * Standard WalletInterface methods proxying to the *active* underlying wallet.\n     * Includes authentication checks and admin originator protection.\n     * ---------------------------------------------------------------------------------------\n     */\n    checkAuthAndUnderlying(originator) {\n        if (!this.authenticated) {\n            throw new Error('User is not authenticated.');\n        }\n        if (!this.underlying) {\n            // This might happen if authentication succeeded but profile switching failed\n            throw new Error('Underlying wallet for the active profile is not initialized.');\n        }\n        if (originator === this.adminOriginator) {\n            throw new Error('External applications are not allowed to use the admin originator.');\n        }\n    }\n    // Example proxy method (repeat pattern for all others)\n    async getPublicKey(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.getPublicKey(args, originator);\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.revealCounterpartyKeyLinkage(args, originator);\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.revealSpecificKeyLinkage(args, originator);\n    }\n    async encrypt(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.encrypt(args, originator);\n    }\n    async decrypt(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.decrypt(args, originator);\n    }\n    async createHmac(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.createHmac(args, originator);\n    }\n    async verifyHmac(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.verifyHmac(args, originator);\n    }\n    async createSignature(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.createSignature(args, originator);\n    }\n    async verifySignature(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.verifySignature(args, originator);\n    }\n    async createAction(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.createAction(args, originator);\n    }\n    async signAction(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.signAction(args, originator);\n    }\n    async abortAction(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.abortAction(args, originator);\n    }\n    async listActions(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.listActions(args, originator);\n    }\n    async internalizeAction(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.internalizeAction(args, originator);\n    }\n    async listOutputs(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.listOutputs(args, originator);\n    }\n    async relinquishOutput(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.relinquishOutput(args, originator);\n    }\n    async acquireCertificate(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.acquireCertificate(args, originator);\n    }\n    async listCertificates(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.listCertificates(args, originator);\n    }\n    async proveCertificate(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.proveCertificate(args, originator);\n    }\n    async relinquishCertificate(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.relinquishCertificate(args, originator);\n    }\n    async discoverByIdentityKey(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.discoverByIdentityKey(args, originator);\n    }\n    async discoverByAttributes(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.discoverByAttributes(args, originator);\n    }\n    async isAuthenticated(_, originator) {\n        if (!this.authenticated) {\n            throw new Error('User is not authenticated.');\n        }\n        if (originator === this.adminOriginator) {\n            throw new Error('External applications are not allowed to use the admin originator.');\n        }\n        return { authenticated: true };\n    }\n    async waitForAuthentication(_, originator) {\n        if (originator === this.adminOriginator) {\n            throw new Error('External applications are not allowed to use the admin originator.');\n        }\n        while (!this.authenticated || !this.underlying) {\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n        return await this.underlying.waitForAuthentication({}, originator);\n    }\n    async getHeight(_, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.getHeight({}, originator);\n    }\n    async getHeaderForHeight(args, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.getHeaderForHeight(args, originator);\n    }\n    async getNetwork(_, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.getNetwork({}, originator);\n    }\n    async getVersion(_, originator) {\n        this.checkAuthAndUnderlying(originator);\n        return this.underlying.getVersion({}, originator);\n    }\n}\nexports.CWIStyleWalletManager = CWIStyleWalletManager;\n//# sourceMappingURL=CWIStyleWalletManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupClient.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupClient.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SetupClient = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ./index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst StorageIdb_1 = __webpack_require__(/*! ./storage/StorageIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageIdb.js\");\n/**\n * The 'Setup` class provides static setup functions to construct BRC-100 compatible\n * wallets in a variety of configurations.\n *\n * It serves as a starting point for experimentation and customization.\n */\nclass SetupClient {\n    /**\n     * Create a `Wallet`. Storage can optionally be provided or configured later.\n     *\n     * The following components are configured: KeyDeriver, WalletStorageManager, WalletService, WalletStorage.\n     * Optionally, PrivilegedKeyManager is also configured.\n     *\n     * @publicbody\n     */\n    static async createWallet(args) {\n        const chain = args.chain;\n        const rootKey = sdk_1.PrivateKey.fromHex(args.rootKeyHex);\n        const identityKey = rootKey.toPublicKey().toString();\n        const keyDeriver = new sdk_1.CachedKeyDeriver(rootKey);\n        const storage = new index_client_1.WalletStorageManager(identityKey, args.active, args.backups);\n        if (storage.canMakeAvailable())\n            await storage.makeAvailable();\n        const serviceOptions = index_client_1.Services.createDefaultOptions(chain);\n        serviceOptions.taalApiKey = args.taalApiKey;\n        const services = new index_client_1.Services(serviceOptions);\n        const monopts = index_client_1.Monitor.createDefaultWalletMonitorOptions(chain, storage, services);\n        const monitor = new index_client_1.Monitor(monopts);\n        monitor.addDefaultTasks();\n        const privilegedKeyManager = args.privilegedKeyGetter\n            ? new index_client_1.sdk.PrivilegedKeyManager(args.privilegedKeyGetter)\n            : undefined;\n        const wallet = new index_client_1.Wallet({\n            chain,\n            keyDeriver,\n            storage,\n            services,\n            monitor,\n            privilegedKeyManager\n        });\n        const r = {\n            rootKey,\n            identityKey,\n            keyDeriver,\n            chain,\n            storage,\n            services,\n            monitor,\n            wallet\n        };\n        return r;\n    }\n    /**\n     * Setup a new `Wallet` without requiring a .env file.\n     *\n     * @param args.chain - 'main' or 'test'\n     * @param args.rootKeyHex  - Root private key for wallet's key deriver.\n     * @param args.storageUrl - Optional. `StorageClient` and `chain` compatible endpoint URL.\n     * @param args.privilegedKeyGetter - Optional. Method that will return the privileged `PrivateKey`, on demand.\n     */\n    static async createWalletClientNoEnv(args) {\n        const chain = args.chain;\n        const endpointUrl = args.storageUrl || `https://${args.chain !== 'main' ? 'staging-' : ''}storage.babbage.systems`;\n        const rootKey = sdk_1.PrivateKey.fromHex(args.rootKeyHex);\n        const keyDeriver = new sdk_1.CachedKeyDeriver(rootKey);\n        const storage = new index_client_1.WalletStorageManager(keyDeriver.identityKey);\n        const services = new index_client_1.Services(chain);\n        const privilegedKeyManager = args.privilegedKeyGetter\n            ? new index_client_1.sdk.PrivilegedKeyManager(args.privilegedKeyGetter)\n            : undefined;\n        const wallet = new index_client_1.Wallet({\n            chain,\n            keyDeriver,\n            storage,\n            services,\n            privilegedKeyManager\n        });\n        const client = new index_client_1.StorageClient(wallet, endpointUrl);\n        await storage.addWalletStorageProvider(client);\n        await storage.makeAvailable();\n        return wallet;\n    }\n    /**\n     * @publicbody\n     */\n    static async createWalletClient(args) {\n        const wo = await SetupClient.createWallet(args);\n        const endpointUrl = args.endpointUrl || `https://${args.chain !== 'main' ? 'staging-' : ''}storage.babbage.systems`;\n        const client = new index_client_1.StorageClient(wo.wallet, endpointUrl);\n        await wo.storage.addWalletStorageProvider(client);\n        await wo.storage.makeAvailable();\n        return {\n            ...wo,\n            endpointUrl\n        };\n    }\n    /**\n     * @publicbody\n     */\n    static getKeyPair(priv) {\n        if (priv === undefined)\n            priv = sdk_1.PrivateKey.fromRandom();\n        else if (typeof priv === 'string')\n            priv = new sdk_1.PrivateKey(priv, 'hex');\n        const pub = sdk_1.PublicKey.fromPrivateKey(priv);\n        const address = pub.toAddress();\n        return { privateKey: priv, publicKey: pub, address };\n    }\n    /**\n     * @publicbody\n     */\n    static getLockP2PKH(address) {\n        const p2pkh = new sdk_1.P2PKH();\n        const lock = p2pkh.lock(address);\n        return lock;\n    }\n    /**\n     * @publicbody\n     */\n    static getUnlockP2PKH(priv, satoshis) {\n        const p2pkh = new sdk_1.P2PKH();\n        const lock = SetupClient.getLockP2PKH(SetupClient.getKeyPair(priv).address);\n        // Prepare to pay with SIGHASH_ALL and without ANYONE_CAN_PAY.\n        // In otherwords:\n        // - all outputs must remain in the current order, amount and locking scripts.\n        // - all inputs must remain from the current outpoints and sequence numbers.\n        // (unlock scripts are never signed)\n        const unlock = p2pkh.unlock(priv, 'all', false, satoshis, lock);\n        return unlock;\n    }\n    /**\n     * @publicbody\n     */\n    static createP2PKHOutputs(outputs) {\n        const os = [];\n        const count = outputs.length;\n        for (let i = 0; i < count; i++) {\n            const o = outputs[i];\n            os.push({\n                basket: o.basket,\n                tags: o.tags,\n                satoshis: o.satoshis,\n                lockingScript: SetupClient.getLockP2PKH(o.address).toHex(),\n                outputDescription: o.outputDescription || `p2pkh ${i}`\n            });\n        }\n        return os;\n    }\n    /**\n     * @publicbody\n     */\n    static async createP2PKHOutputsAction(wallet, outputs, options) {\n        const os = SetupClient.createP2PKHOutputs(outputs);\n        const createArgs = {\n            description: `createP2PKHOutputs`,\n            outputs: os,\n            options: {\n                ...options,\n                // Don't randomize so we can simplify outpoint creation\n                randomizeOutputs: false\n            }\n        };\n        const cr = await wallet.createAction(createArgs);\n        let outpoints;\n        if (cr.txid) {\n            outpoints = os.map((o, i) => `${cr.txid}.${i}`);\n        }\n        return { cr, outpoints };\n    }\n    /**\n     * @publicbody\n     */\n    static async fundWalletFromP2PKHOutpoints(wallet, outpoints, p2pkhKey, inputBEEF) {\n        // TODO\n    }\n    /**\n     * Adds `indexedDB` based storage to a `Wallet` configured by `SetupClient.createWalletOnly`\n     *\n     * @param args.databaseName Name for this storage. For MySQL, the schema name within the MySQL instance.\n     * @param args.chain Which chain this wallet is on: 'main' or 'test'. Defaults to 'test'.\n     * @param args.rootKeyHex\n     *\n     * @publicbody\n     */\n    static async createWalletIdb(args) {\n        const wo = await SetupClient.createWallet(args);\n        const activeStorage = await SetupClient.createStorageIdb(args);\n        await wo.storage.addWalletStorageProvider(activeStorage);\n        const { user, isNew } = await activeStorage.findOrInsertUser(wo.identityKey);\n        const userId = user.userId;\n        const r = {\n            ...wo,\n            activeStorage,\n            userId\n        };\n        return r;\n    }\n    /**\n     * @returns {StorageIdb} - `Knex` based storage provider for a wallet. May be used for either active storage or backup storage.\n     */\n    static async createStorageIdb(args) {\n        const storage = new StorageIdb_1.StorageIdb({\n            chain: args.chain,\n            commissionSatoshis: 0,\n            commissionPubKeyHex: undefined,\n            feeModel: { model: 'sat/kb', value: 1 }\n        });\n        await storage.migrate(args.databaseName, (0, index_client_1.randomBytesHex)(33));\n        await storage.makeAvailable();\n        return storage;\n    }\n}\nexports.SetupClient = SetupClient;\n//# sourceMappingURL=SetupClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupWallet.js":
/*!************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupWallet.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=SetupWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/SimpleWalletManager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/SimpleWalletManager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SimpleWalletManager = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\n/**\n * SimpleWalletManager is a slimmed-down wallet manager that only requires two things to authenticate:\n *  1. A primary key (32 bytes), which represents the core secret for the wallet.\n *  2. A privileged key manager (an instance of `PrivilegedKeyManager`), responsible for\n *     more sensitive operations.\n *\n * Once both pieces are provided (or if a snapshot containing the primary key is loaded,\n * and the privileged key manager is provided separately), the wallet becomes authenticated.\n *\n * After authentication, calls to the standard wallet methods (`createAction`, `signAction`, etc.)\n * are proxied to an underlying `WalletInterface` instance returned by a user-supplied `walletBuilder`.\n *\n * **Important**: This manager does not handle user password flows, recovery, or on-chain\n * token management. It is a straightforward wrapper that ensures the user has provided\n * both their main secret (primary key) and a privileged key manager before allowing usage.\n *\n * It also prevents calls from the special \"admin originator\" from being used externally.\n * (Any call that tries to use the admin originator as its originator, other than the manager itself,\n * will result in an error, ensuring that only internal operations can use that originator.)\n *\n * The manager can also save and load snapshots of its state. In this simplified version,\n * the snapshot only contains the primary key. If you load a snapshot, you still need to\n * re-provide the privileged key manager to complete authentication.\n */\nclass SimpleWalletManager {\n    /**\n     * Constructs a new `SimpleWalletManager`.\n     *\n     * @param adminOriginator The domain name of the administrative originator.\n     * @param walletBuilder   A function that, given a primary key and privileged key manager,\n     *                        returns a fully functional `WalletInterface`.\n     * @param stateSnapshot   If provided, a previously saved snapshot of the wallet's state.\n     *                        If the snapshot contains a primary key, it will be loaded immediately\n     *                        (though you will still need to provide a privileged key manager to authenticate).\n     */\n    constructor(adminOriginator, walletBuilder, stateSnapshot) {\n        this.authenticated = false;\n        this.adminOriginator = adminOriginator;\n        this.walletBuilder = walletBuilder;\n        if (stateSnapshot) {\n            this.loadSnapshot(stateSnapshot);\n        }\n    }\n    /**\n     * Provides the primary key (32 bytes) needed for authentication.\n     * If a privileged key manager has already been provided, we attempt to build\n     * the underlying wallet. Otherwise, we wait until the manager is also provided.\n     *\n     * @param key A 32-byte primary key.\n     */\n    async providePrimaryKey(key) {\n        this.primaryKey = key;\n        await this.tryBuildUnderlying();\n    }\n    /**\n     * Provides the privileged key manager needed for sensitive tasks.\n     * If a primary key has already been provided (or loaded from a snapshot),\n     * we attempt to build the underlying wallet. Otherwise, we wait until the key is provided.\n     *\n     * @param manager An instance of `PrivilegedKeyManager`.\n     */\n    async providePrivilegedKeyManager(manager) {\n        this.underlyingPrivilegedKeyManager = manager;\n        await this.tryBuildUnderlying();\n    }\n    /**\n     * Internal method that checks if we have both the primary key and privileged manager.\n     * If so, we build the underlying wallet instance and become authenticated.\n     */\n    async tryBuildUnderlying() {\n        if (this.authenticated) {\n            throw new Error('The user is already authenticated.');\n        }\n        if (!this.primaryKey || !this.underlyingPrivilegedKeyManager) {\n            return;\n        }\n        // Build the underlying wallet:\n        this.underlying = await this.walletBuilder(this.primaryKey, this.underlyingPrivilegedKeyManager);\n        this.authenticated = true;\n    }\n    /**\n     * Destroys the underlying wallet, returning to a default (unauthenticated) state.\n     *\n     * This clears the primary key, the privileged key manager, and the `authenticated` flag.\n     */\n    destroy() {\n        this.underlying = undefined;\n        this.underlyingPrivilegedKeyManager = undefined;\n        this.authenticated = false;\n        this.primaryKey = undefined;\n    }\n    /**\n     * Saves the current wallet state (including just the primary key)\n     * into an encrypted snapshot. This snapshot can be stored and later\n     * passed to `loadSnapshot` to restore the primary key (and partially authenticate).\n     *\n     * **Note**: The snapshot does NOT include the privileged key manager.\n     * You must still provide that separately after loading the snapshot\n     * in order to complete authentication.\n     *\n     * @remarks\n     * Storing the snapshot (which contains the primary key) provides a significant\n     * portion of the wallet's secret material. It must be protected carefully.\n     *\n     * @returns A byte array representing the encrypted snapshot.\n     * @throws {Error} if no primary key is currently set.\n     */\n    saveSnapshot() {\n        if (!this.primaryKey) {\n            throw new Error('No primary key is set; cannot save snapshot.');\n        }\n        // Generate a random snapshot encryption key:\n        const snapshotKey = (0, sdk_1.Random)(32);\n        // For this simple wallet manager, we only store the primary key.\n        const writer = new sdk_1.Utils.Writer();\n        // Write a 1-byte version:\n        writer.writeUInt8(1);\n        // Write a varint length and then the primary key bytes:\n        writer.writeVarIntNum(this.primaryKey.length);\n        writer.write(this.primaryKey);\n        const snapshotPreimage = writer.toArray();\n        // Encrypt the data with the snapshotKey:\n        const encryptedPayload = new sdk_1.SymmetricKey(snapshotKey).encrypt(snapshotPreimage);\n        // Build the final snapshot: [ snapshotKey (32 bytes) + encryptedPayload ]\n        const snapshotWriter = new sdk_1.Utils.Writer();\n        snapshotWriter.write(snapshotKey);\n        snapshotWriter.write(encryptedPayload);\n        return snapshotWriter.toArray();\n    }\n    /**\n     * Loads a previously saved state snapshot (produced by `saveSnapshot`).\n     * This will restore the primary key but will **not** restore the privileged key manager\n     * (that must be provided separately to complete authentication).\n     *\n     * @param snapshot A byte array that was previously returned by `saveSnapshot`.\n     * @throws {Error} If the snapshot format is invalid or decryption fails.\n     */\n    async loadSnapshot(snapshot) {\n        try {\n            const reader = new sdk_1.Utils.Reader(snapshot);\n            // First 32 bytes is the snapshotKey:\n            const snapshotKey = reader.read(32);\n            // The rest is the encrypted payload:\n            const encryptedPayload = reader.read();\n            // Decrypt the payload with the snapshotKey:\n            const decrypted = new sdk_1.SymmetricKey(snapshotKey).decrypt(encryptedPayload);\n            const payloadReader = new sdk_1.Utils.Reader(decrypted);\n            // Check version:\n            const version = payloadReader.readUInt8();\n            if (version !== 1) {\n                throw new Error(`Unsupported snapshot version: ${version}`);\n            }\n            // Read the varint length and the primary key:\n            const pkLength = payloadReader.readVarIntNum();\n            const pk = payloadReader.read(pkLength);\n            this.primaryKey = pk;\n            // Attempt to build the underlying wallet if the privileged manager is already provided:\n            await this.tryBuildUnderlying();\n        }\n        catch (error) {\n            throw new Error(`Failed to load snapshot: ${error.message}`);\n        }\n    }\n    /**\n     * Returns whether the user is currently authenticated (the wallet has a primary key\n     * and a privileged key manager). If not authenticated, an error is thrown.\n     *\n     * @param _ Not used in this manager.\n     * @param originator The originator domain, which must not be the admin originator.\n     * @throws If not authenticated, or if the originator is the admin.\n     */\n    async isAuthenticated(_, originator) {\n        this.ensureCanCall(originator);\n        return { authenticated: true };\n    }\n    /**\n     * Blocks until the user is authenticated (by providing primaryKey and privileged manager).\n     * If not authenticated yet, it waits until that occurs.\n     *\n     * @param _ Not used in this manager.\n     * @param originator The originator domain, which must not be the admin originator.\n     * @throws If the originator is the admin.\n     */\n    async waitForAuthentication(_, originator) {\n        if (originator === this.adminOriginator) {\n            throw new Error('External applications cannot use the admin originator.');\n        }\n        while (!this.authenticated) {\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n        return { authenticated: true };\n    }\n    async getPublicKey(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.getPublicKey(args, originator);\n    }\n    async revealCounterpartyKeyLinkage(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.revealCounterpartyKeyLinkage(args, originator);\n    }\n    async revealSpecificKeyLinkage(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.revealSpecificKeyLinkage(args, originator);\n    }\n    async encrypt(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.encrypt(args, originator);\n    }\n    async decrypt(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.decrypt(args, originator);\n    }\n    async createHmac(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.createHmac(args, originator);\n    }\n    async verifyHmac(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.verifyHmac(args, originator);\n    }\n    async createSignature(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.createSignature(args, originator);\n    }\n    async verifySignature(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.verifySignature(args, originator);\n    }\n    async createAction(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.createAction(args, originator);\n    }\n    async signAction(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.signAction(args, originator);\n    }\n    async abortAction(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.abortAction(args, originator);\n    }\n    async listActions(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.listActions(args, originator);\n    }\n    async internalizeAction(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.internalizeAction(args, originator);\n    }\n    async listOutputs(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.listOutputs(args, originator);\n    }\n    async relinquishOutput(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.relinquishOutput(args, originator);\n    }\n    async acquireCertificate(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.acquireCertificate(args, originator);\n    }\n    async listCertificates(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.listCertificates(args, originator);\n    }\n    async proveCertificate(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.proveCertificate(args, originator);\n    }\n    async relinquishCertificate(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.relinquishCertificate(args, originator);\n    }\n    async discoverByIdentityKey(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.discoverByIdentityKey(args, originator);\n    }\n    async discoverByAttributes(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.discoverByAttributes(args, originator);\n    }\n    async getHeight(_, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.getHeight({}, originator);\n    }\n    async getHeaderForHeight(args, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.getHeaderForHeight(args, originator);\n    }\n    async getNetwork(_, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.getNetwork({}, originator);\n    }\n    async getVersion(_, originator) {\n        this.ensureCanCall(originator);\n        return this.underlying.getVersion({}, originator);\n    }\n    /**\n     * A small helper that throws if the user is not authenticated or if the\n     * provided originator is the admin (which is not permitted externally).\n     */\n    ensureCanCall(originator) {\n        if (originator === this.adminOriginator) {\n            throw new Error('External applications cannot use the admin originator.');\n        }\n        if (!this.authenticated) {\n            throw new Error('User is not authenticated.');\n        }\n    }\n}\nexports.SimpleWalletManager = SimpleWalletManager;\n//# sourceMappingURL=SimpleWalletManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/SimpleWalletManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/Wallet.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/Wallet.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Wallet = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst sdk = __importStar(__webpack_require__(/*! ./sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nconst acquireDirectCertificate_1 = __webpack_require__(/*! ./signer/methods/acquireDirectCertificate */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/acquireDirectCertificate.js\");\nconst proveCertificate_1 = __webpack_require__(/*! ./signer/methods/proveCertificate */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/proveCertificate.js\");\nconst createAction_1 = __webpack_require__(/*! ./signer/methods/createAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js\");\nconst signAction_1 = __webpack_require__(/*! ./signer/methods/signAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/signAction.js\");\nconst internalizeAction_1 = __webpack_require__(/*! ./signer/methods/internalizeAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/internalizeAction.js\");\nconst WalletSettingsManager_1 = __webpack_require__(/*! ./WalletSettingsManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletSettingsManager.js\");\nconst identityUtils_1 = __webpack_require__(/*! ./utility/identityUtils */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/identityUtils.js\");\nconst generateChange_1 = __webpack_require__(/*! ./storage/methods/generateChange */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/generateChange.js\");\nconst sdk_2 = __webpack_require__(/*! ./sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\nconst utilityHelpers_1 = __webpack_require__(/*! ./utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst ScriptTemplateBRC29_1 = __webpack_require__(/*! ./utility/ScriptTemplateBRC29 */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/ScriptTemplateBRC29.js\");\nfunction isWalletSigner(args) {\n    return args['isWalletSigner'];\n}\nclass Wallet {\n    constructor(argsOrSigner, services, monitor, privilegedKeyManager) {\n        /**\n         * If true, signableTransactions will include sourceTransaction for each input,\n         * including those that do not require signature and those that were also contained\n         * in the inputBEEF.\n         */\n        this.includeAllSourceTransactions = true;\n        /**\n         * If true, txids that are known to the wallet's party beef do not need to be returned from storage.\n         */\n        this.autoKnownTxids = false;\n        /**\n         * If true, beefs returned to the user may contain txidOnly transactions.\n         */\n        this.returnTxidOnly = false;\n        /**\n         * For repeatability testing, set to an array of random numbers from [0..1).\n         */\n        this.randomVals = undefined;\n        const args = !isWalletSigner(argsOrSigner)\n            ? argsOrSigner\n            : {\n                chain: argsOrSigner.chain,\n                keyDeriver: argsOrSigner.keyDeriver,\n                storage: argsOrSigner.storage,\n                services,\n                monitor,\n                privilegedKeyManager\n            };\n        if (args.storage._authId.identityKey != args.keyDeriver.identityKey)\n            throw new sdk.WERR_INVALID_PARAMETER('storage', `authenticated as the same identityKey (${args.storage._authId.identityKey}) as the keyDeriver (${args.keyDeriver.identityKey}).`);\n        this.settingsManager = args.settingsManager || new WalletSettingsManager_1.WalletSettingsManager(this);\n        this.chain = args.chain;\n        this.lookupResolver =\n            args.lookupResolver ||\n                new sdk_1.LookupResolver({\n                    networkPreset: (0, utilityHelpers_1.toWalletNetwork)(this.chain)\n                });\n        this.keyDeriver = args.keyDeriver;\n        this.storage = args.storage;\n        this.proto = new sdk_1.ProtoWallet(args.keyDeriver);\n        this.services = args.services;\n        this.monitor = args.monitor;\n        this.privilegedKeyManager = args.privilegedKeyManager;\n        this.identityKey = this.keyDeriver.identityKey;\n        this.pendingSignActions = {};\n        this.userParty = `user ${this.getClientChangeKeyPair().publicKey}`;\n        this.beef = new sdk_1.BeefParty([this.userParty]);\n        this.trustSelf = 'known';\n        if (this.services) {\n            this.storage.setServices(this.services);\n        }\n    }\n    async destroy() {\n        await this.storage.destroy();\n        if (this.privilegedKeyManager)\n            await this.privilegedKeyManager.destroyKey();\n    }\n    getClientChangeKeyPair() {\n        const kp = {\n            privateKey: this.keyDeriver.rootKey.toString(),\n            publicKey: this.keyDeriver.rootKey.toPublicKey().toString()\n        };\n        return kp;\n    }\n    async getIdentityKey() {\n        return (await this.getPublicKey({ identityKey: true })).publicKey;\n    }\n    getPublicKey(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.getPublicKey(args);\n        }\n        return this.proto.getPublicKey(args);\n    }\n    revealCounterpartyKeyLinkage(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.revealCounterpartyKeyLinkage(args);\n        }\n        return this.proto.revealCounterpartyKeyLinkage(args);\n    }\n    revealSpecificKeyLinkage(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.revealSpecificKeyLinkage(args);\n        }\n        return this.proto.revealSpecificKeyLinkage(args);\n    }\n    encrypt(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.encrypt(args);\n        }\n        return this.proto.encrypt(args);\n    }\n    decrypt(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.decrypt(args);\n        }\n        return this.proto.decrypt(args);\n    }\n    createHmac(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.createHmac(args);\n        }\n        return this.proto.createHmac(args);\n    }\n    verifyHmac(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.verifyHmac(args);\n        }\n        return this.proto.verifyHmac(args);\n    }\n    createSignature(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.createSignature(args);\n        }\n        return this.proto.createSignature(args);\n    }\n    verifySignature(args, originator) {\n        if (args.privileged) {\n            if (!this.privilegedKeyManager) {\n                throw new Error('Privileged operations require the Wallet to be configured with a privileged key manager.');\n            }\n            return this.privilegedKeyManager.verifySignature(args);\n        }\n        return this.proto.verifySignature(args);\n    }\n    getServices() {\n        if (!this.services)\n            throw new sdk.WERR_INVALID_PARAMETER('services', 'valid in constructor arguments to be retreived here.');\n        return this.services;\n    }\n    /**\n     * @returns the full list of txids whose validity this wallet claims to know.\n     *\n     * @param newKnownTxids Optional. Additional new txids known to be valid by the caller to be merged.\n     */\n    getKnownTxids(newKnownTxids) {\n        if (newKnownTxids) {\n            for (const txid of newKnownTxids)\n                this.beef.mergeTxidOnly(txid);\n        }\n        const r = this.beef.sortTxs();\n        const knownTxids = r.valid;\n        return knownTxids;\n    }\n    getStorageIdentity() {\n        const s = this.storage.getSettings();\n        return {\n            storageIdentityKey: s.storageIdentityKey,\n            storageName: s.storageName\n        };\n    }\n    validateAuthAndArgs(args, validate) {\n        const vargs = validate(args);\n        const auth = { identityKey: this.identityKey };\n        return { vargs, auth };\n    }\n    //////////////////\n    // List Methods\n    //////////////////\n    async listActions(args, originator) {\n        sdk.validateOriginator(originator);\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateListActionsArgs);\n        const r = await this.storage.listActions(vargs);\n        return r;\n    }\n    get storageParty() {\n        return `storage ${this.getStorageIdentity().storageIdentityKey}`;\n    }\n    async listOutputs(args, originator) {\n        sdk.validateOriginator(originator);\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateListOutputsArgs);\n        if (this.autoKnownTxids && !vargs.knownTxids) {\n            vargs.knownTxids = this.getKnownTxids();\n        }\n        const r = await this.storage.listOutputs(vargs);\n        if (r.BEEF) {\n            this.beef.mergeBeefFromParty(this.storageParty, r.BEEF);\n            r.BEEF = this.verifyReturnedTxidOnlyBEEF(r.BEEF);\n        }\n        return r;\n    }\n    async listCertificates(args, originator) {\n        sdk.validateOriginator(originator);\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateListCertificatesArgs);\n        const r = await this.storage.listCertificates(vargs);\n        return r;\n    }\n    //////////////////\n    // Certificates\n    //////////////////\n    async acquireCertificate(args, originator) {\n        sdk.validateOriginator(originator);\n        if (args.acquisitionProtocol === 'direct') {\n            const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateAcquireDirectCertificateArgs);\n            vargs.subject = (await this.getPublicKey({\n                identityKey: true,\n                privileged: args.privileged,\n                privilegedReason: args.privilegedReason\n            })).publicKey;\n            try {\n                // Confirm that the information received adds up to a usable certificate...\n                // TODO: Clean up MasterCertificate to support decrypt on instance\n                const cert = new sdk_1.MasterCertificate(vargs.type, vargs.serialNumber, vargs.subject, vargs.certifier, vargs.revocationOutpoint, vargs.fields, vargs.keyringForSubject, vargs.signature);\n                await cert.verify();\n                // Verify certificate details\n                await sdk_1.MasterCertificate.decryptFields(this, vargs.keyringForSubject, vargs.fields, vargs.certifier, vargs.privileged, vargs.privilegedReason);\n            }\n            catch (eu) {\n                const e = sdk.WalletError.fromUnknown(eu);\n                throw new sdk.WERR_INVALID_PARAMETER('args', `valid encrypted and signed certificate and keyring from revealer. ${e.name}: ${e.message}`);\n            }\n            const r = await (0, acquireDirectCertificate_1.acquireDirectCertificate)(this, auth, vargs);\n            return r;\n        }\n        if (args.acquisitionProtocol === 'issuance') {\n            const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateAcquireIssuanceCertificateArgs);\n            // Create a random nonce that the server can verify\n            const clientNonce = await (0, sdk_1.createNonce)(this, vargs.certifier);\n            // TODO: Consider adding support to request certificates from a certifier before acquiring a certificate.\n            const authClient = new sdk_1.AuthFetch(this);\n            // Create a certificate master keyring\n            // The certifier is able to decrypt these fields as they are the counterparty\n            const { certificateFields, masterKeyring } = await sdk_1.MasterCertificate.createCertificateFields(this, vargs.certifier, vargs.fields);\n            // Make a Certificate Signing Request (CSR) to the certifier\n            const response = await authClient.fetch(`${vargs.certifierUrl}/signCertificate`, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    clientNonce,\n                    type: vargs.type,\n                    fields: certificateFields,\n                    masterKeyring\n                })\n            });\n            if (response.headers.get('x-bsv-auth-identity-key') !== vargs.certifier) {\n                throw new Error(`Invalid certifier! Expected: ${vargs.certifier}, Received: ${response.headers.get('x-bsv-auth-identity-key')}`);\n            }\n            const { certificate, serverNonce } = await response.json();\n            // Validate the server response\n            if (!certificate) {\n                throw new Error('No certificate received from certifier!');\n            }\n            if (!serverNonce) {\n                throw new Error('No serverNonce received from certifier!');\n            }\n            const signedCertificate = new sdk_1.Certificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.signature);\n            // Validate server nonce\n            await (0, sdk_1.verifyNonce)(serverNonce, this, vargs.certifier);\n            // Verify the server included our nonce\n            const { valid } = await this.verifyHmac({\n                hmac: sdk_1.Utils.toArray(signedCertificate.serialNumber, 'base64'),\n                data: sdk_1.Utils.toArray(clientNonce + serverNonce, 'base64'),\n                protocolID: [2, 'certificate issuance'],\n                keyID: serverNonce + clientNonce,\n                counterparty: vargs.certifier\n            });\n            if (!valid)\n                throw new Error('Invalid serialNumber');\n            // Validate the certificate received\n            if (signedCertificate.type !== vargs.type) {\n                throw new Error(`Invalid certificate type! Expected: ${vargs.type}, Received: ${signedCertificate.type}`);\n            }\n            if (signedCertificate.subject !== this.identityKey) {\n                throw new Error(`Invalid certificate subject! Expected: ${this.identityKey}, Received: ${signedCertificate.subject}`);\n            }\n            if (signedCertificate.certifier !== vargs.certifier) {\n                throw new Error(`Invalid certifier! Expected: ${vargs.certifier}, Received: ${signedCertificate.certifier}`);\n            }\n            if (!signedCertificate.revocationOutpoint) {\n                throw new Error(`Invalid revocationOutpoint!`);\n            }\n            if (Object.keys(signedCertificate.fields).length !== Object.keys(certificateFields).length) {\n                throw new Error(`Fields mismatch! Objects have different numbers of keys.`);\n            }\n            for (const field of Object.keys(certificateFields)) {\n                if (!(field in signedCertificate.fields)) {\n                    throw new Error(`Missing field: ${field} in certificate.fields`);\n                }\n                if (signedCertificate.fields[field] !== certificateFields[field]) {\n                    throw new Error(`Invalid field! Expected: ${certificateFields[field]}, Received: ${signedCertificate.fields[field]}`);\n                }\n            }\n            await signedCertificate.verify();\n            // Test decryption works\n            await sdk_1.MasterCertificate.decryptFields(this, masterKeyring, certificate.fields, vargs.certifier);\n            // Store the newly issued certificate\n            return await (0, acquireDirectCertificate_1.acquireDirectCertificate)(this, auth, {\n                ...certificate,\n                keyringRevealer: 'certifier',\n                keyringForSubject: masterKeyring,\n                privileged: vargs.privileged\n            });\n        }\n        throw new sdk.WERR_INVALID_PARAMETER('acquisitionProtocol', `valid.${args.acquisitionProtocol} is unrecognized.`);\n    }\n    async relinquishCertificate(args, originator) {\n        sdk.validateOriginator(originator);\n        this.validateAuthAndArgs(args, sdk.validateRelinquishCertificateArgs);\n        const r = await this.storage.relinquishCertificate(args);\n        return { relinquished: true };\n    }\n    async proveCertificate(args, originator) {\n        originator = sdk.validateOriginator(originator);\n        const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateProveCertificateArgs);\n        const r = await (0, proveCertificate_1.proveCertificate)(this, auth, vargs);\n        return r;\n    }\n    async discoverByIdentityKey(args, originator) {\n        sdk.validateOriginator(originator);\n        this.validateAuthAndArgs(args, sdk.validateDiscoverByIdentityKeyArgs);\n        const trustSettings = (await this.settingsManager.get()).trustSettings;\n        const results = await (0, identityUtils_1.queryOverlay)({\n            identityKey: args.identityKey,\n            certifiers: trustSettings.trustedCertifiers.map(certifier => certifier.identityKey)\n        }, this.lookupResolver);\n        if (!results) {\n            return {\n                totalCertificates: 0,\n                certificates: []\n            };\n        }\n        return (0, identityUtils_1.transformVerifiableCertificatesWithTrust)(trustSettings, results);\n    }\n    async discoverByAttributes(args, originator) {\n        sdk.validateOriginator(originator);\n        this.validateAuthAndArgs(args, sdk.validateDiscoverByAttributesArgs);\n        const trustSettings = (await this.settingsManager.get()).trustSettings;\n        const results = await (0, identityUtils_1.queryOverlay)({\n            attributes: args.attributes,\n            certifiers: trustSettings.trustedCertifiers.map(certifier => certifier.identityKey)\n        }, this.lookupResolver);\n        if (!results) {\n            return {\n                totalCertificates: 0,\n                certificates: []\n            };\n        }\n        return (0, identityUtils_1.transformVerifiableCertificatesWithTrust)(trustSettings, results);\n    }\n    verifyReturnedTxidOnly(beef, knownTxids) {\n        if (this.returnTxidOnly)\n            return beef;\n        const onlyTxids = beef.txs.filter(btx => btx.isTxidOnly).map(btx => btx.txid);\n        for (const txid of onlyTxids) {\n            if (knownTxids && knownTxids.indexOf(txid) >= 0)\n                continue;\n            const btx = beef.findTxid(txid);\n            const tx = this.beef.findAtomicTransaction(txid);\n            if (!tx)\n                throw new sdk.WERR_INTERNAL(`unable to merge txid ${txid} into beef`);\n            beef.mergeTransaction(tx);\n        }\n        for (const btx of beef.txs) {\n            if (knownTxids && knownTxids.indexOf(btx.txid) >= 0)\n                continue;\n            if (btx.isTxidOnly)\n                throw new sdk.WERR_INTERNAL(`remaining txidOnly ${btx.txid} is not known`);\n        }\n        return beef;\n    }\n    verifyReturnedTxidOnlyAtomicBEEF(beef, knownTxids) {\n        if (this.returnTxidOnly)\n            return beef;\n        const b = sdk_1.Beef.fromBinary(beef);\n        if (!b.atomicTxid)\n            throw new sdk.WERR_INTERNAL();\n        return this.verifyReturnedTxidOnly(b, knownTxids).toBinaryAtomic(b.atomicTxid);\n    }\n    verifyReturnedTxidOnlyBEEF(beef) {\n        if (this.returnTxidOnly)\n            return beef;\n        const b = sdk_1.Beef.fromBinary(beef);\n        return this.verifyReturnedTxidOnly(b).toBinary();\n    }\n    //////////////////\n    // Actions\n    //////////////////\n    async createAction(args, originator) {\n        var _a;\n        var _b;\n        sdk.validateOriginator(originator);\n        if (!args.options)\n            args.options = {};\n        (_b = args.options).trustSelf || (_b.trustSelf = this.trustSelf);\n        if (this.autoKnownTxids && !args.options.knownTxids) {\n            args.options.knownTxids = this.getKnownTxids(args.options.knownTxids);\n        }\n        const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateCreateActionArgs);\n        if (vargs.labels.indexOf(sdk_2.specOpThrowReviewActions) >= 0)\n            throwDummyReviewActions();\n        vargs.includeAllSourceTransactions = this.includeAllSourceTransactions;\n        if (this.randomVals && this.randomVals.length > 1) {\n            vargs.randomVals = [...this.randomVals];\n        }\n        const r = await (0, createAction_1.createAction)(this, auth, vargs);\n        if (r.tx) {\n            this.beef.mergeBeefFromParty(this.storageParty, r.tx);\n        }\n        if (r.tx)\n            r.tx = this.verifyReturnedTxidOnlyAtomicBEEF(r.tx, (_a = args.options) === null || _a === void 0 ? void 0 : _a.knownTxids);\n        if (!vargs.isDelayed)\n            throwIfAnyUnsuccessfulCreateActions(r);\n        return r;\n    }\n    async signAction(args, originator) {\n        var _a;\n        sdk.validateOriginator(originator);\n        const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateSignActionArgs);\n        // createAction options are merged with undefined signAction options before validation...\n        const r = await (0, signAction_1.signAction)(this, auth, args);\n        if (!vargs.isDelayed)\n            throwIfAnyUnsuccessfulSignActions(r);\n        const prior = this.pendingSignActions[args.reference];\n        if (r.tx)\n            r.tx = this.verifyReturnedTxidOnlyAtomicBEEF(r.tx, (_a = prior.args.options) === null || _a === void 0 ? void 0 : _a.knownTxids);\n        return r;\n    }\n    async internalizeAction(args, originator) {\n        sdk.validateOriginator(originator);\n        const { auth, vargs } = this.validateAuthAndArgs(args, sdk.validateInternalizeActionArgs);\n        if (vargs.labels.indexOf(sdk_2.specOpThrowReviewActions) >= 0)\n            throwDummyReviewActions();\n        const r = await (0, internalizeAction_1.internalizeAction)(this, auth, args);\n        throwIfUnsuccessfulInternalizeAction(r);\n        return r;\n    }\n    async abortAction(args, originator) {\n        sdk.validateOriginator(originator);\n        const { auth } = this.validateAuthAndArgs(args, sdk.validateAbortActionArgs);\n        const r = await this.storage.abortAction(args);\n        return r;\n    }\n    async relinquishOutput(args, originator) {\n        sdk.validateOriginator(originator);\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateRelinquishOutputArgs);\n        const r = await this.storage.relinquishOutput(args);\n        return { relinquished: true };\n    }\n    async isAuthenticated(args, originator) {\n        sdk.validateOriginator(originator);\n        const r = {\n            authenticated: true\n        };\n        return r;\n    }\n    async waitForAuthentication(args, originator) {\n        sdk.validateOriginator(originator);\n        return { authenticated: true };\n    }\n    async getHeight(args, originator) {\n        sdk.validateOriginator(originator);\n        const height = await this.getServices().getHeight();\n        return { height };\n    }\n    async getHeaderForHeight(args, originator) {\n        sdk.validateOriginator(originator);\n        const serializedHeader = await this.getServices().getHeaderForHeight(args.height);\n        return { header: sdk_1.Utils.toHex(serializedHeader) };\n    }\n    async getNetwork(args, originator) {\n        sdk.validateOriginator(originator);\n        return { network: (0, utilityHelpers_1.toWalletNetwork)(this.chain) };\n    }\n    async getVersion(args, originator) {\n        sdk.validateOriginator(originator);\n        return { version: 'wallet-brc100-1.0.0' };\n    }\n    /**\n     * Transfer all possible satoshis held by this wallet to `toWallet`.\n     *\n     * @param toWallet wallet which will receive this wallet's satoshis.\n     */\n    async sweepTo(toWallet) {\n        const derivationPrefix = (0, utilityHelpers_1.randomBytesBase64)(8);\n        const derivationSuffix = (0, utilityHelpers_1.randomBytesBase64)(8);\n        const keyDeriver = this.keyDeriver;\n        const t = new ScriptTemplateBRC29_1.ScriptTemplateBRC29({\n            derivationPrefix,\n            derivationSuffix,\n            keyDeriver\n        });\n        const label = 'sweep';\n        const satoshis = generateChange_1.maxPossibleSatoshis;\n        const car = await this.createAction({\n            outputs: [\n                {\n                    lockingScript: t.lock(keyDeriver.rootKey.toString(), toWallet.identityKey).toHex(),\n                    satoshis,\n                    outputDescription: label,\n                    tags: ['relinquish'],\n                    customInstructions: JSON.stringify({\n                        derivationPrefix,\n                        derivationSuffix,\n                        type: 'BRC29'\n                    })\n                }\n            ],\n            options: {\n                randomizeOutputs: false,\n                acceptDelayedBroadcast: false\n            },\n            labels: [label],\n            description: label\n        });\n        const iar = await toWallet.internalizeAction({\n            tx: car.tx,\n            outputs: [\n                {\n                    outputIndex: 0,\n                    protocol: 'wallet payment',\n                    paymentRemittance: {\n                        derivationPrefix,\n                        derivationSuffix,\n                        senderIdentityKey: this.identityKey\n                    }\n                }\n            ],\n            description: label,\n            labels: [label]\n        });\n    }\n    /**\n     * Uses `listOutputs` to iterate over chunks of up to 1000 outputs to\n     * compute the sum of output satoshis.\n     *\n     * @param {string} basket - Optional. Defaults to 'default', the wallet change basket.\n     * @returns {sdk.WalletBalance} total sum of output satoshis and utxo details (satoshis and outpoints)\n     */\n    async balanceAndUtxos(basket = 'default') {\n        const r = { total: 0, utxos: [] };\n        let offset = 0;\n        for (;;) {\n            const change = await this.listOutputs({\n                basket,\n                limit: 1000,\n                offset\n            });\n            if (change.totalOutputs === 0)\n                break;\n            for (const o of change.outputs) {\n                r.total += o.satoshis;\n                r.utxos.push({ satoshis: o.satoshis, outpoint: o.outpoint });\n            }\n            offset += change.outputs.length;\n        }\n        return r;\n    }\n    /**\n     * Uses `listOutputs` special operation to compute the total value (of satoshis) for\n     * all spendable outputs in the 'default' basket.\n     *\n     * @returns {number} sum of output satoshis\n     */\n    async balance() {\n        const args = {\n            basket: sdk_2.specOpWalletBalance\n        };\n        const r = await this.listOutputs(args);\n        return r.totalOutputs;\n    }\n    /**\n     * Uses `listOutputs` special operation to review the spendability via `Services` of\n     * outputs currently considered spendable. Returns the outputs that fail to verify.\n     *\n     * Ignores the `limit` and `offset` properties.\n     *\n     * @param all Defaults to false. If false, only change outputs ('default' basket) are reviewed. If true, all spendable outputs are reviewed.\n     * @param release Defaults to false. If true, sets outputs that fail to verify to un-spendable (spendable: false)\n     * @param optionalArgs Optional. Additional tags will constrain the outputs processed.\n     * @returns outputs which are/where considered spendable but currently fail to verify as spendable.\n     */\n    async reviewSpendableOutputs(all = false, release = false, optionalArgs) {\n        const args = {\n            ...(optionalArgs || {}),\n            basket: sdk_2.specOpInvalidChange\n        };\n        args.tags || (args.tags = []);\n        if (all)\n            args.tags.push('all');\n        if (release)\n            args.tags.push('release');\n        const r = await this.listOutputs(args);\n        return r;\n    }\n    /**\n     * Uses `listOutputs` special operation to update the 'default' basket's automatic\n     * change generation parameters.\n     *\n     * @param count target number of change UTXOs to maintain.\n     * @param satoshis target value for new change outputs.\n     */\n    async setWalletChangeParams(count, satoshis) {\n        const args = {\n            basket: sdk_2.specOpSetWalletChangeParams,\n            tags: [count.toString(), satoshis.toString()]\n        };\n        await this.listOutputs(args);\n    }\n    /**\n     * Uses `listActions` special operation to return only actions with status 'nosend'.\n     *\n     * @param abort Defaults to false. If true, runs `abortAction` on each 'nosend' action.\n     * @returns {ListActionsResult} start `listActions` result restricted to 'nosend' (or 'failed' if aborted) actions.\n     */\n    async listNoSendActions(args, abort = false) {\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateListActionsArgs);\n        vargs.labels.push(sdk_2.specOpNoSendActions);\n        if (abort)\n            vargs.labels.push('abort');\n        const r = await this.storage.listActions(vargs);\n        return r;\n    }\n    /**\n     * Uses `listActions` special operation to return only actions with status 'failed'.\n     *\n     * @param unfail Defaults to false. If true, queues the action for attempted recovery.\n     * @returns {ListActionsResult} start `listActions` result restricted to 'failed' status actions.\n     */\n    async listFailedActions(args, unfail = false) {\n        const { vargs } = this.validateAuthAndArgs(args, sdk.validateListActionsArgs);\n        vargs.labels.push(sdk_2.specOpFailedActions);\n        if (unfail)\n            vargs.labels.push('unfail');\n        const r = await this.storage.listActions(vargs);\n        return r;\n    }\n}\nexports.Wallet = Wallet;\nfunction throwIfAnyUnsuccessfulCreateActions(r) {\n    const ndrs = r.notDelayedResults;\n    const swrs = r.sendWithResults;\n    if (!ndrs || !swrs || swrs.every(r => r.status === 'unproven'))\n        return;\n    throw new sdk.WERR_REVIEW_ACTIONS(ndrs, swrs, r.txid, r.tx, r.noSendChange);\n}\nfunction throwIfAnyUnsuccessfulSignActions(r) {\n    const ndrs = r.notDelayedResults;\n    const swrs = r.sendWithResults;\n    if (!ndrs || !swrs || swrs.every(r => r.status === 'unproven'))\n        return;\n    throw new sdk.WERR_REVIEW_ACTIONS(ndrs, swrs, r.txid, r.tx);\n}\nfunction throwIfUnsuccessfulInternalizeAction(r) {\n    const ndrs = r.notDelayedResults;\n    const swrs = r.sendWithResults;\n    if (!ndrs || !swrs || swrs.every(r => r.status === 'unproven'))\n        return;\n    throw new sdk.WERR_REVIEW_ACTIONS(ndrs, swrs, r.txid);\n}\n/**\n * Throws a WERR_REVIEW_ACTIONS with a full set of properties to test data formats and propagation.\n */\nfunction throwDummyReviewActions() {\n    const b58Beef = 'gno9MC7VXii1KoCkc2nsVyYJpqzN3dhBzYATETJcys62emMKfpBof4R7GozwYEaSapUtnNvqQ57aaYYjm3U2dv9eUJ1sV46boHkQgppYmAz9YH8FdZduV8aJayPViaKcyPmbDhEw6UW8TM5iFZLXNs7HBnJHUKCeTdNK4FUEL7vAugxAV9WUUZ43BZjJk2SmSeps9TCXjt1Ci9fKWp3d9QSoYvTpxwzyUFHjRKtbUgwq55ZfkBp5bV2Bpz9qSuKywKewW7Hh4S1nCUScwwzpKDozb3zic1V9p2k8rQxoPsRxjUJ8bjhNDdsN8d7KukFuc3n47fXzdWttvnxwsujLJRGnQbgJuknQqx3KLf5kJXHzwjG6TzigZk2t24qeB6d3hbYiaDr2fFkUJBL3tukTHhfNkQYRXuz3kucVDzvejHyqJaF51mXG8BjMN5aQj91ZJXCaPVqkMWCzmvyaqmXMdRiJdSAynhXbQK91xf6RwdNhz1tg5f9B6oJJMhsi9UYSVymmax8VLKD9AKzBCBDcfyD83m3jyS1VgKGZn3SkQmr6bsoWq88L3GsMnnmYUGogvdAYarTqg3pzkjCMxHzmJBMN6ofnUk8c1sRTXQue7BbyUaN5uZu3KW6CmFsEfpuqVvnqFW93TU1jrPP2S8yz8AexAnARPCKE8Yz7RfVaT6RCavwQKL3u5iookwRWEZXW1QWmM37yJWHD87SjVynyg327a1CLwcBxmE2CB48QeNVGyQki4CTQMqw2o8TMhDPJej1g68oniAjBcxBLSCs7KGvK3k7AfrHbCMULX9CTibYhCjdFjbsbBoocqJpxxcvkMo1fEEiAzZuiBVZQDYktDdTVbhKHvYkW25HcYX75NJrpNAhm7AjFeKLzEVxqAQkMfvTufpESNRZF4kQqg2Rg8h2ajcKTd5cpEPwXCrZLHm4EaZEmZVbg3QNfGhn7BJu1bHMtLqPD4y8eJxm2uGrW6saf6qKYmmu64F8A667NbD4yskPRQ1S863VzwGpxxmgLc1Ta3R46jEqsAoRDoZVUaCgBBZG3Yg1CTgi1EVBMXU7qvY4n3h8o2FLCEMWY4KadnV3iD4FbcdCmg4yxBosNAZgbPjhgGjCimjh4YsLd9zymGLmivmz2ZBg5m3xaiXT9NN81X9C1JUujd';\n    const beef = sdk_1.Beef.fromBinary(sdk_1.Utils.fromBase58(b58Beef));\n    const btx = beef.txs.slice(-1)[0];\n    const txid = btx.txid;\n    debugger;\n    throw new sdk.WERR_REVIEW_ACTIONS([\n        {\n            txid, // only care that it is syntactically a txid\n            status: 'doubleSpend',\n            competingTxs: [txid], // a txid in the beef\n            competingBeef: beef.toBinary()\n        }\n    ], [\n        {\n            txid,\n            status: 'failed'\n        }\n    ], txid, beef.toBinaryAtomic(txid), [`${txid}.0`]);\n}\n//# sourceMappingURL=Wallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/Wallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletAuthenticationManager.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletAuthenticationManager.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletAuthenticationManager = void 0;\nconst CWIStyleWalletManager_1 = __webpack_require__(/*! ./CWIStyleWalletManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js\");\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\n/**\n * WalletAuthenticationManager\n *\n * A wallet manager that integrates\n * with a WABClient for user authentication flows (e.g. Twilio phone).\n */\nclass WalletAuthenticationManager extends CWIStyleWalletManager_1.CWIStyleWalletManager {\n    constructor(adminOriginator, walletBuilder, interactor = new CWIStyleWalletManager_1.OverlayUMPTokenInteractor(), recoveryKeySaver, passwordRetriever, wabClient, authMethod, stateSnapshot) {\n        super(adminOriginator, walletBuilder, interactor, recoveryKeySaver, passwordRetriever, \n        // Here, we provide a custom new wallet funder that uses the Secret Server\n        async (presentationKey, wallet, adminOriginator) => {\n            debugger;\n            const { paymentData } = await this.wabClient.requestFaucet(sdk_1.Utils.toHex(presentationKey));\n            if (!paymentData.k || !paymentData.tx) {\n                throw new Error('Invalid');\n            }\n            const tx = sdk_1.Transaction.fromAtomicBEEF(paymentData.tx);\n            console.log(paymentData);\n            const faucetRedeemTXCreationResult = await wallet.createAction({\n                inputBEEF: tx.toBEEF(),\n                inputs: [\n                    {\n                        outpoint: `${paymentData.txid}.0`,\n                        unlockingScriptLength: 108,\n                        inputDescription: 'Fund from faucet'\n                    }\n                ],\n                description: 'Fund wallet',\n                options: {\n                    acceptDelayedBroadcast: false\n                }\n            }, adminOriginator);\n            const faucetRedeemTX = sdk_1.Transaction.fromAtomicBEEF(faucetRedeemTXCreationResult.signableTransaction.tx);\n            const faucetRedemptionPuzzle = new sdk_1.RPuzzle();\n            const randomRedemptionPrivateKey = sdk_1.PrivateKey.fromRandom();\n            const faucetRedeemUnlocker = faucetRedemptionPuzzle.unlock(new sdk_1.BigNumber(paymentData.k, 16), randomRedemptionPrivateKey);\n            const faucetRedeemUnlockingScript = await faucetRedeemUnlocker.sign(faucetRedeemTX, 0);\n            const signActionResult = await wallet.signAction({\n                reference: faucetRedeemTXCreationResult.signableTransaction.reference,\n                spends: {\n                    0: {\n                        unlockingScript: faucetRedeemUnlockingScript.toHex()\n                    }\n                }\n            });\n            console.log('Sign action result:', signActionResult);\n        }, stateSnapshot);\n        this.wabClient = wabClient;\n        this.authMethod = authMethod;\n    }\n    /**\n     * Sets (or switches) the chosen AuthMethodInteractor at runtime,\n     * in case the user changes their mind or picks a new method in the UI.\n     */\n    setAuthMethod(method) {\n        this.authMethod = method;\n    }\n    /**\n     * Initiate the WAB-based flow, e.g. sending an SMS code or starting an ID check,\n     * using the chosen AuthMethodInteractor.\n     */\n    async startAuth(payload) {\n        if (!this.authMethod) {\n            throw new Error('No AuthMethod selected in WalletAuthenticationManager');\n        }\n        this.tempPresentationKey = this.generateTemporaryPresentationKey();\n        // For example, if this.authMethod is Twilio, `payload` might contain { phoneNumber: \"+1...\" }\n        const startRes = await this.wabClient.startAuthMethod(this.authMethod, \n        // The user might not have a presentationKey yet, so we generate one locally to pass to the server.\n        // If its an existing user on the WAB side, the WAB will give us the stored key later.\n        // But we do need some placeholder key for the 'startAuth' call:\n        this.tempPresentationKey, payload);\n        if (!startRes.success) {\n            throw new Error(startRes.message || 'Failed to start WAB auth method');\n        }\n    }\n    /**\n     * Completes the WAB-based flow, retrieving the final presentationKey from WAB if successful.\n     */\n    async completeAuth(payload) {\n        if (!this.authMethod || !this.tempPresentationKey) {\n            throw new Error('No AuthMethod selected in WalletAuthenticationManager or startAuth has yet to be called.');\n        }\n        // Unser the temp presentation key early (for security)\n        const tempKey = this.tempPresentationKey;\n        this.tempPresentationKey = undefined;\n        const result = await this.wabClient.completeAuthMethod(this.authMethod, tempKey, payload);\n        if (!result.success || !result.presentationKey) {\n            throw new Error(result.message || 'Failed to complete WAB auth');\n        }\n        // We now have the final 256-bit key in hex from the WAB\n        const presentationKeyHex = result.presentationKey;\n        const presentationKeyBytes = sdk_1.Utils.toArray(presentationKeyHex, 'hex');\n        // Provide this presentation key to the underlying CWI logic:\n        // This sets 'this.presentationKey' and determines if it's a new or existing user\n        // based on whether a UMP token exists on chain.  We'll do \"presentation-key-and-password\"\n        // for new user flows, for example, or user might choose \"presentation-key-and-recovery-key\" if we wanted.\n        // Either way, WAB has now done its job and we are off to base-layer CWI logic at this point!\n        await this.providePresentationKey(presentationKeyBytes);\n    }\n    generateTemporaryPresentationKey() {\n        // For the 'startAuth' call, we can generate a random 32 bytes  64 hex chars.\n        const randomBytes = (0, sdk_1.Random)(32); // array of length 32\n        return sdk_1.Utils.toHex(randomBytes);\n    }\n}\nexports.WalletAuthenticationManager = WalletAuthenticationManager;\n//# sourceMappingURL=WalletAuthenticationManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletAuthenticationManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletPermissionsManager.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletPermissionsManager.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletPermissionsManager = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst sdk_2 = __webpack_require__(/*! ./sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\n////// TODO: ADD SUPPORT FOR ADMIN COUNTERPARTIES BASED ON WALLET STORAGE\n//////       PROHIBITION OF SPECIAL OPERATIONS IS ALSO CRITICAL.\n////// !!!!!!!! SECURITY-CRITICAL ADDITION  DO NOT USE UNTIL IMPLEMENTED.\nfunction deepEqual(object1, object2) {\n    if (object1 === null || object1 === undefined || object2 === null || object2 === undefined) {\n        return object1 === object2;\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const val1 = object1[key];\n        const val2 = object2[key];\n        const areObjects = isObject(val1) && isObject(val2);\n        if ((areObjects && !deepEqual(val1, val2)) || (!areObjects && val1 !== val2)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isObject(object) {\n    return object != null && typeof object === 'object';\n}\n/**\n * A map from each permission type to a special \"admin basket\" name used for storing\n * the tokens. The tokens themselves are unspent transaction outputs (UTXOs) with a\n * specialized PushDrop script that references the originator, expiry, etc.\n */\nconst BASKET_MAP = {\n    protocol: 'admin protocol-permission',\n    basket: 'admin basket-access',\n    certificate: 'admin certificate-access',\n    spending: 'admin spending-authorization'\n};\n/**\n * @class WalletPermissionsManager\n *\n * Wraps an underlying BRC-100 `Wallet` implementation with permissions management capabilities.\n * The manager intercepts calls from external applications (identified by originators), checks if the request is allowed,\n * and if not, orchestrates user permission flows. It creates or renews on-chain tokens in special\n * admin baskets to track these authorizations. Finally, it proxies the actual call to the underlying wallet.\n *\n * ### Key Responsibilities:\n *  - **Permission Checking**: Before standard wallet operations (e.g. `encrypt`),\n *    the manager checks if a valid permission token exists. If not, it attempts to request permission from the user.\n *  - **On-Chain Tokens**: When permission is granted, the manager stores it as an unspent \"PushDrop\" output.\n *    This can be spent later to revoke or renew the permission.\n *  - **Callbacks**: The manager triggers user-defined callbacks on permission requests (to show a UI prompt),\n *    on grants/denials, and on internal processes.\n *\n * ### Implementation Notes:\n *  - The manager follows the BRC-100 `createAction` + `signAction` pattern for building or spending these tokens.\n *  - Token revocation or renewal uses standard BRC-100 flows: we build a transaction that consumes\n *    the old token UTXO and outputs a new one (or none, if fully revoked).\n */\nclass WalletPermissionsManager {\n    /**\n     * Constructs a new Permissions Manager instance.\n     *\n     * @param underlyingWallet           The underlying BRC-100 wallet, where requests are forwarded after permission is granted\n     * @param adminOriginator            The domain or FQDN that is automatically allowed everything\n     * @param config                     A set of boolean flags controlling how strictly permissions are enforced\n     */\n    constructor(underlyingWallet, adminOriginator, config = {}) {\n        /**\n         * Event callbacks that external code can subscribe to, e.g. to show a UI prompt\n         * or log events. Each event can have multiple handlers.\n         */\n        this.callbacks = {\n            onProtocolPermissionRequested: [],\n            onBasketAccessRequested: [],\n            onCertificateAccessRequested: [],\n            onSpendingAuthorizationRequested: [],\n            onGroupedPermissionRequested: []\n        };\n        /**\n         * We queue parallel requests for the same resource so that only one\n         * user prompt is created for a single resource. If multiple calls come\n         * in at once for the same \"protocol:domain:privileged:counterparty\" etc.,\n         * they get merged.\n         *\n         * The key is a string derived from the operation; the value is an object with a reference to the\n         * associated request and an array of pending promise resolve/reject pairs, one for each active\n         * operation that's waiting on the particular resource described by the key.\n         */\n        this.activeRequests = new Map();\n        /** Cache recently confirmed permissions to avoid repeated lookups. */\n        this.permissionCache = new Map();\n        this.underlying = underlyingWallet;\n        this.adminOriginator = adminOriginator;\n        // Default all config options to true unless specified\n        this.config = {\n            seekProtocolPermissionsForSigning: true,\n            seekProtocolPermissionsForEncrypting: true,\n            seekProtocolPermissionsForHMAC: true,\n            seekPermissionsForKeyLinkageRevelation: true,\n            seekPermissionsForPublicKeyRevelation: true,\n            seekPermissionsForIdentityKeyRevelation: true,\n            seekPermissionsForIdentityResolution: true,\n            seekBasketInsertionPermissions: true,\n            seekBasketRemovalPermissions: true,\n            seekBasketListingPermissions: true,\n            seekPermissionWhenApplyingActionLabels: true,\n            seekPermissionWhenListingActionsByLabel: true,\n            seekCertificateDisclosurePermissions: true,\n            seekCertificateAcquisitionPermissions: true,\n            seekCertificateRelinquishmentPermissions: true,\n            seekCertificateListingPermissions: true,\n            encryptWalletMetadata: true,\n            seekSpendingPermissions: true,\n            seekGroupedPermission: true,\n            differentiatePrivilegedOperations: true,\n            ...config // override with user-specified config\n        };\n    }\n    /* ---------------------------------------------------------------------\n     *  1) PUBLIC API FOR REGISTERING CALLBACKS (UI PROMPTS, LOGGING, ETC.)\n     * --------------------------------------------------------------------- */\n    /**\n     * Binds a callback function to a named event, such as `onProtocolPermissionRequested`.\n     *\n     * @param eventName The name of the event to listen to\n     * @param handler   A function that handles the event\n     * @returns         A numeric ID you can use to unbind later\n     */\n    bindCallback(eventName, handler) {\n        const arr = this.callbacks[eventName];\n        arr.push(handler);\n        return arr.length - 1;\n    }\n    /**\n     * Unbinds a previously registered callback by either its numeric ID (returned by `bindCallback`)\n     * or by exact function reference.\n     *\n     * @param eventName  The event name, e.g. \"onProtocolPermissionRequested\"\n     * @param reference  Either the numeric ID or the function reference\n     * @returns          True if successfully unbound, false otherwise\n     */\n    unbindCallback(eventName, reference) {\n        if (!this.callbacks[eventName])\n            return false;\n        const arr = this.callbacks[eventName];\n        if (typeof reference === 'number') {\n            if (arr[reference]) {\n                arr[reference] = null;\n                return true;\n            }\n            return false;\n        }\n        else {\n            const index = arr.indexOf(reference);\n            if (index !== -1) {\n                arr[index] = null;\n                return true;\n            }\n            return false;\n        }\n    }\n    /**\n     * Internally triggers a named event, calling all subscribed listeners.\n     * Each callback is awaited in turn (though errors are swallowed so that\n     * one failing callback doesn't prevent the others).\n     *\n     * @param eventName The event name\n     * @param param     The parameter object passed to all listeners\n     */\n    async callEvent(eventName, param) {\n        const arr = this.callbacks[eventName] || [];\n        for (const cb of arr) {\n            if (typeof cb === 'function') {\n                try {\n                    await cb(param);\n                }\n                catch (e) {\n                    // Intentionally swallow errors from user-provided callbacks\n                }\n            }\n        }\n    }\n    /* ---------------------------------------------------------------------\n     *  2) PERMISSION (GRANT / DENY) METHODS\n     * --------------------------------------------------------------------- */\n    /**\n     * Grants a previously requested permission.\n     * This method:\n     *  1) Resolves all pending promise calls waiting on this request\n     *  2) Optionally creates or renews an on-chain PushDrop token (unless `ephemeral===true`)\n     *\n     * @param params      requestID to identify which request is granted, plus optional expiry\n     *                    or `ephemeral` usage, etc.\n     */\n    async grantPermission(params) {\n        // 1) Identify the matching queued requests in `activeRequests`\n        const matching = this.activeRequests.get(params.requestID);\n        if (!matching) {\n            throw new Error('Request ID not found.');\n        }\n        // 2) Mark all matching requests as resolved, deleting the entry\n        for (const x of matching.pending) {\n            x.resolve(true);\n        }\n        this.activeRequests.delete(params.requestID);\n        // 3) If `ephemeral !== true`, we create or renew an on-chain token\n        if (!params.ephemeral) {\n            const request = matching.request;\n            if (!request.renewal) {\n                // brand-new permission token\n                await this.createPermissionOnChain(request, params.expiry || Math.floor(Date.now() / 1000) + 3600 * 24 * 30, // default 30-day expiry\n                params.amount);\n            }\n            else {\n                // renewal => spend the old token, produce a new one\n                await this.renewPermissionOnChain(request.previousToken, request, params.expiry || Math.floor(Date.now() / 1000) + 3600 * 24 * 30, params.amount);\n            }\n        }\n        // Only cache non-ephemeral permissions\n        // Ephemeral permissions should not be cached as they are one-time authorizations\n        if (!params.ephemeral) {\n            const expiry = params.expiry || Math.floor(Date.now() / 1000) + 3600 * 24 * 30;\n            const key = this.buildRequestKey(matching.request);\n            this.cachePermission(key, expiry);\n        }\n    }\n    /**\n     * Denies a previously requested permission.\n     * This method rejects all pending promise calls waiting on that request\n     *\n     * @param requestID    requestID identifying which request to deny\n     */\n    async denyPermission(requestID) {\n        // 1) Identify the matching requests\n        const matching = this.activeRequests.get(requestID);\n        if (!matching) {\n            throw new Error('Request ID not found.');\n        }\n        // 2) Reject all matching requests, deleting the entry\n        for (const x of matching.pending) {\n            x.reject(new Error('Permission denied.'));\n        }\n        this.activeRequests.delete(requestID);\n    }\n    /**\n     * Grants a previously requested grouped permission.\n     * @param params.requestID The ID of the request being granted.\n     * @param params.granted A subset of the originally requested permissions that the user has granted.\n     * @param params.expiry An optional expiry time (in seconds) for the new permission tokens.\n     */\n    async grantGroupedPermission(params) {\n        var _a, _b, _c;\n        const matching = this.activeRequests.get(params.requestID);\n        if (!matching) {\n            throw new Error('Request ID not found.');\n        }\n        const originalRequest = matching.request;\n        const { originator, permissions: requestedPermissions } = originalRequest;\n        // --- Validation: Ensure granted permissions are a subset of what was requested ---\n        if (params.granted.spendingAuthorization &&\n            !deepEqual(params.granted.spendingAuthorization, requestedPermissions.spendingAuthorization)) {\n            throw new Error('Granted spending authorization does not match the original request.');\n        }\n        if ((_a = params.granted.protocolPermissions) === null || _a === void 0 ? void 0 : _a.some(g => { var _a; return !((_a = requestedPermissions.protocolPermissions) === null || _a === void 0 ? void 0 : _a.find(r => deepEqual(r, g))); })) {\n            throw new Error('Granted protocol permissions are not a subset of the original request.');\n        }\n        if ((_b = params.granted.basketAccess) === null || _b === void 0 ? void 0 : _b.some(g => { var _a; return !((_a = requestedPermissions.basketAccess) === null || _a === void 0 ? void 0 : _a.find(r => deepEqual(r, g))); })) {\n            throw new Error('Granted basket access permissions are not a subset of the original request.');\n        }\n        if ((_c = params.granted.certificateAccess) === null || _c === void 0 ? void 0 : _c.some(g => { var _a; return !((_a = requestedPermissions.certificateAccess) === null || _a === void 0 ? void 0 : _a.find(r => deepEqual(r, g))); })) {\n            throw new Error('Granted certificate access permissions are not a subset of the original request.');\n        }\n        // --- End Validation ---\n        const expiry = params.expiry || Math.floor(Date.now() / 1000) + 3600 * 24 * 30; // 30-day default\n        if (params.granted.spendingAuthorization) {\n            await this.createPermissionOnChain({\n                type: 'spending',\n                originator,\n                spending: { satoshis: params.granted.spendingAuthorization.amount },\n                reason: params.granted.spendingAuthorization.description\n            }, 0, // No expiry for spending tokens\n            params.granted.spendingAuthorization.amount);\n        }\n        for (const p of params.granted.protocolPermissions || []) {\n            await this.createPermissionOnChain({\n                type: 'protocol',\n                originator,\n                privileged: false, // No privileged protocols allowed in groups for added security.\n                protocolID: p.protocolID,\n                counterparty: p.counterparty || 'self',\n                reason: p.description\n            }, expiry);\n        }\n        for (const b of params.granted.basketAccess || []) {\n            await this.createPermissionOnChain({ type: 'basket', originator, basket: b.basket, reason: b.description }, expiry);\n        }\n        for (const c of params.granted.certificateAccess || []) {\n            await this.createPermissionOnChain({\n                type: 'certificate',\n                originator,\n                privileged: false, // No certificates on the privileged identity are allowed as part of groups.\n                certificate: {\n                    verifier: c.verifierPublicKey,\n                    certType: c.type,\n                    fields: c.fields\n                },\n                reason: c.description\n            }, expiry);\n        }\n        // Resolve all pending promises for this request\n        for (const p of matching.pending) {\n            p.resolve(true);\n        }\n        this.activeRequests.delete(params.requestID);\n    }\n    /**\n     * Denies a previously requested grouped permission.\n     * @param requestID The ID of the request being denied.\n     */\n    async denyGroupedPermission(requestID) {\n        const matching = this.activeRequests.get(requestID);\n        if (!matching) {\n            throw new Error('Request ID not found.');\n        }\n        const err = new Error('The user has denied the request for permission.');\n        err.code = 'ERR_PERMISSION_DENIED';\n        for (const p of matching.pending) {\n            p.reject(err);\n        }\n        this.activeRequests.delete(requestID);\n    }\n    /* ---------------------------------------------------------------------\n     *  3) THE \"ENSURE\" METHODS: CHECK IF PERMISSION EXISTS, OTHERWISE PROMPT\n     * --------------------------------------------------------------------- */\n    /**\n     * Ensures the originator has protocol usage permission.\n     * If no valid (unexpired) permission token is found, triggers a permission request flow.\n     */\n    async ensureProtocolPermission({ originator, privileged, protocolID, counterparty, reason, seekPermission = true, usageType }) {\n        // 1) adminOriginator can do anything\n        if (this.isAdminOriginator(originator))\n            return true;\n        // 2) If security level=0, we consider it \"open\" usage\n        const [level, protoName] = protocolID;\n        if (level === 0)\n            return true;\n        // 3) If protocol is admin-reserved, block\n        if (this.isAdminProtocol(protocolID)) {\n            throw new Error(`Protocol ${protoName} is admin-only.`);\n        }\n        // Allow the configured exceptions.\n        if (usageType === 'signing' && !this.config.seekProtocolPermissionsForSigning) {\n            return true;\n        }\n        if (usageType === 'encrypting' && !this.config.seekProtocolPermissionsForEncrypting) {\n            return true;\n        }\n        if (usageType === 'hmac' && !this.config.seekProtocolPermissionsForHMAC) {\n            return true;\n        }\n        if (usageType === 'publicKey' && !this.config.seekPermissionsForPublicKeyRevelation) {\n            return true;\n        }\n        if (usageType === 'identityKey' && !this.config.seekPermissionsForIdentityKeyRevelation) {\n            return true;\n        }\n        if (usageType === 'linkageRevelation' && !this.config.seekPermissionsForKeyLinkageRevelation) {\n            return true;\n        }\n        if (!this.config.differentiatePrivilegedOperations) {\n            privileged = false;\n        }\n        const cacheKey = this.buildRequestKey({\n            type: 'protocol',\n            originator,\n            privileged,\n            protocolID,\n            counterparty\n        });\n        if (this.isPermissionCached(cacheKey)) {\n            return true;\n        }\n        // 4) Attempt to find a valid token in the internal basket\n        const token = await this.findProtocolToken(originator, privileged, protocolID, counterparty, \n        /*includeExpired=*/ true);\n        if (token) {\n            if (!this.isTokenExpired(token.expiry)) {\n                // valid and unexpired\n                this.cachePermission(cacheKey, token.expiry);\n                return true;\n            }\n            else {\n                // has a token but expired => request renewal if allowed\n                if (!seekPermission) {\n                    throw new Error(`Protocol permission expired and no further user consent allowed (seekPermission=false).`);\n                }\n                return await this.requestPermissionFlow({\n                    type: 'protocol',\n                    originator,\n                    privileged,\n                    protocolID,\n                    counterparty,\n                    reason,\n                    renewal: true,\n                    previousToken: token\n                });\n            }\n        }\n        else {\n            // No token found => request a new one if allowed\n            if (!seekPermission) {\n                throw new Error(`No protocol permission token found (seekPermission=false).`);\n            }\n            const granted = await this.requestPermissionFlow({\n                type: 'protocol',\n                originator,\n                privileged,\n                protocolID,\n                counterparty,\n                reason,\n                renewal: false\n            });\n            return granted;\n        }\n    }\n    /**\n     * Ensures the originator has basket usage permission for the specified basket.\n     * If not, triggers a permission request flow.\n     */\n    async ensureBasketAccess({ originator, basket, reason, seekPermission = true, usageType }) {\n        if (this.isAdminOriginator(originator))\n            return true;\n        if (this.isAdminBasket(basket)) {\n            throw new Error(`Basket ${basket} is admin-only.`);\n        }\n        if (usageType === 'insertion' && !this.config.seekBasketInsertionPermissions)\n            return true;\n        if (usageType === 'removal' && !this.config.seekBasketRemovalPermissions)\n            return true;\n        if (usageType === 'listing' && !this.config.seekBasketListingPermissions)\n            return true;\n        const cacheKey = this.buildRequestKey({ type: 'basket', originator, basket });\n        if (this.isPermissionCached(cacheKey)) {\n            return true;\n        }\n        const token = await this.findBasketToken(originator, basket, true);\n        if (token) {\n            if (!this.isTokenExpired(token.expiry)) {\n                this.cachePermission(cacheKey, token.expiry);\n                return true;\n            }\n            else {\n                if (!seekPermission) {\n                    throw new Error(`Basket permission expired (seekPermission=false).`);\n                }\n                return await this.requestPermissionFlow({\n                    type: 'basket',\n                    originator,\n                    basket,\n                    reason,\n                    renewal: true,\n                    previousToken: token\n                });\n            }\n        }\n        else {\n            // none\n            if (!seekPermission) {\n                throw new Error(`No basket permission found, and no user consent allowed (seekPermission=false).`);\n            }\n            const granted = await this.requestPermissionFlow({\n                type: 'basket',\n                originator,\n                basket,\n                reason,\n                renewal: false\n            });\n            return granted;\n        }\n    }\n    /**\n     * Ensures the originator has a valid certificate permission.\n     * This is relevant when revealing certificate fields in DCAP contexts.\n     */\n    async ensureCertificateAccess({ originator, privileged, verifier, certType, fields, reason, seekPermission = true, usageType }) {\n        if (this.isAdminOriginator(originator))\n            return true;\n        if (usageType === 'disclosure' && !this.config.seekCertificateDisclosurePermissions) {\n            return true;\n        }\n        if (!this.config.differentiatePrivilegedOperations) {\n            privileged = false;\n        }\n        const cacheKey = this.buildRequestKey({\n            type: 'certificate',\n            originator,\n            privileged,\n            certificate: { verifier, certType, fields }\n        });\n        if (this.isPermissionCached(cacheKey)) {\n            return true;\n        }\n        const token = await this.findCertificateToken(originator, privileged, verifier, certType, fields, \n        /*includeExpired=*/ true);\n        if (token) {\n            if (!this.isTokenExpired(token.expiry)) {\n                this.cachePermission(cacheKey, token.expiry);\n                return true;\n            }\n            else {\n                if (!seekPermission) {\n                    throw new Error(`Certificate permission expired (seekPermission=false).`);\n                }\n                return await this.requestPermissionFlow({\n                    type: 'certificate',\n                    originator,\n                    privileged,\n                    certificate: { verifier, certType, fields },\n                    reason,\n                    renewal: true,\n                    previousToken: token\n                });\n            }\n        }\n        else {\n            if (!seekPermission) {\n                throw new Error(`No certificate permission found (seekPermission=false).`);\n            }\n            const granted = await this.requestPermissionFlow({\n                type: 'certificate',\n                originator,\n                privileged,\n                certificate: { verifier, certType, fields },\n                reason,\n                renewal: false\n            });\n            return granted;\n        }\n    }\n    /**\n     * Ensures the originator has spending authorization (DSAP) for a certain satoshi amount.\n     * If the existing token limit is insufficient, attempts to renew. If no token, attempts to create one.\n     */\n    async ensureSpendingAuthorization({ originator, satoshis, lineItems, reason, seekPermission = true }) {\n        if (this.isAdminOriginator(originator))\n            return true;\n        if (!this.config.seekSpendingPermissions) {\n            // We skip spending permission entirely\n            return true;\n        }\n        const cacheKey = this.buildRequestKey({ type: 'spending', originator, spending: { satoshis } });\n        if (this.isPermissionCached(cacheKey)) {\n            return true;\n        }\n        const token = await this.findSpendingToken(originator);\n        if (token === null || token === void 0 ? void 0 : token.authorizedAmount) {\n            // Check how much has been spent so far\n            const spentSoFar = await this.querySpentSince(token);\n            if (spentSoFar + satoshis <= token.authorizedAmount) {\n                this.cachePermission(cacheKey, token.expiry);\n                return true;\n            }\n            else {\n                // Renew if possible\n                if (!seekPermission) {\n                    throw new Error(`Spending authorization insufficient for ${satoshis}, no user consent (seekPermission=false).`);\n                }\n                return await this.requestPermissionFlow({\n                    type: 'spending',\n                    originator,\n                    spending: { satoshis, lineItems },\n                    reason,\n                    renewal: true,\n                    previousToken: token\n                });\n            }\n        }\n        else {\n            // no token\n            if (!seekPermission) {\n                throw new Error(`No spending authorization found, (seekPermission=false).`);\n            }\n            return await this.requestPermissionFlow({\n                type: 'spending',\n                originator,\n                spending: { satoshis, lineItems },\n                reason,\n                renewal: false\n            });\n        }\n    }\n    /**\n     * Ensures the originator has label usage permission.\n     * If no valid (unexpired) permission token is found, triggers a permission request flow.\n     */\n    async ensureLabelAccess({ originator, label, reason, seekPermission = true, usageType }) {\n        // 1) adminOriginator can do anything\n        if (this.isAdminOriginator(originator))\n            return true;\n        // 2) If label is admin-reserved, block\n        if (this.isAdminLabel(label)) {\n            throw new Error(`Label ${label} is admin-only.`);\n        }\n        if (usageType === 'apply' && !this.config.seekPermissionWhenApplyingActionLabels) {\n            return true;\n        }\n        if (usageType === 'list' && !this.config.seekPermissionWhenListingActionsByLabel) {\n            return true;\n        }\n        const cacheKey = this.buildRequestKey({\n            type: 'protocol',\n            originator,\n            privileged: false,\n            protocolID: [1, `action label ${label}`],\n            counterparty: 'self'\n        });\n        if (this.isPermissionCached(cacheKey)) {\n            return true;\n        }\n        // 3) Let ensureProtocolPermission handle the rest.\n        return await this.ensureProtocolPermission({\n            originator,\n            privileged: false,\n            protocolID: [1, `action label ${label}`],\n            counterparty: 'self',\n            reason,\n            seekPermission,\n            usageType: 'generic'\n        });\n    }\n    /**\n     * A central method that triggers the permission request flow.\n     * - It checks if there's already an active request for the same key\n     * - If so, we wait on that existing request rather than creating a duplicative one\n     * - Otherwise we create a new request queue, call the relevant \"onXXXRequested\" event,\n     *   and return a promise that resolves once permission is granted or rejects if denied.\n     */\n    async requestPermissionFlow(r) {\n        const key = this.buildRequestKey(r);\n        // If there's already a queue for the same resource, we piggyback on it\n        const existingQueue = this.activeRequests.get(key);\n        if (existingQueue && existingQueue.pending.length > 0) {\n            return new Promise((resolve, reject) => {\n                existingQueue.pending.push({ resolve, reject });\n            });\n        }\n        // Otherwise, create a new queue with a single entry\n        // Return a promise that resolves or rejects once the user grants/denies\n        return new Promise(async (resolve, reject) => {\n            this.activeRequests.set(key, {\n                request: r,\n                pending: [{ resolve, reject }]\n            });\n            // Fire the relevant onXXXRequested event (which one depends on r.type)\n            switch (r.type) {\n                case 'protocol':\n                    await this.callEvent('onProtocolPermissionRequested', {\n                        ...r,\n                        requestID: key\n                    });\n                    break;\n                case 'basket':\n                    await this.callEvent('onBasketAccessRequested', {\n                        ...r,\n                        requestID: key\n                    });\n                    break;\n                case 'certificate':\n                    await this.callEvent('onCertificateAccessRequested', {\n                        ...r,\n                        requestID: key\n                    });\n                    break;\n                case 'spending':\n                    await this.callEvent('onSpendingAuthorizationRequested', {\n                        ...r,\n                        requestID: key\n                    });\n                    break;\n            }\n        });\n    }\n    /** We always use `keyID=\"1\"` and `counterparty=\"self\"` for these encryption ops. */\n    async encryptPermissionTokenField(plaintext) {\n        const data = typeof plaintext === 'string' ? sdk_1.Utils.toArray(plaintext, 'utf8') : plaintext;\n        const { ciphertext } = await this.underlying.encrypt({\n            plaintext: data,\n            protocolID: WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL,\n            keyID: '1'\n        }, this.adminOriginator);\n        return ciphertext;\n    }\n    async decryptPermissionTokenField(ciphertext) {\n        try {\n            const { plaintext } = await this.underlying.decrypt({\n                ciphertext,\n                protocolID: WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL,\n                keyID: '1'\n            }, this.adminOriginator);\n            return plaintext;\n        }\n        catch (e) {\n            return ciphertext;\n        }\n    }\n    /**\n     * Encrypts wallet metadata if configured to do so, otherwise returns the original plaintext for storage.\n     * @param plaintext The metadata to encrypt if configured to do so\n     * @returns The encrypted metadata, or the original value if encryption was disabled.\n     */\n    async maybeEncryptMetadata(plaintext) {\n        if (!this.config.encryptWalletMetadata) {\n            return plaintext;\n        }\n        const { ciphertext } = await this.underlying.encrypt({\n            plaintext: sdk_1.Utils.toArray(plaintext, 'utf8'),\n            protocolID: WalletPermissionsManager.METADATA_ENCRYPTION_PROTOCOL,\n            keyID: '1'\n        }, this.adminOriginator);\n        return sdk_1.Utils.toBase64(ciphertext);\n    }\n    /**\n     * Attempts to decrypt metadata. if decryption fails, assumes the value is already plaintext and returns it.\n     * @param ciphertext The metadata to attempt decryption for.\n     * @returns The decrypted metadata. If decryption fails, returns the original value instead.\n     */\n    async maybeDecryptMetadata(ciphertext) {\n        try {\n            const { plaintext } = await this.underlying.decrypt({\n                ciphertext: sdk_1.Utils.toArray(ciphertext, 'base64'),\n                protocolID: WalletPermissionsManager.METADATA_ENCRYPTION_PROTOCOL,\n                keyID: '1'\n            }, this.adminOriginator);\n            return sdk_1.Utils.toUTF8(plaintext);\n        }\n        catch (e) {\n            return ciphertext;\n        }\n    }\n    /** Helper to see if a token's expiry is in the past. */\n    isTokenExpired(expiry) {\n        const now = Math.floor(Date.now() / 1000);\n        return expiry > 0 && expiry < now;\n    }\n    /** Looks for a DPACP permission token matching origin/domain, privileged, protocol, cpty. */\n    async findProtocolToken(originator, privileged, protocolID, counterparty, includeExpired) {\n        const [secLevel, protoName] = protocolID;\n        const tags = [\n            `originator ${originator}`,\n            `privileged ${!!privileged}`,\n            `protocolName ${protoName}`,\n            `protocolSecurityLevel ${secLevel}`\n        ];\n        if (secLevel === 2) {\n            tags.push(`counterparty ${counterparty}`);\n        }\n        const result = await this.underlying.listOutputs({\n            basket: BASKET_MAP.protocol,\n            tags,\n            tagQueryMode: 'all',\n            include: 'entire transactions'\n        }, this.adminOriginator);\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!dec || !dec.fields || dec.fields.length < 6)\n                continue;\n            const domainRaw = dec.fields[0];\n            const expiryRaw = dec.fields[1];\n            const privRaw = dec.fields[2];\n            const secLevelRaw = dec.fields[3];\n            const protoNameRaw = dec.fields[4];\n            const counterpartyRaw = dec.fields[5];\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const privDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(privRaw)) === 'true';\n            const secLevelDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(secLevelRaw)), 10);\n            const protoNameDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(protoNameRaw));\n            const cptyDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(counterpartyRaw));\n            if (domainDecoded !== originator ||\n                privDecoded !== !!privileged ||\n                secLevelDecoded !== secLevel ||\n                protoNameDecoded !== protoName ||\n                (secLevelDecoded === 2 && cptyDecoded !== counterparty)) {\n                continue;\n            }\n            if (!includeExpired && this.isTokenExpired(expiryDecoded)) {\n                continue;\n            }\n            return {\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                satoshis: out.satoshis,\n                originator,\n                privileged,\n                protocol: protoName,\n                securityLevel: secLevel,\n                expiry: expiryDecoded,\n                counterparty: cptyDecoded\n            };\n        }\n        return undefined;\n    }\n    /** Looks for a DBAP token matching (originator, basket). */\n    async findBasketToken(originator, basket, includeExpired) {\n        const result = await this.underlying.listOutputs({\n            basket: BASKET_MAP.basket,\n            tags: [`originator ${originator}`, `basket ${basket}`],\n            tagQueryMode: 'all',\n            include: 'entire transactions'\n        }, this.adminOriginator);\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 3)\n                continue;\n            const domainRaw = dec.fields[0];\n            const expiryRaw = dec.fields[1];\n            const basketRaw = dec.fields[2];\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const basketDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(basketRaw));\n            if (domainDecoded !== originator || basketDecoded !== basket)\n                continue;\n            if (!includeExpired && this.isTokenExpired(expiryDecoded))\n                continue;\n            return {\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                satoshis: out.satoshis,\n                originator,\n                basketName: basketDecoded,\n                expiry: expiryDecoded\n            };\n        }\n        return undefined;\n    }\n    /** Looks for a DCAP token matching (origin, privileged, verifier, certType, fields subset). */\n    async findCertificateToken(originator, privileged, verifier, certType, fields, includeExpired) {\n        const result = await this.underlying.listOutputs({\n            basket: BASKET_MAP.certificate,\n            tags: [`originator ${originator}`, `privileged ${!!privileged}`, `type ${certType}`, `verifier ${verifier}`],\n            tagQueryMode: 'all',\n            include: 'entire transactions'\n        }, this.adminOriginator);\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 6)\n                continue;\n            const [domainRaw, expiryRaw, privRaw, typeRaw, fieldsRaw, verifierRaw] = dec.fields;\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const privDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(privRaw)) === 'true';\n            const typeDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(typeRaw));\n            const verifierDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(verifierRaw));\n            const fieldsJson = await this.decryptPermissionTokenField(fieldsRaw);\n            const allFields = JSON.parse(sdk_1.Utils.toUTF8(fieldsJson));\n            if (domainDecoded !== originator ||\n                privDecoded !== !!privileged ||\n                typeDecoded !== certType ||\n                verifierDec !== verifier) {\n                continue;\n            }\n            // Check if 'fields' is a subset of 'allFields'\n            const setAll = new Set(allFields);\n            if (fields.some(f => !setAll.has(f))) {\n                continue;\n            }\n            if (!includeExpired && this.isTokenExpired(expiryDecoded)) {\n                continue;\n            }\n            return {\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                satoshis: out.satoshis,\n                originator,\n                privileged,\n                verifier: verifierDec,\n                certType: typeDecoded,\n                certFields: allFields,\n                expiry: expiryDecoded\n            };\n        }\n        return undefined;\n    }\n    /** Looks for a DSAP token matching origin, returning the first one found. */\n    async findSpendingToken(originator) {\n        const result = await this.underlying.listOutputs({\n            basket: BASKET_MAP.spending,\n            tags: [`originator ${originator}`],\n            tagQueryMode: 'all',\n            include: 'entire transactions'\n        }, this.adminOriginator);\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 2)\n                continue;\n            const domainRaw = dec.fields[0];\n            const amtRaw = dec.fields[1];\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            if (domainDecoded !== originator)\n                continue;\n            const amtDecodedStr = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(amtRaw));\n            const authorizedAmount = parseInt(amtDecodedStr, 10);\n            return {\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                satoshis: out.satoshis,\n                originator,\n                authorizedAmount,\n                expiry: 0 // Not time-limited, monthly authorization\n            };\n        }\n        return undefined;\n    }\n    /**\n     * Returns the current month and year in UTC as a string in the format \"YYYY-MM\".\n     *\n     * @returns {string} The current month and year in UTC.\n     */\n    getCurrentMonthYearUTC() {\n        const now = new Date();\n        const year = now.getUTCFullYear();\n        const month = (now.getUTCMonth() + 1).toString().padStart(2, '0'); // Ensure 2-digit month\n        return `${year}-${month}`;\n    }\n    /**\n     * Returns spending for an originator in the current calendar month.\n     */\n    async querySpentSince(token) {\n        const { actions } = await this.underlying.listActions({\n            labels: [`admin originator ${token.originator}`, `admin month ${this.getCurrentMonthYearUTC()}`],\n            labelQueryMode: 'all'\n        }, this.adminOriginator);\n        return actions.reduce((a, e) => a + e.satoshis, 0);\n    }\n    /* ---------------------------------------------------------------------\n     *  5) CREATE / RENEW / REVOKE PERMISSION TOKENS ON CHAIN\n     * --------------------------------------------------------------------- */\n    /**\n     * Creates a brand-new permission token as a single-output PushDrop script in the relevant admin basket.\n     *\n     * The main difference between each type of token is in the \"fields\" we store in the PushDrop script.\n     *\n     * @param r        The permission request\n     * @param expiry   The expiry epoch time\n     * @param amount   For DSAP, the authorized spending limit\n     */\n    async createPermissionOnChain(r, expiry, amount) {\n        const basketName = BASKET_MAP[r.type];\n        if (!basketName)\n            return;\n        // Build the array of encrypted fields for the PushDrop script\n        const fields = await this.buildPushdropFields(r, expiry, amount);\n        // Construct the script. We do a simple P2PK check. We ask `PushDrop.lock(...)`\n        // to create a script with a single OP_CHECKSIG verifying ownership to redeem.\n        const script = await new sdk_1.PushDrop(this.underlying).lock(fields, WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL, '1', 'self', true, true);\n        // Create tags\n        const tags = this.buildTagsForRequest(r);\n        // Build a transaction with exactly one output, no explicit inputs since the wallet\n        // can internally fund it from its balance.\n        await this.createAction({\n            description: `Grant ${r.type} permission`,\n            outputs: [\n                {\n                    lockingScript: script.toHex(),\n                    satoshis: 1,\n                    outputDescription: `${r.type} permission token`,\n                    basket: basketName,\n                    tags\n                }\n            ],\n            options: {\n                acceptDelayedBroadcast: false\n            }\n        }, this.adminOriginator);\n    }\n    /**\n     * Renews a permission token by spending the old token as input and creating a new token output.\n     * This invalidates the old token and replaces it with a new one.\n     *\n     * @param oldToken The old token to consume\n     * @param r        The permission request being renewed\n     * @param newExpiry The new expiry epoch time\n     * @param newAmount For DSAP, the new authorized amount\n     */\n    async renewPermissionOnChain(oldToken, r, newExpiry, newAmount) {\n        // 1) build new fields\n        const newFields = await this.buildPushdropFields(r, newExpiry, newAmount);\n        // 2) new script\n        const newScript = await new sdk_1.PushDrop(this.underlying).lock(newFields, WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL, '1', 'self', true, true);\n        const tags = this.buildTagsForRequest(r);\n        // 3) For BRC-100, we do a \"createAction\" with a partial input referencing oldToken\n        //    plus a single new output. We'll hydrate the template, then signAction for the wallet to finalize.\n        const oldOutpoint = `${oldToken.txid}.${oldToken.outputIndex}`;\n        const { signableTransaction } = await this.createAction({\n            description: `Renew ${r.type} permission`,\n            inputBEEF: oldToken.tx,\n            inputs: [\n                {\n                    outpoint: oldOutpoint,\n                    unlockingScriptLength: 73, // length of signature\n                    inputDescription: `Consume old ${r.type} token`\n                }\n            ],\n            outputs: [\n                {\n                    lockingScript: newScript.toHex(),\n                    satoshis: 1,\n                    outputDescription: `Renewed ${r.type} permission token`,\n                    basket: BASKET_MAP[r.type],\n                    tags\n                }\n            ],\n            options: {\n                acceptDelayedBroadcast: false\n            }\n        }, this.adminOriginator);\n        const tx = sdk_1.Transaction.fromBEEF(signableTransaction.tx);\n        const unlocker = new sdk_1.PushDrop(this.underlying).unlock(WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL, '1', 'self', 'all', false, 1, sdk_1.LockingScript.fromHex(oldToken.outputScript));\n        const unlockingScript = await unlocker.sign(tx, 0);\n        await this.underlying.signAction({\n            reference: signableTransaction.reference,\n            spends: {\n                0: {\n                    unlockingScript: unlockingScript.toHex()\n                }\n            }\n        });\n    }\n    /**\n     * Builds the encrypted array of fields for a PushDrop permission token\n     * (protocol / basket / certificate / spending).\n     */\n    async buildPushdropFields(r, expiry, amount) {\n        var _a;\n        switch (r.type) {\n            case 'protocol': {\n                const [secLevel, protoName] = r.protocolID;\n                return [\n                    await this.encryptPermissionTokenField(r.originator), // domain\n                    await this.encryptPermissionTokenField(String(expiry)), // expiry\n                    await this.encryptPermissionTokenField(r.privileged === true ? 'true' : 'false'),\n                    await this.encryptPermissionTokenField(String(secLevel)),\n                    await this.encryptPermissionTokenField(protoName),\n                    await this.encryptPermissionTokenField(r.counterparty)\n                ];\n            }\n            case 'basket': {\n                return [\n                    await this.encryptPermissionTokenField(r.originator),\n                    await this.encryptPermissionTokenField(String(expiry)),\n                    await this.encryptPermissionTokenField(r.basket)\n                ];\n            }\n            case 'certificate': {\n                const { certType, fields, verifier } = r.certificate;\n                return [\n                    await this.encryptPermissionTokenField(r.originator),\n                    await this.encryptPermissionTokenField(String(expiry)),\n                    await this.encryptPermissionTokenField(r.privileged ? 'true' : 'false'),\n                    await this.encryptPermissionTokenField(certType),\n                    await this.encryptPermissionTokenField(JSON.stringify(fields)),\n                    await this.encryptPermissionTokenField(verifier)\n                ];\n            }\n            case 'spending': {\n                // DSAP\n                const authAmt = amount !== null && amount !== void 0 ? amount : (((_a = r.spending) === null || _a === void 0 ? void 0 : _a.satoshis) || 0);\n                return [\n                    await this.encryptPermissionTokenField(r.originator),\n                    await this.encryptPermissionTokenField(String(authAmt))\n                ];\n            }\n        }\n    }\n    /**\n     * Helper to build an array of tags for the new output, matching the user request's\n     * origin, basket, privileged, protocol name, etc.\n     */\n    buildTagsForRequest(r) {\n        const tags = [`originator ${r.originator}`];\n        switch (r.type) {\n            case 'protocol': {\n                tags.push(`privileged ${!!r.privileged}`);\n                tags.push(`protocolName ${r.protocolID[1]}`);\n                tags.push(`protocolSecurityLevel ${r.protocolID[0]}`);\n                tags.push(`counterparty ${r.counterparty}`);\n                break;\n            }\n            case 'basket': {\n                tags.push(`basket ${r.basket}`);\n                break;\n            }\n            case 'certificate': {\n                tags.push(`privileged ${!!r.privileged}`);\n                tags.push(`type ${r.certificate.certType}`);\n                tags.push(`verifier ${r.certificate.verifier}`);\n                break;\n            }\n            case 'spending': {\n                // Only 'originator' is strictly required as a tag.\n                break;\n            }\n        }\n        return tags;\n    }\n    /* ---------------------------------------------------------------------\n     *  6) PUBLIC \"LIST/HAS/REVOKE\" METHODS\n     * --------------------------------------------------------------------- */\n    /**\n     * Lists all protocol permission tokens (DPACP) with optional filters.\n     * @param originator Optional originator domain to filter by\n     * @param privileged Optional boolean to filter by privileged status\n     * @param protocolName Optional protocol name to filter by\n     * @param protocolSecurityLevel Optional protocol security level to filter by\n     * @param counterparty Optional counterparty to filter by\n     * @returns Array of permission tokens that match the filter criteria\n     */\n    async listProtocolPermissions({ originator, privileged, protocolName, protocolSecurityLevel, counterparty } = {}) {\n        const basketName = BASKET_MAP.protocol;\n        const tags = [];\n        if (originator) {\n            tags.push(`originator ${originator}`);\n        }\n        if (privileged !== undefined) {\n            tags.push(`privileged ${!!privileged}`);\n        }\n        if (protocolName) {\n            tags.push(`protocolName ${protocolName}`);\n        }\n        if (protocolSecurityLevel !== undefined) {\n            tags.push(`protocolSecurityLevel ${protocolSecurityLevel}`);\n        }\n        if (counterparty) {\n            tags.push(`counterparty ${counterparty}`);\n        }\n        const result = await this.underlying.listOutputs({\n            basket: basketName,\n            tags,\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit: 100\n        }, this.adminOriginator);\n        const tokens = [];\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 6)\n                continue;\n            const [domainRaw, expiryRaw, privRaw, secRaw, protoRaw, cptyRaw] = dec.fields;\n            const domainDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDec = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const privDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(privRaw)) === 'true';\n            const secDec = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(secRaw)), 10);\n            const protoDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(protoRaw));\n            const cptyDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(cptyRaw));\n            tokens.push({\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                satoshis: out.satoshis,\n                originator: domainDec,\n                expiry: expiryDec,\n                privileged: privDec,\n                securityLevel: secDec,\n                protocol: protoDec,\n                counterparty: cptyDec\n            });\n        }\n        return tokens;\n    }\n    /**\n     * Returns true if the originator already holds a valid unexpired protocol permission.\n     * This calls `ensureProtocolPermission` with `seekPermission=false`, so it won't prompt.\n     */\n    async hasProtocolPermission(params) {\n        try {\n            await this.ensureProtocolPermission({\n                ...params,\n                reason: 'hasProtocolPermission',\n                seekPermission: false,\n                usageType: 'generic'\n            });\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Lists basket permission tokens (DBAP) for a given originator or basket (or for all if not specified).\n     * @param params.originator Optional originator to filter by\n     * @param params.basket Optional basket name to filter by\n     * @returns Array of permission tokens that match the filter criteria\n     */\n    async listBasketAccess(params = {}) {\n        const basketName = BASKET_MAP.basket;\n        const tags = [];\n        if (params.originator) {\n            tags.push(`originator ${params.originator}`);\n        }\n        if (params.basket) {\n            tags.push(`basket ${params.basket}`);\n        }\n        const result = await this.underlying.listOutputs({\n            basket: basketName,\n            tags,\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit: 10000\n        }, this.adminOriginator);\n        const tokens = [];\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 3)\n                continue;\n            const [domainRaw, expiryRaw, basketRaw] = dec.fields;\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const basketDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(basketRaw));\n            tokens.push({\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                satoshis: out.satoshis,\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                originator: domainDecoded,\n                basketName: basketDecoded,\n                expiry: expiryDecoded\n            });\n        }\n        return tokens;\n    }\n    /**\n     * Returns `true` if the originator already holds a valid unexpired basket permission for `basket`.\n     */\n    async hasBasketAccess(params) {\n        try {\n            await this.ensureBasketAccess({\n                originator: params.originator,\n                basket: params.basket,\n                seekPermission: false,\n                usageType: 'insertion' // TODO: Consider a generic case for \"has\"\n            });\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Lists spending authorization tokens (DSAP) for a given originator (or all).\n     */\n    async listSpendingAuthorizations(params) {\n        const basketName = BASKET_MAP.spending;\n        const tags = [];\n        if (params.originator) {\n            tags.push(`originator ${params.originator}`);\n        }\n        const result = await this.underlying.listOutputs({\n            basket: basketName,\n            tags,\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit: 10000\n        }, this.adminOriginator);\n        const tokens = [];\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 2)\n                continue;\n            const [domainRaw, amtRaw] = dec.fields;\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const amtDecodedStr = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(amtRaw));\n            const authorizedAmount = parseInt(amtDecodedStr, 10);\n            tokens.push({\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                satoshis: out.satoshis,\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                originator: domainDecoded,\n                authorizedAmount,\n                expiry: 0\n            });\n        }\n        return tokens;\n    }\n    /**\n     * Returns `true` if the originator already holds a valid spending authorization token\n     * with enough available monthly spend. We do not prompt (seekPermission=false).\n     */\n    async hasSpendingAuthorization(params) {\n        try {\n            await this.ensureSpendingAuthorization({\n                originator: params.originator,\n                satoshis: params.satoshis,\n                seekPermission: false\n            });\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Lists certificate permission tokens (DCAP) with optional filters.\n     * @param originator Optional originator domain to filter by\n     * @param privileged Optional boolean to filter by privileged status\n     * @param certType Optional certificate type to filter by\n     * @param verifier Optional verifier to filter by\n     * @returns Array of permission tokens that match the filter criteria\n     */\n    async listCertificateAccess(params = {}) {\n        const basketName = BASKET_MAP.certificate;\n        const tags = [];\n        if (params.originator) {\n            tags.push(`originator ${params.originator}`);\n        }\n        if (params.privileged !== undefined) {\n            tags.push(`privileged ${!!params.privileged}`);\n        }\n        if (params.certType) {\n            tags.push(`type ${params.certType}`);\n        }\n        if (params.verifier) {\n            tags.push(`verifier ${params.verifier}`);\n        }\n        const result = await this.underlying.listOutputs({\n            basket: basketName,\n            tags,\n            tagQueryMode: 'all',\n            include: 'entire transactions',\n            limit: 10000\n        }, this.adminOriginator);\n        const tokens = [];\n        for (const out of result.outputs) {\n            const [txid, outputIndexStr] = out.outpoint.split('.');\n            const tx = sdk_1.Transaction.fromBEEF(result.BEEF, txid);\n            const dec = sdk_1.PushDrop.decode(tx.outputs[Number(outputIndexStr)].lockingScript);\n            if (!(dec === null || dec === void 0 ? void 0 : dec.fields) || dec.fields.length < 6)\n                continue;\n            const [domainRaw, expiryRaw, privRaw, typeRaw, fieldsRaw, verifierRaw] = dec.fields;\n            const domainDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(domainRaw));\n            const expiryDecoded = parseInt(sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(expiryRaw)), 10);\n            const privDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(privRaw)) === 'true';\n            const typeDecoded = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(typeRaw));\n            const verifierDec = sdk_1.Utils.toUTF8(await this.decryptPermissionTokenField(verifierRaw));\n            const fieldsJson = await this.decryptPermissionTokenField(fieldsRaw);\n            const allFields = JSON.parse(sdk_1.Utils.toUTF8(fieldsJson));\n            tokens.push({\n                tx: tx.toBEEF(),\n                txid: out.outpoint.split('.')[0],\n                outputIndex: parseInt(out.outpoint.split('.')[1], 10),\n                satoshis: out.satoshis,\n                outputScript: tx.outputs[Number(outputIndexStr)].lockingScript.toHex(),\n                originator: domainDecoded,\n                privileged: privDecoded,\n                certType: typeDecoded,\n                certFields: allFields,\n                verifier: verifierDec,\n                expiry: expiryDecoded\n            });\n        }\n        return tokens;\n    }\n    /**\n     * Returns `true` if the originator already holds a valid unexpired certificate access\n     * for the given certType/fields. Does not prompt the user.\n     */\n    async hasCertificateAccess(params) {\n        try {\n            await this.ensureCertificateAccess({\n                originator: params.originator,\n                privileged: params.privileged,\n                verifier: params.verifier,\n                certType: params.certType,\n                fields: params.fields,\n                seekPermission: false,\n                usageType: 'disclosure'\n            });\n            return true;\n        }\n        catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Revokes a permission token by spending it with no replacement output.\n     * The manager builds a BRC-100 transaction that consumes the token, effectively invalidating it.\n     */\n    async revokePermission(oldToken) {\n        const oldOutpoint = `${oldToken.txid}.${oldToken.outputIndex}`;\n        const { signableTransaction } = await this.createAction({\n            description: `Revoke permission`,\n            inputBEEF: oldToken.tx,\n            inputs: [\n                {\n                    outpoint: oldOutpoint,\n                    unlockingScriptLength: 73, // length of signature\n                    inputDescription: `Consume old permission token`\n                }\n            ],\n            options: {\n                acceptDelayedBroadcast: false\n            }\n        }, this.adminOriginator);\n        const tx = sdk_1.Transaction.fromBEEF(signableTransaction.tx);\n        const unlocker = new sdk_1.PushDrop(this.underlying).unlock(WalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL, '1', 'self', 'all', false, 1, sdk_1.LockingScript.fromHex(oldToken.outputScript));\n        const unlockingScript = await unlocker.sign(tx, 0);\n        await this.underlying.signAction({\n            reference: signableTransaction.reference,\n            spends: {\n                0: {\n                    unlockingScript: unlockingScript.toHex()\n                }\n            }\n        });\n    }\n    /* ---------------------------------------------------------------------\n     *  7) BRC-100 WALLET INTERFACE FORWARDING WITH PERMISSION CHECKS\n     * --------------------------------------------------------------------- */\n    async createAction(args, originator) {\n        // 1) Ensure basket and label permissions\n        if (args.outputs) {\n            for (const out of args.outputs) {\n                if (out.basket) {\n                    await this.ensureBasketAccess({\n                        originator: originator,\n                        basket: out.basket,\n                        reason: args.description,\n                        usageType: 'insertion'\n                    });\n                }\n            }\n        }\n        if (args.labels) {\n            for (const lbl of args.labels) {\n                await this.ensureLabelAccess({\n                    originator: originator,\n                    label: lbl,\n                    reason: args.description,\n                    usageType: 'apply'\n                });\n            }\n        }\n        /**\n         * 2) Force signAndProcess=false unless the originator is admin and explicitly sets it to true.\n         *    This ensures the underlying wallet returns a signableTransaction, letting us parse the transaction\n         *    to determine net spending and request authorization if needed.\n         */\n        const modifiedOptions = { ...(args.options || {}) };\n        if (modifiedOptions.signAndProcess !== true) {\n            modifiedOptions.signAndProcess = false;\n        }\n        else if (!this.isAdminOriginator(originator)) {\n            throw new Error('Only the admin originator can set signAndProcess=true explicitly.');\n        }\n        // 3) Encrypt transaction metadata, saving originals for use in permissions and line items.\n        const originalDescription = args.description;\n        const originalInputDescriptions = {};\n        const originalOutputDescriptions = {};\n        args.description = await this.maybeEncryptMetadata(args.description);\n        for (let i = 0; i < (args.inputs || []).length; i++) {\n            if (args.inputs[i].inputDescription) {\n                originalInputDescriptions[i] = args.inputs[i].inputDescription;\n                args.inputs[i].inputDescription = await this.maybeEncryptMetadata(args.inputs[i].inputDescription);\n            }\n        }\n        for (let i = 0; i < (args.outputs || []).length; i++) {\n            if (args.outputs[i].outputDescription) {\n                originalOutputDescriptions[i] = args.outputs[i].outputDescription;\n                args.outputs[i].outputDescription = await this.maybeEncryptMetadata(args.outputs[i].outputDescription);\n            }\n            if (args.outputs[i].customInstructions) {\n                args.outputs[i].customInstructions = await this.maybeEncryptMetadata(args.outputs[i].customInstructions);\n            }\n        }\n        /**\n         * 4) Call the underlying wallets createAction. We add two admin labels:\n         *    - \"admin originator <domain>\"\n         *    - \"admin month YYYY-MM\"\n         *    These labels help track the originators monthly spending.\n         */\n        const createResult = await this.underlying.createAction({\n            ...args,\n            options: modifiedOptions,\n            labels: [\n                ...(args.labels || []),\n                `admin originator ${originator}`,\n                `admin month ${this.getCurrentMonthYearUTC()}`\n            ]\n        }, originator);\n        // If there's no signableTransaction, the underlying wallet must have fully finalized it. Return as is.\n        if (!createResult.signableTransaction) {\n            return createResult;\n        }\n        /**\n         * 5) We have a signable transaction. Parse it to determine how much the originator is actually spending.\n         *    We only consider inputs the originator explicitly listed in args.inputs.\n         *    netSpent = (sum of originator-requested outputs) - (sum of matching originator inputs).\n         *    If netSpent > 0, we need spending authorization.\n         */\n        const tx = sdk_1.Transaction.fromAtomicBEEF(createResult.signableTransaction.tx);\n        const reference = createResult.signableTransaction.reference;\n        let netSpent = 0;\n        const lineItems = [];\n        // Sum originator-provided inputs:\n        let totalInputSatoshis = 0;\n        for (const input of tx.inputs) {\n            const outpoint = `${input.sourceTXID}.${input.sourceOutputIndex}`;\n            const matchingIndex = (args.inputs || []).findIndex(i => i.outpoint === outpoint);\n            if (matchingIndex !== -1) {\n                const satoshis = input.sourceTransaction.outputs[input.sourceOutputIndex].satoshis;\n                totalInputSatoshis += satoshis;\n                lineItems.push({\n                    type: 'input',\n                    description: originalInputDescriptions[matchingIndex] || 'No input description provided',\n                    satoshis: satoshis\n                });\n            }\n        }\n        // Sum originator-requested outputs:\n        const totalOutputSatoshis = (args.outputs || []).reduce((acc, out) => acc + out.satoshis, 0);\n        for (const outIndex in args.outputs || []) {\n            const out = args.outputs[outIndex];\n            lineItems.push({\n                type: 'output',\n                satoshis: out.satoshis,\n                description: originalOutputDescriptions[outIndex] || 'No output description provided'\n            });\n        }\n        // Add an entry for the transaction fee:\n        lineItems.push({\n            type: 'fee',\n            satoshis: tx.getFee(),\n            description: 'Network fee'\n        });\n        /**\n         * When it comes to spending authorizations, and the computation of net spend, there are\n         * two types of inputs and two types of outputs:\n         *\n         * There are foreign (originator-requested) ones, and domestic (internally-provided) ones.\n         * The net spend is always calculated from the domestic, internal perspective. Therefore, the\n         * cost of funding the foreign outputs is the base cost to the domestic user, unless this is\n         * somehow offset.\n         *\n         * The only way to offset this cost is when the foreign inputs help carry some of the burden.\n         * This is why we can subtract the sum of the foreign inputs from the sum of foreign outputs,\n         * to gague how much of that cost needs to be born domestically by the user.\n         *\n         * The logic does not need to account for whatever domestic inputs are provided, or whatever\n         * domestic outputs are re-captured by the wallet back as change. The wallet could conceivably\n         * provide 21e8 satoshis as input and re-capture the same amount as change, but the net effect\n         * on actual spending would be zero. Therefore, we base net spend on total foreign outflows\n         * minus total foreign inflows. Fees are also considered.\n         */\n        netSpent = totalOutputSatoshis + tx.getFee() - totalInputSatoshis;\n        // 6) If netSpent > 0, require spending authorization. Abort if denied.\n        if (netSpent > 0) {\n            try {\n                await this.ensureSpendingAuthorization({\n                    originator: originator,\n                    satoshis: netSpent,\n                    lineItems,\n                    reason: originalDescription\n                });\n            }\n            catch (err) {\n                await this.underlying.abortAction({ reference });\n                throw err;\n            }\n        }\n        /**\n         * 7) Decide whether to finalize the transaction automatically or return the signableTransaction:\n         *    - If the user originally wanted signAndProcess (the default when undefined), we forcibly set it to false earlier, so check if we should now finalize it.\n         *    - If the transaction still needs more signatures, we must return the signableTransaction.\n         */\n        const vargs = (0, sdk_2.validateCreateActionArgs)(args);\n        if (vargs.isSignAction) {\n            return createResult;\n        }\n        const signResult = await this.underlying.signAction({ reference, spends: {}, options: args.options }, originator);\n        // Merge signResult into createResult and remove signableTransaction:\n        return {\n            ...createResult,\n            ...signResult,\n            signableTransaction: undefined\n        };\n    }\n    async signAction(...args) {\n        return this.underlying.signAction(...args);\n    }\n    async abortAction(...args) {\n        return this.underlying.abortAction(...args);\n    }\n    async listActions(...args) {\n        const [requestArgs, originator] = args;\n        // for each label, ensure label access\n        if (requestArgs.labels) {\n            for (const lbl of requestArgs.labels) {\n                await this.ensureLabelAccess({\n                    originator: originator,\n                    label: lbl,\n                    reason: 'listActions',\n                    usageType: 'list'\n                });\n            }\n        }\n        const results = await this.underlying.listActions(...args);\n        // Transparently decrypt transaction metadata, if configured to do so.\n        if (results.actions) {\n            for (let i = 0; i < results.actions.length; i++) {\n                if (results.actions[i].description) {\n                    results.actions[i].description = await this.maybeDecryptMetadata(results.actions[i].description);\n                }\n                if (results.actions[i].inputs) {\n                    for (let j = 0; j < results.actions[i].inputs.length; j++) {\n                        if (results.actions[i].inputs[j].inputDescription) {\n                            results.actions[i].inputs[j].inputDescription = await this.maybeDecryptMetadata(results.actions[i].inputs[j].inputDescription);\n                        }\n                    }\n                }\n                if (results.actions[i].outputs) {\n                    for (let j = 0; j < results.actions[i].outputs.length; j++) {\n                        if (results.actions[i].outputs[j].outputDescription) {\n                            results.actions[i].outputs[j].outputDescription = await this.maybeDecryptMetadata(results.actions[i].outputs[j].outputDescription);\n                        }\n                        if (results.actions[i].outputs[j].customInstructions) {\n                            results.actions[i].outputs[j].customInstructions = await this.maybeDecryptMetadata(results.actions[i].outputs[j].customInstructions);\n                        }\n                    }\n                }\n            }\n        }\n        return results;\n    }\n    async internalizeAction(...args) {\n        const [requestArgs, originator] = args;\n        // If the transaction is inserting outputs into baskets, we also ensure basket permission\n        for (const outIndex in requestArgs.outputs) {\n            const out = requestArgs.outputs[outIndex];\n            if (out.protocol === 'basket insertion') {\n                await this.ensureBasketAccess({\n                    originator: originator,\n                    basket: out.insertionRemittance.basket,\n                    reason: requestArgs.description,\n                    usageType: 'insertion'\n                });\n                if (out.insertionRemittance.customInstructions) {\n                    requestArgs.outputs[outIndex].insertionRemittance.customInstructions = await this.maybeEncryptMetadata(out.insertionRemittance.customInstructions);\n                }\n            }\n        }\n        return this.underlying.internalizeAction(...args);\n    }\n    async listOutputs(...args) {\n        const [requestArgs, originator] = args;\n        // Ensure the originator has permission for the basket.\n        await this.ensureBasketAccess({\n            originator: originator,\n            basket: requestArgs.basket,\n            reason: 'listOutputs',\n            usageType: 'listing'\n        });\n        const results = await this.underlying.listOutputs(...args);\n        // Transparently decrypt transaction metadata, if configured to do so.\n        if (results.outputs) {\n            for (let i = 0; i < results.outputs.length; i++) {\n                if (results.outputs[i].customInstructions) {\n                    results.outputs[i].customInstructions = await this.maybeDecryptMetadata(results.outputs[i].customInstructions);\n                }\n            }\n        }\n        return results;\n    }\n    async relinquishOutput(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureBasketAccess({\n            originator: originator,\n            basket: requestArgs.basket,\n            reason: 'relinquishOutput',\n            usageType: 'removal'\n        });\n        return this.underlying.relinquishOutput(...args);\n    }\n    async getPublicKey(...args) {\n        const [requestArgs, originator] = args;\n        if (requestArgs.protocolID) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: requestArgs.privileged,\n                protocolID: requestArgs.protocolID,\n                counterparty: requestArgs.counterparty || 'self',\n                reason: requestArgs.privilegedReason,\n                usageType: 'publicKey'\n            });\n        }\n        if (requestArgs.identityKey) {\n            // We also require a minimal protocol permission to retrieve the user's identity key\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: requestArgs.privileged,\n                protocolID: [1, 'identity key retrieval'],\n                counterparty: 'self',\n                reason: requestArgs.privilegedReason,\n                usageType: 'identityKey'\n            });\n        }\n        return this.underlying.getPublicKey(...args);\n    }\n    async revealCounterpartyKeyLinkage(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: [2, `counterparty key linkage revelation ${requestArgs.counterparty}`],\n            counterparty: requestArgs.verifier,\n            reason: requestArgs.privilegedReason,\n            usageType: 'linkageRevelation'\n        });\n        return this.underlying.revealCounterpartyKeyLinkage(...args);\n    }\n    async revealSpecificKeyLinkage(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: [\n                2,\n                `specific key linkage revelation ${requestArgs.protocolID[1]} ${requestArgs.protocolID[0] === 2 ? requestArgs.keyID : 'all'}`\n            ],\n            counterparty: requestArgs.verifier,\n            reason: requestArgs.privilegedReason,\n            usageType: 'linkageRevelation'\n        });\n        return this.underlying.revealSpecificKeyLinkage(...args);\n    }\n    async encrypt(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            protocolID: requestArgs.protocolID,\n            privileged: requestArgs.privileged,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'encrypting'\n        });\n        return this.underlying.encrypt(...args);\n    }\n    async decrypt(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: requestArgs.protocolID,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'encrypting'\n        });\n        return this.underlying.decrypt(...args);\n    }\n    async createHmac(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: requestArgs.protocolID,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'hmac'\n        });\n        return this.underlying.createHmac(...args);\n    }\n    async verifyHmac(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: requestArgs.protocolID,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'hmac'\n        });\n        return this.underlying.verifyHmac(...args);\n    }\n    async createSignature(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: requestArgs.protocolID,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'signing'\n        });\n        return this.underlying.createSignature(...args);\n    }\n    async verifySignature(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureProtocolPermission({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            protocolID: requestArgs.protocolID,\n            counterparty: requestArgs.counterparty || 'self',\n            reason: requestArgs.privilegedReason,\n            usageType: 'signing'\n        });\n        return this.underlying.verifySignature(...args);\n    }\n    async acquireCertificate(...args) {\n        const [requestArgs, originator] = args;\n        if (this.config.seekCertificateAcquisitionPermissions) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: requestArgs.privileged,\n                protocolID: [1, `certificate acquisition ${requestArgs.type}`],\n                counterparty: 'self',\n                reason: requestArgs.privilegedReason,\n                usageType: 'generic'\n            });\n        }\n        return this.underlying.acquireCertificate(...args);\n    }\n    async listCertificates(...args) {\n        const [requestArgs, originator] = args;\n        if (this.config.seekCertificateListingPermissions) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: requestArgs.privileged,\n                protocolID: [1, `certificate list`],\n                counterparty: 'self',\n                reason: requestArgs.privilegedReason,\n                usageType: 'generic'\n            });\n        }\n        return this.underlying.listCertificates(...args);\n    }\n    async proveCertificate(...args) {\n        const [requestArgs, originator] = args;\n        await this.ensureCertificateAccess({\n            originator: originator,\n            privileged: requestArgs.privileged,\n            verifier: requestArgs.verifier,\n            certType: requestArgs.certificate.type,\n            fields: requestArgs.fieldsToReveal,\n            reason: 'proveCertificate',\n            usageType: 'disclosure'\n        });\n        return this.underlying.proveCertificate(...args);\n    }\n    async relinquishCertificate(...args) {\n        const [requestArgs, originator] = args;\n        if (this.config.seekCertificateRelinquishmentPermissions) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: requestArgs.privileged ? true : false,\n                protocolID: [1, `certificate relinquishment ${requestArgs.type}`],\n                counterparty: 'self',\n                reason: requestArgs.privilegedReason || 'relinquishCertificate',\n                usageType: 'generic'\n            });\n        }\n        return this.underlying.relinquishCertificate(...args);\n    }\n    async discoverByIdentityKey(...args) {\n        const [_, originator] = args;\n        if (this.config.seekPermissionsForIdentityResolution) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: false,\n                protocolID: [1, `identity resolution`],\n                counterparty: 'self',\n                reason: 'discoverByIdentityKey',\n                usageType: 'generic'\n            });\n        }\n        return this.underlying.discoverByIdentityKey(...args);\n    }\n    async discoverByAttributes(...args) {\n        const [_, originator] = args;\n        if (this.config.seekPermissionsForIdentityResolution) {\n            await this.ensureProtocolPermission({\n                originator: originator,\n                privileged: false,\n                protocolID: [1, `identity resolution`],\n                counterparty: 'self',\n                reason: 'discoverByAttributes',\n                usageType: 'generic'\n            });\n        }\n        return this.underlying.discoverByAttributes(...args);\n    }\n    async isAuthenticated(...args) {\n        return this.underlying.isAuthenticated(...args);\n    }\n    async waitForAuthentication(...args) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const [_, originator] = args;\n        if (this.config.seekGroupedPermission && originator) {\n            // 1. Fetch manifest.json from the originator\n            let groupPermissions;\n            try {\n                const proto = originator.startsWith('localhost:') ? 'http' : 'https';\n                const response = await fetch(`${proto}://${originator}/manifest.json`);\n                if (response.ok) {\n                    const manifest = await response.json();\n                    if ((_a = manifest === null || manifest === void 0 ? void 0 : manifest.babbage) === null || _a === void 0 ? void 0 : _a.groupPermissions) {\n                        groupPermissions = manifest.babbage.groupPermissions;\n                    }\n                }\n            }\n            catch (e) {\n                // Ignore fetch/parse errors, just proceed without group permissions.\n            }\n            if (groupPermissions) {\n                // 2. Filter out already-granted permissions\n                const permissionsToRequest = {\n                    protocolPermissions: [],\n                    basketAccess: [],\n                    certificateAccess: []\n                };\n                if (groupPermissions.spendingAuthorization) {\n                    const hasAuth = await this.hasSpendingAuthorization({\n                        originator,\n                        satoshis: groupPermissions.spendingAuthorization.amount\n                    });\n                    if (!hasAuth) {\n                        permissionsToRequest.spendingAuthorization = groupPermissions.spendingAuthorization;\n                    }\n                }\n                for (const p of groupPermissions.protocolPermissions || []) {\n                    const hasPerm = await this.hasProtocolPermission({\n                        originator,\n                        privileged: false, // Privilege is never allowed here\n                        protocolID: p.protocolID,\n                        counterparty: p.counterparty || 'self'\n                    });\n                    if (!hasPerm) {\n                        permissionsToRequest.protocolPermissions.push(p);\n                    }\n                }\n                for (const b of groupPermissions.basketAccess || []) {\n                    const hasAccess = await this.hasBasketAccess({\n                        originator,\n                        basket: b.basket\n                    });\n                    if (!hasAccess) {\n                        permissionsToRequest.basketAccess.push(b);\n                    }\n                }\n                for (const c of groupPermissions.certificateAccess || []) {\n                    const hasAccess = await this.hasCertificateAccess({\n                        originator,\n                        privileged: false, // Privilege is never allowed here for security\n                        verifier: c.verifierPublicKey,\n                        certType: c.type,\n                        fields: c.fields\n                    });\n                    if (!hasAccess) {\n                        permissionsToRequest.certificateAccess.push(c);\n                    }\n                }\n                // 3. If any permissions are left to request, start the flow\n                const hasRequests = permissionsToRequest.spendingAuthorization ||\n                    ((_c = (_b = permissionsToRequest.protocolPermissions) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 0 ||\n                    ((_e = (_d = permissionsToRequest.basketAccess) === null || _d === void 0 ? void 0 : _d.length) !== null && _e !== void 0 ? _e : 0) > 0 ||\n                    ((_g = (_f = permissionsToRequest.certificateAccess) === null || _f === void 0 ? void 0 : _f.length) !== null && _g !== void 0 ? _g : 0) > 0;\n                if (hasRequests) {\n                    const key = `group:${originator}`;\n                    if (this.activeRequests.has(key)) {\n                        // Another call is already waiting, piggyback on it\n                        await new Promise((resolve, reject) => {\n                            this.activeRequests.get(key).pending.push({ resolve, reject });\n                        });\n                    }\n                    else {\n                        // This is the first call, create a new request\n                        try {\n                            await new Promise(async (resolve, reject) => {\n                                this.activeRequests.set(key, {\n                                    request: { originator, permissions: permissionsToRequest },\n                                    pending: [{ resolve, reject }]\n                                });\n                                await this.callEvent('onGroupedPermissionRequested', {\n                                    requestID: key,\n                                    originator,\n                                    permissions: permissionsToRequest\n                                });\n                            });\n                        }\n                        catch (e) {\n                            // Permission was denied, re-throw to stop execution\n                            throw e;\n                        }\n                    }\n                }\n            }\n        }\n        // Finally, after handling grouped permissions, call the underlying method.\n        return this.underlying.waitForAuthentication(...args);\n    }\n    async getHeight(...args) {\n        return this.underlying.getHeight(...args);\n    }\n    async getHeaderForHeight(...args) {\n        return this.underlying.getHeaderForHeight(...args);\n    }\n    async getNetwork(...args) {\n        return this.underlying.getNetwork(...args);\n    }\n    async getVersion(...args) {\n        return this.underlying.getVersion(...args);\n    }\n    /* ---------------------------------------------------------------------\n     *  8) INTERNAL HELPER UTILITIES\n     * --------------------------------------------------------------------- */\n    /** Returns true if the specified origin is the admin originator. */\n    isAdminOriginator(originator) {\n        return originator === this.adminOriginator;\n    }\n    /**\n     * Checks if the given protocol is admin-reserved per BRC-100 rules:\n     *\n     *  - Must not start with `admin` (admin-reserved)\n     *  - Must not start with `p ` (allows for future specially permissioned protocols)\n     *\n     * If it violates these rules and the caller is not admin, we consider it \"admin-only.\"\n     */\n    isAdminProtocol(proto) {\n        const protocolName = proto[1];\n        if (protocolName.startsWith('admin') || protocolName.startsWith('p ')) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Checks if the given label is admin-reserved per BRC-100 rules:\n     *\n     *  - Must not start with `admin` (admin-reserved)\n     *\n     * If it violates these rules and the caller is not admin, we consider it \"admin-only.\"\n     */\n    isAdminLabel(label) {\n        if (label.startsWith('admin')) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Checks if the given basket is admin-reserved per BRC-100 rules:\n     *\n     *  - Must not start with `admin`\n     *  - Must not be `default` (some wallets use this for internal operations)\n     *  - Must not start with `p ` (future specially permissioned baskets)\n     */\n    isAdminBasket(basket) {\n        if (basket === 'default')\n            return true;\n        if (basket.startsWith('admin'))\n            return true;\n        if (basket.startsWith('p '))\n            return true;\n        return false;\n    }\n    /**\n     * Returns true if we have a cached record that the permission identified by\n     * `key` is valid and unexpired.\n     */\n    isPermissionCached(key) {\n        const entry = this.permissionCache.get(key);\n        if (!entry)\n            return false;\n        if (Date.now() - entry.cachedAt > WalletPermissionsManager.CACHE_TTL_MS) {\n            this.permissionCache.delete(key);\n            return false;\n        }\n        if (this.isTokenExpired(entry.expiry)) {\n            this.permissionCache.delete(key);\n            return false;\n        }\n        return true;\n    }\n    /** Caches the fact that the permission for `key` is valid until `expiry`. */\n    cachePermission(key, expiry) {\n        this.permissionCache.set(key, { expiry, cachedAt: Date.now() });\n    }\n    /**\n     * Builds a \"map key\" string so that identical requests (e.g. \"protocol:domain:true:protoName:counterparty\")\n     * do not produce multiple user prompts.\n     */\n    buildRequestKey(r) {\n        var _a, _b, _c, _d, _e;\n        switch (r.type) {\n            case 'protocol':\n                return `proto:${r.originator}:${!!r.privileged}:${(_a = r.protocolID) === null || _a === void 0 ? void 0 : _a.join(',')}:${r.counterparty}`;\n            case 'basket':\n                return `basket:${r.originator}:${r.basket}`;\n            case 'certificate':\n                return `cert:${r.originator}:${!!r.privileged}:${(_b = r.certificate) === null || _b === void 0 ? void 0 : _b.verifier}:${(_c = r.certificate) === null || _c === void 0 ? void 0 : _c.certType}:${(_d = r.certificate) === null || _d === void 0 ? void 0 : _d.fields.join('|')}`;\n            case 'spending':\n                return `spend:${r.originator}:${(_e = r.spending) === null || _e === void 0 ? void 0 : _e.satoshis}`;\n        }\n    }\n}\nexports.WalletPermissionsManager = WalletPermissionsManager;\n/** How long a cached permission remains valid (5 minutes). */\nWalletPermissionsManager.CACHE_TTL_MS = 5 * 60 * 1000;\n/* ---------------------------------------------------------------------\n *  4) SEARCH / DECODE / DECRYPT ON-CHAIN TOKENS (PushDrop Scripts)\n * --------------------------------------------------------------------- */\n/**\n * We will use a administrative \"permission token encryption\" protocol to store fields\n * in each permission's PushDrop script. This ensures that only the user's wallet\n * can decrypt them. In practice, this data is not super sensitive, but we still\n * follow the principle of least exposure.\n */\nWalletPermissionsManager.PERM_TOKEN_ENCRYPTION_PROTOCOL = [\n    2,\n    'admin permission token encryption'\n];\n/**\n * Similarly, we will use a \"metadata encryption\" protocol to preserve the confidentiality\n * of transaction descriptions and input/output descriptions from lower storage layers.\n */\nWalletPermissionsManager.METADATA_ENCRYPTION_PROTOCOL = [\n    2,\n    'admin metadata encryption'\n];\n//# sourceMappingURL=WalletPermissionsManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletPermissionsManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletSettingsManager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletSettingsManager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletSettingsManager = exports.TESTNET_DEFAULT_SETTINGS = exports.DEFAULT_SETTINGS = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst SETTINGS_BASKET = 'wallet settings';\n// Defaults can be overridden as needed\nexports.DEFAULT_SETTINGS = {\n    trustSettings: {\n        trustLevel: 2,\n        trustedCertifiers: [\n            {\n                name: 'Metanet Trust Services',\n                description: 'Registry for protocols, baskets, and certificates types',\n                iconUrl: 'https://bsvblockchain.org/favicon.ico',\n                identityKey: '03daf815fe38f83da0ad83b5bedc520aa488aef5cbc93a93c67a7fe60406cbffe8',\n                trust: 4\n            },\n            {\n                name: 'SocialCert',\n                description: 'Certifies social media handles, phone numbers and emails',\n                iconUrl: 'https://socialcert.net/favicon.ico',\n                trust: 3,\n                identityKey: '02cf6cdf466951d8dfc9e7c9367511d0007ed6fba35ed42d425cc412fd6cfd4a17'\n            }\n        ]\n    },\n    theme: { mode: 'dark' }\n};\n// Mapping of certifier names to their testnet identity keys\nconst TESTNET_IDENTITY_KEYS = {\n    'Babbage Trust Services': '03d0b36b5c98b000ec9ffed9a2cf005e279244edf6a19cf90545cdebe873162761',\n    IdentiCert: '036dc48522aba1705afbb43df3c04dbd1da373b6154341a875bceaa2a3e7f21528',\n    SocialCert: '02cf6cdf466951d8dfc9e7c9367511d0007ed6fba35ed42d425cc412fd6cfd4a17'\n};\n// Define defaults that can be imported for a testnet environment\nexports.TESTNET_DEFAULT_SETTINGS = {\n    ...exports.DEFAULT_SETTINGS,\n    trustSettings: {\n        ...exports.DEFAULT_SETTINGS.trustSettings,\n        trustedCertifiers: exports.DEFAULT_SETTINGS.trustSettings.trustedCertifiers.map(certifier => ({\n            ...certifier,\n            // Use the testnet key if provided, otherwise fallback to the default\n            identityKey: TESTNET_IDENTITY_KEYS[certifier.name] || certifier.identityKey\n        }))\n    }\n};\n/**\n * Manages wallet settings\n */\nclass WalletSettingsManager {\n    constructor(wallet, config = {\n        defaultSettings: exports.DEFAULT_SETTINGS\n    }) {\n        this.wallet = wallet;\n        this.config = config;\n        this.kv = new sdk_1.LocalKVStore(wallet, SETTINGS_BASKET, true);\n    }\n    /**\n     * Returns a user's wallet settings\n     *\n     * @returns - Wallet settings object\n     */\n    async get() {\n        return JSON.parse((await this.kv.get('settings', JSON.stringify(this.config.defaultSettings))));\n    }\n    /**\n     * Creates (or updates) the user's settings token.\n     *\n     * @param settings - The wallet settings to be stored.\n     */\n    async set(settings) {\n        await this.kv.set('settings', JSON.stringify(settings));\n    }\n    /**\n     * Deletes the user's settings token.\n     */\n    async delete() {\n        await this.kv.remove('settings');\n    }\n}\nexports.WalletSettingsManager = WalletSettingsManager;\n//# sourceMappingURL=WalletSettingsManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletSettingsManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sdk = void 0;\nexports.sdk = __importStar(__webpack_require__(/*! ./sdk/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\n__exportStar(__webpack_require__(/*! ./utility/index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SetupClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SetupWallet */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/SetupWallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./signer/WalletSigner */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/WalletSigner.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletPermissionsManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletPermissionsManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./CWIStyleWalletManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletAuthenticationManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletAuthenticationManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/WABClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/WABClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/TwilioPhoneInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/TwilioPhoneInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/PersonaIDInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/PersonaIDInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/AuthMethodInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./services/Services */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sdk/PrivilegedKeyManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SimpleWalletManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/SimpleWalletManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Wallet */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/Wallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./monitor/Monitor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/Monitor.js\"), exports);\n//# sourceMappingURL=index.client.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.mobile.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.mobile.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sdk = void 0;\nexports.sdk = __importStar(__webpack_require__(/*! ./sdk/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\n__exportStar(__webpack_require__(/*! ./utility/index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./signer/WalletSigner */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/WalletSigner.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletPermissionsManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletPermissionsManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./CWIStyleWalletManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/CWIStyleWalletManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletAuthenticationManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/WalletAuthenticationManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/WABClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/WABClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/TwilioPhoneInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/TwilioPhoneInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/PersonaIDInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/PersonaIDInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./wab-client/auth-method-interactors/AuthMethodInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js\"), exports);\n__exportStar(__webpack_require__(/*! ./services/Services */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js\"), exports);\n__exportStar(__webpack_require__(/*! ./sdk/PrivilegedKeyManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./SimpleWalletManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/SimpleWalletManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./storage/index.mobile */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.mobile.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Wallet */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/Wallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./monitor/Monitor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/Monitor.js\"), exports);\n//# sourceMappingURL=index.mobile.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.mobile.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/Monitor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/Monitor.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Monitor = void 0;\nconst sdk = __importStar(__webpack_require__(/*! ../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nconst services_1 = __webpack_require__(/*! ../services */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/index.js\");\nconst utilityHelpers_1 = __webpack_require__(/*! ../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst TaskPurge_1 = __webpack_require__(/*! ./tasks/TaskPurge */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskPurge.js\");\nconst TaskReviewStatus_1 = __webpack_require__(/*! ./tasks/TaskReviewStatus */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskReviewStatus.js\");\nconst TaskSyncWhenIdle_1 = __webpack_require__(/*! ./tasks/TaskSyncWhenIdle */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSyncWhenIdle.js\");\nconst TaskFailAbandoned_1 = __webpack_require__(/*! ./tasks/TaskFailAbandoned */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskFailAbandoned.js\");\nconst TaskCheckForProofs_1 = __webpack_require__(/*! ./tasks/TaskCheckForProofs */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckForProofs.js\");\nconst TaskClock_1 = __webpack_require__(/*! ./tasks/TaskClock */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskClock.js\");\nconst TaskNewHeader_1 = __webpack_require__(/*! ./tasks/TaskNewHeader */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskNewHeader.js\");\nconst TaskMonitorCallHistory_1 = __webpack_require__(/*! ./tasks/TaskMonitorCallHistory */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskMonitorCallHistory.js\");\nconst TaskSendWaiting_1 = __webpack_require__(/*! ./tasks/TaskSendWaiting */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSendWaiting.js\");\nconst TaskCheckNoSends_1 = __webpack_require__(/*! ./tasks/TaskCheckNoSends */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckNoSends.js\");\nconst TaskUnFail_1 = __webpack_require__(/*! ./tasks/TaskUnFail */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskUnFail.js\");\n/**\n * Background task to make sure transactions are processed, transaction proofs are received and propagated,\n * and potentially that reorgs update proofs that were already received.\n */\nclass Monitor {\n    static createDefaultWalletMonitorOptions(chain, storage, services) {\n        services || (services = new services_1.Services(chain));\n        if (!services.options.chaintracks)\n            throw new sdk.WERR_INVALID_PARAMETER('services.options.chaintracks', 'valid');\n        const o = {\n            chain,\n            services,\n            storage,\n            msecsWaitPerMerkleProofServiceReq: 500,\n            taskRunWaitMsecs: 5000,\n            abandonedMsecs: 1000 * 60 * 5,\n            unprovenAttemptsLimitTest: 10,\n            unprovenAttemptsLimitMain: 144,\n            chaintracks: services.options.chaintracks\n        };\n        return o;\n    }\n    constructor(options) {\n        this.oneSecond = 1000;\n        this.oneMinute = 60 * this.oneSecond;\n        this.oneHour = 60 * this.oneMinute;\n        this.oneDay = 24 * this.oneHour;\n        this.oneWeek = 7 * this.oneDay;\n        /**\n         * _tasks are typically run by the scheduler but may also be run by runTask.\n         */\n        this._tasks = [];\n        /**\n         * _otherTasks can be run by runTask but not by scheduler.\n         */\n        this._otherTasks = [];\n        this._tasksRunning = false;\n        this.defaultPurgeParams = {\n            purgeSpent: false,\n            purgeCompleted: false,\n            purgeFailed: true,\n            purgeSpentAge: 2 * this.oneWeek,\n            purgeCompletedAge: 2 * this.oneWeek,\n            purgeFailedAge: 5 * this.oneDay\n        };\n        this._runAsyncSetup = true;\n        this.options = { ...options };\n        this.services = options.services;\n        this.chain = this.services.chain;\n        this.storage = options.storage;\n        this.chaintracks = options.chaintracks;\n        this.onTransactionProven = options.onTransactionProven;\n        this.onTransactionBroadcasted = options.onTransactionBroadcasted;\n    }\n    addAllTasksToOther() {\n        this._otherTasks.push(new TaskClock_1.TaskClock(this));\n        this._otherTasks.push(new TaskNewHeader_1.TaskNewHeader(this));\n        this._otherTasks.push(new TaskMonitorCallHistory_1.TaskMonitorCallHistory(this));\n        this._otherTasks.push(new TaskPurge_1.TaskPurge(this, this.defaultPurgeParams));\n        this._otherTasks.push(new TaskReviewStatus_1.TaskReviewStatus(this));\n        this._otherTasks.push(new TaskSendWaiting_1.TaskSendWaiting(this));\n        this._otherTasks.push(new TaskCheckForProofs_1.TaskCheckForProofs(this));\n        this._otherTasks.push(new TaskCheckNoSends_1.TaskCheckNoSends(this));\n        this._otherTasks.push(new TaskUnFail_1.TaskUnFail(this));\n        this._otherTasks.push(new TaskFailAbandoned_1.TaskFailAbandoned(this));\n        this._otherTasks.push(new TaskSyncWhenIdle_1.TaskSyncWhenIdle(this));\n    }\n    /**\n     * Default tasks with settings appropriate for a single user storage\n     * possibly with sync'ing enabled\n     */\n    addDefaultTasks() {\n        this._tasks.push(new TaskClock_1.TaskClock(this));\n        this._tasks.push(new TaskNewHeader_1.TaskNewHeader(this));\n        this._tasks.push(new TaskMonitorCallHistory_1.TaskMonitorCallHistory(this));\n        this._tasks.push(new TaskSendWaiting_1.TaskSendWaiting(this, 8 * this.oneSecond, 7 * this.oneSecond)); // Check every 8 seconds but must be 7 seconds old\n        this._tasks.push(new TaskCheckForProofs_1.TaskCheckForProofs(this, 2 * this.oneHour)); // Every two hours if no block found\n        this._tasks.push(new TaskCheckNoSends_1.TaskCheckNoSends(this));\n        this._tasks.push(new TaskFailAbandoned_1.TaskFailAbandoned(this, 8 * this.oneMinute));\n        this._tasks.push(new TaskUnFail_1.TaskUnFail(this));\n        //this._tasks.push(new TaskPurge(this, this.defaultPurgeParams, 6 * this.oneHour))\n        this._tasks.push(new TaskReviewStatus_1.TaskReviewStatus(this));\n    }\n    /**\n     * Tasks appropriate for multi-user storage\n     * without sync'ing enabled.\n     */\n    addMultiUserTasks() {\n        this._tasks.push(new TaskClock_1.TaskClock(this));\n        this._tasks.push(new TaskNewHeader_1.TaskNewHeader(this));\n        this._tasks.push(new TaskMonitorCallHistory_1.TaskMonitorCallHistory(this));\n        this._tasks.push(new TaskSendWaiting_1.TaskSendWaiting(this, 8 * this.oneSecond, 7 * this.oneSecond)); // Check every 8 seconds but must be 7 seconds old\n        this._tasks.push(new TaskCheckForProofs_1.TaskCheckForProofs(this, 2 * this.oneHour)); // Every two hours if no block found\n        this._tasks.push(new TaskCheckNoSends_1.TaskCheckNoSends(this));\n        this._tasks.push(new TaskFailAbandoned_1.TaskFailAbandoned(this, 8 * this.oneMinute));\n        this._tasks.push(new TaskUnFail_1.TaskUnFail(this));\n        //this._tasks.push(new TaskPurge(this, this.defaultPurgeParams, 6 * this.oneHour))\n        this._tasks.push(new TaskReviewStatus_1.TaskReviewStatus(this));\n    }\n    addTask(task) {\n        if (this._tasks.some(t => t.name === task.name))\n            throw new sdk.WERR_BAD_REQUEST(`task ${task.name} has already been added.`);\n        this._tasks.push(task);\n    }\n    removeTask(name) {\n        this._tasks = this._tasks.filter(t => t.name !== name);\n    }\n    async setupChaintracksListeners() {\n        try {\n            // TODO: Use a task monitoring the newest block headere to trigger processNewHeader and reorg handling.\n        }\n        catch (err) {\n            /* this chaintracks doesn't support event subscriptions */\n        }\n    }\n    async runTask(name) {\n        let task = this._tasks.find(t => t.name === name);\n        let log = '';\n        if (!task)\n            task = this._otherTasks.find(t => t.name === name);\n        if (task) {\n            await task.asyncSetup();\n            log = await task.runTask();\n        }\n        return log;\n    }\n    async runOnce() {\n        if (this._runAsyncSetup) {\n            for (const t of this._tasks) {\n                try {\n                    await t.asyncSetup();\n                }\n                catch (eu) {\n                    const e = sdk.WalletError.fromUnknown(eu);\n                    const details = `monitor task ${t.name} asyncSetup error ${e.code} ${e.description}`;\n                    console.log(details);\n                    await this.logEvent('error0', details);\n                }\n                if (!this._tasksRunning)\n                    break;\n            }\n            this._runAsyncSetup = false;\n        }\n        if (this.storage.getActive().isStorageProvider()) {\n            const tasksToRun = [];\n            const now = new Date().getTime();\n            for (const t of this._tasks) {\n                try {\n                    if (t.trigger(now).run)\n                        tasksToRun.push(t);\n                }\n                catch (eu) {\n                    const e = sdk.WalletError.fromUnknown(eu);\n                    const details = `monitor task ${t.name} trigger error ${e.code} ${e.description}`;\n                    console.log(details);\n                    await this.logEvent('error0', details);\n                }\n            }\n            for (const ttr of tasksToRun) {\n                try {\n                    if (this.storage.getActive().isStorageProvider()) {\n                        const log = await ttr.runTask();\n                        if (log && log.length > 0) {\n                            console.log(`Task${ttr.name} ${log.slice(0, 256)}`);\n                            await this.logEvent(ttr.name, log);\n                        }\n                    }\n                }\n                catch (eu) {\n                    const e = sdk.WalletError.fromUnknown(eu);\n                    const details = `monitor task ${ttr.name} runTask error ${e.code} ${e.description}\\n${e.stack}`;\n                    console.log(details);\n                    await this.logEvent('error1', details);\n                }\n                finally {\n                    ttr.lastRunMsecsSinceEpoch = new Date().getTime();\n                }\n            }\n        }\n    }\n    async startTasks() {\n        if (this._tasksRunning)\n            throw new sdk.WERR_BAD_REQUEST('monitor tasks are already runnining.');\n        this._tasksRunning = true;\n        for (; this._tasksRunning;) {\n            await this.runOnce();\n            // console.log(`${new Date().toISOString()} tasks run, waiting...`)\n            await (0, utilityHelpers_1.wait)(this.options.taskRunWaitMsecs);\n        }\n    }\n    async logEvent(event, details) {\n        await this.storage.runAsStorageProvider(async (sp) => {\n            await sp.insertMonitorEvent({\n                created_at: new Date(),\n                updated_at: new Date(),\n                id: 0,\n                event,\n                details\n            });\n        });\n    }\n    stopTasks() {\n        this._tasksRunning = false;\n    }\n    /**\n     * Process new chain header event received from Chaintracks\n     *\n     * Kicks processing 'unconfirmed' and 'unmined' request processing.\n     *\n     * @param reqs\n     */\n    processNewBlockHeader(header) {\n        const h = header;\n        this.lastNewHeader = h;\n        this.lastNewHeaderWhen = new Date();\n        console.log(`WalletMonitor notified of new block header ${h.height}`);\n        // Nudge the proof checker to try again.\n        TaskCheckForProofs_1.TaskCheckForProofs.checkNow = true;\n    }\n    /**\n     * This is a function run from a TaskSendWaiting Monitor task.\n     *\n     * This allows the user of wallet-toolbox to 'subscribe' for transaction broadcast updates.\n     *\n     * @param broadcastResult\n     */\n    callOnBroadcastedTransaction(broadcastResult) {\n        if (this.onTransactionBroadcasted) {\n            this.onTransactionBroadcasted(broadcastResult);\n        }\n    }\n    /**\n     * This is a function run from a TaskCheckForProofs Monitor task.\n     *\n     * This allows the user of wallet-toolbox to 'subscribe' for transaction updates.\n     *\n     * @param txStatus\n     */\n    callOnProvenTransaction(txStatus) {\n        if (this.onTransactionProven) {\n            this.onTransactionProven(txStatus);\n        }\n    }\n    /**\n     * Process reorg event received from Chaintracks\n     *\n     * Reorgs can move recent transactions to new blocks at new index positions.\n     * Affected transaction proofs become invalid and must be updated.\n     *\n     * It is possible for a transaction to become invalid.\n     *\n     * Coinbase transactions always become invalid.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    processReorg(depth, oldTip, newTip) {\n        /* */\n    }\n}\nexports.Monitor = Monitor;\n//# sourceMappingURL=Monitor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/Monitor.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckForProofs.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckForProofs.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskCheckForProofs = void 0;\nexports.getProofs = getProofs;\nconst entities_1 = __webpack_require__(/*! ../../storage/schema/entities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nconst utilityHelpers_1 = __webpack_require__(/*! ../../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst utilityHelpers_noBuffer_1 = __webpack_require__(/*! ../../utility/utilityHelpers.noBuffer */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.noBuffer.js\");\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\n/**\n * `TaskCheckForProofs` is a WalletMonitor task that retreives merkle proofs for\n * transactions.\n *\n * It is normally triggered by the Chaintracks new block header event.\n *\n * When a new block is found, cwi-external-services are used to obtain proofs for\n * any transactions that are currently in the 'unmined' or 'unknown' state.\n *\n * If a proof is obtained and validated, a new ProvenTx record is created and\n * the original ProvenTxReq status is advanced to 'notifying'.\n */\nclass TaskCheckForProofs extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 0) {\n        super(monitor, TaskCheckForProofs.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    /**\n     * Normally triggered by checkNow getting set by new block header found event from chaintracks\n     */\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: TaskCheckForProofs.checkNow ||\n                (this.triggerMsecs > 0 && nowMsecsSinceEpoch - this.lastRunMsecsSinceEpoch > this.triggerMsecs)\n        };\n    }\n    async runTask() {\n        var _a;\n        let log = '';\n        const countsAsAttempt = TaskCheckForProofs.checkNow;\n        TaskCheckForProofs.checkNow = false;\n        const maxAcceptableHeight = (_a = this.monitor.lastNewHeader) === null || _a === void 0 ? void 0 : _a.height;\n        if (maxAcceptableHeight === undefined) {\n            return log;\n        }\n        const limit = 100;\n        let offset = 0;\n        for (;;) {\n            const reqs = await this.storage.findProvenTxReqs({\n                partial: {},\n                status: ['callback', 'unmined', 'sending', 'unknown', 'unconfirmed'],\n                paged: { limit, offset }\n            });\n            if (reqs.length === 0)\n                break;\n            log += `${reqs.length} reqs with status 'callback', 'unmined', 'sending', 'unknown', or 'unconfirmed'\\n`;\n            const r = await getProofs(this, reqs, 2, countsAsAttempt, false, maxAcceptableHeight);\n            log += `${r.log}\\n`;\n            //console.log(log);\n            if (reqs.length < limit)\n                break;\n            offset += limit;\n        }\n        return log;\n    }\n}\nexports.TaskCheckForProofs = TaskCheckForProofs;\nTaskCheckForProofs.taskName = 'CheckForProofs';\n/**\n * An external service such as the chaintracks new block header\n * listener can set this true to cause\n */\nTaskCheckForProofs.checkNow = false;\n/**\n * Process an array of table.ProvenTxReq (typically with status 'unmined' or 'unknown')\n *\n * If req is invalid, set status 'invalid'\n *\n * Verify the requests are valid, lookup proofs or updated transaction status using the array of getProofServices,\n *\n * When proofs are found, create new ProvenTxApi records and transition the requests' status to 'unconfirmed' or 'notifying',\n * depending on chaintracks succeeding on proof verification.\n *\n * Increments attempts if proofs where requested.\n *\n * @param reqs\n * @returns reqs partitioned by status\n */\nasync function getProofs(task, reqs, indent = 0, countsAsAttempt = false, ignoreStatus = false, maxAcceptableHeight) {\n    const proven = [];\n    const invalid = [];\n    let log = '';\n    for (const reqApi of reqs) {\n        log += ' '.repeat(indent);\n        log += `reqId ${reqApi.provenTxReqId} txid ${reqApi.txid}: `;\n        if (!ignoreStatus &&\n            reqApi.status !== 'callback' &&\n            reqApi.status !== 'unmined' &&\n            reqApi.status !== 'unknown' &&\n            reqApi.status !== 'unconfirmed' &&\n            reqApi.status !== 'nosend' &&\n            reqApi.status !== 'sending') {\n            log += `status of '${reqApi.status}' is not ready to be proven.\\n`;\n            continue;\n        }\n        const req = new entities_1.EntityProvenTxReq(reqApi);\n        if (Number.isInteger(req.provenTxId)) {\n            log += `Already linked to provenTxId ${req.provenTxId}.\\n`;\n            req.notified = false;\n            req.status = 'completed';\n            await req.updateStorageDynamicProperties(task.storage);\n            proven.push(reqApi);\n            continue;\n        }\n        log += '\\n';\n        let reqIsValid = false;\n        if (req.rawTx) {\n            const txid = (0, utilityHelpers_noBuffer_1.asString)((0, utilityHelpers_1.doubleSha256BE)(req.rawTx));\n            if (txid === req.txid)\n                reqIsValid = true;\n        }\n        if (!reqIsValid) {\n            log += ` rawTx doesn't hash to txid. status => invalid.\\n`;\n            req.notified = false;\n            req.status = 'invalid';\n            await req.updateStorageDynamicProperties(task.storage);\n            invalid.push(reqApi);\n            continue;\n        }\n        const limit = task.monitor.chain === 'main'\n            ? task.monitor.options.unprovenAttemptsLimitMain\n            : task.monitor.options.unprovenAttemptsLimitTest;\n        if (!ignoreStatus && req.attempts > limit) {\n            log += ` too many failed attempts ${req.attempts}\\n`;\n            req.notified = false;\n            req.status = 'invalid';\n            await req.updateStorageDynamicProperties(task.storage);\n            invalid.push(reqApi);\n            continue;\n        }\n        const since = new Date();\n        let r;\n        let ptx;\n        // External services will try multiple providers until one returns a proof,\n        // or they all fail.\n        // There may also be an array of proofs to consider when a transaction\n        // is recently mined and appears in orphan blocks in addition to active chain blocks.\n        // Since orphan blocks can end up on chain again, multiple proofs has value.\n        //\n        // On failure, there may be a mapi response, or an error.\n        //\n        // The proofs returned are considered sequentially, validating and chaintracks confirming.\n        //\n        // If a good proof is found, proceed to using it.\n        //\n        // When all received proofs fail, force a bump to the next service provider and try\n        // one more time.\n        //\n        r = await task.monitor.services.getMerklePath(req.txid);\n        if (r.header && r.header.height > maxAcceptableHeight) {\n            // Ignore proofs from bleeding edge of new blocks as these are the most often re-orged.\n            log += ` ignoring possible proof from very new block at height ${r.header.height} ${r.header.hash}\\n`;\n            continue;\n        }\n        ptx = await entities_1.EntityProvenTx.fromReq(req, r, countsAsAttempt && req.status !== 'nosend');\n        if (ptx) {\n            // We have a merklePath proof for the request (and a block header)\n            await req.updateStorageDynamicProperties(task.storage);\n            await req.refreshFromStorage(task.storage);\n            const { provenTxReqId, status, txid, attempts, history } = req.toApi();\n            const { index, height, blockHash, merklePath, merkleRoot } = ptx.toApi();\n            const r = await task.storage.runAsStorageProvider(async (sp) => {\n                return await sp.updateProvenTxReqWithNewProvenTx({\n                    provenTxReqId,\n                    status,\n                    txid,\n                    attempts,\n                    history,\n                    index,\n                    height,\n                    blockHash,\n                    merklePath,\n                    merkleRoot\n                });\n            });\n            req.status = r.status;\n            req.apiHistory = r.history;\n            req.provenTxId = r.provenTxId;\n            req.notified = true;\n            task.monitor.callOnProvenTransaction({\n                txid,\n                txIndex: index,\n                blockHeight: height,\n                blockHash,\n                merklePath,\n                merkleRoot\n            });\n        }\n        else {\n            if (countsAsAttempt && req.status !== 'nosend') {\n                req.attempts++;\n            }\n        }\n        await req.updateStorageDynamicProperties(task.storage);\n        await req.refreshFromStorage(task.storage);\n        log += req.historyPretty(since, indent + 2) + '\\n';\n        if (req.status === 'completed')\n            proven.push(req.api);\n        if (req.status === 'invalid')\n            invalid.push(req.api);\n    }\n    return { proven, invalid, log };\n}\n//# sourceMappingURL=TaskCheckForProofs.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckForProofs.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckNoSends.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckNoSends.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskCheckNoSends = void 0;\nconst TaskCheckForProofs_1 = __webpack_require__(/*! ./TaskCheckForProofs */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckForProofs.js\");\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\n/**\n * `TaskCheckNoSends` is a WalletMonitor task that retreives merkle proofs for\n * 'nosend' transactions that MAY have been shared externally.\n *\n * Unlike intentionally processed transactions, 'nosend' transactions are fully valid\n * transactions which have not been processed by the wallet.\n *\n * By default, this task runs once a day to check if any 'nosend' transaction has\n * managed to get mined by some external process.\n *\n * If a proof is obtained and validated, a new ProvenTx record is created and\n * the original ProvenTxReq status is advanced to 'notifying'.\n */\nclass TaskCheckNoSends extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = monitor.oneDay * 1) {\n        super(monitor, TaskCheckNoSends.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    /**\n     * Normally triggered by checkNow getting set by new block header found event from chaintracks\n     */\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: TaskCheckNoSends.checkNow ||\n                (this.triggerMsecs > 0 && nowMsecsSinceEpoch - this.lastRunMsecsSinceEpoch > this.triggerMsecs)\n        };\n    }\n    async runTask() {\n        var _a;\n        let log = '';\n        const countsAsAttempt = TaskCheckNoSends.checkNow;\n        TaskCheckNoSends.checkNow = false;\n        const maxAcceptableHeight = (_a = this.monitor.lastNewHeader) === null || _a === void 0 ? void 0 : _a.height;\n        if (maxAcceptableHeight === undefined) {\n            return log;\n        }\n        const limit = 100;\n        let offset = 0;\n        for (;;) {\n            const reqs = await this.storage.findProvenTxReqs({\n                partial: {},\n                status: ['nosend'],\n                paged: { limit, offset }\n            });\n            if (reqs.length === 0)\n                break;\n            log += `${reqs.length} reqs with status 'nosend'\\n`;\n            const r = await (0, TaskCheckForProofs_1.getProofs)(this, reqs, 2, countsAsAttempt, false, maxAcceptableHeight);\n            log += `${r.log}\\n`;\n            //console.log(log);\n            if (reqs.length < limit)\n                break;\n            offset += limit;\n        }\n        return log;\n    }\n}\nexports.TaskCheckNoSends = TaskCheckNoSends;\nTaskCheckNoSends.taskName = 'CheckNoSends';\n/**\n * An external service such as the chaintracks new block header\n * listener can set this true to cause\n */\nTaskCheckNoSends.checkNow = false;\n//# sourceMappingURL=TaskCheckNoSends.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskCheckNoSends.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskClock.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskClock.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskClock = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nclass TaskClock extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 1 * monitor.oneSecond) {\n        super(monitor, TaskClock.taskName);\n        this.triggerMsecs = triggerMsecs;\n        this.nextMinute = this.getNextMinute();\n    }\n    trigger(nowMsecsSinceEpoch) {\n        const s = this.storage;\n        const run = Date.now() > this.nextMinute;\n        return { run };\n    }\n    async runTask() {\n        const log = `${new Date(this.nextMinute).toISOString()}`;\n        this.nextMinute = this.getNextMinute();\n        return log;\n    }\n    getNextMinute() {\n        return Math.ceil(Date.now() / this.monitor.oneMinute) * this.monitor.oneMinute;\n    }\n}\nexports.TaskClock = TaskClock;\nTaskClock.taskName = 'Clock';\n//# sourceMappingURL=TaskClock.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskClock.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskFailAbandoned.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskFailAbandoned.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskFailAbandoned = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\n/**\n * Handles transactions which do not have terminal status and have not been\n * updated for an extended time period.\n *\n * Calls `updateTransactionStatus` to set `status` to `failed`.\n * This returns inputs to spendable status and verifies that any\n * outputs are not spendable.\n */\nclass TaskFailAbandoned extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 1000 * 60 * 5) {\n        super(monitor, TaskFailAbandoned.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: nowMsecsSinceEpoch > this.lastRunMsecsSinceEpoch + this.triggerMsecs\n        };\n    }\n    async runTask() {\n        let log = '';\n        const limit = 100;\n        let offset = 0;\n        for (;;) {\n            const now = new Date();\n            const abandoned = new Date(now.getTime() - this.monitor.options.abandonedMsecs);\n            const done = await this.storage.runAsStorageProvider(async (sp) => {\n                const txsAll = await sp.findTransactions({\n                    partial: {},\n                    status: ['unprocessed', 'unsigned'],\n                    paged: { limit, offset }\n                });\n                const txs = txsAll.filter(t => t.updated_at && t.updated_at < abandoned);\n                for (const tx of txs) {\n                    await sp.updateTransactionStatus('failed', tx.transactionId);\n                    log += `updated tx ${tx.transactionId} status to 'failed'\\n`;\n                }\n                return txs.length < limit;\n            });\n            if (done)\n                break;\n            offset += limit;\n        }\n        return log;\n    }\n}\nexports.TaskFailAbandoned = TaskFailAbandoned;\nTaskFailAbandoned.taskName = 'FailAbandoned';\n//# sourceMappingURL=TaskFailAbandoned.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskFailAbandoned.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskMonitorCallHistory.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskMonitorCallHistory.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskMonitorCallHistory = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nclass TaskMonitorCallHistory extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = monitor.oneMinute * 12) {\n        super(monitor, TaskMonitorCallHistory.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: nowMsecsSinceEpoch > this.lastRunMsecsSinceEpoch + this.triggerMsecs\n        };\n    }\n    async runTask() {\n        const r = await this.monitor.services.getServicesCallHistory(true);\n        const log = JSON.stringify(r);\n        return log;\n    }\n}\nexports.TaskMonitorCallHistory = TaskMonitorCallHistory;\nTaskMonitorCallHistory.taskName = 'MonitorCallHistory';\n//# sourceMappingURL=TaskMonitorCallHistory.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskMonitorCallHistory.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskNewHeader.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskNewHeader.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskNewHeader = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\n/**\n * This task polls for new block headers performing two essential functions:\n * 1. The arrival of a new block is the right time to check for proofs for recently broadcast transactions.\n * 2. The height of the block is used to limit which proofs are accepted with the aim of avoiding re-orged proofs.\n *\n * The most common new block orphan is one which is almost immediately orphaned.\n * Waiting a minute before pursuing proof requests avoids almost all the re-org work that could be done.\n * Thus this task queues new headers for one cycle.\n * If a new header arrives during that cycle, it replaces the queued header and delays again.\n * Only when there is an elapsed cycle without a new header does proof solicitation get triggered,\n * with that header height as the limit for which proofs are accepted.\n */\nclass TaskNewHeader extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 1 * monitor.oneMinute) {\n        super(monitor, TaskNewHeader.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    async getHeader() {\n        return await this.monitor.chaintracks.findChainTipHeader();\n    }\n    trigger(nowMsecsSinceEpoch) {\n        const run = true;\n        return { run };\n    }\n    async runTask() {\n        let log = '';\n        const oldHeader = this.header;\n        this.header = await this.getHeader();\n        let isNew = true;\n        if (!oldHeader) {\n            log = `first header: ${this.header.height} ${this.header.hash}`;\n        }\n        else if (oldHeader.height < this.header.height) {\n            const skip = this.header.height - oldHeader.height - 1;\n            const skipped = skip > 0 ? ` SKIPPED ${skip}` : '';\n            log = `new header: ${this.header.height} ${this.header.hash}${skipped}`;\n        }\n        else if (oldHeader.height === this.header.height && oldHeader.hash != this.header.hash) {\n            log = `reorg header: ${this.header.height} ${this.header.hash}`;\n        }\n        else {\n            isNew = false;\n        }\n        if (isNew) {\n            this.queuedHeader = this.header;\n        }\n        else if (this.queuedHeader) {\n            // Only process new block header if it has remained the chain tip for a full cycle\n            log = `process header: ${this.header.height} ${this.header.hash}`;\n            this.monitor.processNewBlockHeader(this.queuedHeader);\n            this.queuedHeader = undefined;\n        }\n        return log;\n    }\n}\nexports.TaskNewHeader = TaskNewHeader;\nTaskNewHeader.taskName = 'NewHeader';\n//# sourceMappingURL=TaskNewHeader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskNewHeader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskPurge.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskPurge.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskPurge = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nclass TaskPurge extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, params, triggerMsecs = 0) {\n        super(monitor, TaskPurge.taskName);\n        this.params = params;\n        this.triggerMsecs = triggerMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: TaskPurge.checkNow ||\n                (this.triggerMsecs > 0 && nowMsecsSinceEpoch - this.lastRunMsecsSinceEpoch > this.triggerMsecs)\n        };\n    }\n    async runTask() {\n        let log = '';\n        TaskPurge.checkNow = false;\n        const r = await this.storage.runAsStorageProvider(async (sp) => {\n            return await sp.purgeData(this.params);\n        });\n        if (r.count > 0)\n            log = `${r.count} records updated or deleted.\\n${r.log}`;\n        return log;\n    }\n}\nexports.TaskPurge = TaskPurge;\nTaskPurge.taskName = 'Purge';\n/**\n * Set to true to trigger running this task\n */\nTaskPurge.checkNow = false;\n//# sourceMappingURL=TaskPurge.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskPurge.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskReviewStatus.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskReviewStatus.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskReviewStatus = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\n/**\n * Notify Transaction records of changes in ProvenTxReq records they may have missed.\n *\n * The `notified` property flags reqs that do not need to be checked.\n *\n * Looks for aged Transactions with provenTxId with status != 'completed', sets status to 'completed'.\n *\n * Looks for reqs with 'invalid' status that have corresonding transactions with status other than 'failed'.\n */\nclass TaskReviewStatus extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 1000 * 60 * 15, agedMsecs = 1000 * 60 * 5) {\n        super(monitor, TaskReviewStatus.taskName);\n        this.triggerMsecs = triggerMsecs;\n        this.agedMsecs = agedMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: this.triggerMsecs > 0 && nowMsecsSinceEpoch - this.lastRunMsecsSinceEpoch > this.triggerMsecs\n        };\n    }\n    async runTask() {\n        let log = '';\n        const agedLimit = new Date(Date.now() - this.agedMsecs);\n        const r = await this.storage.runAsStorageProvider(async (sp) => {\n            const r = await sp.reviewStatus({ agedLimit });\n            return r;\n        });\n        if (r.log.length > 0)\n            log += `${r.log}`;\n        return log;\n    }\n}\nexports.TaskReviewStatus = TaskReviewStatus;\nTaskReviewStatus.taskName = 'ReviewStatus';\n/**\n * Set to true to trigger running this task\n */\nTaskReviewStatus.checkNow = false;\n//# sourceMappingURL=TaskReviewStatus.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskReviewStatus.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSendWaiting.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSendWaiting.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskSendWaiting = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../storage/index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.client.js\");\nconst index_client_2 = __webpack_require__(/*! ../../utility/index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js\");\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nconst attemptToPostReqsToNetwork_1 = __webpack_require__(/*! ../../storage/methods/attemptToPostReqsToNetwork */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/attemptToPostReqsToNetwork.js\");\nconst aggregateResults_1 = __webpack_require__(/*! ../../utility/aggregateResults */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/aggregateResults.js\");\nclass TaskSendWaiting extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = monitor.oneSecond * 8, agedMsecs = monitor.oneSecond * 7, sendingMsecs = monitor.oneMinute * 5) {\n        super(monitor, TaskSendWaiting.taskName);\n        this.triggerMsecs = triggerMsecs;\n        this.agedMsecs = agedMsecs;\n        this.sendingMsecs = sendingMsecs;\n        this.includeSending = true;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        this.includeSending =\n            !this.lastSendingRunMsecsSinceEpoch || nowMsecsSinceEpoch > this.lastSendingRunMsecsSinceEpoch + this.sendingMsecs;\n        if (this.includeSending)\n            this.lastSendingRunMsecsSinceEpoch = nowMsecsSinceEpoch;\n        return {\n            run: nowMsecsSinceEpoch > this.lastRunMsecsSinceEpoch + this.triggerMsecs\n        };\n    }\n    async runTask() {\n        let log = '';\n        const limit = 100;\n        let offset = 0;\n        const agedLimit = new Date(Date.now() - this.agedMsecs);\n        const status = this.includeSending ? ['unsent', 'sending'] : ['unsent'];\n        for (;;) {\n            let reqs = await this.storage.findProvenTxReqs({\n                partial: {},\n                status,\n                paged: { limit, offset }\n            });\n            const count = reqs.length;\n            if (reqs.length === 0)\n                break;\n            log += `${reqs.length} reqs with status ${status.join(' or ')}\\n`;\n            const agedReqs = reqs.filter(req => (0, index_client_2.verifyTruthy)(req.updated_at) < agedLimit);\n            log += `  Of those reqs, ${agedReqs.length} where last updated before ${agedLimit.toISOString()}.\\n`;\n            log += await this.processUnsent(agedReqs, 2);\n            if (count < limit)\n                break;\n            offset += limit;\n        }\n        return log;\n    }\n    /**\n     * Process an array of 'unsent' status table.ProvenTxReq\n     *\n     * Send rawTx to transaction processor(s), requesting proof callbacks when possible.\n     *\n     * Set status 'invalid' if req is invalid.\n     *\n     * Set status to 'callback' on successful network submission with callback service.\n     *\n     * Set status to 'unmined' on successful network submission without callback service.\n     *\n     * Add mapi responses to database table if received.\n     *\n     * Increments attempts if sending was attempted.\n     *\n     * @param reqApis\n     */\n    async processUnsent(reqApis, indent = 0) {\n        let log = '';\n        for (let i = 0; i < reqApis.length; i++) {\n            const reqApi = reqApis[i];\n            log += ' '.repeat(indent);\n            log += `${i} reqId=${reqApi.provenTxReqId} attempts=${reqApi.attempts} txid=${reqApi.txid}: \\n`;\n            if (reqApi.status !== 'unsent' && reqApi.status !== 'sending') {\n                log += `  status now ${reqApi.status}\\n`;\n                continue;\n            }\n            const req = new index_client_1.EntityProvenTxReq(reqApi);\n            const reqs = [];\n            if (req.batch) {\n                // Make sure wew process entire batch together for efficient beef generation\n                const batchReqApis = await this.storage.findProvenTxReqs({\n                    partial: { batch: req.batch, status: 'unsent' }\n                });\n                for (const bra of batchReqApis) {\n                    // Remove any matching batchReqApis from reqApis\n                    const index = reqApis.findIndex(ra => ra.provenTxReqId === bra.provenTxReqId);\n                    if (index > -1)\n                        reqApis.slice(index, index + 1);\n                    // And add to reqs being processed now:\n                    reqs.push(new index_client_1.EntityProvenTxReq(bra));\n                }\n            }\n            else {\n                // Just a single non-batched req...\n                reqs.push(req);\n            }\n            const r = await this.storage.runAsStorageProvider(async (sp) => {\n                return (0, attemptToPostReqsToNetwork_1.attemptToPostReqsToNetwork)(sp, reqs);\n            });\n            if (this.monitor.onTransactionBroadcasted) {\n                const rar = await this.storage.runAsStorageProvider(async (sp) => {\n                    const ars = [{ txid: req.txid, status: 'sending' }];\n                    const { rar } = await (0, aggregateResults_1.aggregateActionResults)(sp, ars, r);\n                    return rar;\n                });\n                this.monitor.callOnBroadcastedTransaction(rar[0]);\n            }\n            log += r.log;\n        }\n        return log;\n    }\n}\nexports.TaskSendWaiting = TaskSendWaiting;\nTaskSendWaiting.taskName = 'SendWaiting';\n//# sourceMappingURL=TaskSendWaiting.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSendWaiting.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSyncWhenIdle.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSyncWhenIdle.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskSyncWhenIdle = void 0;\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nclass TaskSyncWhenIdle extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = 1000 * 60 * 1) {\n        super(monitor, TaskSyncWhenIdle.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        const s = this.storage;\n        const run = false;\n        return { run };\n    }\n    async runTask() {\n        // TODO...\n        return '';\n    }\n}\nexports.TaskSyncWhenIdle = TaskSyncWhenIdle;\nTaskSyncWhenIdle.taskName = 'SyncWhenIdle';\n//# sourceMappingURL=TaskSyncWhenIdle.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskSyncWhenIdle.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskUnFail.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskUnFail.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskUnFail = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst WalletMonitorTask_1 = __webpack_require__(/*! ./WalletMonitorTask */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js\");\nconst entities_1 = __webpack_require__(/*! ../../storage/schema/entities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\n/**\n * Setting provenTxReq status to 'unfail' when 'invalid' will attempt to find a merklePath, and if successful:\n *\n * 1. set the req status to 'unmined'\n * 2. set the referenced txs to 'unproven'\n * 3. determine if any inputs match user's existing outputs and if so update spentBy and spendable of those outputs.\n * 4. set the txs outputs to spendable\n *\n * If it fails (to find a merklePath), returns the req status to 'invalid'.\n */\nclass TaskUnFail extends WalletMonitorTask_1.WalletMonitorTask {\n    constructor(monitor, triggerMsecs = monitor.oneMinute * 10) {\n        super(monitor, TaskUnFail.taskName);\n        this.triggerMsecs = triggerMsecs;\n    }\n    trigger(nowMsecsSinceEpoch) {\n        return {\n            run: TaskUnFail.checkNow ||\n                (this.triggerMsecs > 0 && nowMsecsSinceEpoch - this.lastRunMsecsSinceEpoch > this.triggerMsecs)\n        };\n    }\n    async runTask() {\n        let log = '';\n        TaskUnFail.checkNow = false;\n        const limit = 100;\n        let offset = 0;\n        for (;;) {\n            const reqs = await this.storage.findProvenTxReqs({\n                partial: {},\n                status: ['unfail'],\n                paged: { limit, offset }\n            });\n            if (reqs.length === 0)\n                break;\n            log += `${reqs.length} reqs with status 'unfail'\\n`;\n            const r = await this.unfail(reqs, 2);\n            log += `${r.log}\\n`;\n            //console.log(log);\n            if (reqs.length < limit)\n                break;\n            offset += limit;\n        }\n        return log;\n    }\n    async unfail(reqs, indent = 0) {\n        let log = '';\n        for (const reqApi of reqs) {\n            const req = new entities_1.EntityProvenTxReq(reqApi);\n            log += ' '.repeat(indent);\n            log += `reqId ${reqApi.provenTxReqId} txid ${reqApi.txid}: `;\n            const r = await this.monitor.services.getMerklePath(req.txid);\n            if (r.merklePath) {\n                // 1. set the req status to 'unmined'\n                req.status = 'unmined';\n                req.attempts = 0;\n                log += `unfailed. status is now 'unmined'\\n`;\n                log += await this.unfailReq(req, indent + 2);\n            }\n            else {\n                req.status = 'invalid';\n                log += `returned to status 'invalid'\\n`;\n            }\n            await req.updateStorageDynamicProperties(this.storage);\n        }\n        return { log };\n    }\n    /**\n     * 2. set the referenced txs to 'unproven'\n     * 3. determine if any inputs match user's existing outputs and if so update spentBy and spendable of those outputs.\n     * 4. set the txs outputs to spendable\n     *\n     * @param req\n     * @param indent\n     * @returns\n     */\n    async unfailReq(req, indent) {\n        let log = '';\n        const storage = this.storage;\n        const services = this.monitor.services;\n        const txIds = req.notify.transactionIds || [];\n        for (const id of txIds) {\n            const bsvtx = sdk_1.Transaction.fromBinary(req.rawTx);\n            await this.storage.runAsStorageProvider(async (sp) => {\n                const spk = sp;\n                const tx = await sp.findTransactionById(id, undefined, true);\n                if (!tx) {\n                    log += ' '.repeat(indent) + `transaction ${id} was not found\\n`;\n                    return;\n                }\n                await sp.updateTransaction(tx.transactionId, { status: 'unproven' });\n                tx.status = 'unproven';\n                log += ' '.repeat(indent) + `transaction ${id} status is now 'unproven'\\n`;\n                let vin = -1;\n                for (const bi of bsvtx.inputs) {\n                    vin++;\n                    const is = await sp.findOutputs({\n                        partial: { userId: tx.userId, txid: bi.sourceTXID, vout: bi.sourceOutputIndex }\n                    });\n                    if (is.length !== 1) {\n                        log += ' '.repeat(indent + 2) + `input ${vin} not matched to user's outputs\\n`;\n                    }\n                    else {\n                        const oi = is[0];\n                        log +=\n                            ' '.repeat(indent + 2) +\n                                `input ${vin} matched to output ${oi.outputId} updated spentBy ${tx.transactionId}\\n`;\n                        await sp.updateOutput(oi.outputId, { spendable: false, spentBy: tx.transactionId });\n                    }\n                }\n                const outputs = await sp.findOutputs({ partial: { userId: tx.userId, transactionId: tx.transactionId } });\n                for (const o of outputs) {\n                    await spk.validateOutputScript(o);\n                    if (!o.lockingScript) {\n                        log += ' '.repeat(indent + 2) + `output ${o.outputId} does not have a valid locking script\\n`;\n                    }\n                    else {\n                        const isUtxo = await services.isUtxo(o);\n                        if (isUtxo !== o.spendable) {\n                            log += ' '.repeat(indent + 2) + `output ${o.outputId} set to ${isUtxo ? 'spendable' : 'spent'}\\n`;\n                            await sp.updateOutput(o.outputId, { spendable: isUtxo });\n                        }\n                        else {\n                            log += ' '.repeat(indent + 2) + `output ${o.outputId} unchanged\\n`;\n                        }\n                    }\n                }\n            });\n        }\n        return log;\n    }\n}\nexports.TaskUnFail = TaskUnFail;\nTaskUnFail.taskName = 'UnFail';\n/**\n * Set to true to trigger running this task\n */\nTaskUnFail.checkNow = false;\n//# sourceMappingURL=TaskUnFail.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/TaskUnFail.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletMonitorTask = void 0;\n/**\n * A monitor task performs some periodic or state triggered maintenance function\n * on the data managed by a wallet (Bitcoin UTXO manager, aka wallet)\n *\n * The monitor maintains a collection of tasks.\n *\n * It runs each task's non-asynchronous trigger to determine if the runTask method needs to run.\n *\n * Tasks that need to be run are run consecutively by awaiting their async runTask override method.\n *\n * The monitor then waits a fixed interval before repeating...\n *\n * Tasks may use the monitor_events table to persist their execution history.\n * This is done by accessing the wathman.storage object.\n */\nclass WalletMonitorTask {\n    constructor(monitor, name) {\n        this.monitor = monitor;\n        this.name = name;\n        /**\n         * Set by monitor each time runTask completes\n         */\n        this.lastRunMsecsSinceEpoch = 0;\n        this.storage = monitor.storage;\n    }\n    /**\n     * Override to handle async task setup configuration.\n     *\n     * Called before first call to `trigger`\n     */\n    async asyncSetup() { }\n}\nexports.WalletMonitorTask = WalletMonitorTask;\n//# sourceMappingURL=WalletMonitorTask.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/monitor/tasks/WalletMonitorTask.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/CertOpsWallet.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/CertOpsWallet.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=CertOpsWallet.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/CertOpsWallet.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PrivilegedKeyManager = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\n/**\n * PrivilegedKeyManager\n *\n * This class manages a privileged (i.e., very sensitive) private key, obtained from\n * an external function (`keyGetter`), which might be backed by HSMs, secure enclaves,\n * or other secure storage. The manager retains the key in memory only for a limited\n * duration (`retentionPeriod`), uses XOR-based chunk-splitting obfuscation, and\n * includes decoy data to raise the difficulty of discovering the real key in memory.\n *\n * IMPORTANT: While these measures raise the bar for attackers, JavaScript environments\n * do not provide perfect in-memory secrecy.\n */\nclass PrivilegedKeyManager {\n    /**\n     * @param keyGetter - Asynchronous function that retrieves the PrivateKey from a secure environment.\n     * @param retentionPeriod - Time in milliseconds to retain the obfuscated key in memory before zeroizing.\n     */\n    constructor(keyGetter, retentionPeriod = 120000) {\n        /**\n         * A list of dynamically generated property names used to store\n         * real key chunks (XORed with random pads).\n         */\n        this.chunkPropNames = [];\n        /**\n         * A list of dynamically generated property names used to store\n         * the random pads that correspond to the real key chunks.\n         */\n        this.chunkPadPropNames = [];\n        /**\n         * A list of decoy property names that will be removed\n         * when the real key is destroyed.\n         */\n        this.decoyPropNamesDestroy = [];\n        /**\n         * A list of decoy property names that remain in memory\n         * even after the real key is destroyed (just to cause confusion).\n         */\n        this.decoyPropNamesRemain = [];\n        /**\n         * Number of chunks to split the 32-byte key into.\n         * Adjust to increase or decrease obfuscation complexity.\n         */\n        this.CHUNK_COUNT = 4;\n        this.keyGetter = keyGetter;\n        this.retentionPeriod = retentionPeriod;\n        // Initialize some random decoy properties that always remain:\n        for (let i = 0; i < 2; i++) {\n            const propName = this.generateRandomPropName();\n            this[propName] = Uint8Array.from((0, sdk_1.Random)(16));\n            this.decoyPropNamesRemain.push(propName);\n        }\n    }\n    /**\n     * Safely destroys the in-memory obfuscated key material by zeroizing\n     * and deleting related fields. Also destroys some (but not all) decoy\n     * properties to further confuse an attacker.\n     */\n    destroyKey() {\n        try {\n            // Zero out real chunk data\n            for (const name of this.chunkPropNames) {\n                const data = this[name];\n                if (data) {\n                    data.fill(0);\n                }\n                delete this[name];\n            }\n            for (const name of this.chunkPadPropNames) {\n                const data = this[name];\n                if (data) {\n                    data.fill(0);\n                }\n                delete this[name];\n            }\n            // Destroy some decoys\n            for (const name of this.decoyPropNamesDestroy) {\n                const data = this[name];\n                if (data) {\n                    data.fill(0);\n                }\n                delete this[name];\n            }\n            // Clear arrays of property names\n            this.chunkPropNames = [];\n            this.chunkPadPropNames = [];\n            this.decoyPropNamesDestroy = [];\n        }\n        catch (_) {\n            // Swallow any errors in the destruction process\n        }\n        finally {\n            if (this.destroyTimer) {\n                clearTimeout(this.destroyTimer);\n                this.destroyTimer = undefined;\n            }\n        }\n    }\n    /**\n     * Re/sets the destruction timer that removes the key from memory\n     * after `retentionPeriod` ms. If a timer is already running, it\n     * is cleared and re-set. This ensures the key remains in memory\n     * for exactly the desired window after its most recent acquisition.\n     */\n    scheduleKeyDestruction() {\n        if (this.destroyTimer) {\n            // TODO: Consider a constructor flag to avoid clearing timers for higher security\n            clearTimeout(this.destroyTimer);\n        }\n        this.destroyTimer = setTimeout(() => {\n            this.destroyKey();\n        }, this.retentionPeriod);\n    }\n    /**\n     * XOR-based obfuscation on a per-chunk basis.\n     * This function takes two equal-length byte arrays\n     * and returns the XOR combination.\n     */\n    xorBytes(a, b) {\n        const out = new Uint8Array(a.length);\n        for (let i = 0; i < a.length; i++) {\n            out[i] = a[i] ^ b[i];\n        }\n        return out;\n    }\n    /**\n     * Splits the 32-byte key into `this.CHUNK_COUNT` smaller chunks\n     * (mostly equal length; the last chunk picks up leftover bytes\n     * if 32 is not evenly divisible).\n     */\n    splitKeyIntoChunks(keyBytes) {\n        const chunkSize = Math.floor(keyBytes.length / this.CHUNK_COUNT);\n        const chunks = [];\n        let offset = 0;\n        for (let i = 0; i < this.CHUNK_COUNT; i++) {\n            const size = i === this.CHUNK_COUNT - 1 ? keyBytes.length - offset : chunkSize;\n            chunks.push(keyBytes.slice(offset, offset + size));\n            offset += size;\n        }\n        return chunks;\n    }\n    /**\n     * Reassembles the chunks from the dynamic properties, XORs them\n     * with their corresponding pads, and returns a single 32-byte\n     * Uint8Array representing the raw key.\n     */\n    reassembleKeyFromChunks() {\n        try {\n            const chunkArrays = [];\n            for (let i = 0; i < this.chunkPropNames.length; i++) {\n                const chunkEnc = this[this.chunkPropNames[i]];\n                const chunkPad = this[this.chunkPadPropNames[i]];\n                if (!chunkEnc || !chunkPad || chunkEnc.length !== chunkPad.length) {\n                    return null;\n                }\n                const rawChunk = this.xorBytes(chunkEnc, chunkPad);\n                chunkArrays.push(rawChunk);\n            }\n            // Concat them back to a single 32-byte array:\n            const totalLength = chunkArrays.reduce((sum, c) => sum + c.length, 0);\n            if (totalLength !== 32) {\n                // We only handle 32-byte keys\n                return null;\n            }\n            const rawKey = new Uint8Array(totalLength);\n            let offset = 0;\n            for (const chunk of chunkArrays) {\n                rawKey.set(chunk, offset);\n                offset += chunk.length;\n                // Attempt to zero the ephemeral chunk\n                chunk.fill(0);\n            }\n            return rawKey;\n        }\n        catch (_) {\n            // If any property is missing or type mismatch, we return null\n            return null;\n        }\n    }\n    /**\n     * Generates a random property name to store key chunks or decoy data.\n     */\n    generateRandomPropName() {\n        // E.g., 8 random hex characters for the property name\n        const randomHex = sdk_1.Utils.toHex((0, sdk_1.Random)(4));\n        return `_${randomHex}_${Math.floor(Math.random() * 1e6)}`;\n    }\n    /**\n     * Forces a PrivateKey to be represented as exactly 32 bytes, left-padding\n     * with zeros if its numeric value has fewer than 32 bytes.\n     */\n    get32ByteRepresentation(privKey) {\n        // The internal \"toArray()\" can be up to 32 bytes, but sometimes fewer\n        // if the numeric value has leading zeros.\n        const buf = privKey.toArray();\n        if (buf.length > 32) {\n            throw new Error('PrivilegedKeyManager: Expected a 32-byte key, but got more.');\n        }\n        // Left-pad with zeros if needed\n        const keyBytes = new Uint8Array(32);\n        keyBytes.set(buf, 32 - buf.length);\n        return keyBytes;\n    }\n    /**\n     * Returns the privileged key needed to perform cryptographic operations.\n     * Uses in-memory chunk-based obfuscation if the key was already fetched.\n     * Otherwise, it calls out to `keyGetter`, splits the 32-byte representation\n     * of the key, XORs each chunk with a random pad, and stores them under\n     * dynamic property names. Also populates new decoy properties.\n     *\n     * @param reason - The reason for why the key is needed, passed to keyGetter.\n     * @returns The PrivateKey object needed for cryptographic operations.\n     */\n    async getPrivilegedKey(reason) {\n        // If we already have chunk properties, try reassemble\n        if (this.chunkPropNames.length > 0 && this.chunkPadPropNames.length > 0) {\n            const rawKeyBytes = this.reassembleKeyFromChunks();\n            if (rawKeyBytes && rawKeyBytes.length === 32) {\n                // Convert 32 raw bytes back to a PrivateKey\n                // (Leading zeros are preserved, but PrivateKey() will parse it as a big integer.)\n                const hexKey = sdk_1.Utils.toHex([...rawKeyBytes]); // 64 hex chars\n                rawKeyBytes.fill(0); // Zero ephemeral copy\n                this.scheduleKeyDestruction();\n                return new sdk_1.PrivateKey(hexKey, 'hex');\n            }\n        }\n        // Otherwise, fetch a fresh key from the secure environment\n        const fetchedKey = await this.keyGetter(reason);\n        // Force 32byte representation (left-pad if necessary)\n        const keyBytes = this.get32ByteRepresentation(fetchedKey);\n        // Clean up any old data first (in case we had something stale)\n        this.destroyKey();\n        // Split the key\n        const chunks = this.splitKeyIntoChunks(keyBytes);\n        // Store new chunk data under random property names\n        for (let i = 0; i < chunks.length; i++) {\n            const chunkProp = this.generateRandomPropName();\n            const padProp = this.generateRandomPropName();\n            this.chunkPropNames.push(chunkProp);\n            this.chunkPadPropNames.push(padProp);\n            // Generate random pad of the same length as the chunk\n            const pad = Uint8Array.from((0, sdk_1.Random)(chunks[i].length));\n            // XOR the chunk to obfuscate\n            const obf = this.xorBytes(chunks[i], pad);\n            this[chunkProp] = obf;\n            this[padProp] = pad;\n        }\n        // Generate some decoy properties that will be destroyed with the key\n        for (let i = 0; i < 2; i++) {\n            const decoyProp = this.generateRandomPropName();\n            this[decoyProp] = Uint8Array.from((0, sdk_1.Random)(32));\n            this.decoyPropNamesDestroy.push(decoyProp);\n        }\n        // Zero out ephemeral original\n        keyBytes.fill(0);\n        // Schedule destruction\n        this.scheduleKeyDestruction();\n        // Return the newly fetched key as a normal PrivateKey\n        return fetchedKey;\n    }\n    async getPublicKey(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).getPublicKey(args);\n    }\n    async revealCounterpartyKeyLinkage(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).revealCounterpartyKeyLinkage(args);\n    }\n    async revealSpecificKeyLinkage(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).revealSpecificKeyLinkage(args);\n    }\n    async encrypt(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).encrypt(args);\n    }\n    async decrypt(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).decrypt(args);\n    }\n    async createHmac(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).createHmac(args);\n    }\n    async verifyHmac(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).verifyHmac(args);\n    }\n    async createSignature(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).createSignature(args);\n    }\n    async verifySignature(args) {\n        return new sdk_1.ProtoWallet(await this.getPrivilegedKey(args.privilegedReason)).verifySignature(args);\n    }\n}\nexports.PrivilegedKeyManager = PrivilegedKeyManager;\n//# sourceMappingURL=PrivilegedKeyManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WERR_errors.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WERR_errors.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WERR_REVIEW_ACTIONS = exports.WERR_INVALID_PUBLIC_KEY = exports.WERR_INSUFFICIENT_FUNDS = exports.WERR_NOT_ACTIVE = exports.WERR_UNAUTHORIZED = exports.WERR_NETWORK_CHAIN = exports.WERR_BAD_REQUEST = exports.WERR_MISSING_PARAMETER = exports.WERR_INVALID_PARAMETER = exports.WERR_BROADCAST_UNAVAILABLE = exports.WERR_INVALID_OPERATION = exports.WERR_INTERNAL = exports.WERR_NOT_IMPLEMENTED = void 0;\nconst WalletError_1 = __webpack_require__(/*! ./WalletError */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletError.js\");\n/**\n * Not implemented.\n */\nclass WERR_NOT_IMPLEMENTED extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_NOT_IMPLEMENTED', message !== null && message !== void 0 ? message : 'Not implemented.');\n    }\n}\nexports.WERR_NOT_IMPLEMENTED = WERR_NOT_IMPLEMENTED;\n/**\n * An internal error has occurred.\n *\n * This is an example of an error with an optional custom `message`.\n */\nclass WERR_INTERNAL extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_INTERNAL', message !== null && message !== void 0 ? message : 'An internal error has occurred.');\n    }\n}\nexports.WERR_INTERNAL = WERR_INTERNAL;\n/**\n * The ${parameter} parameter is invalid.\n *\n * This is an example of an error object with a custom property `parameter` and templated `message`.\n */\nclass WERR_INVALID_OPERATION extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_INVALID_OPERATION', message !== null && message !== void 0 ? message : `An invalid operation was requested.`);\n    }\n}\nexports.WERR_INVALID_OPERATION = WERR_INVALID_OPERATION;\n/**\n * Unable to broadcast transaction at this time.\n */\nclass WERR_BROADCAST_UNAVAILABLE extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_BROADCAST_UNAVAILABLE', `Unable to broadcast transaction at this time.`);\n    }\n}\nexports.WERR_BROADCAST_UNAVAILABLE = WERR_BROADCAST_UNAVAILABLE;\n/**\n * The ${parameter} parameter is invalid.\n *\n * This is an example of an error object with a custom property `parameter` and templated `message`.\n */\nclass WERR_INVALID_PARAMETER extends WalletError_1.WalletError {\n    constructor(parameter, mustBe) {\n        super('WERR_INVALID_PARAMETER', `The ${parameter} parameter must be ${mustBe !== null && mustBe !== void 0 ? mustBe : 'valid.'}`);\n        this.parameter = parameter;\n    }\n}\nexports.WERR_INVALID_PARAMETER = WERR_INVALID_PARAMETER;\n/**\n * The required ${parameter} parameter is missing.\n *\n * This is an example of an error object with a custom property `parameter`\n */\nclass WERR_MISSING_PARAMETER extends WalletError_1.WalletError {\n    constructor(parameter) {\n        super('WERR_MISSING_PARAMETER', `The required ${parameter} parameter is missing.`);\n        this.parameter = parameter;\n    }\n}\nexports.WERR_MISSING_PARAMETER = WERR_MISSING_PARAMETER;\n/**\n * The request is invalid.\n */\nclass WERR_BAD_REQUEST extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_BAD_REQUEST', message !== null && message !== void 0 ? message : 'The request is invalid.');\n    }\n}\nexports.WERR_BAD_REQUEST = WERR_BAD_REQUEST;\n/**\n * Configured network chain is invalid or does not match across services.\n */\nclass WERR_NETWORK_CHAIN extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_NETWORK_CHAIN', message !== null && message !== void 0 ? message : 'Configured network chain is invalid or does not match across services.');\n    }\n}\nexports.WERR_NETWORK_CHAIN = WERR_NETWORK_CHAIN;\n/**\n * Access is denied due to an authorization error.\n */\nclass WERR_UNAUTHORIZED extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_UNAUTHORIZED', message !== null && message !== void 0 ? message : 'Access is denied due to an authorization error.');\n    }\n}\nexports.WERR_UNAUTHORIZED = WERR_UNAUTHORIZED;\n/**\n * WalletStorageManager is not accessing user's active storage or there are conflicting active stores configured.\n */\nclass WERR_NOT_ACTIVE extends WalletError_1.WalletError {\n    constructor(message) {\n        super('WERR_NOT_ACTIVE', message !== null && message !== void 0 ? message : `WalletStorageManager is not accessing user's active storage or there are conflicting active stores configured.`);\n    }\n}\nexports.WERR_NOT_ACTIVE = WERR_NOT_ACTIVE;\n/**\n * Insufficient funds in the available inputs to cover the cost of the required outputs\n * and the transaction fee (${moreSatoshisNeeded} more satoshis are needed,\n * for a total of ${totalSatoshisNeeded}), plus whatever would be required in order\n * to pay the fee to unlock and spend the outputs used to provide the additional satoshis.\n */\nclass WERR_INSUFFICIENT_FUNDS extends WalletError_1.WalletError {\n    /**\n     * @param totalSatoshisNeeded Total satoshis required to fund transactions after net of required inputs and outputs.\n     * @param moreSatoshisNeeded Shortfall on total satoshis required to fund transactions after net of required inputs and outputs.\n     */\n    constructor(totalSatoshisNeeded, moreSatoshisNeeded) {\n        super('WERR_INSUFFICIENT_FUNDS', `Insufficient funds in the available inputs to cover the cost of the required outputs and the transaction fee (${moreSatoshisNeeded} more satoshis are needed, for a total of ${totalSatoshisNeeded}), plus whatever would be required in order to pay the fee to unlock and spend the outputs used to provide the additional satoshis.`);\n        this.totalSatoshisNeeded = totalSatoshisNeeded;\n        this.moreSatoshisNeeded = moreSatoshisNeeded;\n    }\n}\nexports.WERR_INSUFFICIENT_FUNDS = WERR_INSUFFICIENT_FUNDS;\nclass WERR_INVALID_PUBLIC_KEY extends WalletError_1.WalletError {\n    /**\n     * @param key The invalid public key that caused the error.\n     * @param environment Optional environment flag to control whether the key is included in the message.\n     */\n    constructor(key, network = 'mainnet') {\n        const message = network === 'mainnet'\n            ? `The provided public key \"${key}\" is invalid or malformed.`\n            : `The provided public key is invalid or malformed.`;\n        super('WERR_INVALID_PUBLIC_KEY', message);\n        this.key = key;\n    }\n}\nexports.WERR_INVALID_PUBLIC_KEY = WERR_INVALID_PUBLIC_KEY;\n/**\n * When a `createAction` or `signAction` is completed in undelayed mode (`acceptDelayedBroadcast`: false),\n * any unsucccessful result will return the results by way of this exception to ensure attention is\n * paid to processing errors.\n */\nclass WERR_REVIEW_ACTIONS extends WalletError_1.WalletError {\n    /**\n     * All parameters correspond to their comparable `createAction` or `signSction` results\n     * with the exception of `reviewActionResults`;\n     * which contains more details, particularly for double spend results.\n     */\n    constructor(reviewActionResults, sendWithResults, txid, tx, noSendChange) {\n        super('WERR_REVIEW_ACTIONS', 'Undelayed createAction or signAction results require review.');\n        this.reviewActionResults = reviewActionResults;\n        this.sendWithResults = sendWithResults;\n        this.txid = txid;\n        this.tx = tx;\n        this.noSendChange = noSendChange;\n    }\n}\nexports.WERR_REVIEW_ACTIONS = WERR_REVIEW_ACTIONS;\n//# sourceMappingURL=WERR_errors.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WERR_errors.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletError.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletError.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletError = void 0;\n/**\n * Derived class constructors should use the derived class name as the value for `name`,\n * and an internationalizable constant string for `message`.\n *\n * If a derived class intends to wrap another WalletError, the public property should\n * be named `walletError` and will be recovered by `fromUnknown`.\n *\n * Optionaly, the derived class `message` can include template parameters passed in\n * to the constructor. See WERR_MISSING_PARAMETER for an example.\n *\n * To avoid derived class name colisions, packages should include a package specific\n * identifier after the 'WERR_' prefix. e.g. 'WERR_FOO_' as the prefix for Foo package error\n * classes.\n */\nclass WalletError extends Error {\n    constructor(name, message, stack, details) {\n        super(message);\n        this.details = details;\n        // Facilitates detection of Error objects from non-error return values.\n        this.isError = true;\n        this.name = name;\n        if (stack)\n            this.stack = stack;\n    }\n    /**\n     * Error class compatible accessor for  `code`.\n     */\n    get code() {\n        return this.name;\n    }\n    set code(v) {\n        this.name = v;\n    }\n    /**\n     * Error class compatible accessor for `description`.\n     */\n    get description() {\n        return this.message;\n    }\n    set description(v) {\n        this.message = v;\n    }\n    /**\n     * Recovers all public fields from WalletError derived error classes and relevant Error derived errors.\n     *\n     */\n    static fromUnknown(err) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let name = 'WERR_UNKNOWN';\n        let message = '';\n        let stack;\n        const details = {};\n        if (err !== null && typeof err === 'object') {\n            if (err['name'] === 'Error' || err['name'] === 'FetchError')\n                name = err['code'] || err['status'] || 'WERR_UNKNOWN';\n            else\n                name = err['name'] || err['code'] || err['status'] || 'WERR_UNKNOWN';\n            if (typeof name !== 'string')\n                name = 'WERR_UNKNOWN';\n            message = err['message'] || err['description'] || '';\n            if (typeof message !== 'string')\n                message = 'WERR_UNKNOWN';\n            if (typeof err['stack'] === 'string')\n                stack = err['stack'];\n            if (typeof err['sql'] === 'string')\n                details.sql = err['sql'];\n            if (typeof err['sqlMessage'] === 'string')\n                details.sqlMessage = err['sqlMessage'];\n        }\n        const e = new WalletError(name, message, stack, Object.keys(details).length > 0 ? details : undefined);\n        if (err !== null && typeof err === 'object') {\n            for (const [key, value] of Object.entries(err)) {\n                if (key !== 'walletError' && typeof value !== 'string' && typeof value !== 'number' && !Array.isArray(value))\n                    continue;\n                switch (key) {\n                    case 'walletError':\n                        e[key] = WalletError.fromUnknown(value);\n                        break;\n                    case 'status':\n                        break;\n                    case 'name':\n                        break;\n                    case 'code':\n                        break;\n                    case 'message':\n                        break;\n                    case 'description':\n                        break;\n                    case 'stack':\n                        break;\n                    case 'sql':\n                        break;\n                    case 'sqlMessage':\n                        break;\n                    default:\n                        e[key] = value;\n                        break;\n                }\n            }\n        }\n        return e;\n    }\n    /**\n     * @returns standard HTTP error status object with status property set to 'error'.\n     */\n    asStatus() {\n        return {\n            status: 'error',\n            code: this.name,\n            description: this.message\n        };\n    }\n}\nexports.WalletError = WalletError;\n//# sourceMappingURL=WalletError.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletError.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletServices.interfaces.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletServices.interfaces.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=WalletServices.interfaces.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletServices.interfaces.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletSigner.interfaces.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletSigner.interfaces.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=WalletSigner.interfaces.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletSigner.interfaces.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletStorage.interfaces.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletStorage.interfaces.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=WalletStorage.interfaces.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletStorage.interfaces.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./WalletError */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletError.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletSigner.interfaces */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletSigner.interfaces.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletStorage.interfaces */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletStorage.interfaces.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WERR_errors */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WERR_errors.js\"), exports);\n__exportStar(__webpack_require__(/*! ./validationHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/validationHelpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./CertOpsWallet */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/CertOpsWallet.js\"), exports);\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WalletServices.interfaces */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/WalletServices.interfaces.js\"), exports);\n__exportStar(__webpack_require__(/*! ./PrivilegedKeyManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/PrivilegedKeyManager.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.specOpThrowReviewActions = exports.specOpFailedActions = exports.specOpNoSendActions = exports.specOpSetWalletChangeParams = exports.specOpInvalidChange = exports.specOpWalletBalance = exports.ProvenTxReqNonTerminalStatus = exports.ProvenTxReqTerminalStatus = void 0;\nexports.isListOutputsSpecOp = isListOutputsSpecOp;\nexports.isListActionsSpecOp = isListActionsSpecOp;\nexports.isCreateActionSpecOp = isCreateActionSpecOp;\nexports.ProvenTxReqTerminalStatus = ['completed', 'invalid', 'doubleSpend'];\nexports.ProvenTxReqNonTerminalStatus = [\n    'sending',\n    'unsent',\n    'nosend',\n    'unknown',\n    'nonfinal',\n    'unprocessed',\n    'unmined',\n    'callback',\n    'unconfirmed'\n];\n/**\n * `listOutputs` special operation basket name value.\n *\n * Returns wallet's current change balance in the `totalOutputs` result property.\n * The `outputs` result property will always be an empty array.\n */\nexports.specOpWalletBalance = '893b7646de0e1c9f741bd6e9169b76a8847ae34adef7bef1e6a285371206d2e8';\n/**\n * `listOutputs` special operation basket name value.\n *\n * Returns currently spendable wallet change outputs that fail to validate as unspent transaction outputs.\n *\n * Optional tag value 'release'. If present, updates invalid change outputs to not spendable.\n *\n * Optional tag value 'all'. If present, processes all spendable true outputs, independent of baskets.\n */\nexports.specOpInvalidChange = '5a76fd430a311f8bc0553859061710a4475c19fed46e2ff95969aa918e612e57';\n/**\n * `listOutputs` special operation basket name value.\n *\n * Updates the wallet's automatic change management parameters.\n *\n * Tag at index 0 is the new desired number of spendable change outputs to maintain.\n *\n * Tag at index 1 is the new target for minimum satoshis when creating new change outputs.\n */\nexports.specOpSetWalletChangeParams = 'a4979d28ced8581e9c1c92f1001cc7cb3aabf8ea32e10888ad898f0a509a3929';\n/**\n * @param basket Output basket name value.\n * @returns true iff the `basket` name is a reserved `listOutputs` special operation identifier.\n */\nfunction isListOutputsSpecOp(basket) {\n    return [exports.specOpWalletBalance, exports.specOpInvalidChange, exports.specOpSetWalletChangeParams].indexOf(basket) >= 0;\n}\n/**\n * `listActions` special operation label name value.\n *\n * Processes only actions currently with status 'nosend'\n *\n * Optional label value 'abort'. If present, runs abortAction on all the actions returned.\n */\nexports.specOpNoSendActions = 'ac6b20a3bb320adafecd637b25c84b792ad828d3aa510d05dc841481f664277d';\n/**\n * `listActions` special operation label name value.\n *\n * Processes only actions currently with status 'failed'\n *\n * Optional label value 'unfail'. If present, sets status to 'unfail', which queues them for attempted recovery by the Monitor.\n */\nexports.specOpFailedActions = '97d4eb1e49215e3374cc2c1939a7c43a55e95c7427bf2d45ed63e3b4e0c88153';\n/**\n * @param label Action / Transaction label name value.\n * @returns true iff the `label` name is a reserved `listActions` special operation identifier.\n */\nfunction isListActionsSpecOp(label) {\n    return [exports.specOpNoSendActions, exports.specOpFailedActions].indexOf(label) >= 0;\n}\n/**\n * `createAction` special operation label name value.\n *\n * Causes WERR_REVIEW_ACTIONS throw with dummy properties.\n *\n */\nexports.specOpThrowReviewActions = 'a496e747fc3ad5fabdd4ae8f91184e71f87539bd3d962aa2548942faaaf0047a';\n/**\n * @param label Action / Transaction label name value.\n * @returns true iff the `label` name is a reserved `createAction` special operation identifier.\n */\nfunction isCreateActionSpecOp(label) {\n    return [exports.specOpThrowReviewActions].indexOf(label) >= 0;\n}\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/types.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/validationHelpers.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/validationHelpers.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseWalletOutpoint = parseWalletOutpoint;\nexports.validateSatoshis = validateSatoshis;\nexports.validateOptionalInteger = validateOptionalInteger;\nexports.validateInteger = validateInteger;\nexports.validatePositiveIntegerOrZero = validatePositiveIntegerOrZero;\nexports.validateStringLength = validateStringLength;\nexports.isHexString = isHexString;\nexports.validateCreateActionInput = validateCreateActionInput;\nexports.validateCreateActionOutput = validateCreateActionOutput;\nexports.validateCreateActionOptions = validateCreateActionOptions;\nexports.validateCreateActionArgs = validateCreateActionArgs;\nexports.validateSignActionOptions = validateSignActionOptions;\nexports.validateSignActionArgs = validateSignActionArgs;\nexports.validateAbortActionArgs = validateAbortActionArgs;\nexports.validateWalletPayment = validateWalletPayment;\nexports.validateBasketInsertion = validateBasketInsertion;\nexports.validateInternalizeOutput = validateInternalizeOutput;\nexports.validateOriginator = validateOriginator;\nexports.validateInternalizeActionArgs = validateInternalizeActionArgs;\nexports.validateOptionalOutpointString = validateOptionalOutpointString;\nexports.validateOutpointString = validateOutpointString;\nexports.validateRelinquishOutputArgs = validateRelinquishOutputArgs;\nexports.validateRelinquishCertificateArgs = validateRelinquishCertificateArgs;\nexports.validateListCertificatesArgs = validateListCertificatesArgs;\nexports.validateAcquireCertificateArgs = validateAcquireCertificateArgs;\nexports.validateAcquireIssuanceCertificateArgs = validateAcquireIssuanceCertificateArgs;\nexports.validateAcquireDirectCertificateArgs = validateAcquireDirectCertificateArgs;\nexports.validateProveCertificateArgs = validateProveCertificateArgs;\nexports.validateDiscoverByIdentityKeyArgs = validateDiscoverByIdentityKeyArgs;\nexports.validateDiscoverByAttributesArgs = validateDiscoverByAttributesArgs;\nexports.validateListOutputsArgs = validateListOutputsArgs;\nexports.validateListActionsArgs = validateListActionsArgs;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nfunction parseWalletOutpoint(outpoint) {\n    const [txid, vout] = outpoint.split('.');\n    return { txid, vout: Number(vout) };\n}\nfunction defaultTrue(v) {\n    return v !== null && v !== void 0 ? v : true;\n}\nfunction defaultFalse(v) {\n    return v !== null && v !== void 0 ? v : false;\n}\nfunction defaultZero(v) {\n    return v !== null && v !== void 0 ? v : 0;\n}\nfunction default0xffffffff(v) {\n    return v !== null && v !== void 0 ? v : 0xffffffff;\n}\nfunction defaultOne(v) {\n    return v !== null && v !== void 0 ? v : 1;\n}\nfunction defaultEmpty(v) {\n    return v !== null && v !== void 0 ? v : [];\n}\nfunction validateOptionalStringLength(s, name, min, max) {\n    if (s === undefined)\n        return undefined;\n    return validateStringLength(s, name, min, max);\n}\nfunction validateSatoshis(v, name, min) {\n    if (v === undefined || !Number.isInteger(v) || v < 0 || v > 21e14)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'a valid number of satoshis');\n    if (min !== undefined && v < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} satoshis.`);\n    return v;\n}\nfunction validateOptionalInteger(v, name, min, max) {\n    if (v === undefined)\n        return undefined;\n    return validateInteger(v, name, undefined, min, max);\n}\nfunction validateInteger(v, name, defaultValue, min, max) {\n    if (v === undefined) {\n        if (defaultValue !== undefined)\n            return defaultValue;\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'a valid integer');\n    }\n    if (!Number.isInteger(v))\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, 'an integer');\n    v = Number(v);\n    if (min !== undefined && v < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);\n    if (max !== undefined && v > max)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);\n    return v;\n}\nfunction validatePositiveIntegerOrZero(v, name) {\n    return validateInteger(v, name, 0, 0);\n}\nfunction validateStringLength(s, name, min, max) {\n    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;\n    if (min !== undefined && bytes < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);\n    if (max !== undefined && bytes > max)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);\n    return s;\n}\nfunction validateOptionalBasket(s) {\n    if (s === undefined)\n        return undefined;\n    return validateBasket(s);\n}\nfunction validateBasket(s) {\n    return validateIdentifier(s, 'basket', 1, 300);\n}\nfunction validateLabel(s) {\n    return validateIdentifier(s, 'label', 1, 300);\n}\nfunction validateTag(s) {\n    return validateIdentifier(s, 'tag', 1, 300);\n}\nfunction validateIdentifier(s, name, min, max) {\n    s = s.trim().toLowerCase();\n    const bytes = sdk_1.Utils.toArray(s, 'utf8').length;\n    if (min !== undefined && bytes < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);\n    if (max !== undefined && bytes > max)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);\n    return s;\n}\nfunction validateOptionalBase64String(s, name, min, max) {\n    if (s === undefined)\n        return undefined;\n    return validateBase64String(s, name, min, max);\n}\nfunction validateBase64String(s, name, min, max) {\n    // Remove any whitespace and check if the string length is valid for Base64\n    s = s.trim();\n    const base64Regex = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/;\n    const paddingMatch = /=+$/.exec(s);\n    const paddingCount = paddingMatch ? paddingMatch[0].length : 0;\n    if (paddingCount > 2 || (s.length % 4 !== 0 && paddingCount !== 0) || !base64Regex.test(s)) {\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `balid base64 string`);\n    }\n    const bytes = sdk_1.Utils.toArray(s, 'base64').length;\n    if (min !== undefined && bytes < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);\n    if (max !== undefined && bytes > max)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);\n    return s;\n}\nfunction validateOptionalHexString(s, name, min, max) {\n    if (s === undefined)\n        return undefined;\n    return validateHexString(s, name, min, max);\n}\n/**\n * @param s\n * @param name\n * @param min if valid, string length minimum (not bytes)\n * @param max if valid, string length maximum (not bytes)\n * @returns\n */\nfunction validateHexString(s, name, min, max) {\n    s = s.trim().toLowerCase();\n    if (s.length % 2 === 1)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `even length, not ${s.length}.`);\n    const hexRegex = /^[0-9A-Fa-f]+$/;\n    if (!hexRegex.test(s))\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `hexadecimal string.`);\n    if (min !== undefined && s.length < min)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `at least ${min} length.`);\n    if (max !== undefined && s.length > max)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `no more than ${max} length.`);\n    return s;\n}\nfunction isHexString(s) {\n    s = s.trim();\n    if (s.length % 2 === 1)\n        return false;\n    const hexRegex = /^[0-9A-Fa-f]+$/;\n    if (!hexRegex.test(s))\n        return false;\n    return true;\n}\nfunction validateCreateActionInput(i) {\n    var _a;\n    if (i.unlockingScript === undefined && i.unlockingScriptLength === undefined)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('unlockingScript, unlockingScriptLength', `at least one valid value.`);\n    const unlockingScript = validateOptionalHexString(i.unlockingScript, 'unlockingScript');\n    const unlockingScriptLength = (_a = i.unlockingScriptLength) !== null && _a !== void 0 ? _a : unlockingScript.length / 2;\n    if (unlockingScript && unlockingScriptLength !== unlockingScript.length / 2)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('unlockingScriptLength', `length unlockingScript if both valid.`);\n    const vi = {\n        outpoint: parseWalletOutpoint(i.outpoint),\n        inputDescription: validateStringLength(i.inputDescription, 'inputDescription', 5, 2000),\n        unlockingScript,\n        unlockingScriptLength,\n        sequenceNumber: default0xffffffff(i.sequenceNumber)\n    };\n    return vi;\n}\nfunction validateCreateActionOutput(o) {\n    const vo = {\n        lockingScript: validateHexString(o.lockingScript, 'lockingScript'),\n        satoshis: validateSatoshis(o.satoshis, 'satoshis'),\n        outputDescription: validateStringLength(o.outputDescription, 'outputDescription', 5, 2000),\n        basket: validateOptionalBasket(o.basket),\n        customInstructions: o.customInstructions,\n        tags: defaultEmpty(o.tags).map(t => validateTag(t))\n    };\n    return vo;\n}\n/**\n * Set all default true/false booleans to true or false if undefined.\n * Set all possibly undefined numbers to their default values.\n * Set all possibly undefined arrays to empty arrays.\n * Convert string outpoints to `{ txid: string, vout: number }`\n */\nfunction validateCreateActionOptions(options) {\n    const o = options || {};\n    const vo = {\n        signAndProcess: defaultTrue(o.signAndProcess),\n        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),\n        knownTxids: defaultEmpty(o.knownTxids),\n        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),\n        noSend: defaultFalse(o.noSend),\n        noSendChange: defaultEmpty(o.noSendChange).map(nsc => parseWalletOutpoint(nsc)),\n        sendWith: defaultEmpty(o.sendWith),\n        randomizeOutputs: defaultTrue(o.randomizeOutputs)\n    };\n    return vo;\n}\nfunction validateCreateActionArgs(args) {\n    var _a;\n    const vargs = {\n        description: validateStringLength(args.description, 'description', 5, 2000),\n        inputBEEF: args.inputBEEF,\n        inputs: defaultEmpty(args.inputs).map(i => validateCreateActionInput(i)),\n        outputs: defaultEmpty(args.outputs).map(o => validateCreateActionOutput(o)),\n        lockTime: defaultZero(args.lockTime),\n        version: defaultOne(args.version),\n        labels: defaultEmpty((_a = args.labels) === null || _a === void 0 ? void 0 : _a.map(l => validateLabel(l))),\n        options: validateCreateActionOptions(args.options),\n        isSendWith: false,\n        isDelayed: false,\n        isNoSend: false,\n        isNewTx: false,\n        isRemixChange: false,\n        isSignAction: false,\n        randomVals: undefined,\n        includeAllSourceTransactions: false\n    };\n    vargs.isSendWith = vargs.options.sendWith.length > 0;\n    vargs.isRemixChange = !vargs.isSendWith && vargs.inputs.length === 0 && vargs.outputs.length === 0;\n    vargs.isNewTx = vargs.isRemixChange || vargs.inputs.length > 0 || vargs.outputs.length > 0;\n    vargs.isSignAction =\n        vargs.isNewTx && (vargs.options.signAndProcess === false || vargs.inputs.some(i => i.unlockingScript === undefined));\n    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;\n    vargs.isNoSend = vargs.options.noSend;\n    return vargs;\n}\n/**\n * Set all default true/false booleans to true or false if undefined.\n * Set all possibly undefined numbers to their default values.\n * Set all possibly undefined arrays to empty arrays.\n * Convert string outpoints to `{ txid: string, vout: number }`\n */\nfunction validateSignActionOptions(options) {\n    const o = options || {};\n    const vo = {\n        acceptDelayedBroadcast: defaultTrue(o.acceptDelayedBroadcast),\n        returnTXIDOnly: defaultFalse(o.returnTXIDOnly),\n        noSend: defaultFalse(o.noSend),\n        sendWith: defaultEmpty(o.sendWith)\n    };\n    return vo;\n}\nfunction validateSignActionArgs(args) {\n    const vargs = {\n        spends: args.spends,\n        reference: args.reference,\n        options: validateSignActionOptions(args.options),\n        isSendWith: false,\n        isDelayed: false,\n        isNoSend: false,\n        isNewTx: true,\n        isRemixChange: false\n    };\n    vargs.isSendWith = vargs.options.sendWith.length > 0;\n    vargs.isDelayed = vargs.options.acceptDelayedBroadcast;\n    vargs.isNoSend = vargs.options.noSend;\n    return vargs;\n}\nfunction validateAbortActionArgs(args) {\n    const vargs = {\n        reference: validateBase64String(args.reference, 'reference')\n    };\n    return vargs;\n}\nfunction validateWalletPayment(args) {\n    if (args === undefined)\n        return undefined;\n    const v = {\n        derivationPrefix: validateBase64String(args.derivationPrefix, 'derivationPrefix'),\n        derivationSuffix: validateBase64String(args.derivationSuffix, 'derivationSuffix'),\n        senderIdentityKey: validateHexString(args.senderIdentityKey, 'senderIdentityKey')\n    };\n    return v;\n}\nfunction validateBasketInsertion(args) {\n    if (args === undefined)\n        return undefined;\n    const v = {\n        basket: validateBasket(args.basket),\n        customInstructions: validateOptionalStringLength(args.customInstructions, 'customInstructions', 0, 1000), // TODO: real max??\n        tags: defaultEmpty(args.tags).map(t => validateTag(t))\n    };\n    return v;\n}\nfunction validateInternalizeOutput(args) {\n    if (args.protocol !== 'basket insertion' && args.protocol !== 'wallet payment')\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('protocol', `'basket insertion' or 'wallet payment'`);\n    const v = {\n        outputIndex: validatePositiveIntegerOrZero(args.outputIndex, 'outputIndex'),\n        protocol: args.protocol,\n        paymentRemittance: validateWalletPayment(args.paymentRemittance),\n        insertionRemittance: validateBasketInsertion(args.insertionRemittance)\n    };\n    return v;\n}\nfunction validateOriginator(s) {\n    if (s === undefined)\n        return undefined;\n    s = s.trim().toLowerCase();\n    validateStringLength(s, 'originator', 1, 250);\n    const sps = s.split('.');\n    for (const sp of sps) {\n        validateStringLength(sp, 'originator part', 1, 63);\n    }\n}\nfunction validateInternalizeActionArgs(args) {\n    const vargs = {\n        tx: args.tx,\n        outputs: args.outputs.map(o => validateInternalizeOutput(o)),\n        description: validateStringLength(args.description, 'description', 5, 2000),\n        labels: (args.labels || []).map(t => validateLabel(t)),\n        seekPermission: defaultTrue(args.seekPermission)\n    };\n    try {\n        const beef = sdk_1.Beef.fromBinary(vargs.tx);\n        if (beef.txs.length < 1)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `at least one transaction to internalize an output from`);\n    }\n    catch (_a) {\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `valid with at least one transaction to internalize an output from`);\n    }\n    if (vargs.outputs.length < 1)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputs', `at least one output to internalize from the transaction`);\n    return vargs;\n}\nfunction validateOptionalOutpointString(outpoint, name) {\n    if (outpoint === undefined)\n        return undefined;\n    return validateOutpointString(outpoint, name);\n}\nfunction validateOutpointString(outpoint, name) {\n    const s = outpoint.split('.');\n    if (s.length !== 2 || !Number.isInteger(Number(s[1])))\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(name, `txid as hex string and numeric output index joined with '.'`);\n    const txid = validateHexString(s[0], `${name} txid`, undefined, 64);\n    const vout = validatePositiveIntegerOrZero(Number(s[1]), `${name} vout`);\n    return `${txid}.${vout}`;\n}\nfunction validateRelinquishOutputArgs(args) {\n    const vargs = {\n        basket: validateBasket(args.basket),\n        output: validateOutpointString(args.output, 'output')\n    };\n    return vargs;\n}\nfunction validateRelinquishCertificateArgs(args) {\n    const vargs = {\n        type: validateBase64String(args.type, 'type'),\n        serialNumber: validateBase64String(args.serialNumber, 'serialNumber'),\n        certifier: validateHexString(args.certifier, 'certifier')\n    };\n    return vargs;\n}\nfunction validateListCertificatesArgs(args) {\n    const vargs = {\n        certifiers: defaultEmpty(args.certifiers.map(c => validateHexString(c.trim(), 'certifiers'))),\n        types: defaultEmpty(args.types.map(t => validateBase64String(t.trim(), 'types'))),\n        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),\n        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),\n        privileged: defaultFalse(args.privileged),\n        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),\n        partial: undefined\n    };\n    return vargs;\n}\nfunction validateCertificateFields(fields) {\n    for (const fieldName of Object.keys(fields)) {\n        validateStringLength(fieldName, 'field name', 1, 50);\n    }\n    return fields;\n}\nfunction validateKeyringRevealer(kr, name) {\n    if (kr === 'certifier')\n        return kr;\n    return validateHexString(kr, name);\n}\nfunction validateOptionalKeyringRevealer(kr, name) {\n    if (kr === undefined)\n        return undefined;\n    return validateKeyringRevealer(kr, name);\n}\nfunction validateKeyringForSubject(kr, name) {\n    for (const fn of Object.keys(kr)) {\n        validateStringLength(fn, `${name} field name`, 1, 50);\n        validateBase64String(kr[fn], `${name} field value`);\n    }\n    return kr;\n}\nfunction validateOptionalKeyringForSubject(kr, name) {\n    if (kr === undefined)\n        return undefined;\n    return validateKeyringForSubject(kr, name);\n}\n/**\n *\n * @param args\n * @param subject Must be valid for \"direct\" `acquisitionProtocol`. public key of the certificate subject.\n * @returns\n */\nasync function validateAcquireCertificateArgs(args) {\n    const vargs = {\n        acquisitionProtocol: args.acquisitionProtocol,\n        type: validateBase64String(args.type, 'type'),\n        serialNumber: validateOptionalBase64String(args.serialNumber, 'serialNumber'),\n        certifier: validateHexString(args.certifier, 'certifier'),\n        revocationOutpoint: validateOptionalOutpointString(args.revocationOutpoint, 'revocationOutpoint'),\n        fields: validateCertificateFields(args.fields),\n        signature: validateOptionalHexString(args.signature, 'signature'),\n        certifierUrl: args.certifierUrl,\n        keyringRevealer: validateOptionalKeyringRevealer(args.keyringRevealer, 'keyringRevealer'),\n        keyringForSubject: validateOptionalKeyringForSubject(args.keyringForSubject, 'keyringForSubject'),\n        privileged: defaultFalse(args.privileged),\n        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50)\n    };\n    if (vargs.privileged && !vargs.privilegedReason)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);\n    if (vargs.acquisitionProtocol === 'direct') {\n        if (!vargs.serialNumber)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is \"direct\"');\n        if (!vargs.signature)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is \"direct\"');\n        if (!vargs.revocationOutpoint)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is \"direct\"');\n    }\n    return vargs;\n}\nfunction validateAcquireIssuanceCertificateArgs(args) {\n    if (args.acquisitionProtocol !== 'issuance')\n        throw new index_client_1.sdk.WERR_INTERNAL('Only acquire certificate via issuance requests allowed here.');\n    if (args.serialNumber)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is \"direct\"');\n    if (args.signature)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is \"direct\"');\n    if (args.revocationOutpoint)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is \"direct\"');\n    if (args.keyringRevealer)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringRevealer', 'valid when acquisitionProtocol is \"direct\"');\n    if (args.keyringForSubject)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringForSubject', 'valid when acquisitionProtocol is \"direct\"');\n    if (!args.certifierUrl)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('certifierUrl', 'valid when acquisitionProtocol is \"issuance\"');\n    if (args.privileged && !args.privilegedReason)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);\n    const vargs = {\n        type: validateBase64String(args.type, 'type'),\n        certifier: validateHexString(args.certifier, 'certifier'),\n        certifierUrl: args.certifierUrl,\n        fields: validateCertificateFields(args.fields),\n        privileged: defaultFalse(args.privileged),\n        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),\n        subject: ''\n    };\n    return vargs;\n}\nfunction validateAcquireDirectCertificateArgs(args) {\n    if (args.acquisitionProtocol !== 'direct')\n        throw new index_client_1.sdk.WERR_INTERNAL('Only acquire direct certificate requests allowed here.');\n    if (!args.serialNumber)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('serialNumber', 'valid when acquisitionProtocol is \"direct\"');\n    if (!args.signature)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('signature', 'valid when acquisitionProtocol is \"direct\"');\n    if (!args.revocationOutpoint)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('revocationOutpoint', 'valid when acquisitionProtocol is \"direct\"');\n    if (!args.keyringRevealer)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringRevealer', 'valid when acquisitionProtocol is \"direct\"');\n    if (!args.keyringForSubject)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('keyringForSubject', 'valid when acquisitionProtocol is \"direct\"');\n    if (args.privileged && !args.privilegedReason)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);\n    const vargs = {\n        type: validateBase64String(args.type, 'type'),\n        serialNumber: validateBase64String(args.serialNumber, 'serialNumber'),\n        certifier: validateHexString(args.certifier, 'certifier'),\n        revocationOutpoint: validateOutpointString(args.revocationOutpoint, 'revocationOutpoint'),\n        fields: validateCertificateFields(args.fields),\n        signature: validateHexString(args.signature, 'signature'),\n        keyringRevealer: validateKeyringRevealer(args.keyringRevealer, 'keyringRevealer'),\n        keyringForSubject: validateKeyringForSubject(args.keyringForSubject, 'keyringForSubject'),\n        privileged: defaultFalse(args.privileged),\n        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50),\n        subject: ''\n    };\n    return vargs;\n}\nfunction validateProveCertificateArgs(args) {\n    if (args.privileged && !args.privilegedReason)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('privilegedReason', `valid when 'privileged' is true `);\n    const vargs = {\n        type: validateOptionalBase64String(args.certificate.type, 'certificate.type'),\n        serialNumber: validateOptionalBase64String(args.certificate.serialNumber, 'certificate.serialNumber'),\n        certifier: validateOptionalHexString(args.certificate.certifier, 'certificate.certifier'),\n        subject: validateOptionalHexString(args.certificate.subject, 'certificate.subject'),\n        revocationOutpoint: validateOptionalOutpointString(args.certificate.revocationOutpoint, 'certificate.revocationOutpoint'),\n        signature: validateOptionalHexString(args.certificate.signature, 'certificate.signature'),\n        fieldsToReveal: defaultEmpty(args.fieldsToReveal).map(fieldName => validateStringLength(fieldName, `fieldsToReveal ${fieldName}`, 1, 50)),\n        verifier: validateHexString(args.verifier, 'verifier'),\n        privileged: defaultFalse(args.privileged),\n        privilegedReason: validateOptionalStringLength(args.privilegedReason, 'privilegedReason', 5, 50)\n    };\n    return vargs;\n}\nfunction validateDiscoverByIdentityKeyArgs(args) {\n    const vargs = {\n        identityKey: validateHexString(args.identityKey, 'identityKey', 66, 66),\n        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),\n        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),\n        seekPermission: defaultFalse(args.seekPermission)\n    };\n    return vargs;\n}\nfunction validateAttributes(attributes) {\n    for (const fieldName of Object.keys(attributes)) {\n        validateStringLength(fieldName, `field name ${fieldName}`, 1, 50);\n    }\n    return attributes;\n}\nfunction validateDiscoverByAttributesArgs(args) {\n    const vargs = {\n        attributes: validateAttributes(args.attributes),\n        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),\n        offset: validatePositiveIntegerOrZero(defaultZero(args.offset), 'offset'),\n        seekPermission: defaultFalse(args.seekPermission)\n    };\n    return vargs;\n}\n/**\n * @param {BasketStringUnder300Bytes} args.basket - Required. The associated basket name whose outputs should be listed.\n * @param {OutputTagStringUnder300Bytes[]} [args.tags] - Optional. Filter outputs based on these tags.\n * @param {'all' | 'any'} [args.tagQueryMode] - Optional. Filter mode, defining whether all or any of the tags must match. By default, any tag can match.\n * @param {'locking scripts' | 'entire transactions'} [args.include] - Optional. Whether to include locking scripts (with each output) or entire transactions (as aggregated BEEF, at the top level) in the result. By default, unless specified, neither are returned.\n * @param {BooleanDefaultFalse} [args.includeEntireTransactions] - Optional. Whether to include the entire transaction(s) in the result.\n * @param {BooleanDefaultFalse} [args.includeCustomInstructions] - Optional. Whether custom instructions should be returned in the result.\n * @param {BooleanDefaultFalse} [args.includeTags] - Optional. Whether the tags associated with the output should be returned.\n * @param {BooleanDefaultFalse} [args.includeLabels] - Optional. Whether the labels associated with the transaction containing the output should be returned.\n * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional limit on the number of outputs to return.\n * @param {PositiveIntegerOrZero} [args.offset] - Optional. Number of outputs to skip before starting to return results.\n * @param {BooleanDefaultTrue} [args.seekPermission]  Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.\n */\nfunction validateListOutputsArgs(args) {\n    let tagQueryMode;\n    if (args.tagQueryMode === undefined || args.tagQueryMode === 'any')\n        tagQueryMode = 'any';\n    else if (args.tagQueryMode === 'all')\n        tagQueryMode = 'all';\n    else\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tagQueryMode', `undefined, 'any', or 'all'`);\n    const vargs = {\n        basket: validateStringLength(args.basket, 'basket', 1, 300),\n        tags: (args.tags || []).map(t => validateStringLength(t, 'tag', 1, 300)),\n        tagQueryMode,\n        includeLockingScripts: args.include === 'locking scripts',\n        includeTransactions: args.include === 'entire transactions',\n        includeCustomInstructions: defaultFalse(args.includeCustomInstructions),\n        includeTags: defaultFalse(args.includeTags),\n        includeLabels: defaultFalse(args.includeLabels),\n        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),\n        offset: validateInteger(args.offset, 'offset', 0, 0),\n        seekPermission: defaultTrue(args.seekPermission),\n        knownTxids: []\n    };\n    return vargs;\n}\n/**\n * @param {LabelStringUnder300Bytes[]} args.labels - An array of labels used to filter actions.\n * @param {'any' | 'all'} [args.labelQueryMode] - Optional. Specifies how to match labels (default is any which matches any of the labels).\n * @param {BooleanDefaultFalse} [args.includeLabels] - Optional. Whether to include transaction labels in the result set.\n * @param {BooleanDefaultFalse} [args.includeInputs] - Optional. Whether to include input details in the result set.\n * @param {BooleanDefaultFalse} [args.includeInputSourceLockingScripts] - Optional. Whether to include input source locking scripts in the result set.\n * @param {BooleanDefaultFalse} [args.includeInputUnlockingScripts] - Optional. Whether to include input unlocking scripts in the result set.\n * @param {BooleanDefaultFalse} [args.includeOutputs] - Optional. Whether to include output details in the result set.\n * @param {BooleanDefaultFalse} [args.includeOutputLockingScripts] - Optional. Whether to include output locking scripts in the result set.\n * @param {PositiveIntegerDefault10Max10000} [args.limit] - Optional. The maximum number of transactions to retrieve.\n * @param {PositiveIntegerOrZero} [args.offset] - Optional. Number of transactions to skip before starting to return the results.\n * @param {BooleanDefaultTrue} [args.seekPermission]  Optional. Whether to seek permission from the user for this operation if required. Default true, will return an error rather than proceed if set to false.\n */\nfunction validateListActionsArgs(args) {\n    let labelQueryMode;\n    if (args.labelQueryMode === undefined || args.labelQueryMode === 'any')\n        labelQueryMode = 'any';\n    else if (args.labelQueryMode === 'all')\n        labelQueryMode = 'all';\n    else\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('labelQueryMode', `undefined, 'any', or 'all'`);\n    const vargs = {\n        labels: (args.labels || []).map(t => validateLabel(t)),\n        labelQueryMode,\n        includeLabels: defaultFalse(args.includeLabels),\n        includeInputs: defaultFalse(args.includeInputs),\n        includeInputSourceLockingScripts: defaultFalse(args.includeInputSourceLockingScripts),\n        includeInputUnlockingScripts: defaultFalse(args.includeInputUnlockingScripts),\n        includeOutputs: defaultFalse(args.includeOutputs),\n        includeOutputLockingScripts: defaultFalse(args.includeOutputLockingScripts),\n        limit: validateInteger(args.limit, 'limit', 10, 1, 10000),\n        offset: validateInteger(args.offset, 'offset', 0, 0),\n        seekPermission: defaultTrue(args.seekPermission)\n    };\n    return vargs;\n}\n//# sourceMappingURL=validationHelpers.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/validationHelpers.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/ServiceCollection.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/ServiceCollection.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServiceCollection = void 0;\nconst MAX_RESET_COUNTS = 32;\nconst MAX_CALL_HISTORY = 32;\nclass ServiceCollection {\n    constructor(serviceName, services) {\n        this.serviceName = serviceName;\n        this._historyByProvider = {};\n        this.services = services || [];\n        this._index = 0;\n        this.since = new Date();\n    }\n    add(s) {\n        this.services.push(s);\n        return this;\n    }\n    remove(name) {\n        this.services = this.services.filter(s => s.name !== name);\n    }\n    get name() {\n        return this.services[this._index].name;\n    }\n    get service() {\n        return this.services[this._index].service;\n    }\n    getServiceToCall(i) {\n        const name = this.services[i].name;\n        const service = this.services[i].service;\n        const call = { name, when: new Date(), msecs: 0, success: false, result: undefined, error: undefined };\n        return { serviceName: this.serviceName, providerName: name, service, call };\n    }\n    get serviceToCall() {\n        return this.getServiceToCall(this._index);\n    }\n    get allServicesToCall() {\n        const all = [];\n        for (let i = 0; i < this.services.length; i++) {\n            all.push(this.getServiceToCall(i));\n        }\n        return all;\n    }\n    /**\n     * Used to de-prioritize a service call by moving it to the end of the list.\n     * @param stc\n     */\n    moveServiceToLast(stc) {\n        const index = this.services.findIndex(s => s.name === stc.providerName);\n        if (index !== -1) {\n            const [service] = this.services.splice(index, 1);\n            this.services.push(service);\n        }\n    }\n    get allServices() {\n        return this.services.map(x => x.service);\n    }\n    get count() {\n        return this.services.length;\n    }\n    get index() {\n        return this._index;\n    }\n    reset() {\n        this._index = 0;\n    }\n    next() {\n        this._index = (this._index + 1) % this.count;\n        return this._index;\n    }\n    clone() {\n        return new ServiceCollection(this.serviceName, [...this.services]);\n    }\n    _addServiceCall(providerName, call) {\n        const now = new Date();\n        let h = this._historyByProvider[providerName];\n        if (!h) {\n            h = {\n                serviceName: this.serviceName,\n                providerName: providerName,\n                calls: [],\n                totalCounts: { success: 0, failure: 0, error: 0, since: this.since, until: now },\n                resetCounts: [{ success: 0, failure: 0, error: 0, since: this.since, until: now }]\n            };\n            this._historyByProvider[providerName] = h;\n        }\n        h.calls.unshift(call);\n        h.calls = h.calls.slice(0, MAX_CALL_HISTORY);\n        h.totalCounts.until = now;\n        h.resetCounts[0].until = now;\n        return h;\n    }\n    getDuration(since) {\n        const now = new Date();\n        if (typeof since === 'string')\n            since = new Date(since);\n        return now.getTime() - since.getTime();\n    }\n    addServiceCallSuccess(stc, result) {\n        const call = stc.call;\n        call.success = true;\n        call.result = result;\n        call.error = undefined;\n        call.msecs = this.getDuration(call.when);\n        const h = this._addServiceCall(stc.providerName, call);\n        h.totalCounts.success++;\n        h.resetCounts[0].success++;\n    }\n    addServiceCallFailure(stc, result) {\n        const call = stc.call;\n        call.success = false;\n        call.result = result;\n        call.error = undefined;\n        call.msecs = this.getDuration(call.when);\n        const h = this._addServiceCall(this.name, call);\n        h.totalCounts.failure++;\n        h.resetCounts[0].failure++;\n    }\n    addServiceCallError(stc, error) {\n        const call = stc.call;\n        call.success = false;\n        call.result = undefined;\n        call.error = error;\n        call.msecs = this.getDuration(call.when);\n        const h = this._addServiceCall(this.name, call);\n        h.totalCounts.failure++;\n        h.totalCounts.error++;\n        h.resetCounts[0].failure++;\n        h.resetCounts[0].error++;\n    }\n    /**\n     * @returns A copy of current service call history\n     */\n    getServiceCallHistory(reset) {\n        const now = new Date();\n        const history = { serviceName: this.serviceName, historyByProvider: {} };\n        for (const name of Object.keys(this._historyByProvider)) {\n            const h = this._historyByProvider[name];\n            const c = {\n                serviceName: h.serviceName,\n                providerName: h.providerName,\n                calls: h.calls.map(c => ({\n                    when: dateToString(c.when),\n                    msecs: c.msecs,\n                    success: c.success,\n                    result: c.result,\n                    error: c.error ? { message: c.error.message, code: c.error.code } : undefined\n                })),\n                totalCounts: {\n                    success: h.totalCounts.success,\n                    failure: h.totalCounts.failure,\n                    error: h.totalCounts.error,\n                    since: dateToString(h.totalCounts.since),\n                    until: dateToString(h.totalCounts.until)\n                },\n                resetCounts: []\n            };\n            for (let i = 0; i < h.resetCounts.length; i++) {\n                const r = h.resetCounts[i];\n                c.resetCounts.push({\n                    success: r.success,\n                    failure: r.failure,\n                    error: r.error,\n                    since: dateToString(r.since),\n                    until: dateToString(r.until)\n                });\n            }\n            history.historyByProvider[name] = c;\n            if (reset) {\n                // Make sure intervals are continuous.\n                h.resetCounts[0].until = now;\n                // insert a new resetCounts interval\n                h.resetCounts.unshift({\n                    success: 0,\n                    failure: 0,\n                    error: 0,\n                    // start of new interval\n                    since: now,\n                    // end of new interval, gets bumped with each new call added\n                    until: now\n                });\n                // limit history to most recent intervals\n                h.resetCounts = h.resetCounts.slice(0, MAX_CALL_HISTORY);\n            }\n        }\n        return history;\n        function dateToString(d) {\n            return typeof d === 'string' ? d : d.toISOString();\n        }\n    }\n}\nexports.ServiceCollection = ServiceCollection;\n//# sourceMappingURL=ServiceCollection.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/ServiceCollection.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Services = void 0;\nexports.validateScriptHash = validateScriptHash;\nexports.toBinaryBaseBlockHeader = toBinaryBaseBlockHeader;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst ServiceCollection_1 = __webpack_require__(/*! ./ServiceCollection */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/ServiceCollection.js\");\nconst createDefaultWalletServicesOptions_1 = __webpack_require__(/*! ./createDefaultWalletServicesOptions */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/createDefaultWalletServicesOptions.js\");\nconst chaintracker_1 = __webpack_require__(/*! ./chaintracker */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/index.js\");\nconst WhatsOnChain_1 = __webpack_require__(/*! ./providers/WhatsOnChain */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/WhatsOnChain.js\");\nconst echangeRates_1 = __webpack_require__(/*! ./providers/echangeRates */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/echangeRates.js\");\nconst ARC_1 = __webpack_require__(/*! ./providers/ARC */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/ARC.js\");\nconst Bitails_1 = __webpack_require__(/*! ./providers/Bitails */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/Bitails.js\");\nconst getBeefForTxid_1 = __webpack_require__(/*! ./providers/getBeefForTxid */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/getBeefForTxid.js\");\nclass Services {\n    static createDefaultOptions(chain) {\n        return (0, createDefaultWalletServicesOptions_1.createDefaultWalletServicesOptions)(chain);\n    }\n    constructor(optionsOrChain) {\n        this.postBeefMode = 'UntilSuccess';\n        this.targetCurrencies = ['USD', 'GBP', 'EUR'];\n        this.chain = typeof optionsOrChain === 'string' ? optionsOrChain : optionsOrChain.chain;\n        this.options = typeof optionsOrChain === 'string' ? Services.createDefaultOptions(this.chain) : optionsOrChain;\n        this.whatsonchain = new WhatsOnChain_1.WhatsOnChain(this.chain, { apiKey: this.options.whatsOnChainApiKey }, this);\n        this.arcTaal = new ARC_1.ARC(this.options.arcUrl, this.options.arcConfig, 'arcTaal');\n        if (this.options.arcGorillaPoolUrl) {\n            this.arcGorillaPool = new ARC_1.ARC(this.options.arcGorillaPoolUrl, this.options.arcGorillaPoolConfig, 'arcGorillaPool');\n        }\n        this.bitails = new Bitails_1.Bitails(this.chain);\n        //prettier-ignore\n        this.getMerklePathServices = new ServiceCollection_1.ServiceCollection('getMerklePath')\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.getMerklePath.bind(this.whatsonchain) })\n            .add({ name: 'Bitails', service: this.bitails.getMerklePath.bind(this.bitails) });\n        //prettier-ignore\n        this.getRawTxServices = new ServiceCollection_1.ServiceCollection('getRawTx')\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.getRawTxResult.bind(this.whatsonchain) });\n        this.postBeefServices = new ServiceCollection_1.ServiceCollection('postBeef');\n        if (this.arcGorillaPool) {\n            //prettier-ignore\n            this.postBeefServices.add({ name: 'GorillaPoolArcBeef', service: this.arcGorillaPool.postBeef.bind(this.arcGorillaPool) });\n        }\n        //prettier-ignore\n        this.postBeefServices\n            .add({ name: 'TaalArcBeef', service: this.arcTaal.postBeef.bind(this.arcTaal) })\n            .add({ name: 'Bitails', service: this.bitails.postBeef.bind(this.bitails) })\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.postBeef.bind(this.whatsonchain) });\n        //prettier-ignore\n        this.getUtxoStatusServices = new ServiceCollection_1.ServiceCollection('getUtxoStatus')\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.getUtxoStatus.bind(this.whatsonchain) });\n        //prettier-ignore\n        this.getStatusForTxidsServices = new ServiceCollection_1.ServiceCollection('getStatusForTxids')\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.getStatusForTxids.bind(this.whatsonchain) });\n        //prettier-ignore\n        this.getScriptHashHistoryServices = new ServiceCollection_1.ServiceCollection('getScriptHashHistory')\n            .add({ name: 'WhatsOnChain', service: this.whatsonchain.getScriptHashHistory.bind(this.whatsonchain) });\n        //prettier-ignore\n        this.updateFiatExchangeRateServices = new ServiceCollection_1.ServiceCollection('updateFiatExchangeRate')\n            .add({ name: 'ChaintracksService', service: echangeRates_1.updateChaintracksFiatExchangeRates })\n            .add({ name: 'exchangeratesapi', service: echangeRates_1.updateExchangeratesapi });\n    }\n    getServicesCallHistory(reset) {\n        return {\n            version: 2,\n            getMerklePath: this.getMerklePathServices.getServiceCallHistory(reset),\n            getRawTx: this.getRawTxServices.getServiceCallHistory(reset),\n            postBeef: this.postBeefServices.getServiceCallHistory(reset),\n            getUtxoStatus: this.getUtxoStatusServices.getServiceCallHistory(reset),\n            getStatusForTxids: this.getStatusForTxidsServices.getServiceCallHistory(reset),\n            getScriptHashHistory: this.getScriptHashHistoryServices.getServiceCallHistory(reset),\n            updateFiatExchangeRates: this.updateFiatExchangeRateServices.getServiceCallHistory(reset)\n        };\n    }\n    async getChainTracker() {\n        if (!this.options.chaintracks)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('options.chaintracks', `valid to enable 'getChainTracker' service.`);\n        return new chaintracker_1.ChaintracksChainTracker(this.chain, this.options.chaintracks);\n    }\n    async getBsvExchangeRate() {\n        this.options.bsvExchangeRate = await this.whatsonchain.updateBsvExchangeRate(this.options.bsvExchangeRate, this.options.bsvUpdateMsecs);\n        return this.options.bsvExchangeRate.rate;\n    }\n    async getFiatExchangeRate(currency, base) {\n        const rates = await this.updateFiatExchangeRates(this.options.fiatExchangeRates, this.options.fiatUpdateMsecs);\n        this.options.fiatExchangeRates = rates;\n        base || (base = 'USD');\n        const rate = rates.rates[currency] / rates.rates[base];\n        return rate;\n    }\n    get getProofsCount() {\n        return this.getMerklePathServices.count;\n    }\n    get getRawTxsCount() {\n        return this.getRawTxServices.count;\n    }\n    get postBeefServicesCount() {\n        return this.postBeefServices.count;\n    }\n    get getUtxoStatsCount() {\n        return this.getUtxoStatusServices.count;\n    }\n    async getStatusForTxids(txids, useNext) {\n        const services = this.getStatusForTxidsServices;\n        if (useNext)\n            services.next();\n        let r0 = {\n            name: '<noservices>',\n            status: 'error',\n            error: new index_client_1.sdk.WERR_INTERNAL('No services available.'),\n            results: []\n        };\n        for (let tries = 0; tries < services.count; tries++) {\n            const stc = services.serviceToCall;\n            try {\n                const r = await stc.service(txids);\n                if (r.status === 'success') {\n                    services.addServiceCallSuccess(stc);\n                    r0 = r;\n                    break;\n                }\n                else {\n                    if (r.error)\n                        services.addServiceCallError(stc, r.error);\n                    else\n                        services.addServiceCallFailure(stc);\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                services.addServiceCallError(stc, e);\n            }\n            services.next();\n        }\n        return r0;\n    }\n    /**\n     * @param script Output script to be hashed for `getUtxoStatus` default `outputFormat`\n     * @returns script hash in 'hashLE' format, which is the default.\n     */\n    hashOutputScript(script) {\n        const hash = sdk_1.Utils.toHex((0, index_client_1.sha256Hash)(sdk_1.Utils.toArray(script, 'hex')));\n        return hash;\n    }\n    async isUtxo(output) {\n        if (!output.lockingScript) {\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('output.lockingScript', 'validated by storage provider validateOutputScript.');\n        }\n        const hash = this.hashOutputScript(sdk_1.Utils.toHex(output.lockingScript));\n        const or = await this.getUtxoStatus(hash, undefined, `${output.txid}.${output.vout}`);\n        return or.isUtxo === true;\n    }\n    async getUtxoStatus(output, outputFormat, outpoint, useNext) {\n        const services = this.getUtxoStatusServices;\n        if (useNext)\n            services.next();\n        let r0 = {\n            name: '<noservices>',\n            status: 'error',\n            error: new index_client_1.sdk.WERR_INTERNAL('No services available.'),\n            details: []\n        };\n        for (let retry = 0; retry < 2; retry++) {\n            for (let tries = 0; tries < services.count; tries++) {\n                const stc = services.serviceToCall;\n                try {\n                    const r = await stc.service(output, outputFormat, outpoint);\n                    if (r.status === 'success') {\n                        services.addServiceCallSuccess(stc);\n                        r0 = r;\n                        break;\n                    }\n                    else {\n                        if (r.error)\n                            services.addServiceCallError(stc, r.error);\n                        else\n                            services.addServiceCallFailure(stc);\n                    }\n                }\n                catch (eu) {\n                    const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                    services.addServiceCallError(stc, e);\n                }\n                services.next();\n            }\n            if (r0.status === 'success')\n                break;\n            await (0, index_client_1.wait)(2000);\n        }\n        return r0;\n    }\n    async getScriptHashHistory(hash, useNext) {\n        const services = this.getScriptHashHistoryServices;\n        if (useNext)\n            services.next();\n        let r0 = {\n            name: '<noservices>',\n            status: 'error',\n            error: new index_client_1.sdk.WERR_INTERNAL('No services available.'),\n            history: []\n        };\n        for (let tries = 0; tries < services.count; tries++) {\n            const stc = services.serviceToCall;\n            try {\n                const r = await stc.service(hash);\n                if (r.status === 'success') {\n                    r0 = r;\n                    break;\n                }\n                else {\n                    if (r.error)\n                        services.addServiceCallError(stc, r.error);\n                    else\n                        services.addServiceCallFailure(stc);\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                services.addServiceCallError(stc, e);\n            }\n            services.next();\n        }\n        return r0;\n    }\n    /**\n     *\n     * @param beef\n     * @param chain\n     * @returns\n     */\n    async postBeef(beef, txids) {\n        let rs = [];\n        const services = this.postBeefServices;\n        const stcs = services.allServicesToCall;\n        switch (this.postBeefMode) {\n            case 'UntilSuccess':\n                {\n                    for (const stc of stcs) {\n                        const r = await callService(stc);\n                        rs.push(r);\n                        if (r.status === 'success')\n                            break;\n                        if (r.txidResults && r.txidResults.every(txr => txr.serviceError)) {\n                            // move this service to the end of the list\n                            this.postBeefServices.moveServiceToLast(stc);\n                        }\n                    }\n                }\n                break;\n            case 'PromiseAll':\n                {\n                    rs = await Promise.all(stcs.map(async (stc) => {\n                        const r = await callService(stc);\n                        return r;\n                    }));\n                }\n                break;\n        }\n        return rs;\n        async function callService(stc) {\n            const r = await stc.service(beef, txids);\n            if (r.status === 'success') {\n                services.addServiceCallSuccess(stc);\n            }\n            else {\n                if (r.error) {\n                    services.addServiceCallError(stc, r.error);\n                }\n                else {\n                    services.addServiceCallFailure(stc);\n                }\n            }\n            return r;\n        }\n    }\n    async getRawTx(txid, useNext) {\n        const services = this.getRawTxServices;\n        if (useNext)\n            services.next();\n        const r0 = { txid };\n        for (let tries = 0; tries < services.count; tries++) {\n            const stc = services.serviceToCall;\n            try {\n                const r = await stc.service(txid, this.chain);\n                if (r.rawTx) {\n                    const hash = (0, index_client_1.asString)((0, index_client_1.doubleSha256BE)(r.rawTx));\n                    // Confirm transaction hash matches txid\n                    if (hash === (0, index_client_1.asString)(txid)) {\n                        // If we have a match, call it done.\n                        r0.rawTx = r.rawTx;\n                        r0.name = r.name;\n                        r0.error = undefined;\n                        services.addServiceCallSuccess(stc);\n                        break;\n                    }\n                    r.error = new index_client_1.sdk.WERR_INTERNAL(`computed txid ${hash} doesn't match requested value ${txid}`);\n                    r.rawTx = undefined;\n                }\n                if (r.error)\n                    services.addServiceCallError(stc, r.error);\n                else if (!r.rawTx)\n                    services.addServiceCallSuccess(stc, `not found`);\n                else\n                    services.addServiceCallFailure(stc);\n                if (r.error && !r0.error && !r0.rawTx)\n                    // If we have an error and didn't before...\n                    r0.error = r.error;\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                services.addServiceCallError(stc, e);\n            }\n            services.next();\n        }\n        return r0;\n    }\n    async invokeChaintracksWithRetry(method) {\n        if (!this.options.chaintracks)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('options.chaintracks', 'valid for this service operation.');\n        for (let retry = 0; retry < 3; retry++) {\n            try {\n                const r = await method();\n                return r;\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                if (e.code != 'ECONNRESET')\n                    throw eu;\n            }\n        }\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('hashToHeader service unavailable');\n    }\n    async getHeaderForHeight(height) {\n        const method = async () => {\n            const header = await this.options.chaintracks.findHeaderForHeight(height);\n            if (!header)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('hash', `valid height '${height}' on mined chain ${this.chain}`);\n            return toBinaryBaseBlockHeader(header);\n        };\n        return this.invokeChaintracksWithRetry(method);\n    }\n    async getHeight() {\n        const method = async () => {\n            return await this.options.chaintracks.currentHeight();\n        };\n        return this.invokeChaintracksWithRetry(method);\n    }\n    async hashToHeader(hash) {\n        const method = async () => {\n            const header = await this.options.chaintracks.findHeaderForBlockHash(hash);\n            if (!header)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('hash', `valid blockhash '${hash}' on mined chain ${this.chain}`);\n            return header;\n        };\n        return this.invokeChaintracksWithRetry(method);\n    }\n    async getMerklePath(txid, useNext) {\n        const services = this.getMerklePathServices;\n        if (useNext)\n            services.next();\n        const r0 = { notes: [] };\n        for (let tries = 0; tries < services.count; tries++) {\n            const stc = services.serviceToCall;\n            try {\n                const r = await stc.service(txid, this);\n                if (r.notes)\n                    r0.notes.push(...r.notes);\n                if (!r0.name)\n                    r0.name = r.name;\n                if (r.merklePath) {\n                    // If we have a proof, call it done.\n                    r0.merklePath = r.merklePath;\n                    r0.header = r.header;\n                    r0.name = r.name;\n                    r0.error = undefined;\n                    services.addServiceCallSuccess(stc);\n                    break;\n                }\n                if (r.error)\n                    services.addServiceCallError(stc, r.error);\n                else\n                    services.addServiceCallFailure(stc);\n                if (r.error && !r0.error) {\n                    // If we have an error and didn't before...\n                    r0.error = r.error;\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                services.addServiceCallError(stc, e);\n            }\n            services.next();\n        }\n        return r0;\n    }\n    async updateFiatExchangeRates(rates, updateMsecs) {\n        updateMsecs || (updateMsecs = 1000 * 60 * 15);\n        const freshnessDate = new Date(Date.now() - updateMsecs);\n        if (rates) {\n            // Check if the rate we know is stale enough to update.\n            updateMsecs || (updateMsecs = 1000 * 60 * 15);\n            if (rates.timestamp > freshnessDate)\n                return rates;\n        }\n        // Make sure we always start with the first service listed (chaintracks aggregator)\n        const services = this.updateFiatExchangeRateServices.clone();\n        let r0;\n        for (let tries = 0; tries < services.count; tries++) {\n            const stc = services.serviceToCall;\n            try {\n                const r = await stc.service(this.targetCurrencies, this.options);\n                if (this.targetCurrencies.every(c => typeof r.rates[c] === 'number')) {\n                    services.addServiceCallSuccess(stc);\n                    r0 = r;\n                    break;\n                }\n                else {\n                    services.addServiceCallFailure(stc);\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                services.addServiceCallError(stc, e);\n            }\n            services.next();\n        }\n        if (!r0) {\n            console.error('Failed to update fiat exchange rates.');\n            if (!rates)\n                throw new index_client_1.sdk.WERR_INTERNAL();\n            return rates;\n        }\n        return r0;\n    }\n    async nLockTimeIsFinal(tx) {\n        const MAXINT = 0xffffffff;\n        const BLOCK_LIMIT = 500000000;\n        let nLockTime;\n        if (typeof tx === 'number')\n            nLockTime = tx;\n        else {\n            if (typeof tx === 'string') {\n                tx = sdk_1.Transaction.fromHex(tx);\n            }\n            else if (Array.isArray(tx)) {\n                tx = sdk_1.Transaction.fromBinary(tx);\n            }\n            if (tx instanceof sdk_1.Transaction) {\n                if (tx.inputs.every(i => i.sequence === MAXINT)) {\n                    return true;\n                }\n                nLockTime = tx.lockTime;\n            }\n            else {\n                throw new index_client_1.sdk.WERR_INTERNAL('Should be either @bsv/sdk Transaction or babbage-bsv Transaction');\n            }\n        }\n        if (nLockTime >= BLOCK_LIMIT) {\n            const limit = Math.floor(Date.now() / 1000);\n            return nLockTime < limit;\n        }\n        const height = await this.getHeight();\n        return nLockTime < height;\n    }\n    async getBeefForTxid(txid) {\n        const beef = await (0, getBeefForTxid_1.getBeefForTxid)(this, txid);\n        return beef;\n    }\n}\nexports.Services = Services;\nfunction validateScriptHash(output, outputFormat) {\n    let b = (0, index_client_1.asArray)(output);\n    if (!outputFormat) {\n        if (b.length === 32)\n            outputFormat = 'hashLE';\n        else\n            outputFormat = 'script';\n    }\n    switch (outputFormat) {\n        case 'hashBE':\n            break;\n        case 'hashLE':\n            b = b.reverse();\n            break;\n        case 'script':\n            b = (0, index_client_1.sha256Hash)(b).reverse();\n            break;\n        default:\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputFormat', `not be ${outputFormat}`);\n    }\n    return (0, index_client_1.asString)(b);\n}\n/**\n * Serializes a block header as an 80 byte array.\n * The exact serialized format is defined in the Bitcoin White Paper\n * such that computing a double sha256 hash of the array computes\n * the block hash for the header.\n * @returns 80 byte array\n * @publicbody\n */\nfunction toBinaryBaseBlockHeader(header) {\n    const writer = new sdk_1.Utils.Writer();\n    writer.writeUInt32BE(header.version);\n    writer.writeReverse((0, index_client_1.asArray)(header.previousHash));\n    writer.writeReverse((0, index_client_1.asArray)(header.merkleRoot));\n    writer.writeUInt32BE(header.time);\n    writer.writeUInt32BE(header.bits);\n    writer.writeUInt32BE(header.nonce);\n    const r = writer.toArray();\n    return r;\n}\n//# sourceMappingURL=Services.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/BHServiceClient.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/BHServiceClient.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BHServiceClient = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst ChaintracksServiceClient_1 = __webpack_require__(/*! ./chaintracks/ChaintracksServiceClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js\");\nconst blockHeaderUtilities_1 = __webpack_require__(/*! ./chaintracks/util/blockHeaderUtilities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/blockHeaderUtilities.js\");\nclass BHServiceClient {\n    constructor(chain, url, apiKey) {\n        this.bhs = new sdk_1.BlockHeadersService(url, { apiKey });\n        this.cache = {};\n        this.chain = chain;\n        this.serviceUrl = url;\n        this.options = ChaintracksServiceClient_1.ChaintracksServiceClient.createChaintracksServiceClientOptions();\n        this.options.useAuthrite = true;\n        this.apiKey = apiKey;\n    }\n    async currentHeight() {\n        return await this.bhs.currentHeight();\n    }\n    async isValidRootForHeight(root, height) {\n        const cachedRoot = this.cache[height];\n        if (cachedRoot) {\n            return cachedRoot === root;\n        }\n        const isValid = await this.bhs.isValidRootForHeight(root, height);\n        this.cache[height] = root;\n        return isValid;\n    }\n    async getPresentHeight() {\n        return await this.bhs.currentHeight();\n    }\n    async findHeaderForHeight(height) {\n        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/byHeight?height=${height}`);\n        const header = response === null || response === void 0 ? void 0 : response[0];\n        if (!header)\n            return undefined;\n        const formatted = {\n            version: header.version,\n            previousHash: header.prevBlockHash,\n            merkleRoot: header.merkleRoot,\n            time: header.creationTimestamp,\n            bits: header.difficultyTarget,\n            nonce: header.nonce,\n            height,\n            hash: header.hash\n        };\n        return formatted;\n    }\n    async findHeaderForBlockHash(hash) {\n        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/state/${hash}`);\n        if (!(response === null || response === void 0 ? void 0 : response.header))\n            return undefined;\n        const formatted = {\n            version: response.header.version,\n            previousHash: response.header.prevBlockHash,\n            merkleRoot: response.header.merkleRoot,\n            time: response.header.creationTimestamp,\n            bits: response.header.difficultyTarget,\n            nonce: response.header.nonce,\n            height: response.height,\n            hash: response.header.hash\n        };\n        return formatted;\n    }\n    async getHeaders(height, count) {\n        const response = await this.getJsonOrUndefined(`/api/v1/chain/header/byHeight?height=${height}&count=${count}`);\n        if (!response)\n            return '';\n        if (response.length < count)\n            throw new Error('Cannot retrieve enough headers');\n        const headers = response.map(response => {\n            const header = {\n                version: response.version,\n                previousHash: response.prevBlockHash,\n                merkleRoot: response.merkleRoot,\n                time: response.creationTimestamp,\n                bits: response.difficultyTarget,\n                nonce: response.nonce\n            };\n            return (0, blockHeaderUtilities_1.serializeBlockHeader)(header);\n        });\n        return headers.reduce((str, arr) => str + sdk_1.Utils.toHex(arr), '');\n    }\n    async findChainWorkForBlockHash(hash) {\n        throw new Error('Not implemented');\n    }\n    async findChainTipHeader() {\n        const response = await this.getJson('/api/v1/chain/tip/longest');\n        const formatted = {\n            version: response.header.version,\n            previousHash: response.header.prevBlockHash,\n            merkleRoot: response.header.merkleRoot,\n            time: response.header.creationTimestamp,\n            bits: response.header.difficultyTarget,\n            nonce: response.header.nonce,\n            height: response.height,\n            hash: response.header.hash\n        };\n        return formatted;\n    }\n    async getJsonOrUndefined(path) {\n        let e = undefined;\n        for (let retry = 0; retry < 3; retry++) {\n            try {\n                const r = await fetch(`${this.serviceUrl}${path}`, { headers: { Authorization: `Bearer ${this.apiKey}` } });\n                if (r.status !== 200)\n                    throw new Error(JSON.stringify(r));\n                const v = await r.json();\n                if (!v)\n                    return undefined;\n                return v;\n            }\n            catch (eu) {\n                e = eu;\n            }\n            if (e && e.name !== 'ECONNRESET')\n                break;\n        }\n        if (e)\n            throw e;\n    }\n    async getJson(path) {\n        const r = await this.getJsonOrUndefined(path);\n        if (r === undefined)\n            throw new Error('Value was undefined. Requested object may not exist.');\n        return r;\n    }\n    /*\n      Please note that all methods hereafter are included only to match the interface of ChaintracksServiceClient.\n    */\n    async postJsonVoid(path, params) {\n        throw new Error('Not implemented');\n    }\n    async addHeader(header) {\n        throw new Error('Not implemented');\n    }\n    async findHeaderForMerkleRoot(merkleRoot, height) {\n        throw new Error('Not implemented');\n    }\n    async startListening() {\n        throw new Error('Not implemented');\n    }\n    async listening() {\n        throw new Error('Not implemented');\n    }\n    async isSynchronized() {\n        throw new Error('Not implemented');\n    }\n    async getChain() {\n        return this.chain;\n    }\n    async isListening() {\n        throw new Error('Not implemented');\n    }\n    async getChainTipHeader() {\n        throw new Error('Not implemented');\n    }\n    async findChainTipHashHex() {\n        throw new Error('Not implemented');\n    }\n}\nexports.BHServiceClient = BHServiceClient;\n//# sourceMappingURL=BHServiceClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/BHServiceClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/ChaintracksChainTracker.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/ChaintracksChainTracker.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChaintracksChainTracker = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst ChaintracksServiceClient_1 = __webpack_require__(/*! ./chaintracks/ChaintracksServiceClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js\");\nclass ChaintracksChainTracker {\n    constructor(chain, chaintracks, options) {\n        chain || (chain = 'main');\n        this.chaintracks =\n            chaintracks !== null && chaintracks !== void 0 ? chaintracks : new ChaintracksServiceClient_1.ChaintracksServiceClient(chain, `https://npm-registry.babbage.systems:808${chain === 'main' ? '4' : '3'}`);\n        this.cache = {};\n        this.options = options || {};\n    }\n    async currentHeight() {\n        return await this.chaintracks.getPresentHeight();\n    }\n    async isValidRootForHeight(root, height) {\n        const cachedRoot = this.cache[height];\n        if (cachedRoot) {\n            return cachedRoot === root;\n        }\n        let header;\n        const retries = this.options.maxRetries || 3;\n        let error = undefined;\n        for (let tryCount = 1; tryCount <= retries; tryCount++) {\n            try {\n                header = await this.chaintracks.findHeaderForHeight(height);\n                if (!header) {\n                    return false;\n                }\n                break;\n            }\n            catch (eu) {\n                error = index_client_1.sdk.WalletError.fromUnknown(eu);\n                if (tryCount > retries) {\n                    throw error;\n                }\n                await (0, index_client_1.wait)(1000);\n            }\n        }\n        if (!header)\n            throw new index_client_1.sdk.WERR_INTERNAL('no header should have returned false or thrown an error.');\n        this.cache[height] = header.merkleRoot;\n        if (header.merkleRoot !== root) {\n            return false;\n        }\n        return true;\n    }\n}\nexports.ChaintracksChainTracker = ChaintracksChainTracker;\n//# sourceMappingURL=ChaintracksChainTracker.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/ChaintracksChainTracker.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/Api/BlockHeaderApi.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/Api/BlockHeaderApi.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isLive = isLive;\nexports.isBaseBlockHeader = isBaseBlockHeader;\nexports.isBlockHeader = isBlockHeader;\nexports.isLiveBlockHeader = isLiveBlockHeader;\n//\n// TYPE GUARDS\n//\n/**\n * Type guard function.\n * @publicbody\n */\nfunction isLive(header) {\n    return header.headerId !== undefined;\n}\n/**\n * Type guard function.\n * @publicbody\n */\nfunction isBaseBlockHeader(header) {\n    return typeof header.previousHash === 'string';\n}\n/**\n * Type guard function.\n * @publicbody\n */\nfunction isBlockHeader(header) {\n    return 'height' in header && typeof header.previousHash === 'string';\n}\n/**\n * Type guard function.\n * @publicbody\n */\nfunction isLiveBlockHeader(header) {\n    return 'chainwork' in header && typeof header.previousHash === 'string';\n}\n//# sourceMappingURL=BlockHeaderApi.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/Api/BlockHeaderApi.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ChaintracksServiceClient = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * Connects to a ChaintracksService to implement 'ChaintracksClientApi'\n *\n */\nclass ChaintracksServiceClient {\n    static createChaintracksServiceClientOptions() {\n        const options = {\n            useAuthrite: false\n        };\n        return options;\n    }\n    constructor(chain, serviceUrl, options) {\n        this.chain = chain;\n        this.serviceUrl = serviceUrl;\n        this.options = options || ChaintracksServiceClient.createChaintracksServiceClientOptions();\n    }\n    async currentHeight() {\n        return await this.getPresentHeight();\n    }\n    async isValidRootForHeight(root, height) {\n        const r = await this.findHeaderForHeight(height);\n        if (!r)\n            return false;\n        const isValid = root === (0, index_client_1.asString)(r.merkleRoot);\n        return isValid;\n    }\n    async getJsonOrUndefined(path) {\n        let e = undefined;\n        for (let retry = 0; retry < 3; retry++) {\n            try {\n                const r = await fetch(`${this.serviceUrl}${path}`);\n                const v = await r.json();\n                if (v.status === 'success')\n                    return v.value;\n                else\n                    e = new Error(JSON.stringify(v));\n            }\n            catch (eu) {\n                e = eu;\n            }\n            if (e && e.name !== 'ECONNRESET')\n                break;\n        }\n        if (e)\n            throw e;\n    }\n    async getJson(path) {\n        const r = await this.getJsonOrUndefined(path);\n        if (r === undefined)\n            throw new Error('Value was undefined. Requested object may not exist.');\n        return r;\n    }\n    async postJsonVoid(path, params) {\n        const headers = {};\n        headers['Content-Type'] = 'application/json';\n        const r = await fetch(`${this.serviceUrl}${path}`, {\n            body: JSON.stringify(params),\n            method: 'POST',\n            headers\n            //cache: 'no-cache',\n        });\n        try {\n            const s = await r.json();\n            if (s.status === 'success')\n                return;\n            throw new Error(JSON.stringify(s));\n        }\n        catch (e) {\n            console.log(`Exception: ${JSON.stringify(e)}`);\n            throw new Error(JSON.stringify(e));\n        }\n    }\n    //\n    // HTTP API FUNCTIONS\n    //\n    async addHeader(header) {\n        const r = await this.postJsonVoid('/addHeaderHex', header);\n        if (typeof r === 'string')\n            throw new Error(r);\n    }\n    async startListening() {\n        return await this.getJsonOrUndefined('/startListening');\n    }\n    async listening() {\n        return await this.getJsonOrUndefined('/listening');\n    }\n    async getChain() {\n        return this.chain;\n        //return await this.getJson('/getChain')\n    }\n    async isListening() {\n        return await this.getJson('/isListening');\n    }\n    async isSynchronized() {\n        return await this.getJson('/isSynchronized');\n    }\n    async getPresentHeight() {\n        return await this.getJson('/getPresentHeight');\n    }\n    async findChainTipHeader() {\n        return await this.getJson('/findChainTipHeaderHex');\n    }\n    async findChainTipHashHex() {\n        return await this.getJson('/findChainTipHashHex');\n    }\n    async getHeaders(height, count) {\n        return await this.getJson(`/getHeaders?height=${height}&count=${count}`);\n    }\n    async findHeaderForHeight(height) {\n        return await this.getJsonOrUndefined(`/findHeaderHexForHeight?height=${height}`);\n    }\n    async findChainWorkForBlockHash(hash) {\n        return await this.getJsonOrUndefined(`/findChainWorkHexForBlockHash?hash=${(0, index_client_1.asString)(hash)}`);\n    }\n    async findHeaderForBlockHash(hash) {\n        return await this.getJsonOrUndefined(`/findHeaderHexForBlockHash?hash=${(0, index_client_1.asString)(hash)}`);\n    }\n    async findHeaderForMerkleRoot(merkleRoot, height) {\n        return await this.getJsonOrUndefined(`/findHeaderHexForMerkleRoot?root=${(0, index_client_1.asString)(merkleRoot)}&height=${height}`);\n    }\n}\nexports.ChaintracksServiceClient = ChaintracksServiceClient;\n//# sourceMappingURL=ChaintracksServiceClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/index.js ***!
  \****************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./ChaintracksServiceClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/ChaintracksServiceClient.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Api/BlockHeaderApi */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/Api/BlockHeaderApi.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/blockHeaderUtilities.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/blockHeaderUtilities.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateBufferOfHeaders = validateBufferOfHeaders;\nexports.workBNtoBuffer = workBNtoBuffer;\nexports.isMoreWork = isMoreWork;\nexports.addWork = addWork;\nexports.subWork = subWork;\nexports.convertBitsToTarget = convertBitsToTarget;\nexports.convertBitsToWork = convertBitsToWork;\nexports.deserializeBaseBlockHeaders = deserializeBaseBlockHeaders;\nexports.deserializeBlockHeaders = deserializeBlockHeaders;\nexports.extractHashesAndRoots = extractHashesAndRoots;\nexports.validateHeaderFormat = validateHeaderFormat;\nexports.validateHeaderDifficulty = validateHeaderDifficulty;\nexports.blockHash = blockHash;\nexports.serializeBlockHeader = serializeBlockHeader;\nexports.deserializeBlockHeader = deserializeBlockHeader;\nexports.genesisHeader = genesisHeader;\nexports.genesisBuffer = genesisBuffer;\nexports.swapByteOrder = swapByteOrder;\nexports.convertUint32ToBuffer = convertUint32ToBuffer;\nexports.writeUInt32LE = writeUInt32LE;\nexports.writeUInt32BE = writeUInt32BE;\nexports.readUInt32LE = readUInt32LE;\nexports.readUInt32BE = readUInt32BE;\nexports.convertBufferToUint32 = convertBufferToUint32;\nconst dirtyHashes_1 = __webpack_require__(/*! ./dirtyHashes */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/dirtyHashes.js\");\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst utilityHelpers_buffer_1 = __webpack_require__(/*! ../../../../utility/utilityHelpers.buffer */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.buffer.js\");\nconst utilityHelpers_1 = __webpack_require__(/*! ../../../../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\n/**\n * Computes sha256 hash of file contents read as bytes with no encoding.\n * @param filepath Full filepath to file.\n * @param bufferSize Optional read buffer size to use. Defaults to 80,000 bytes.\n * @returns `{hash, length}` where `hash` is base64 string form of file hash and `length` is file length in bytes.\n */\n/*\nexport async function sha256HashOfBinaryFile(\n  filepath: string,\n  bufferSize = 80000\n): Promise<{ hash: string; length: number }> {\n  const file = await fs.open(filepath, 'r')\n  try {\n    let length = 0\n\n    const sha256 = new Hash.SHA256()\n    const readBuf = Buffer.alloc(bufferSize)\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const rr = await file.read(readBuf, 0, readBuf.length)\n      if (!rr.bytesRead) break\n      length += rr.bytesRead\n      sha256.update(asArray(rr.buffer))\n    }\n\n    return { hash: Utils.toBase64(sha256.digest()), length }\n  } finally {\n    await file.close()\n  }\n}\n*/\n/**\n * Validate headers contained in an array of bytes. The headers must be consecutive block headers, 80 bytes long,\n *  where the hash of each header equals the previousHash of the following header.\n * @param buffer Buffer of headers to be validated.\n * @param previousHash Expected previousHash of first header.\n * @param offset Optional starting offset within `buffer`.\n * @param count Optional number of headers to validate. Validates to end of buffer if missing.\n * @returns Header hash of last header validated or previousHash if there where none.\n */\nfunction validateBufferOfHeaders(buffer, previousHash, offset = 0, count = -1) {\n    if (count < 0)\n        count = Math.floor((buffer.length - offset) / 80);\n    count = Math.max(0, count);\n    let lastHeaderHash = previousHash;\n    for (let i = 0; i < count; i++) {\n        const headerStart = offset + i * 80;\n        const headerEnd = headerStart + 80;\n        if (headerEnd > buffer.length) {\n            throw {\n                message: `header ${i} missing bytes for header at offset ${headerStart} in buffer of length ${buffer.length}`\n            };\n        }\n        const header = buffer.slice(headerStart, headerEnd);\n        const hashPrev = (0, utilityHelpers_buffer_1.asString)(header.slice(4, 36).reverse());\n        if (lastHeaderHash !== hashPrev)\n            throw { message: `header ${i} invalid previousHash ${lastHeaderHash} vs ${hashPrev}` };\n        lastHeaderHash = (0, utilityHelpers_buffer_1.asString)((0, utilityHelpers_1.doubleSha256BE)(header));\n        (0, dirtyHashes_1.validateAgainstDirtyHashes)(lastHeaderHash);\n    }\n    return lastHeaderHash;\n}\n/**\n * @param work chainWork as a BigNumber\n * @returns Converted chainWork value from BN to hex string of 32 bytes.\n */\nfunction workBNtoBuffer(work) {\n    return work.toString(16).padStart(64, '0');\n}\n/**\n * Returns true if work1 is more work (greater than) work2\n */\nfunction isMoreWork(work1, work2) {\n    return new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work1), 16).gt(new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work2), 16));\n}\n/**\n * Add two Buffer encoded chainwork values\n * @returns Sum of work1 + work2 as Buffer encoded chainWork value\n */\nfunction addWork(work1, work2) {\n    const sum = new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work1), 16).add(new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work2), 16));\n    return workBNtoBuffer(sum);\n}\n/**\n * Subtract Buffer encoded chainwork values\n * @returns work1 - work2 as Buffer encoded chainWork value\n */\nfunction subWork(work1, work2) {\n    const sum = new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work1), 16).sub(new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(work2), 16));\n    return workBNtoBuffer(sum);\n}\n/**\n * Computes \"target\" value for 4 byte Bitcoin block header \"bits\" value.\n * @param bits number or converted from Buffer using `readUint32LE`\n * @returns 32 byte Buffer with \"target\" value\n */\nfunction convertBitsToTarget(bits) {\n    if (Array.isArray(bits))\n        bits = readUInt32LE(bits, 0);\n    const shift = (bits >> 24) & 0xff;\n    const data = bits & 0x007fffff;\n    const target = new sdk_1.BigNumber(data);\n    if (shift <= 3) {\n        target.iushrn(8 * (3 - shift));\n    }\n    else {\n        target.iushln(8 * (shift - 3));\n    }\n    return target;\n}\n/**\n * Computes \"chainWork\" value for 4 byte Bitcoin block header \"bits\" value.\n * @param bits number or converted from Buffer using `readUint32LE`\n * @returns 32 byte Buffer with \"chainWork\" value\n */\nfunction convertBitsToWork(bits) {\n    const target = convertBitsToTarget(bits);\n    // convert target to work\n    const work = target.notn(256).div(target.addn(1)).addn(1);\n    return work.toString(16).padStart(64, '0');\n}\nfunction deserializeBaseBlockHeaders(buffer, offset = 0, count) {\n    const headers = [];\n    while ((!count || headers.length < count) && offset + 80 <= buffer.length && offset >= 0) {\n        headers.push(deserializeBlockHeader(buffer, offset));\n        offset += 80;\n    }\n    return headers;\n}\nfunction deserializeBlockHeaders(firstHeight, buffer, offset = 0, count) {\n    const headers = [];\n    let nextHeight = firstHeight;\n    while ((!count || headers.length < count) && offset + 80 <= buffer.length && offset >= 0) {\n        const baseBuffer = buffer.slice(offset, offset + 80);\n        const base = deserializeBlockHeader(baseBuffer);\n        const header = {\n            ...base,\n            height: nextHeight++,\n            hash: (0, utilityHelpers_buffer_1.asString)(blockHash(baseBuffer))\n        };\n        headers.push(header);\n        offset += 80;\n    }\n    return headers;\n}\n/**\n * Extract an array of block hashes and of merkleRoots from a buffer of serialized block headers.\n * @param buffer\n */\nfunction extractHashesAndRoots(buffer) {\n    const hashes = [];\n    const merkleRoots = [];\n    for (let i = 0; i < buffer.length / 80; i++) {\n        const offset = i * 80;\n        const hash = (0, utilityHelpers_buffer_1.asBuffer)((0, utilityHelpers_1.doubleSha256LE)((0, utilityHelpers_buffer_1.asArray)(buffer.subarray(offset, 80 + offset))).reverse());\n        const merkleRoot = buffer.subarray(36 + offset, 68 + offset).reverse();\n        hashes.push(hash);\n        merkleRoots.push(merkleRoot);\n    }\n    return { hashes, merkleRoots };\n}\n/**\n * Given a block header, ensures that its format is correct. This does not\n * check its difficulty or validity relative to the chain of headers.\n *\n * Throws on format errors.\n *\n * @param The header to validate\n *\n * @returns true if the header is correctly formatted\n */\nfunction validateHeaderFormat(header) {\n    const ALLOWED_KEYS = {\n        version: true,\n        previousHash: true,\n        merkleRoot: true,\n        time: true,\n        bits: true,\n        nonce: true,\n        height: true,\n        hash: true\n    };\n    const UINT_MAX = 0xffffffff;\n    /**\n     * Root object checks\n     */\n    if (typeof header === 'undefined') {\n        throw new Error('Missing header.');\n    }\n    if (typeof header !== 'object') {\n        throw new Error('Header must be an object.');\n    }\n    if (!Object.keys(header).every(key => ALLOWED_KEYS[key])) {\n        throw new Error('Header contains extra properties.');\n    }\n    /**\n     * Version\n     */\n    if (typeof header.version !== 'number') {\n        throw new Error('Header version must be a number.');\n    }\n    if (!Number.isInteger(header.version)) {\n        throw new Error('Header version must be an integer.');\n    }\n    if (header.version < 0 || header.version > UINT_MAX) {\n        throw new Error(`Header version must be between 0 and ${UINT_MAX}.`);\n    }\n    /**\n     * Height\n     */\n    if (typeof header.height !== 'number') {\n        throw new Error('Header height must be a number.');\n    }\n    if (!Number.isInteger(header.height)) {\n        throw new Error('Header height must be an integer.');\n    }\n    if (header.height < 0 || header.height > UINT_MAX / 2) {\n        throw new Error(`Header version must be between 0 and ${UINT_MAX / 2}.`);\n    }\n    /**\n     * Previous hash\n     */\n    if (header.previousHash.length !== 64) {\n        throw new Error('Header previousHash must be 32 hex bytes.');\n    }\n    /**\n     * Merkle root\n     */\n    if (header.merkleRoot.length !== 64) {\n        throw new Error('Header merkleRoot must be 32 hex bytes.');\n    }\n    /**\n     * Time\n     */\n    if (typeof header.time !== 'number') {\n        throw new Error('Header time must be a number.');\n    }\n    if (!Number.isInteger(header.time)) {\n        throw new Error('Header time must be an integer.');\n    }\n    if (header.time < 0 || header.time > UINT_MAX) {\n        throw new Error(`Header time must be between 0 and ${UINT_MAX}.`);\n    }\n    /**\n     * Bits\n     */\n    if (typeof header.bits !== 'number') {\n        throw new Error('Header bits must be a number.');\n    }\n    if (!Number.isInteger(header.bits)) {\n        throw new Error('Header bits must be an integer.');\n    }\n    if (header.bits < 0 || header.bits > UINT_MAX) {\n        throw new Error(`Header bits must be between 0 and ${UINT_MAX}.`);\n    }\n    /**\n     * Nonce\n     */\n    if (typeof header.nonce !== 'number') {\n        throw new Error('Header nonce must be a number.');\n    }\n    if (!Number.isInteger(header.nonce)) {\n        throw new Error('Header nonce must be an integer.');\n    }\n    if (header.nonce < 0 || header.nonce > UINT_MAX) {\n        throw new Error(`Header nonce must be between 0 and ${UINT_MAX}.`);\n    }\n    /**\n     * Hash\n     */\n    if (header.hash.length !== 64) {\n        throw new Error('Header hash must be 32 hex bytes.');\n    }\n    if (header.hash !== (0, utilityHelpers_buffer_1.asString)(blockHash(header))) {\n        throw new Error('Header hash is invalid.');\n    }\n}\n/**\n * Ensures that a header has a valid proof-of-work\n * Requires chain is 'main'\n *\n * @param header The header to validate\n *\n * @returns true if the header is valid\n */\nfunction validateHeaderDifficulty(hash, bits) {\n    const hashBN = new sdk_1.BigNumber((0, utilityHelpers_buffer_1.asArray)(hash));\n    const target = convertBitsToTarget(bits);\n    if (hashBN.lte(target))\n        return true;\n    throw new Error('Block hash is not less than specified target.');\n}\n/**\n * Computes double sha256 hash of bitcoin block header\n * bytes are reversed to bigendian order\n *\n * If header is a Buffer, it is required to 80 bytes long\n * and in standard block header serialized encoding.\n *\n * @returns doule sha256 hash of header bytes reversed\n * @publicbody\n */\nfunction blockHash(header) {\n    const a = !Array.isArray(header) ? serializeBlockHeader(header) : header;\n    if (a.length !== 80)\n        throw new Error('Block header must be 80 bytes long.');\n    return (0, utilityHelpers_buffer_1.asString)((0, utilityHelpers_1.doubleSha256BE)(a));\n}\n/**\n * Serializes a block header as an 80 byte Buffer.\n * The exact serialized format is defined in the Bitcoin White Paper\n * such that computing a double sha256 hash of the buffer computes\n * the block hash for the header.\n * @returns 80 byte Buffer\n * @publicbody\n */\nfunction serializeBlockHeader(header, buffer, offset) {\n    const writer = new sdk_1.Utils.Writer();\n    writer.writeUInt32LE(header.version);\n    writer.write((0, utilityHelpers_buffer_1.asArray)(header.previousHash).reverse());\n    writer.write((0, utilityHelpers_buffer_1.asArray)(header.merkleRoot).reverse());\n    writer.writeUInt32LE(header.time);\n    writer.writeUInt32LE(header.bits);\n    writer.writeUInt32LE(header.nonce);\n    const data = writer.toArray();\n    if (buffer) {\n        offset || (offset = 0);\n        buffer.splice(offset, buffer.length, ...data);\n    }\n    return data;\n}\n/**\n * Deserialize a block header from an 80 byte buffer\n * @publicbody\n */\nfunction deserializeBlockHeader(buffer, offset = 0) {\n    const reader = new sdk_1.Utils.Reader(buffer, offset);\n    const header = {\n        version: reader.readUInt32LE(),\n        previousHash: (0, utilityHelpers_buffer_1.asString)(reader.read(32).reverse()),\n        merkleRoot: (0, utilityHelpers_buffer_1.asString)(reader.read(32).reverse()),\n        time: reader.readUInt32LE(),\n        bits: reader.readUInt32LE(),\n        nonce: reader.readUInt32LE()\n    };\n    return header;\n}\n/**\n * Returns the genesis block for the specified chain.\n * @publicbody\n */\nfunction genesisHeader(chain) {\n    return chain === 'main'\n        ? {\n            version: 1,\n            previousHash: '0000000000000000000000000000000000000000000000000000000000000000',\n            merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',\n            time: 1231006505,\n            bits: 486604799,\n            nonce: 2083236893,\n            height: 0,\n            hash: '000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f'\n        }\n        : {\n            version: 1,\n            previousHash: '0000000000000000000000000000000000000000000000000000000000000000',\n            merkleRoot: '4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b',\n            time: 1296688602,\n            bits: 486604799,\n            nonce: 414098458,\n            height: 0,\n            hash: '000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943'\n        };\n}\n/**\n * Returns the genesis block for the specified chain.\n * @publicbody\n */\nfunction genesisBuffer(chain) {\n    return serializeBlockHeader(genesisHeader(chain));\n}\n/**\n * Returns a copy of a Buffer with byte order reversed.\n * @returns new buffer with byte order reversed.\n * @publicbody\n */\nfunction swapByteOrder(buffer) {\n    return buffer.slice().reverse();\n}\n/**\n * @param num a number value in the Uint32 value range\n * @param littleEndian true for little-endian byte order in Buffer\n * @returns four byte buffer with Uint32 number encoded\n * @publicbody\n */\nfunction convertUint32ToBuffer(n, littleEndian = true) {\n    const a = [\n        n & 0xff, // lowest byte\n        (n >> 8) & 0xff,\n        (n >> 16) & 0xff,\n        (n >> 24) & 0xff // highest byte\n    ];\n    return littleEndian ? a : a.reverse();\n}\nfunction writeUInt32LE(n, a, offset) {\n    a[offset++] = n & 0xff; // lowest byte\n    a[offset++] = (n >> 8) & 0xff;\n    a[offset++] = (n >> 16) & 0xff;\n    a[offset++] = (n >> 24) & 0xff; // highest byte\n    return offset;\n}\nfunction writeUInt32BE(n, a, offset) {\n    a[offset++] = (n >> 24) & 0xff; // highest byte\n    a[offset++] = (n >> 16) & 0xff;\n    a[offset++] = (n >> 8) & 0xff;\n    a[offset++] = n & 0xff; // lowest byte\n    return offset;\n}\nfunction readUInt32LE(a, offset) {\n    return a[offset++] | (a[offset++] << 8) | (a[offset++] << 16) | (a[offset++] << 24);\n}\nfunction readUInt32BE(a, offset) {\n    return (a[offset++] << 24) | (a[offset++] << 16) | (a[offset++] << 8) | a[offset++];\n}\n/**\n * @param buffer four byte buffer with Uint32 number encoded\n * @param littleEndian true for little-endian byte order in Buffer\n * @returns a number value in the Uint32 value range\n * @publicbody\n */\nfunction convertBufferToUint32(buffer, littleEndian = true) {\n    const a = littleEndian ? buffer : buffer.slice().reverse();\n    const n = a[0] | (a[1] << 8) | (a[2] << 16) | (a[3] << 24);\n    return n;\n}\n//# sourceMappingURL=blockHeaderUtilities.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/blockHeaderUtilities.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/dirtyHashes.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/dirtyHashes.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dirtyHashes = void 0;\nexports.validateAgainstDirtyHashes = validateAgainstDirtyHashes;\n/**\n * These hashes are for blocks that are to known to have violated the Bitcoin\n * protocol. Regardless of the amount of proof-of-work that chains built on top\n * of them may have accumulated, they cannot be considered valid Bitcoin blocks.\n *\n * In the first instance, segregating witness data from transactions is not\n * part of the design of Bitcoin.\n *\n * In the second instance, adding new opcodes to be used when evaluating\n * scripts is also not allowed.\n */\nexports.dirtyHashes = {\n    // Block 478,558 with hash of 0000000000000000011865af4122fe3b144e2cbeea86142e8ff2fb4107352d43 was the last block shared by BSV, BCH and BTC\n    // Block 478,559 with hash of 00000000000000000019f112ec0a9982926f1258cdcc558dd7c3b7e5dc7fa148 was the first block of the BTC Segwit chain.\n    // Block 478,559 with hash of 000000000000000000651ef99cb9fcbe0dadde1d424bd9f15ff20136191a5eec was the valid Bitcoin block shared by BSV and BCH.\n    '00000000000000000019f112ec0a9982926f1258cdcc558dd7c3b7e5dc7fa148': 'This is the first header of the invalid SegWit chain.',\n    '0000000000000000004626ff6e3b936941d341c5932ece4357eeccac44e6d56c': 'This is the first header of the invalid ABC chain.'\n};\n/**\n * Throws Error if blockHash is in the dirtyHashes list.\n */\nfunction validateAgainstDirtyHashes(blockHash) {\n    if (exports.dirtyHashes[blockHash]) {\n        throw new Error(`Not adding a header with a dirty hash: ${exports.dirtyHashes[blockHash]}`);\n    }\n}\n//# sourceMappingURL=dirtyHashes.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/util/dirtyHashes.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./chaintracks */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/chaintracks/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ChaintracksChainTracker */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/ChaintracksChainTracker.js\"), exports);\n__exportStar(__webpack_require__(/*! ./BHServiceClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/BHServiceClient.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/createDefaultWalletServicesOptions.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/createDefaultWalletServicesOptions.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createDefaultWalletServicesOptions = createDefaultWalletServicesOptions;\nexports.arcDefaultUrl = arcDefaultUrl;\nexports.arcGorillaPoolUrl = arcGorillaPoolUrl;\nconst index_client_1 = __webpack_require__(/*! ../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst chaintracker_1 = __webpack_require__(/*! ./chaintracker */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/chaintracker/index.js\");\nfunction createDefaultWalletServicesOptions(chain, arcCallbackUrl, arcCallbackToken, arcApiKey) {\n    const deploymentId = `wallet-toolbox-${(0, index_client_1.randomBytesHex)(16)}`;\n    const taalApiKey = arcApiKey || chain === 'main'\n        ? 'mainnet_9596de07e92300c6287e4393594ae39c' // no plan\n        : 'testnet_0e6cf72133b43ea2d7861da2a38684e3'; // personal \"starter\" key\n    const o = {\n        chain,\n        taalApiKey,\n        bsvExchangeRate: {\n            timestamp: new Date('2023-12-13'),\n            base: 'USD',\n            rate: 47.52\n        },\n        bsvUpdateMsecs: 1000 * 60 * 15, // 15 minutes\n        fiatExchangeRates: {\n            timestamp: new Date('2023-12-13'),\n            base: 'USD',\n            rates: {\n                USD: 1,\n                GBP: 0.8,\n                EUR: 0.93\n            }\n        },\n        fiatUpdateMsecs: 1000 * 60 * 60 * 24, // 24 hours\n        disableMapiCallback: true, // Rely on WalletMonitor by default.\n        exchangeratesapiKey: 'bd539d2ff492bcb5619d5f27726a766f',\n        chaintracksFiatExchangeRatesUrl: `https://npm-registry.babbage.systems:${chain === 'main' ? 8084 : 8083}/getFiatExchangeRates`,\n        chaintracks: new chaintracker_1.ChaintracksServiceClient(chain, `https://npm-registry.babbage.systems:${chain === 'main' ? 8084 : 8083}`),\n        arcUrl: arcDefaultUrl(chain),\n        arcConfig: {\n            apiKey: arcApiKey !== null && arcApiKey !== void 0 ? arcApiKey : undefined,\n            deploymentId,\n            callbackUrl: arcCallbackUrl !== null && arcCallbackUrl !== void 0 ? arcCallbackUrl : undefined,\n            callbackToken: arcCallbackToken !== null && arcCallbackToken !== void 0 ? arcCallbackToken : undefined\n        },\n        arcGorillaPoolUrl: arcGorillaPoolUrl(chain),\n        arcGorillaPoolConfig: {\n            apiKey: arcApiKey !== null && arcApiKey !== void 0 ? arcApiKey : undefined,\n            deploymentId,\n            callbackUrl: arcCallbackUrl !== null && arcCallbackUrl !== void 0 ? arcCallbackUrl : undefined,\n            callbackToken: arcCallbackToken !== null && arcCallbackToken !== void 0 ? arcCallbackToken : undefined\n        }\n    };\n    return o;\n}\nfunction arcDefaultUrl(chain) {\n    const url = chain === 'main' ? 'https://arc.taal.com' : 'https://arc-test.taal.com';\n    return url;\n}\nfunction arcGorillaPoolUrl(chain) {\n    const url = chain === 'main' ? 'https://arc.gorillapool.io' : undefined;\n    return url;\n}\n//# sourceMappingURL=createDefaultWalletServicesOptions.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/createDefaultWalletServicesOptions.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./Services */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/Services.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/ARC.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/ARC.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ARC = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nfunction defaultDeploymentId() {\n    return `ts-sdk-${sdk_1.Utils.toHex((0, sdk_1.Random)(16))}`;\n}\n/**\n * Represents an ARC transaction broadcaster.\n */\nclass ARC {\n    constructor(URL, config, name) {\n        this.name = name !== null && name !== void 0 ? name : 'ARC';\n        this.URL = URL;\n        if (typeof config === 'string') {\n            this.apiKey = config;\n            this.httpClient = (0, sdk_1.defaultHttpClient)();\n            this.deploymentId = defaultDeploymentId();\n            this.callbackToken = undefined;\n            this.callbackUrl = undefined;\n        }\n        else {\n            const configObj = config !== null && config !== void 0 ? config : {};\n            const { apiKey, deploymentId, httpClient, callbackToken, callbackUrl, headers } = configObj;\n            this.apiKey = apiKey;\n            this.httpClient = httpClient !== null && httpClient !== void 0 ? httpClient : (0, sdk_1.defaultHttpClient)();\n            this.deploymentId = deploymentId !== null && deploymentId !== void 0 ? deploymentId : defaultDeploymentId();\n            this.callbackToken = callbackToken;\n            this.callbackUrl = callbackUrl;\n            this.headers = headers;\n        }\n    }\n    /**\n     * Constructs a dictionary of the default & supplied request headers.\n     */\n    requestHeaders() {\n        const headers = {\n            'Content-Type': 'application/json',\n            'XDeployment-ID': this.deploymentId\n        };\n        if (this.apiKey != null && this.apiKey !== '') {\n            headers.Authorization = `Bearer ${this.apiKey}`;\n        }\n        if (this.callbackUrl != null && this.callbackUrl !== '') {\n            headers['X-CallbackUrl'] = this.callbackUrl;\n        }\n        if (this.callbackToken != null && this.callbackToken !== '') {\n            headers['X-CallbackToken'] = this.callbackToken;\n        }\n        if (this.headers != null) {\n            for (const key in this.headers) {\n                headers[key] = this.headers[key];\n            }\n        }\n        return headers;\n    }\n    /**\n     * The ARC '/v1/tx' endpoint, as of 2025-02-17 supports all of the following hex string formats:\n     *   1. Single serialized raw transaction.\n     *   2. Single EF serialized raw transaction (untested).\n     *   3. V1 serialized Beef (results returned reflect only the last transaction in the beef)\n     *\n     * The ARC '/v1/tx' endpoint, as of 2025-02-17 DOES NOT support the following hex string formats:\n     *   1. V2 serialized Beef\n     *\n     * @param rawTx\n     * @param txids\n     * @returns\n     */\n    async postRawTx(rawTx, txids) {\n        let txid = sdk_1.Utils.toHex((0, index_client_1.doubleSha256BE)(sdk_1.Utils.toArray(rawTx, 'hex')));\n        if (txids) {\n            txid = txids.slice(-1)[0];\n        }\n        else {\n            txids = [txid];\n        }\n        const requestOptions = {\n            method: 'POST',\n            headers: this.requestHeaders(),\n            data: { rawTx },\n            signal: AbortSignal.timeout(1000 * 30) // 30 seconds timeout, error.code will be 'ABORT_ERR'\n        };\n        const r = {\n            txid,\n            status: 'success',\n            notes: []\n        };\n        const url = `${this.URL}/v1/tx`;\n        const nn = () => ({ name: this.name, when: new Date().toISOString() });\n        const nne = () => ({ ...nn(), rawTx, txids: txids.join(','), url });\n        try {\n            const response = await this.httpClient.request(url, requestOptions);\n            const { txid, extraInfo, txStatus, competingTxs } = response.data;\n            const nnr = () => ({\n                txid,\n                extraInfo,\n                txStatus,\n                competingTxs: competingTxs === null || competingTxs === void 0 ? void 0 : competingTxs.join(',')\n            });\n            if (response.ok) {\n                r.data = `${txStatus} ${extraInfo}`;\n                if (r.txid !== txid)\n                    r.data += ` txid altered from ${r.txid} to ${txid}`;\n                r.txid = txid;\n                if (txStatus === 'DOUBLE_SPEND_ATTEMPTED' || txStatus === 'SEEN_IN_ORPHAN_MEMPOOL') {\n                    r.status = 'error';\n                    r.doubleSpend = true;\n                    r.competingTxs = competingTxs;\n                    r.notes.push({ ...nne(), ...nnr(), what: 'postRawTxDoubleSpend' });\n                }\n                else {\n                    r.notes.push({ ...nn(), ...nnr(), what: 'postRawTxSuccess' });\n                }\n            }\n            else if (typeof response === 'string') {\n                r.notes.push({ ...nne(), what: 'postRawTxString', response });\n                r.status = 'error';\n                // response is not normally a string\n                r.serviceError = true;\n            }\n            else {\n                r.status = 'error';\n                // Treat unknown errors as service errors\n                r.serviceError = true;\n                const n = {\n                    ...nn(),\n                    ...nne(),\n                    ...nnr(),\n                    what: 'postRawTxError'\n                };\n                const ed = {};\n                r.data = ed;\n                const st = typeof response.status;\n                if (st === 'number' || st === 'string') {\n                    n.status = response.status;\n                    ed.status = response.status.toString();\n                }\n                else {\n                    n.status = st;\n                    ed.status = 'ERR_UNKNOWN';\n                }\n                let d = response.data;\n                if (d && typeof d === 'string') {\n                    n.data = response.data.slice(0, 128);\n                    try {\n                        d = JSON.parse(d);\n                    }\n                    catch (_a) {\n                        // Intentionally left empty\n                    }\n                }\n                else if (d && typeof d === 'object') {\n                    ed.more = d;\n                    ed.detail = d['detail'];\n                    if (typeof ed.detail !== 'string')\n                        ed.detail = undefined;\n                    if (ed.detail) {\n                        n.detail = ed.detail;\n                    }\n                }\n                r.notes.push(n);\n            }\n        }\n        catch (eu) {\n            const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n            r.status = 'error';\n            r.serviceError = true;\n            r.data = `${e.code} ${e.message}`;\n            r.notes.push({\n                ...nne(),\n                what: 'postRawTxCatch',\n                code: e.code,\n                description: e.description\n            });\n        }\n        return r;\n    }\n    /**\n     * ARC does not natively support a postBeef end-point aware of multiple txids of interest in the Beef.\n     *\n     * It does process multiple new transactions, however, which allows results for all txids of interest\n     * to be collected by the `/v1/tx/${txid}` endpoint.\n     *\n     * @param beef\n     * @param txids\n     * @returns\n     */\n    async postBeef(beef, txids) {\n        const r = {\n            name: this.name,\n            status: 'success',\n            txidResults: [],\n            notes: []\n        };\n        const nn = () => ({ name: this.name, when: new Date().toISOString() });\n        if (beef.version === sdk_1.BEEF_V2 && beef.txs.every(btx => !btx.isTxidOnly)) {\n            beef.version = sdk_1.BEEF_V1;\n            r.notes.push({ ...nn(), what: 'postBeefV2ToV1' });\n        }\n        const beefHex = beef.toHex();\n        const prtr = await this.postRawTx(beefHex, txids);\n        r.status = prtr.status;\n        r.txidResults = [prtr];\n        // Since postRawTx only returns results for a single txid,\n        // replicate the basic results any additional txids.\n        // TODO: Temporary hack...\n        for (const txid of txids) {\n            if (prtr.txid === txid)\n                continue;\n            const tr = {\n                txid,\n                status: 'success',\n                notes: []\n            };\n            // For the extra txids, go back to the service for confirmation...\n            const dr = await this.getTxData(txid);\n            if (dr.txid !== txid) {\n                tr.status = 'error';\n                tr.data = 'internal error';\n                tr.notes.push({\n                    ...nn(),\n                    what: 'postBeefGetTxDataInternal',\n                    txid,\n                    returnedTxid: dr.txid\n                });\n            }\n            else if (dr.txStatus === 'SEEN_ON_NETWORK' || dr.txStatus === 'STORED') {\n                tr.data = dr.txStatus;\n                tr.notes.push({\n                    ...nn(),\n                    what: 'postBeefGetTxDataSuccess',\n                    txid,\n                    txStatus: dr.txStatus\n                });\n            }\n            else {\n                tr.status = 'error';\n                tr.data = dr;\n                tr.notes.push({\n                    ...nn(),\n                    what: 'postBeefGetTxDataError',\n                    txid,\n                    txStatus: dr.txStatus\n                });\n            }\n            r.txidResults.push(tr);\n            if (r.status === 'success' && tr.status === 'error')\n                r.status = 'error';\n        }\n        return r;\n    }\n    /**\n     * This seems to only work for recently submitted txids...but that's all we need to complete postBeef!\n     * @param txid\n     * @returns\n     */\n    async getTxData(txid) {\n        const requestOptions = {\n            method: 'GET',\n            headers: this.requestHeaders()\n        };\n        const response = await this.httpClient.request(`${this.URL}/v1/tx/${txid}`, requestOptions);\n        return response.data;\n    }\n}\nexports.ARC = ARC;\n//# sourceMappingURL=ARC.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/ARC.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/Bitails.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/Bitails.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Bitails = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n *\n */\nclass Bitails {\n    constructor(chain = 'main', config = {}) {\n        const { apiKey, httpClient } = config;\n        this.chain = chain;\n        this.URL = chain === 'main' ? `https://api.bitails.io/` : `https://test-api.bitails.io/`;\n        this.httpClient = httpClient !== null && httpClient !== void 0 ? httpClient : (0, sdk_1.defaultHttpClient)();\n        this.apiKey = apiKey !== null && apiKey !== void 0 ? apiKey : '';\n    }\n    getHttpHeaders() {\n        const headers = {\n            Accept: 'application/json'\n        };\n        if (typeof this.apiKey === 'string' && this.apiKey.trim() !== '') {\n            headers.Authorization = this.apiKey;\n        }\n        return headers;\n    }\n    /**\n     * Bitails does not natively support a postBeef end-point aware of multiple txids of interest in the Beef.\n     *\n     * Send rawTx in `txids` order from beef.\n     *\n     * @param beef\n     * @param txids\n     * @returns\n     */\n    async postBeef(beef, txids) {\n        const nn = () => ({\n            name: 'BitailsPostBeef',\n            when: new Date().toISOString()\n        });\n        const nne = () => ({ ...nn(), beef: beef.toHex(), txids: txids.join(',') });\n        const note = { ...nn(), what: 'postBeef' };\n        const raws = [];\n        for (const txid of txids) {\n            const rawTx = sdk_1.Utils.toHex(beef.findTxid(txid).rawTx);\n            raws.push(rawTx);\n        }\n        const r = await this.postRaws(raws, txids);\n        r.notes.unshift(note);\n        if (r.status !== 'success')\n            r.notes.push({ ...nne(), what: 'postBeefError' });\n        else\n            r.notes.push({ ...nn(), what: 'postBeefSuccess' });\n        return r;\n    }\n    /**\n     * @param raws Array of raw transactions to broadcast as hex strings\n     * @param txids Array of txids for transactions in raws for which results are requested, remaining raws are supporting only.\n     * @returns\n     */\n    async postRaws(raws, txids) {\n        const r = {\n            name: 'BitailsPostRaws',\n            status: 'success',\n            txidResults: [],\n            notes: []\n        };\n        const rawTxids = [];\n        for (const raw of raws) {\n            const txid = sdk_1.Utils.toHex((0, index_client_1.doubleSha256BE)(sdk_1.Utils.toArray(raw, 'hex')));\n            // Results aren't always identified by txid.\n            rawTxids.push(txid);\n            if (!txids || txids.indexOf(txid) >= 0) {\n                r.txidResults.push({\n                    txid,\n                    status: 'success',\n                    notes: []\n                });\n            }\n        }\n        const headers = this.getHttpHeaders();\n        headers['Content-Type'] = 'application/json';\n        //headers['Accept'] = 'text/json'\n        const data = { raws: raws };\n        const requestOptions = {\n            method: 'POST',\n            headers,\n            data\n        };\n        const url = `${this.URL}tx/broadcast/multi`;\n        const nn = () => ({\n            name: 'BitailsPostRawTx',\n            when: new Date().toISOString()\n        });\n        const nne = () => ({\n            ...nn(),\n            raws: raws.join(','),\n            txids: r.txidResults.map(r => r.txid).join(','),\n            url\n        });\n        try {\n            const response = await this.httpClient.request(url, requestOptions);\n            if (response.ok) {\n                // status: 201, statusText: 'Created'\n                const btrs = response.data;\n                if (btrs.length !== raws.length) {\n                    r.status = 'error';\n                    r.notes.push({ ...nne(), what: 'postRawsErrorResultsCount' });\n                }\n                else {\n                    // Check that each response result has a txid that matches corresponding rawTxids\n                    let i = -1;\n                    for (const btr of btrs) {\n                        i++;\n                        if (!btr.txid) {\n                            btr.txid = rawTxids[i];\n                            r.notes.push({ ...nn(), what: 'postRawsResultMissingTxids', i, rawsTxid: rawTxids[i] });\n                        }\n                        else if (btr.txid !== rawTxids[i]) {\n                            r.status = 'error';\n                            r.notes.push({ ...nn(), what: 'postRawsResultTxids', i, txid: btr.txid, rawsTxid: rawTxids[i] });\n                        }\n                    }\n                    if (r.status === 'success') {\n                        // btrs has correct number of results and each one has expected txid.\n                        // focus on results for requested txids\n                        for (const rt of r.txidResults) {\n                            const btr = btrs.find(btr => btr.txid === rt.txid);\n                            const txid = rt.txid;\n                            if (btr.error) {\n                                // code: -25, message: 'missing-inputs'\n                                // code: -27, message: 'already-in-mempool'\n                                const { code, message } = btr.error;\n                                if (code === -27) {\n                                    rt.notes.push({ ...nne(), what: 'postRawsSuccessAlreadyInMempool' });\n                                }\n                                else {\n                                    rt.status = 'error';\n                                    if (code === -25) {\n                                        rt.doubleSpend = true; // this is a possible double spend attempt\n                                        rt.competingTxs = undefined; // not provided with any data for this.\n                                        rt.notes.push({ ...nne(), what: 'postRawsErrorMissingInputs' });\n                                    }\n                                    else if (btr['code'] === 'ECONNRESET') {\n                                        rt.notes.push({ ...nne(), what: 'postRawsErrorECONNRESET', txid, message });\n                                    }\n                                    else {\n                                        rt.notes.push({ ...nne(), what: 'postRawsError', txid, code, message });\n                                    }\n                                }\n                            }\n                            else {\n                                rt.notes.push({ ...nn(), what: 'postRawsSuccess' });\n                            }\n                            if (rt.status !== 'success' && r.status === 'success')\n                                r.status = 'error';\n                        }\n                    }\n                }\n            }\n            else {\n                r.status = 'error';\n                const n = { ...nne(), what: 'postRawsError' };\n                r.notes.push(n);\n            }\n        }\n        catch (eu) {\n            r.status = 'error';\n            const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n            const { code, description } = e;\n            r.notes.push({ ...nne(), what: 'postRawsCatch', code, description });\n        }\n        return r;\n    }\n    /**\n     *\n     * @param txid\n     * @param services\n     * @returns\n     */\n    async getMerklePath(txid, services) {\n        const r = { name: 'BitailsTsc', notes: [] };\n        const url = `${this.URL}tx/${txid}/proof/tsc`;\n        const nn = () => ({ name: 'BitailsProofTsc', when: new Date().toISOString(), txid, url });\n        const headers = this.getHttpHeaders();\n        const requestOptions = { method: 'GET', headers };\n        try {\n            const response = await this.httpClient.request(url, requestOptions);\n            const nne = () => ({ ...nn(), txid, url, status: response.status, statusText: response.statusText });\n            if (response.status === 404 && response.statusText === 'Not Found') {\n                r.notes.push({ ...nn(), what: 'getMerklePathNotFound' });\n            }\n            else if (!response.ok || response.status !== 200 || response.statusText !== 'OK') {\n                r.notes.push({ ...nne(), what: 'getMerklePathBadStatus' });\n            }\n            else if (!response.data) {\n                r.notes.push({ ...nne(), what: 'getMerklePathNoData' });\n            }\n            else {\n                const p = response.data;\n                const header = await services.hashToHeader(p.target);\n                if (header) {\n                    const proof = { index: p.index, nodes: p.nodes, height: header.height };\n                    r.merklePath = (0, index_client_1.convertProofToMerklePath)(txid, proof);\n                    r.header = header;\n                    r.notes.push({ ...nne(), what: 'getMerklePathSuccess' });\n                }\n                else {\n                    r.notes.push({ ...nne(), what: 'getMerklePathNoHeader', target: p.target });\n                }\n            }\n        }\n        catch (eu) {\n            const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n            const { code, description } = e;\n            r.notes.push({ ...nn(), what: 'getMerklePathCatch', code, description });\n            r.error = e;\n        }\n        return r;\n    }\n}\nexports.Bitails = Bitails;\n//# sourceMappingURL=Bitails.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/Bitails.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/SdkWhatsOnChain.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/SdkWhatsOnChain.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\n/**\n * Represents a chain tracker based on What's On Chain .\n */\nclass SdkWhatsOnChain {\n    /**\n     * Constructs an instance of the WhatsOnChain ChainTracker.\n     *\n     * @param {'main' | 'test' | 'stn'} network - The BSV network to use when calling the WhatsOnChain API.\n     * @param {WhatsOnChainConfig} config - Configuration options for the WhatsOnChain ChainTracker.\n     */\n    constructor(network = 'main', config = {}) {\n        const { apiKey, httpClient } = config;\n        this.network = network;\n        this.URL = `https://api.whatsonchain.com/v1/bsv/${network}`;\n        this.httpClient = httpClient !== null && httpClient !== void 0 ? httpClient : (0, sdk_1.defaultHttpClient)();\n        this.apiKey = apiKey !== null && apiKey !== void 0 ? apiKey : '';\n    }\n    async isValidRootForHeight(root, height) {\n        const requestOptions = {\n            method: 'GET',\n            headers: this.getHttpHeaders()\n        };\n        const response = await this.httpClient.request(`${this.URL}/block/${height}/header`, requestOptions);\n        if (response.ok) {\n            const { merkleroot } = response.data;\n            return merkleroot === root;\n        }\n        else if (response.status === 404) {\n            return false;\n        }\n        else {\n            throw new Error(`Failed to verify merkleroot for height ${height} because of an error: ${JSON.stringify(response.data)} `);\n        }\n    }\n    async currentHeight() {\n        try {\n            const requestOptions = {\n                method: 'GET',\n                headers: this.getHttpHeaders()\n            };\n            const response = await this.httpClient.request(`${this.URL}/block/headers`, requestOptions);\n            if (response.ok) {\n                return response.data[0].height;\n            }\n            else {\n                throw new Error(`Failed to get current height because of an error: ${JSON.stringify(response.data)} `);\n            }\n        }\n        catch (error) {\n            throw new Error(`Failed to get current height because of an error: ${error instanceof Error ? error.message : String(error)}`);\n        }\n    }\n    getHttpHeaders() {\n        const headers = {\n            Accept: 'application/json'\n        };\n        if (typeof this.apiKey === 'string' && this.apiKey.trim() !== '') {\n            headers.Authorization = this.apiKey;\n        }\n        return headers;\n    }\n}\nexports[\"default\"] = SdkWhatsOnChain;\n//# sourceMappingURL=SdkWhatsOnChain.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/SdkWhatsOnChain.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/WhatsOnChain.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/WhatsOnChain.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WhatsOnChain = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst tscProofToMerklePath_1 = __webpack_require__(/*! ../../utility/tscProofToMerklePath */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/tscProofToMerklePath.js\");\nconst SdkWhatsOnChain_1 = __importDefault(__webpack_require__(/*! ./SdkWhatsOnChain */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/SdkWhatsOnChain.js\"));\nconst sdk_2 = __webpack_require__(/*! ../../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\n/**\n *\n */\nclass WhatsOnChain extends SdkWhatsOnChain_1.default {\n    constructor(chain = 'main', config = {}, services) {\n        super(chain, config);\n        this.services = services || new index_client_1.Services(chain);\n    }\n    /**\n     * POST\n     * https://api.whatsonchain.com/v1/bsv/main/txs/status\n     * Content-Type: application/json\n     * data: \"{\\\"txids\\\":[\\\"6815f8014db74eab8b7f75925c68929597f1d97efa970109d990824c25e5e62b\\\"]}\"\n     *\n     * result for a mined txid:\n     *     [{\n     *        \"txid\":\"294cd1ebd5689fdee03509f92c32184c0f52f037d4046af250229b97e0c8f1aa\",\n     *        \"blockhash\":\"000000000000000004b5ce6670f2ff27354a1e87d0a01bf61f3307f4ccd358b5\",\n     *        \"blockheight\":612251,\n     *        \"blocktime\":1575841517,\n     *        \"confirmations\":278272\n     *      }]\n     *\n     * result for a valid recent txid:\n     *     [{\"txid\":\"6815f8014db74eab8b7f75925c68929597f1d97efa970109d990824c25e5e62b\"}]\n     *\n     * result for an unknown txid:\n     *     [{\"txid\":\"6815f8014db74eab8b7f75925c68929597f1d97efa970109d990824c25e5e62c\",\"error\":\"unknown\"}]\n     */\n    async getStatusForTxids(txids) {\n        const r = {\n            name: 'WoC',\n            status: 'error',\n            error: undefined,\n            results: []\n        };\n        const requestOptions = {\n            method: 'POST',\n            headers: this.getHttpHeaders(),\n            data: { txids }\n        };\n        const url = `${this.URL}/txs/status`;\n        try {\n            const response = await this.httpClient.request(url, requestOptions);\n            if (!response.data || !response.ok || response.status !== 200)\n                throw new index_client_1.sdk.WERR_INVALID_OPERATION(`Unable to get status for txids at this timei.`);\n            const data = response.data;\n            for (const txid of txids) {\n                const d = data.find(d => d.txid === txid);\n                if (!d || d.error === 'unknown')\n                    r.results.push({ txid, status: 'unknown', depth: undefined });\n                else if (d.error !== undefined) {\n                    console.log(`WhatsOnChain getStatusForTxids unexpected error ${d.error} ${txid}`);\n                    r.results.push({ txid, status: 'unknown', depth: undefined });\n                }\n                else if (d.confirmations === undefined)\n                    r.results.push({ txid, status: 'known', depth: 0 });\n                else\n                    r.results.push({ txid, status: 'mined', depth: d.confirmations });\n            }\n            r.status = 'success';\n        }\n        catch (eu) {\n            const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n            r.error = e;\n        }\n        return r;\n    }\n    /**\n     * 2025-02-16 throwing internal server error 500.\n     * @param txid\n     * @returns\n     */\n    async getTxPropagation(txid) {\n        const requestOptions = {\n            method: 'GET',\n            headers: this.getHttpHeaders()\n        };\n        const response = await this.httpClient.request(`${this.URL}/tx/hash/${txid}/propagation`, requestOptions);\n        // response.statusText is often, but not always 'OK' on success...\n        if (!response.data || !response.ok || response.status !== 200)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('txid', `valid transaction. '${txid}' response ${response.statusText}`);\n        return 0;\n    }\n    /**\n     * May return undefined for unmined transactions that are in the mempool.\n     * @param txid\n     * @returns raw transaction as hex string or undefined if txid not found in mined block.\n     */\n    async getRawTx(txid) {\n        const headers = this.getHttpHeaders();\n        headers['Cache-Control'] = 'no-cache';\n        const requestOptions = {\n            method: 'GET',\n            headers\n        };\n        const url = `${this.URL}/tx/${txid}/hex`;\n        for (let retry = 0; retry < 2; retry++) {\n            const response = await this.httpClient.request(url, requestOptions);\n            if (response.statusText === 'Too Many Requests' && retry < 2) {\n                await (0, index_client_1.wait)(2000);\n                continue;\n            }\n            if (response.status === 404 && response.statusText === 'Not Found')\n                return undefined;\n            // response.statusText is often, but not always 'OK' on success...\n            if (!response.data || !response.ok || response.status !== 200)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('txid', `valid transaction. '${txid}' response ${response.statusText}`);\n            return response.data;\n        }\n        throw new index_client_1.sdk.WERR_INTERNAL();\n    }\n    async getRawTxResult(txid) {\n        const r = { name: 'WoC', txid: (0, index_client_1.asString)(txid) };\n        try {\n            const rawTxHex = await this.getRawTx(txid);\n            if (rawTxHex)\n                r.rawTx = (0, index_client_1.asArray)(rawTxHex);\n        }\n        catch (err) {\n            r.error = index_client_1.sdk.WalletError.fromUnknown(err);\n        }\n        return r;\n    }\n    /**\n     * WhatsOnChain does not natively support a postBeef end-point aware of multiple txids of interest in the Beef.\n     *\n     * Send rawTx in `txids` order from beef.\n     *\n     * @param beef\n     * @param txids\n     * @returns\n     */\n    async postBeef(beef, txids) {\n        const r = {\n            name: 'WoC',\n            status: 'success',\n            txidResults: [],\n            notes: []\n        };\n        let delay = false;\n        const nn = () => ({ name: 'WoCpostBeef', when: new Date().toISOString() });\n        const nne = () => ({ ...nn(), beef: beef.toHex(), txids: txids.join(',') });\n        for (const txid of txids) {\n            const rawTx = sdk_1.Utils.toHex(beef.findTxid(txid).rawTx);\n            if (delay) {\n                // For multiple txids, give WoC time to propagate each one.\n                await (0, index_client_1.wait)(3000);\n            }\n            delay = true;\n            const tr = await this.postRawTx(rawTx);\n            if (txid !== tr.txid) {\n                tr.notes.push({ ...nne(), what: 'postRawTxTxidChanged', txid, trTxid: tr.txid });\n            }\n            r.txidResults.push(tr);\n            if (r.status === 'success' && tr.status !== 'success')\n                r.status = 'error';\n        }\n        if (r.status === 'success') {\n            r.notes.push({ ...nn(), what: 'postBeefSuccess' });\n        }\n        else {\n            r.notes.push({ ...nne(), what: 'postBeefError' });\n        }\n        return r;\n    }\n    /**\n     * @param rawTx raw transaction to broadcast as hex string\n     * @returns txid returned by transaction processor of transaction broadcast\n     */\n    async postRawTx(rawTx) {\n        let txid = sdk_1.Utils.toHex((0, index_client_1.doubleSha256BE)(sdk_1.Utils.toArray(rawTx, 'hex')));\n        const r = {\n            txid,\n            status: 'success',\n            notes: []\n        };\n        const headers = this.getHttpHeaders();\n        headers['Content-Type'] = 'application/json';\n        headers['Accept'] = 'text/plain';\n        const requestOptions = {\n            method: 'POST',\n            headers,\n            data: { txhex: rawTx }\n        };\n        const url = `${this.URL}/tx/raw`;\n        const nn = () => ({ name: 'WoCpostRawTx', when: new Date().toISOString() });\n        const nne = () => ({ ...nn(), rawTx, txid, url });\n        const retryLimit = 5;\n        for (let retry = 0; retry < retryLimit; retry++) {\n            try {\n                const response = await this.httpClient.request(url, requestOptions);\n                if (response.statusText === 'Too Many Requests' && retry < 2) {\n                    r.notes.push({ ...nn(), what: 'postRawTxRateLimit' });\n                    await (0, index_client_1.wait)(2000);\n                    continue;\n                }\n                if (response.ok) {\n                    const txid = response.data;\n                    r.notes.push({ ...nn(), what: 'postRawTxSuccess' });\n                }\n                else if (response.data === 'unexpected response code 500: Transaction already in the mempool') {\n                    r.notes.push({ ...nne(), what: 'postRawTxSuccessAlreadyInMempool' });\n                }\n                else {\n                    r.status = 'error';\n                    if (response.data === 'unexpected response code 500: 258: txn-mempool-conflict') {\n                        r.doubleSpend = true; // this is a possible double spend attempt\n                        r.competingTxs = undefined; // not provided with any data for this.\n                        r.notes.push({ ...nne(), what: 'postRawTxErrorMempoolConflict' });\n                    }\n                    else if (response.data === 'unexpected response code 500: Missing inputs') {\n                        r.doubleSpend = true; // this is a possible double spend attempt\n                        r.competingTxs = undefined; // not provided with any data for this.\n                        r.notes.push({ ...nne(), what: 'postRawTxErrorMissingInputs' });\n                    }\n                    else {\n                        const n = {\n                            ...nne(),\n                            what: 'postRawTxError'\n                        };\n                        if (typeof response.data === 'string') {\n                            n.data = response.data.slice(0, 128);\n                            r.data = response.data;\n                        }\n                        else {\n                            r.data = '';\n                        }\n                        if (typeof response.statusText === 'string') {\n                            n.statusText = response.statusText.slice(0, 128);\n                            r.data += `,${response.statusText}`;\n                        }\n                        if (typeof response.status === 'string') {\n                            n.status = response.status.slice(0, 128);\n                            r.data += `,${response.status}`;\n                        }\n                        if (typeof response.status === 'number') {\n                            n.status = response.status;\n                            r.data += `,${response.status}`;\n                        }\n                        r.notes.push(n);\n                    }\n                }\n            }\n            catch (eu) {\n                r.status = 'error';\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                r.notes.push({\n                    ...nne(),\n                    what: 'postRawTxCatch',\n                    code: e.code,\n                    description: e.description\n                });\n                r.serviceError = true;\n                r.data = `${e.code} ${e.description}`;\n            }\n            return r;\n        }\n        r.status = 'error';\n        r.serviceError = true;\n        r.notes.push({\n            ...nne(),\n            what: 'postRawTxRetryLimit',\n            retryLimit\n        });\n        return r;\n    }\n    /**\n     * @param txid\n     * @returns\n     */\n    async getMerklePath(txid, services) {\n        const r = { name: 'WoCTsc', notes: [] };\n        const headers = this.getHttpHeaders();\n        const requestOptions = {\n            method: 'GET',\n            headers\n        };\n        for (let retry = 0; retry < 2; retry++) {\n            try {\n                const response = await this.httpClient.request(`${this.URL}/tx/${txid}/proof/tsc`, requestOptions);\n                if (response.statusText === 'Too Many Requests' && retry < 2) {\n                    r.notes.push({\n                        what: 'getMerklePathRetry',\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                    await (0, index_client_1.wait)(2000);\n                    continue;\n                }\n                if (response.status === 404 && response.statusText === 'Not Found') {\n                    r.notes.push({\n                        what: 'getMerklePathNotFound',\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                    return r;\n                }\n                // response.statusText is often, but not always 'OK' on success...\n                if (!response.ok || response.status !== 200) {\n                    r.notes.push({\n                        what: 'getMerklePathBadStatus',\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('txid', `valid transaction. '${txid}' response ${response.statusText}`);\n                }\n                if (!response.data) {\n                    // Unmined, proof not yet available.\n                    r.notes.push({\n                        what: 'getMerklePathNoData',\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                    return r;\n                }\n                if (!Array.isArray(response.data))\n                    response.data = [response.data];\n                if (response.data.length != 1)\n                    return r;\n                const p = response.data[0];\n                const header = await services.hashToHeader(p.target);\n                if (header) {\n                    const proof = {\n                        index: p.index,\n                        nodes: p.nodes,\n                        height: header.height\n                    };\n                    r.merklePath = (0, tscProofToMerklePath_1.convertProofToMerklePath)(txid, proof);\n                    r.header = header;\n                    r.notes.push({\n                        what: 'getMerklePathSuccess',\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                }\n                else {\n                    r.notes.push({\n                        what: 'getMerklePathNoHeader',\n                        target: p.target,\n                        name: r.name,\n                        status: response.status,\n                        statusText: response.statusText\n                    });\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('blockhash', 'a valid on-chain block hash');\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                r.notes.push({\n                    what: 'getMerklePathError',\n                    name: r.name,\n                    code: e.code,\n                    description: e.description\n                });\n                r.error = e;\n            }\n            return r;\n        }\n        r.notes.push({ what: 'getMerklePathInternal', name: r.name });\n        throw new index_client_1.sdk.WERR_INTERNAL();\n    }\n    async updateBsvExchangeRate(rate, updateMsecs) {\n        if (rate) {\n            // Check if the rate we know is stale enough to update.\n            updateMsecs || (updateMsecs = 1000 * 60 * 15);\n            if (new Date(Date.now() - updateMsecs) < rate.timestamp)\n                return rate;\n        }\n        const requestOptions = {\n            method: 'GET',\n            headers: this.getHttpHeaders()\n        };\n        for (let retry = 0; retry < 2; retry++) {\n            const response = await this.httpClient.request(`${this.URL}/exchangerate`, requestOptions);\n            if (response.statusText === 'Too Many Requests' && retry < 2) {\n                await (0, index_client_1.wait)(2000);\n                continue;\n            }\n            // response.statusText is often, but not always 'OK' on success...\n            if (!response.data || !response.ok || response.status !== 200)\n                throw new index_client_1.sdk.WERR_INVALID_OPERATION(`WoC exchangerate response ${response.statusText}`);\n            const wocrate = response.data;\n            if (wocrate.currency !== 'USD')\n                wocrate.rate = NaN;\n            const newRate = {\n                timestamp: new Date(),\n                base: 'USD',\n                rate: wocrate.rate\n            };\n            return newRate;\n        }\n        throw new index_client_1.sdk.WERR_INTERNAL();\n    }\n    async getUtxoStatus(output, outputFormat, outpoint) {\n        const r = {\n            name: 'WoC',\n            status: 'error',\n            error: new index_client_1.sdk.WERR_INTERNAL(),\n            details: []\n        };\n        for (let retry = 0;; retry++) {\n            let url = '';\n            try {\n                const scriptHash = (0, index_client_1.validateScriptHash)(output, outputFormat);\n                const requestOptions = {\n                    method: 'GET',\n                    headers: this.getHttpHeaders()\n                };\n                const response = await this.httpClient.request(`${this.URL}/script/${scriptHash}/unspent/all`, requestOptions);\n                if (response.statusText === 'Too Many Requests' && retry < 2) {\n                    await (0, index_client_1.wait)(2000);\n                    continue;\n                }\n                // response.statusText is often, but not always 'OK' on success...\n                if (!response.data || !response.ok || response.status !== 200)\n                    throw new index_client_1.sdk.WERR_INVALID_OPERATION(`WoC getUtxoStatus response ${response.statusText}`);\n                const data = response.data;\n                if (data.script !== scriptHash || !Array.isArray(data.result)) {\n                    throw new index_client_1.sdk.WERR_INTERNAL('data. is not an array');\n                }\n                if (data.result.length === 0) {\n                    r.status = 'success';\n                    r.error = undefined;\n                    r.isUtxo = false;\n                }\n                else {\n                    r.status = 'success';\n                    r.error = undefined;\n                    for (const s of data.result) {\n                        r.details.push({\n                            txid: s.tx_hash,\n                            satoshis: s.value,\n                            height: s.height,\n                            index: s.tx_pos\n                        });\n                    }\n                    if (outpoint) {\n                        const { txid, vout } = (0, sdk_2.parseWalletOutpoint)(outpoint);\n                        r.isUtxo = r.details.find(d => d.txid === txid && d.index === vout) !== undefined;\n                    }\n                    else\n                        r.isUtxo = r.details.length > 0;\n                }\n                return r;\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                if (e.code !== 'ECONNRESET' || retry > 2) {\n                    r.error = new index_client_1.sdk.WERR_INTERNAL(`service failure: ${url}, error: ${JSON.stringify(index_client_1.sdk.WalletError.fromUnknown(eu))}`);\n                    return r;\n                }\n            }\n        }\n    }\n    async getScriptHashConfirmedHistory(hash) {\n        const r = {\n            name: 'WoC',\n            status: 'error',\n            error: undefined,\n            history: []\n        };\n        // reverse hash from LE to BE for Woc\n        hash = sdk_1.Utils.toHex(sdk_1.Utils.toArray(hash, 'hex').reverse());\n        const url = `${this.URL}/script/${hash}/confirmed/history`;\n        for (let retry = 0;; retry++) {\n            try {\n                const requestOptions = {\n                    method: 'GET',\n                    headers: this.getHttpHeaders()\n                };\n                const response = await this.httpClient.request(url, requestOptions);\n                if (response.statusText === 'Too Many Requests' && retry < 2) {\n                    await (0, index_client_1.wait)(2000);\n                    continue;\n                }\n                if (!response.ok && response.status === 404) {\n                    // There is no history for this script hash...\n                    r.status = 'success';\n                    return r;\n                }\n                // response.statusText is often, but not always 'OK' on success...\n                if (!response.data || !response.ok || response.status !== 200) {\n                    r.error = new index_client_1.sdk.WERR_BAD_REQUEST(`WoC getScriptHashConfirmedHistory response ${response.ok} ${response.status} ${response.statusText}`);\n                    return r;\n                }\n                if (response.data.error) {\n                    r.error = new index_client_1.sdk.WERR_BAD_REQUEST(`WoC getScriptHashConfirmedHistory error ${response.data.error}`);\n                    return r;\n                }\n                r.history = response.data.result.map(d => ({ txid: d.tx_hash, height: d.height }));\n                r.status = 'success';\n                return r;\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                if (e.code !== 'ECONNRESET' || retry > 2) {\n                    r.error = new index_client_1.sdk.WERR_INTERNAL(`WoC getScriptHashConfirmedHistory service failure: ${url}, error: ${JSON.stringify(index_client_1.sdk.WalletError.fromUnknown(eu))}`);\n                    return r;\n                }\n            }\n        }\n        return r;\n    }\n    async getScriptHashUnconfirmedHistory(hash) {\n        const r = {\n            name: 'WoC',\n            status: 'error',\n            error: undefined,\n            history: []\n        };\n        // reverse hash from LE to BE for Woc\n        hash = sdk_1.Utils.toHex(sdk_1.Utils.toArray(hash, 'hex').reverse());\n        const url = `${this.URL}/script/${hash}/unconfirmed/history`;\n        for (let retry = 0;; retry++) {\n            try {\n                const requestOptions = {\n                    method: 'GET',\n                    headers: this.getHttpHeaders()\n                };\n                const response = await this.httpClient.request(url, requestOptions);\n                if (response.statusText === 'Too Many Requests' && retry < 2) {\n                    await (0, index_client_1.wait)(2000);\n                    continue;\n                }\n                if (!response.ok && response.status === 404) {\n                    // There is no history for this script hash...\n                    r.status = 'success';\n                    return r;\n                }\n                // response.statusText is often, but not always 'OK' on success...\n                if (!response.data || !response.ok || response.status !== 200) {\n                    r.error = new index_client_1.sdk.WERR_BAD_REQUEST(`WoC getScriptHashUnconfirmedHistory response ${response.ok} ${response.status} ${response.statusText}`);\n                    return r;\n                }\n                if (response.data.error) {\n                    r.error = new index_client_1.sdk.WERR_BAD_REQUEST(`WoC getScriptHashUnconfirmedHistory error ${response.data.error}`);\n                    return r;\n                }\n                r.history = response.data.result.map(d => ({ txid: d.tx_hash, height: d.height }));\n                r.status = 'success';\n                return r;\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                if (e.code !== 'ECONNRESET' || retry > 2) {\n                    r.error = new index_client_1.sdk.WERR_INTERNAL(`WoC getScriptHashUnconfirmedHistory service failure: ${url}, error: ${JSON.stringify(index_client_1.sdk.WalletError.fromUnknown(eu))}`);\n                    return r;\n                }\n            }\n        }\n        return r;\n    }\n    async getScriptHashHistory(hash) {\n        const r1 = await this.getScriptHashConfirmedHistory(hash);\n        if (r1.error || r1.status !== 'success')\n            return r1;\n        const r2 = await this.getScriptHashUnconfirmedHistory(hash);\n        if (r2.error || r2.status !== 'success')\n            return r2;\n        r1.history = r1.history.concat(r2.history);\n        return r1;\n    }\n}\nexports.WhatsOnChain = WhatsOnChain;\n//# sourceMappingURL=WhatsOnChain.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/WhatsOnChain.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/echangeRates.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/echangeRates.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.updateChaintracksFiatExchangeRates = updateChaintracksFiatExchangeRates;\nexports.updateExchangeratesapi = updateExchangeratesapi;\nexports.getExchangeRatesIo = getExchangeRatesIo;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nasync function updateChaintracksFiatExchangeRates(targetCurrencies, options) {\n    const url = options.chaintracksFiatExchangeRatesUrl;\n    if (!url)\n        throw new index_client_1.sdk.WERR_MISSING_PARAMETER('options.chaintracksFiatExchangeRatesUrl');\n    const response = await fetch(url);\n    const data = await response.json();\n    const r = { status: response.status, data };\n    if (r.status !== 200 || !r.data || r.data.status != 'success') {\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(`${url} returned status ${r.status}`);\n    }\n    const rates = r.data.value;\n    rates.timestamp = new Date(rates.timestamp);\n    return rates;\n}\nasync function updateExchangeratesapi(targetCurrencies, options) {\n    if (!options.exchangeratesapiKey)\n        throw new index_client_1.sdk.WERR_MISSING_PARAMETER('options.exchangeratesapiKey');\n    const iorates = await getExchangeRatesIo(options.exchangeratesapiKey);\n    if (!iorates.success)\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(`getExchangeRatesIo returned success ${iorates.success}`);\n    if (!iorates.rates['USD'] || !iorates.rates[iorates.base])\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(`getExchangeRatesIo missing rates for 'USD' or base`);\n    const r = {\n        timestamp: new Date(iorates.timestamp * 1000),\n        base: 'USD',\n        rates: {}\n    };\n    const basePerUsd = iorates.rates[iorates.base] / iorates.rates['USD'];\n    let updates = 0;\n    for (const [key, value] of Object.entries(iorates.rates)) {\n        if (targetCurrencies.indexOf(key) > -1) {\n            r.rates[key] = value * basePerUsd;\n            updates++;\n        }\n    }\n    if (updates !== targetCurrencies.length)\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(`getExchangeRatesIo failed to update all target currencies`);\n    //console.log(`new fiat rates=${JSON.stringify(r)}`)\n    return r;\n}\nasync function getExchangeRatesIo(key) {\n    const url = `http://api.exchangeratesapi.io/v1/latest?access_key=${key}`;\n    const response = await fetch(url);\n    const data = await response.json();\n    const r = { status: response.status, data };\n    if (r.status !== 200 || !r.data) {\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(`getExchangeRatesIo returned status ${r.status}`);\n    }\n    const rates = r.data;\n    return rates;\n}\n/*\n{\n    \"success\": true,\n    \"timestamp\": 1702405384,\n    \"base\": \"EUR\",\n    \"date\": \"2023-12-12\",\n    \"rates\": {\n        \"AED\": 3.96261,\n        \"AFN\": 74.453362,\n        \"ALL\": 101.807155,\n        \"AMD\": 435.489459,\n        \"ANG\": 1.944069,\n        \"AOA\": 897.226337,\n        \"ARS\": 395.468082,\n        \"AUD\": 1.646886,\n        \"AWG\": 1.942271,\n        \"AZN\": 1.832044,\n        \"BAM\": 1.95407,\n        \"BBD\": 2.177971,\n        \"BDT\": 118.654929,\n        \"BGN\": 1.956827,\n        \"BHD\": 0.406753,\n        \"BIF\": 3078.499675,\n        \"BMD\": 1.079039,\n        \"BND\": 1.446102,\n        \"BOB\": 7.4534,\n        \"BRL\": 5.35741,\n        \"BSD\": 1.07874,\n        \"BTC\": 0.000026145469,\n        \"BTN\": 89.916078,\n        \"BWP\": 14.715901,\n        \"BYN\": 3.553337,\n        \"BYR\": 21149.174075,\n        \"BZD\": 2.174364,\n        \"CAD\": 1.468287,\n        \"CDF\": 2875.640503,\n        \"CHF\": 0.945353,\n        \"CLF\": 0.034313,\n        \"CLP\": 948.09775,\n        \"CNY\": 7.743512,\n        \"COP\": 4307.525658,\n        \"CRC\": 569.093422,\n        \"CUC\": 1.079039,\n        \"CUP\": 28.594547,\n        \"CVE\": 110.978933,\n        \"CZK\": 24.507795,\n        \"DJF\": 191.766554,\n        \"DKK\": 7.457544,\n        \"DOP\": 61.505535,\n        \"DZD\": 145.236415,\n        \"EGP\": 33.367028,\n        \"ERN\": 16.185592,\n        \"ETB\": 60.199033,\n        \"EUR\": 1,\n        \"FJD\": 2.416779,\n        \"FKP\": 0.859886,\n        \"GBP\": 0.859574,\n        \"GEL\": 2.880527,\n        \"GGP\": 0.859886,\n        \"GHS\": 12.980915,\n        \"GIP\": 0.859886,\n        \"GMD\": 72.726644,\n        \"GNF\": 9285.134874,\n        \"GTQ\": 8.443457,\n        \"GYD\": 225.859997,\n        \"HKD\": 8.426031,\n        \"HNL\": 26.685156,\n        \"HRK\": 7.598132,\n        \"HTG\": 142.513142,\n        \"HUF\": 382.707793,\n        \"IDR\": 16801.292339,\n        \"ILS\": 4.007585,\n        \"IMP\": 0.859886,\n        \"INR\": 89.987955,\n        \"IQD\": 1414.081256,\n        \"IRR\": 45602.907562,\n        \"ISK\": 151.109018,\n        \"JEP\": 0.859886,\n        \"JMD\": 167.700721,\n        \"JOD\": 0.765366,\n        \"JPY\": 157.115675,\n        \"KES\": 165.523229,\n        \"KGS\": 96.379362,\n        \"KHR\": 4440.24707,\n        \"KMF\": 493.571281,\n        \"KPW\": 971.097551,\n        \"KRW\": 1417.685123,\n        \"KWD\": 0.332733,\n        \"KYD\": 0.8989,\n        \"KZT\": 493.04112,\n        \"LAK\": 22368.488843,\n        \"LBP\": 16154.243871,\n        \"LKR\": 352.747636,\n        \"LRD\": 203.02122,\n        \"LSL\": 20.582684,\n        \"LTL\": 3.186123,\n        \"LVL\": 0.6527,\n        \"LYD\": 5.211954,\n        \"MAD\": 10.976529,\n        \"MDL\": 19.340873,\n        \"MGA\": 4939.301335,\n        \"MKD\": 61.507276,\n        \"MMK\": 2265.283559,\n        \"MNT\": 3705.780074,\n        \"MOP\": 8.676817,\n        \"MRU\": 42.727878,\n        \"MUR\": 47.690625,\n        \"MVR\": 16.584924,\n        \"MWK\": 1816.023037,\n        \"MXN\": 18.69803,\n        \"MYR\": 5.052606,\n        \"MZN\": 68.249194,\n        \"NAD\": 20.588506,\n        \"NGN\": 865.924709,\n        \"NIO\": 39.6024,\n        \"NOK\": 11.848426,\n        \"NPR\": 143.865605,\n        \"NZD\": 1.761931,\n        \"OMR\": 0.415394,\n        \"PAB\": 1.07864,\n        \"PEN\": 4.073376,\n        \"PGK\": 4.025102,\n        \"PHP\": 59.974075,\n        \"PKR\": 306.446851,\n        \"PLN\": 4.334063,\n        \"PYG\": 7963.910929,\n        \"QAR\": 3.928776,\n        \"RON\": 4.973399,\n        \"RSD\": 117.196649,\n        \"RUB\": 97.248412,\n        \"RWF\": 1351.496966,\n        \"SAR\": 4.047186,\n        \"SBD\": 9.12268,\n        \"SCR\": 14.561036,\n        \"SDG\": 648.5028,\n        \"SEK\": 11.285032,\n        \"SGD\": 1.449037,\n        \"SHP\": 1.312921,\n        \"SLE\": 24.488188,\n        \"SLL\": 21311.029931,\n        \"SOS\": 616.131981,\n        \"SRD\": 40.655509,\n        \"STD\": 22333.938945,\n        \"SYP\": 14029.21897,\n        \"SZL\": 20.587826,\n        \"THB\": 38.597298,\n        \"TJS\": 11.757734,\n        \"TMT\": 3.776638,\n        \"TND\": 3.377493,\n        \"TOP\": 2.551714,\n        \"TRY\": 31.312865,\n        \"TTD\": 7.321483,\n        \"TWD\": 34.012943,\n        \"TZS\": 2697.598652,\n        \"UAH\": 39.917867,\n        \"UGX\": 4102.367289,\n        \"USD\": 1.079039,\n        \"UYU\": 42.422631,\n        \"UZS\": 13299.161683,\n        \"VEF\": 3838024.202021,\n        \"VES\": 38.392542,\n        \"VND\": 26188.28851,\n        \"VUV\": 129.693288,\n        \"WST\": 2.964402,\n        \"XAF\": 655.37362,\n        \"XAG\": 0.047456,\n        \"XAU\": 0.000545,\n        \"XCD\": 2.916158,\n        \"XDR\": 0.811478,\n        \"XOF\": 657.134976,\n        \"XPF\": 119.331742,\n        \"YER\": 270.110528,\n        \"ZAR\": 20.470755,\n        \"ZMK\": 9712.646776,\n        \"ZMW\": 26.319693,\n        \"ZWL\": 347.450277\n    }\n}\n*/\n//# sourceMappingURL=echangeRates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/echangeRates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/getBeefForTxid.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/getBeefForTxid.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBeefForTxid = getBeefForTxid;\nconst StorageProvider_1 = __webpack_require__(/*! ../../storage/StorageProvider */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js\");\nasync function getBeefForTxid(services, txid) {\n    const storage = new ServicesOnlyStorageProvider(services);\n    const beef = await storage.getBeefForTxid(txid);\n    return beef;\n}\n/**\n * The generalized implementation of getBeefForTransaction uses storage to\n * avoid incurring the cost of redundant block chain data queries.\n *\n * This class makes the generalized implementation of getBeefForTransaction\n * available in situations where there storage is not relevant.\n */\nclass ServicesOnlyStorageProvider extends StorageProvider_1.StorageProvider {\n    constructor(services) {\n        const o = StorageProvider_1.StorageProvider.createStorageBaseOptions(services.chain);\n        super(o);\n        this.nip = new Error('Method not implemented.');\n        this.setServices(services);\n        this.gbo = {\n            ignoreServices: false,\n            ignoreStorage: true,\n            ignoreNewProven: true\n        };\n    }\n    async getBeefForTxid(txid) {\n        const beef = await this.getBeefForTransaction(txid, this.gbo);\n        return beef;\n    }\n    reviewStatus(args) {\n        throw this.nip;\n    }\n    purgeData(params, trx) {\n        throw this.nip;\n    }\n    allocateChangeInput(userId, basketId, targetSatoshis, exactSatoshis, excludeSending, transactionId) {\n        throw this.nip;\n    }\n    getProvenOrRawTx(txid, trx) {\n        throw this.nip;\n    }\n    getRawTxOfKnownValidTransaction(txid, offset, length, trx) {\n        throw this.nip;\n    }\n    getLabelsForTransactionId(transactionId, trx) {\n        throw this.nip;\n    }\n    getTagsForOutputId(outputId, trx) {\n        throw this.nip;\n    }\n    listActions(auth, args) {\n        throw this.nip;\n    }\n    listOutputs(auth, args) {\n        throw this.nip;\n    }\n    countChangeInputs(userId, basketId, excludeSending) {\n        throw this.nip;\n    }\n    findCertificatesAuth(auth, args) {\n        throw this.nip;\n    }\n    findOutputBasketsAuth(auth, args) {\n        throw this.nip;\n    }\n    findOutputsAuth(auth, args) {\n        throw this.nip;\n    }\n    insertCertificateAuth(auth, certificate) {\n        throw this.nip;\n    }\n    dropAllData() {\n        throw this.nip;\n    }\n    migrate(storageName, storageIdentityKey) {\n        throw this.nip;\n    }\n    findOutputTagMaps(args) {\n        throw this.nip;\n    }\n    findProvenTxReqs(args) {\n        throw this.nip;\n    }\n    findProvenTxs(args) {\n        throw this.nip;\n    }\n    findTxLabelMaps(args) {\n        throw this.nip;\n    }\n    countOutputTagMaps(args) {\n        throw this.nip;\n    }\n    countProvenTxReqs(args) {\n        throw this.nip;\n    }\n    countProvenTxs(args) {\n        throw this.nip;\n    }\n    countTxLabelMaps(args) {\n        throw this.nip;\n    }\n    insertCertificate(certificate, trx) {\n        throw this.nip;\n    }\n    insertCertificateField(certificateField, trx) {\n        throw this.nip;\n    }\n    insertCommission(commission, trx) {\n        throw this.nip;\n    }\n    insertMonitorEvent(event, trx) {\n        throw this.nip;\n    }\n    insertOutput(output, trx) {\n        throw this.nip;\n    }\n    insertOutputBasket(basket, trx) {\n        throw this.nip;\n    }\n    insertOutputTag(tag, trx) {\n        throw this.nip;\n    }\n    insertOutputTagMap(tagMap, trx) {\n        throw this.nip;\n    }\n    insertProvenTx(tx, trx) {\n        throw this.nip;\n    }\n    insertProvenTxReq(tx, trx) {\n        throw this.nip;\n    }\n    insertSyncState(syncState, trx) {\n        throw this.nip;\n    }\n    insertTransaction(tx, trx) {\n        throw this.nip;\n    }\n    insertTxLabel(label, trx) {\n        throw this.nip;\n    }\n    insertTxLabelMap(labelMap, trx) {\n        throw this.nip;\n    }\n    insertUser(user, trx) {\n        throw this.nip;\n    }\n    updateCertificate(id, update, trx) {\n        throw this.nip;\n    }\n    updateCertificateField(certificateId, fieldName, update, trx) {\n        throw this.nip;\n    }\n    updateCommission(id, update, trx) {\n        throw this.nip;\n    }\n    updateMonitorEvent(id, update, trx) {\n        throw this.nip;\n    }\n    updateOutput(id, update, trx) {\n        throw this.nip;\n    }\n    updateOutputBasket(id, update, trx) {\n        throw this.nip;\n    }\n    updateOutputTag(id, update, trx) {\n        throw this.nip;\n    }\n    updateOutputTagMap(outputId, tagId, update, trx) {\n        throw this.nip;\n    }\n    updateProvenTx(id, update, trx) {\n        throw this.nip;\n    }\n    updateProvenTxReq(id, update, trx) {\n        throw this.nip;\n    }\n    updateSyncState(id, update, trx) {\n        throw this.nip;\n    }\n    updateTransaction(id, update, trx) {\n        throw this.nip;\n    }\n    updateTxLabel(id, update, trx) {\n        throw this.nip;\n    }\n    updateTxLabelMap(transactionId, txLabelId, update, trx) {\n        throw this.nip;\n    }\n    updateUser(id, update, trx) {\n        throw this.nip;\n    }\n    destroy() {\n        throw this.nip;\n    }\n    transaction(scope, trx) {\n        throw this.nip;\n    }\n    readSettings(trx) {\n        throw this.nip;\n    }\n    findCertificateFields(args) {\n        throw this.nip;\n    }\n    findCertificates(args) {\n        throw this.nip;\n    }\n    findCommissions(args) {\n        throw this.nip;\n    }\n    findMonitorEvents(args) {\n        throw this.nip;\n    }\n    findOutputBaskets(args) {\n        throw this.nip;\n    }\n    findOutputs(args) {\n        throw this.nip;\n    }\n    findOutputTags(args) {\n        throw this.nip;\n    }\n    findSyncStates(args) {\n        throw this.nip;\n    }\n    findTransactions(args) {\n        throw this.nip;\n    }\n    findTxLabels(args) {\n        throw this.nip;\n    }\n    findUsers(args) {\n        throw this.nip;\n    }\n    countCertificateFields(args) {\n        throw this.nip;\n    }\n    countCertificates(args) {\n        throw this.nip;\n    }\n    countCommissions(args) {\n        throw this.nip;\n    }\n    countMonitorEvents(args) {\n        throw this.nip;\n    }\n    countOutputBaskets(args) {\n        throw this.nip;\n    }\n    countOutputs(args) {\n        throw this.nip;\n    }\n    countOutputTags(args) {\n        throw this.nip;\n    }\n    countSyncStates(args) {\n        throw this.nip;\n    }\n    countTransactions(args) {\n        throw this.nip;\n    }\n    countTxLabels(args) {\n        throw this.nip;\n    }\n    countUsers(args) {\n        throw this.nip;\n    }\n    getProvenTxsForUser(args) {\n        throw this.nip;\n    }\n    getProvenTxReqsForUser(args) {\n        throw this.nip;\n    }\n    getTxLabelMapsForUser(args) {\n        throw this.nip;\n    }\n    getOutputTagMapsForUser(args) {\n        throw this.nip;\n    }\n    adminStats(adminIdentityKey) {\n        throw this.nip;\n    }\n}\n//# sourceMappingURL=getBeefForTxid.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/services/providers/getBeefForTxid.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/WalletSigner.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/WalletSigner.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletSigner = void 0;\nclass WalletSigner {\n    constructor(chain, keyDeriver, storage) {\n        this.isWalletSigner = true;\n        this.chain = chain;\n        this.keyDeriver = keyDeriver;\n        this.storage = storage;\n    }\n}\nexports.WalletSigner = WalletSigner;\n//# sourceMappingURL=WalletSigner.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/WalletSigner.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/acquireDirectCertificate.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/acquireDirectCertificate.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.acquireDirectCertificate = acquireDirectCertificate;\nasync function acquireDirectCertificate(wallet, auth, vargs) {\n    var _a;\n    const now = new Date();\n    const newCert = {\n        certificateId: 0, // replaced by storage insert\n        created_at: now,\n        updated_at: now,\n        userId: auth.userId,\n        type: vargs.type,\n        subject: vargs.subject,\n        verifier: vargs.keyringRevealer === 'certifier' ? vargs.certifier : vargs.keyringRevealer,\n        serialNumber: vargs.serialNumber,\n        certifier: vargs.certifier,\n        revocationOutpoint: vargs.revocationOutpoint,\n        signature: vargs.signature,\n        fields: [],\n        isDeleted: false\n    };\n    for (const [name, value] of Object.entries(vargs.fields)) {\n        (_a = newCert.fields) === null || _a === void 0 ? void 0 : _a.push({\n            certificateId: 0, // replaced by storage insert\n            created_at: now,\n            updated_at: now,\n            userId: auth.userId,\n            fieldName: name,\n            fieldValue: value,\n            masterKey: vargs.keyringForSubject[name] || ''\n        });\n    }\n    const count = await wallet.storage.insertCertificate(newCert);\n    const r = {\n        type: vargs.type,\n        subject: vargs.subject,\n        serialNumber: vargs.serialNumber,\n        certifier: vargs.certifier,\n        revocationOutpoint: vargs.revocationOutpoint,\n        signature: vargs.signature,\n        fields: vargs.fields\n    };\n    return r;\n}\n//# sourceMappingURL=acquireDirectCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/acquireDirectCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/buildSignableTransaction.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/buildSignableTransaction.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buildSignableTransaction = buildSignableTransaction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst createAction_1 = __webpack_require__(/*! ./createAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js\");\nfunction buildSignableTransaction(dctr, args, wallet) {\n    var _a;\n    const changeKeys = wallet.getClientChangeKeyPair();\n    const inputBeef = args.inputBEEF ? sdk_1.Beef.fromBinary(args.inputBEEF) : undefined;\n    const { inputs: storageInputs, outputs: storageOutputs } = dctr;\n    const tx = new sdk_1.Transaction(args.version, [], [], args.lockTime);\n    // The order of outputs in storageOutputs is always:\n    // CreateActionArgs.outputs in the original order\n    // Commission output\n    // Change outputs\n    // The Vout values will be randomized if args.options.randomizeOutputs is true. Default is true.\n    const voutToIndex = Array(storageOutputs.length);\n    for (let vout = 0; vout < storageOutputs.length; vout++) {\n        const i = storageOutputs.findIndex(o => o.vout === vout);\n        if (i < 0)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('output.vout', `sequential. ${vout} is missing`);\n        voutToIndex[vout] = i;\n    }\n    //////////////\n    // Add OUTPUTS\n    /////////////\n    for (let vout = 0; vout < storageOutputs.length; vout++) {\n        const i = voutToIndex[vout];\n        const out = storageOutputs[i];\n        if (vout !== out.vout)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('output.vout', `equal to array index. ${out.vout} !== ${vout}`);\n        const change = out.providedBy === 'storage' && out.purpose === 'change';\n        const lockingScript = change\n            ? (0, createAction_1.makeChangeLock)(out, dctr, args, changeKeys, wallet)\n            : (0, index_client_1.asBsvSdkScript)(out.lockingScript);\n        const output = {\n            satoshis: out.satoshis,\n            lockingScript,\n            change\n        };\n        tx.addOutput(output);\n    }\n    if (storageOutputs.length === 0) {\n        // Add a dummy output to avoid transaction rejection by processors for having no outputs.\n        const output = {\n            satoshis: 0,\n            lockingScript: sdk_1.Script.fromASM('OP_FALSE OP_RETURN 42'),\n            change: false\n        };\n        tx.addOutput(output);\n    }\n    //////////////\n    // Merge and sort INPUTS info by vin order.\n    /////////////\n    const inputs = [];\n    for (const storageInput of storageInputs) {\n        const argsInput = storageInput.vin !== undefined && storageInput.vin < args.inputs.length\n            ? args.inputs[storageInput.vin]\n            : undefined;\n        inputs.push({ argsInput, storageInput });\n    }\n    inputs.sort((a, b) => a.storageInput.vin < b.storageInput.vin ? -1 : a.storageInput.vin === b.storageInput.vin ? 0 : 1);\n    const pendingStorageInputs = [];\n    //////////////\n    // Add INPUTS\n    /////////////\n    let totalChangeInputs = 0;\n    for (const { storageInput, argsInput } of inputs) {\n        // Two types of inputs are handled: user specified wth/without unlockingScript and storage specified using SABPPP template.\n        if (argsInput) {\n            // Type 1: User supplied input, with or without an explicit unlockingScript.\n            // If without, signAction must be used to provide the actual unlockScript.\n            const hasUnlock = typeof argsInput.unlockingScript === 'string';\n            const unlock = hasUnlock ? (0, index_client_1.asBsvSdkScript)(argsInput.unlockingScript) : new sdk_1.Script();\n            const sourceTransaction = args.isSignAction ? (_a = inputBeef === null || inputBeef === void 0 ? void 0 : inputBeef.findTxid(argsInput.outpoint.txid)) === null || _a === void 0 ? void 0 : _a.tx : undefined;\n            const inputToAdd = {\n                sourceTXID: argsInput.outpoint.txid,\n                sourceOutputIndex: argsInput.outpoint.vout,\n                // Include the source transaction for access to the outputs locking script and output satoshis for user side fee calculation.\n                // TODO: Make this conditional to improve performance when user can supply locking scripts themselves.\n                sourceTransaction,\n                unlockingScript: unlock,\n                sequence: argsInput.sequenceNumber\n            };\n            tx.addInput(inputToAdd);\n        }\n        else {\n            // Type2: SABPPP protocol inputs which are signed using ScriptTemplateBRC29.\n            if (storageInput.type !== 'P2PKH')\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('type', `vin ${storageInput.vin}, \"${storageInput.type}\" is not a supported unlocking script type.`);\n            pendingStorageInputs.push({\n                vin: tx.inputs.length,\n                derivationPrefix: (0, index_client_1.verifyTruthy)(storageInput.derivationPrefix),\n                derivationSuffix: (0, index_client_1.verifyTruthy)(storageInput.derivationSuffix),\n                unlockerPubKey: storageInput.senderIdentityKey,\n                sourceSatoshis: storageInput.sourceSatoshis,\n                lockingScript: storageInput.sourceLockingScript\n            });\n            const inputToAdd = {\n                sourceTXID: storageInput.sourceTxid,\n                sourceOutputIndex: storageInput.sourceVout,\n                sourceTransaction: storageInput.sourceTransaction\n                    ? sdk_1.Transaction.fromBinary(storageInput.sourceTransaction)\n                    : undefined,\n                unlockingScript: new sdk_1.Script(),\n                sequence: 0xffffffff\n            };\n            tx.addInput(inputToAdd);\n            totalChangeInputs += (0, index_client_1.verifyTruthy)(storageInput.sourceSatoshis);\n        }\n    }\n    // The amount is the total of non-foreign inputs minus change outputs\n    // Note that the amount can be negative when we are redeeming more inputs than we are spending\n    const totalChangeOutputs = storageOutputs\n        .filter(x => x.purpose === 'change')\n        .reduce((acc, el) => acc + el.satoshis, 0);\n    const amount = totalChangeInputs - totalChangeOutputs;\n    return {\n        tx,\n        amount,\n        pdi: pendingStorageInputs,\n        log: ''\n    };\n}\n//# sourceMappingURL=buildSignableTransaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/buildSignableTransaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/completeSignedTransaction.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/completeSignedTransaction.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.completeSignedTransaction = completeSignedTransaction;\nexports.verifyUnlockScripts = verifyUnlockScripts;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst sdk_2 = __webpack_require__(/*! ../../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\nasync function completeSignedTransaction(prior, spends, wallet) {\n    /////////////////////\n    // Insert the user provided unlocking scripts from \"spends\" arg\n    /////////////////////\n    for (const [key, spend] of Object.entries(spends)) {\n        const vin = Number(key);\n        const createInput = prior.args.inputs[vin];\n        const input = prior.tx.inputs[vin];\n        if (!createInput || !input || createInput.unlockingScript || !Number.isInteger(createInput.unlockingScriptLength))\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `spend does not correspond to prior input with valid unlockingScriptLength.`);\n        if (spend.unlockingScript.length / 2 > createInput.unlockingScriptLength)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `spend unlockingScript length ${spend.unlockingScript.length} exceeds expected length ${createInput.unlockingScriptLength}`);\n        input.unlockingScript = (0, index_client_1.asBsvSdkScript)(spend.unlockingScript);\n        if (spend.sequenceNumber !== undefined)\n            input.sequence = spend.sequenceNumber;\n    }\n    const results = {\n        sdk: {}\n    };\n    /////////////////////\n    // Insert SABPPP unlock templates for wallet signed inputs\n    /////////////////////\n    for (const pdi of prior.pdi) {\n        const sabppp = new index_client_1.ScriptTemplateBRC29({\n            derivationPrefix: pdi.derivationPrefix,\n            derivationSuffix: pdi.derivationSuffix,\n            keyDeriver: wallet.keyDeriver\n        });\n        const keys = wallet.getClientChangeKeyPair();\n        const lockerPrivKey = keys.privateKey;\n        const unlockerPubKey = pdi.unlockerPubKey || keys.publicKey;\n        const sourceSatoshis = pdi.sourceSatoshis;\n        const lockingScript = (0, index_client_1.asBsvSdkScript)(pdi.lockingScript);\n        const unlockTemplate = sabppp.unlock(lockerPrivKey, unlockerPubKey, sourceSatoshis, lockingScript);\n        const input = prior.tx.inputs[pdi.vin];\n        input.unlockingScriptTemplate = unlockTemplate;\n    }\n    /////////////////////\n    // Sign wallet signed inputs making transaction fully valid.\n    /////////////////////\n    await prior.tx.sign();\n    return prior.tx;\n}\n/**\n * @param txid The TXID of a transaction in the beef for which all unlocking scripts must be valid.\n * @param beef Must contain transactions for txid and all its inputs.\n * @throws WERR_INVALID_PARAMETER if any unlocking script is invalid, if sourceTXID is invalid, if beef doesn't contain required transactions.\n */\nfunction verifyUnlockScripts(txid, beef) {\n    var _a, _b, _c, _d;\n    const tx = (_a = beef.findTxid(txid)) === null || _a === void 0 ? void 0 : _a.tx;\n    if (!tx)\n        throw new sdk_2.WERR_INVALID_PARAMETER(`txid`, `contained in beef, txid ${txid}`);\n    for (let i = 0; i < tx.inputs.length; i++) {\n        const input = tx.inputs[i];\n        if (!input.sourceTXID)\n            throw new sdk_2.WERR_INVALID_PARAMETER(`inputs[${i}].sourceTXID`, `valid`);\n        if (!input.unlockingScript)\n            throw new sdk_2.WERR_INVALID_PARAMETER(`inputs[${i}].unlockingScript`, `valid`);\n        input.sourceTransaction = (_b = beef.findTxid(input.sourceTXID)) === null || _b === void 0 ? void 0 : _b.tx;\n        if (!input.sourceTransaction) {\n            // The beef doesn't contain all the source transactions only if advanced features\n            // such as knownTxids are used.\n            // Skip unlock script checks.\n            return;\n            // throw new WERR_INVALID_PARAMETER(`inputs[${i}].sourceTXID`, `contained in beef`)\n        }\n    }\n    for (let i = 0; i < tx.inputs.length; i++) {\n        const input = tx.inputs[i];\n        const sourceOutput = input.sourceTransaction.outputs[input.sourceOutputIndex];\n        const otherInputs = tx.inputs.filter((_, idx) => idx !== i);\n        const spend = new sdk_1.Spend({\n            sourceTXID: input.sourceTXID,\n            sourceOutputIndex: input.sourceOutputIndex,\n            lockingScript: sourceOutput.lockingScript,\n            sourceSatoshis: (_c = sourceOutput.satoshis) !== null && _c !== void 0 ? _c : 0,\n            transactionVersion: tx.version,\n            otherInputs,\n            unlockingScript: input.unlockingScript,\n            inputSequence: (_d = input.sequence) !== null && _d !== void 0 ? _d : 0,\n            inputIndex: i,\n            outputs: tx.outputs,\n            lockTime: tx.lockTime\n        });\n        try {\n            const spendValid = spend.validate();\n            if (!spendValid)\n                throw new sdk_2.WERR_INVALID_PARAMETER(`inputs[${i}].unlockScript`, `valid`);\n        }\n        catch (eu) {\n            const e = sdk_2.WalletError.fromUnknown(eu);\n            throw new sdk_2.WERR_INVALID_PARAMETER(`inputs[${i}].unlockScript`, `valid. ${e.message}`);\n        }\n    }\n}\n//# sourceMappingURL=completeSignedTransaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/completeSignedTransaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createAction = createAction;\nexports.makeChangeLock = makeChangeLock;\nexports.processAction = processAction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst sdk_2 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst buildSignableTransaction_1 = __webpack_require__(/*! ./buildSignableTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/buildSignableTransaction.js\");\nconst completeSignedTransaction_1 = __webpack_require__(/*! ./completeSignedTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/completeSignedTransaction.js\");\nasync function createAction(wallet, auth, vargs) {\n    var _a;\n    const r = {};\n    let prior = undefined;\n    if (vargs.isNewTx) {\n        prior = await createNewTx(wallet, vargs);\n        if (vargs.isSignAction) {\n            return makeSignableTransactionResult(prior, wallet, vargs);\n        }\n        prior.tx = await (0, completeSignedTransaction_1.completeSignedTransaction)(prior, {}, wallet);\n        r.txid = prior.tx.id('hex');\n        const beef = new sdk_1.Beef();\n        if (prior.dcr.inputBeef)\n            beef.mergeBeef(prior.dcr.inputBeef);\n        beef.mergeTransaction(prior.tx);\n        (0, completeSignedTransaction_1.verifyUnlockScripts)(r.txid, beef);\n        r.noSendChange = (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${r.txid}.${vout}`);\n        if (!vargs.options.returnTXIDOnly)\n            r.tx = beef.toBinaryAtomic(r.txid);\n    }\n    const { sendWithResults, notDelayedResults } = await processAction(prior, wallet, auth, vargs);\n    r.sendWithResults = sendWithResults;\n    r.notDelayedResults = notDelayedResults;\n    return r;\n}\nasync function createNewTx(wallet, args) {\n    const storageArgs = removeUnlockScripts(args);\n    const dcr = await wallet.storage.createAction(storageArgs);\n    const reference = dcr.reference;\n    const { tx, amount, pdi } = (0, buildSignableTransaction_1.buildSignableTransaction)(dcr, args, wallet);\n    const prior = { reference, dcr, args, amount, tx, pdi };\n    return prior;\n}\nfunction makeSignableTransactionResult(prior, wallet, args) {\n    var _a;\n    if (!prior.dcr.inputBeef)\n        throw new index_client_1.sdk.WERR_INTERNAL('prior.dcr.inputBeef must be valid');\n    const txid = prior.tx.id('hex');\n    const r = {\n        noSendChange: args.isNoSend ? (_a = prior.dcr.noSendChangeOutputVouts) === null || _a === void 0 ? void 0 : _a.map(vout => `${txid}.${vout}`) : undefined,\n        signableTransaction: {\n            reference: prior.dcr.reference,\n            tx: makeSignableTransactionBeef(prior.tx, prior.dcr.inputBeef)\n        }\n    };\n    wallet.pendingSignActions[r.signableTransaction.reference] = prior;\n    return r;\n}\nfunction makeSignableTransactionBeef(tx, inputBEEF) {\n    // This is a special case beef for transaction signing.\n    // We only need the transaction being signed, and for each input, the raw source transaction.\n    const beef = new sdk_1.Beef();\n    for (const input of tx.inputs) {\n        if (!input.sourceTransaction)\n            throw new index_client_1.sdk.WERR_INTERNAL('Every signableTransaction input must have a sourceTransaction');\n        beef.mergeRawTx(input.sourceTransaction.toBinary());\n    }\n    beef.mergeRawTx(tx.toBinary());\n    return beef.toBinaryAtomic(tx.id('hex'));\n}\n/**\n * Derive a change output locking script\n */\nfunction makeChangeLock(out, dctr, args, changeKeys, wallet) {\n    const derivationPrefix = dctr.derivationPrefix;\n    const derivationSuffix = (0, index_client_1.verifyTruthy)(out.derivationSuffix);\n    const sabppp = new index_client_1.ScriptTemplateBRC29({\n        derivationPrefix,\n        derivationSuffix,\n        keyDeriver: wallet.keyDeriver\n    });\n    const lockingScript = sabppp.lock(changeKeys.privateKey, changeKeys.publicKey);\n    return lockingScript;\n}\nfunction removeUnlockScripts(args) {\n    let storageArgs = args;\n    if (!storageArgs.inputs.every(i => i.unlockingScript === undefined)) {\n        // Never send unlocking scripts to storage, all it needs is the script length.\n        storageArgs = { ...args, inputs: [] };\n        for (const i of args.inputs) {\n            const di = {\n                ...i,\n                unlockingScriptLength: i.unlockingScript !== undefined ? i.unlockingScript.length : i.unlockingScriptLength\n            };\n            delete di.unlockingScript;\n            storageArgs.inputs.push(di);\n        }\n    }\n    return storageArgs;\n}\nasync function processAction(prior, wallet, auth, vargs) {\n    const args = {\n        isNewTx: vargs.isNewTx,\n        isSendWith: vargs.isSendWith,\n        isNoSend: vargs.isNoSend,\n        isDelayed: vargs.isDelayed,\n        reference: prior ? prior.reference : undefined,\n        txid: prior ? prior.tx.id('hex') : undefined,\n        rawTx: prior ? prior.tx.toBinary() : undefined,\n        sendWith: vargs.isSendWith ? vargs.options.sendWith : []\n    };\n    const r = await wallet.storage.processAction(args);\n    return r;\n}\nfunction makeDummyTransactionForOutputSatoshis(vout, satoshis) {\n    const tx = new sdk_2.Transaction();\n    for (let i = 0; i < vout; i++)\n        tx.addOutput({ lockingScript: new sdk_2.Script(), satoshis: 0 });\n    tx.addOutput({ lockingScript: new sdk_2.Script(), satoshis });\n    return tx;\n}\n//# sourceMappingURL=createAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/internalizeAction.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/internalizeAction.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.internalizeAction = internalizeAction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * Internalize Action allows a wallet to take ownership of outputs in a pre-existing transaction.\n * The transaction may, or may not already be known to both the storage and user.\n *\n * Two types of outputs are handled: \"wallet payments\" and \"basket insertions\".\n *\n * A \"basket insertion\" output is considered a custom output and has no effect on the wallet's \"balance\".\n *\n * A \"wallet payment\" adds an outputs value to the wallet's change \"balance\". These outputs are assigned to the \"default\" basket.\n *\n * Processing starts with simple validation and then checks for a pre-existing transaction.\n * If the transaction is already known to the user, then the outputs are reviewed against the existing outputs treatment,\n * and merge rules are added to the arguments passed to the storage layer.\n * The existing transaction must be in the 'unproven' or 'completed' status. Any other status is an error.\n *\n * When the transaction already exists, the description is updated. The isOutgoing sense is not changed.\n *\n * \"basket insertion\" Merge Rules:\n * 1. The \"default\" basket may not be specified as the insertion basket.\n * 2. A change output in the \"default\" basket may not be target of an insertion into a different basket.\n * 3. These baskets do not affect the wallet's balance and are typed \"custom\".\n *\n * \"wallet payment\" Merge Rules:\n * 1. Targetting an existing change \"default\" basket output results in a no-op. No error. No alterations made.\n * 2. Targetting a previously \"custom\" non-change output converts it into a change output. This alters the transaction's `amount`, and the wallet balance.\n *\n */\nasync function internalizeAction(wallet, auth, args) {\n    const vargs = index_client_1.sdk.validateInternalizeActionArgs(args);\n    const { ab, tx, txid } = await validateAtomicBeef();\n    const brc29ProtocolID = [2, '3241645161d8'];\n    for (const o of vargs.outputs) {\n        if (o.outputIndex < 0 || o.outputIndex >= tx.outputs.length)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputIndex', `a valid output index in range 0 to ${tx.outputs.length - 1}`);\n        switch (o.protocol) {\n            case 'basket insertion':\n                setupBasketInsertionForOutput(o, vargs);\n                break;\n            case 'wallet payment':\n                setupWalletPaymentForOutput(o, vargs);\n                break;\n            default:\n                throw new index_client_1.sdk.WERR_INTERNAL(`unexpected protocol ${o.protocol}`);\n        }\n    }\n    const r = await wallet.storage.internalizeAction(args);\n    return r;\n    function setupWalletPaymentForOutput(o, dargs) {\n        const p = o.paymentRemittance;\n        const output = tx.outputs[o.outputIndex];\n        if (!p)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('paymentRemitance', `valid for protocol ${o.protocol}`);\n        const keyID = `${p.derivationPrefix} ${p.derivationSuffix}`;\n        const privKey = wallet.keyDeriver.derivePrivateKey(brc29ProtocolID, keyID, p.senderIdentityKey);\n        const expectedLockScript = new sdk_1.P2PKH().lock(privKey.toAddress());\n        if (output.lockingScript.toHex() !== expectedLockScript.toHex())\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('paymentRemitance', `locked by script conforming to BRC-29`);\n    }\n    function setupBasketInsertionForOutput(o, dargs) {\n        /*\n        No additional validations...\n        */\n    }\n    async function validateAtomicBeef() {\n        const ab = sdk_1.Beef.fromBinary(vargs.tx);\n        // TODO: Add support for known txids...\n        const txValid = await ab.verify(await wallet.getServices().getChainTracker(), false);\n        if (!txValid || !ab.atomicTxid) {\n            console.log(`internalizeAction beef is invalid: ${ab.toLogString()}`);\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', 'valid AtomicBEEF');\n        }\n        const txid = ab.atomicTxid;\n        const btx = ab.findTxid(txid);\n        if (!btx)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `valid AtomicBEEF with newest txid of ${txid}`);\n        const tx = btx.tx;\n        return { ab, tx, txid };\n    }\n}\n//# sourceMappingURL=internalizeAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/internalizeAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/proveCertificate.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/proveCertificate.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.proveCertificate = proveCertificate;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nasync function proveCertificate(wallet, auth, vargs) {\n    const lcargs = {\n        partial: {\n            type: vargs.type,\n            serialNumber: vargs.serialNumber,\n            certifier: vargs.certifier,\n            subject: vargs.subject,\n            revocationOutpoint: vargs.revocationOutpoint,\n            signature: vargs.signature\n        },\n        certifiers: [],\n        types: [],\n        limit: 2,\n        offset: 0,\n        privileged: false\n    };\n    const lcr = await wallet.storage.listCertificates(lcargs);\n    if (lcr.certificates.length != 1)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('args', `a unique certificate match`);\n    const storageCert = lcr.certificates[0];\n    const keyringForVerifier = await sdk_1.MasterCertificate.createKeyringForVerifier(wallet, storageCert.certifier, vargs.verifier, storageCert.fields, vargs.fieldsToReveal, storageCert.keyring, storageCert.serialNumber, vargs.privileged, vargs.privilegedReason);\n    return { keyringForVerifier };\n}\n//# sourceMappingURL=proveCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/proveCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/signAction.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/signAction.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.signAction = signAction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst createAction_1 = __webpack_require__(/*! ./createAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/createAction.js\");\nconst sdk_2 = __webpack_require__(/*! ../../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\nconst completeSignedTransaction_1 = __webpack_require__(/*! ./completeSignedTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/completeSignedTransaction.js\");\nasync function signAction(wallet, auth, args) {\n    const prior = wallet.pendingSignActions[args.reference];\n    if (!prior)\n        throw new index_client_1.sdk.WERR_NOT_IMPLEMENTED('recovery of out-of-session signAction reference data is not yet implemented.');\n    if (!prior.dcr.inputBeef)\n        throw new index_client_1.sdk.WERR_INTERNAL('prior.dcr.inputBeef must be valid');\n    const vargs = mergePriorOptions(prior.args, args);\n    prior.tx = await (0, completeSignedTransaction_1.completeSignedTransaction)(prior, vargs.spends, wallet);\n    const { sendWithResults, notDelayedResults } = await (0, createAction_1.processAction)(prior, wallet, auth, vargs);\n    const txid = prior.tx.id('hex');\n    const beef = sdk_1.Beef.fromBinary(prior.dcr.inputBeef);\n    beef.mergeTransaction(prior.tx);\n    (0, completeSignedTransaction_1.verifyUnlockScripts)(txid, beef);\n    const r = {\n        txid: prior.tx.id('hex'),\n        tx: vargs.options.returnTXIDOnly ? undefined : beef.toBinaryAtomic(txid),\n        sendWithResults,\n        notDelayedResults\n    };\n    return r;\n}\nfunction mergePriorOptions(caVargs, saArgs) {\n    const saOptions = (saArgs.options || (saArgs.options = {}));\n    if (saOptions.acceptDelayedBroadcast === undefined)\n        saOptions.acceptDelayedBroadcast = caVargs.options.acceptDelayedBroadcast;\n    if (saOptions.returnTXIDOnly === undefined)\n        saOptions.returnTXIDOnly = caVargs.options.returnTXIDOnly;\n    if (saOptions.noSend === undefined)\n        saOptions.noSend = caVargs.options.noSend;\n    if (saOptions.sendWith === undefined)\n        saOptions.sendWith = caVargs.options.sendWith;\n    return (0, sdk_2.validateSignActionArgs)(saArgs);\n}\n//# sourceMappingURL=signAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/signer/methods/signAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageIdb.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageIdb.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageIdb = void 0;\nconst idb_1 = __webpack_require__(/*! idb */ \"../node_modules/idb/build/index.js\");\nconst sdk = __importStar(__webpack_require__(/*! ../sdk/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nconst utilityHelpers_1 = __webpack_require__(/*! ../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst StorageProvider_1 = __webpack_require__(/*! ./StorageProvider */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js\");\nconst listActionsIdb_1 = __webpack_require__(/*! ./methods/listActionsIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listActionsIdb.js\");\nconst listOutputsIdb_1 = __webpack_require__(/*! ./methods/listOutputsIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listOutputsIdb.js\");\nconst reviewStatusIdb_1 = __webpack_require__(/*! ./methods/reviewStatusIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/reviewStatusIdb.js\");\nconst purgeDataIdb_1 = __webpack_require__(/*! ./methods/purgeDataIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/purgeDataIdb.js\");\n/**\n * This class implements the `StorageProvider` interface using IndexedDB,\n * via the promises wrapper package `idb`.\n */\nclass StorageIdb extends StorageProvider_1.StorageProvider {\n    constructor(options) {\n        super(options);\n        this.allStores = [\n            'certificates',\n            'certificate_fields',\n            'commissions',\n            'monitor_events',\n            'outputs',\n            'output_baskets',\n            'output_tags',\n            'output_tags_map',\n            'proven_txs',\n            'proven_tx_reqs',\n            'sync_states',\n            'transactions',\n            'tx_labels',\n            'tx_labels_map',\n            'users'\n        ];\n        this.dbName = `wallet-toolbox-${this.chain}net`;\n    }\n    /**\n     * This method must be called at least once before any other method accesses the database,\n     * and each time the schema may have updated.\n     *\n     * If the database has already been created in this context, `storageName` and `storageIdentityKey`\n     * are ignored.\n     *\n     * @param storageName\n     * @param storageIdentityKey\n     * @returns\n     */\n    async migrate(storageName, storageIdentityKey) {\n        const db = await this.verifyDB(storageName, storageIdentityKey);\n        return db.version.toString();\n    }\n    /**\n     * Following initial database initialization, this method verfies that db is ready for use.\n     *\n     * @throws `WERR_INVALID_OPERATION` if the database has not been initialized by a call to `migrate`.\n     *\n     * @param storageName\n     * @param storageIdentityKey\n     *\n     * @returns\n     */\n    async verifyDB(storageName, storageIdentityKey) {\n        if (this.db)\n            return this.db;\n        this.db = await this.initDB(storageName, storageIdentityKey);\n        this._settings = (await this.db.getAll('settings'))[0];\n        this.whenLastAccess = new Date();\n        return this.db;\n    }\n    /**\n     * Convert the standard optional `TrxToken` parameter into either a direct knex database instance,\n     * or a Knex.Transaction as appropriate.\n     */\n    toDbTrx(stores, mode, trx) {\n        if (trx) {\n            const t = trx;\n            return t;\n        }\n        else {\n            if (!this.db)\n                throw new Error('not initialized');\n            const db = this.db;\n            const trx = db.transaction(stores || this.allStores, mode || 'readwrite');\n            this.whenLastAccess = new Date();\n            return trx;\n        }\n    }\n    /**\n     * Called by `makeAvailable` to return storage `TableSettings`.\n     * Since this is the first async method that must be called by all clients,\n     * it is where async initialization occurs.\n     *\n     * After initialization, cached settings are returned.\n     *\n     * @param trx\n     */\n    async readSettings(trx) {\n        await this.verifyDB();\n        return this._settings;\n    }\n    async initDB(storageName, storageIdentityKey) {\n        const chain = this.chain;\n        const maxOutputScript = 1024;\n        const db = await (0, idb_1.openDB)(this.dbName, 1, {\n            upgrade(db, oldVersion, newVersion, transaction) {\n                if (!db.objectStoreNames.contains('proven_txs')) {\n                    // proven_txs object store\n                    const provenTxsStore = db.createObjectStore('proven_txs', {\n                        keyPath: 'provenTxId',\n                        autoIncrement: true\n                    });\n                    provenTxsStore.createIndex('txid', 'txid', { unique: true });\n                }\n                if (!db.objectStoreNames.contains('proven_tx_reqs')) {\n                    // proven_tx_reqs object store\n                    const provenTxReqsStore = db.createObjectStore('proven_tx_reqs', {\n                        keyPath: 'provenTxReqId',\n                        autoIncrement: true\n                    });\n                    provenTxReqsStore.createIndex('provenTxId', 'provenTxId');\n                    provenTxReqsStore.createIndex('txid', 'txid', { unique: true });\n                    provenTxReqsStore.createIndex('status', 'status');\n                    provenTxReqsStore.createIndex('batch', 'batch');\n                }\n                if (!db.objectStoreNames.contains('users')) {\n                    const users = db.createObjectStore('users', {\n                        keyPath: 'userId',\n                        autoIncrement: true\n                    });\n                    users.createIndex('identityKey', 'identityKey', { unique: true });\n                }\n                if (!db.objectStoreNames.contains('certificates')) {\n                    // certificates object store\n                    const certificatesStore = db.createObjectStore('certificates', {\n                        keyPath: 'certificateId',\n                        autoIncrement: true\n                    });\n                    certificatesStore.createIndex('userId', 'userId');\n                    certificatesStore.createIndex('userId_type_certifier_serialNumber', ['userId', 'type', 'certifier', 'serialNumber'], { unique: true });\n                }\n                if (!db.objectStoreNames.contains('certificate_fields')) {\n                    // certificate_fields object store\n                    const certificateFieldsStore = db.createObjectStore('certificate_fields', {\n                        keyPath: ['certificateId', 'fieldName'] // Composite key\n                    });\n                    certificateFieldsStore.createIndex('userId', 'userId');\n                    certificateFieldsStore.createIndex('certificateId', 'certificateId');\n                }\n                if (!db.objectStoreNames.contains('output_baskets')) {\n                    // output_baskets object store\n                    const outputBasketsStore = db.createObjectStore('output_baskets', {\n                        keyPath: 'basketId',\n                        autoIncrement: true\n                    });\n                    outputBasketsStore.createIndex('userId', 'userId');\n                    outputBasketsStore.createIndex('name_userId', ['name', 'userId'], { unique: true });\n                }\n                if (!db.objectStoreNames.contains('transactions')) {\n                    // transactions object store\n                    const transactionsStore = db.createObjectStore('transactions', {\n                        keyPath: 'transactionId',\n                        autoIncrement: true\n                    });\n                    transactionsStore.createIndex('userId', 'userId');\n                    transactionsStore.createIndex('status', 'status'),\n                        transactionsStore.createIndex('status_userId', ['status', 'userId']);\n                    transactionsStore.createIndex('provenTxId', 'provenTxId');\n                    transactionsStore.createIndex('reference', 'reference', { unique: true });\n                }\n                if (!db.objectStoreNames.contains('commissions')) {\n                    // commissions object store\n                    const commissionsStore = db.createObjectStore('commissions', {\n                        keyPath: 'commissionId',\n                        autoIncrement: true\n                    });\n                    commissionsStore.createIndex('userId', 'userId');\n                    commissionsStore.createIndex('transactionId', 'transactionId', { unique: true });\n                }\n                if (!db.objectStoreNames.contains('outputs')) {\n                    // outputs object store\n                    const outputsStore = db.createObjectStore('outputs', {\n                        keyPath: 'outputId',\n                        autoIncrement: true\n                    });\n                    outputsStore.createIndex('userId', 'userId');\n                    outputsStore.createIndex('transactionId', 'transactionId');\n                    outputsStore.createIndex('basketId', 'basketId');\n                    outputsStore.createIndex('spentBy', 'spentBy');\n                    outputsStore.createIndex('transactionId_vout_userId', ['transactionId', 'vout', 'userId'], { unique: true });\n                }\n                if (!db.objectStoreNames.contains('output_tags')) {\n                    // output_tags object store\n                    const outputTagsStore = db.createObjectStore('output_tags', {\n                        keyPath: 'outputTagId',\n                        autoIncrement: true\n                    });\n                    outputTagsStore.createIndex('userId', 'userId');\n                    outputTagsStore.createIndex('tag_userId', ['tag', 'userId'], { unique: true });\n                }\n                if (!db.objectStoreNames.contains('output_tags_map')) {\n                    // output_tags_map object store\n                    const outputTagsMapStore = db.createObjectStore('output_tags_map', {\n                        keyPath: ['outputTagId', 'outputId']\n                    });\n                    outputTagsMapStore.createIndex('outputTagId', 'outputTagId');\n                    outputTagsMapStore.createIndex('outputId', 'outputId');\n                }\n                if (!db.objectStoreNames.contains('tx_labels')) {\n                    // tx_labels object store\n                    const txLabelsStore = db.createObjectStore('tx_labels', {\n                        keyPath: 'txLabelId',\n                        autoIncrement: true\n                    });\n                    txLabelsStore.createIndex('userId', 'userId');\n                    txLabelsStore.createIndex('label_userId', ['label', 'userId'], { unique: true });\n                }\n                if (!db.objectStoreNames.contains('tx_labels_map')) {\n                    // tx_labels_map object store\n                    const txLabelsMapStore = db.createObjectStore('tx_labels_map', {\n                        keyPath: ['txLabelId', 'transactionId']\n                    });\n                    txLabelsMapStore.createIndex('txLabelId', 'txLabelId');\n                    txLabelsMapStore.createIndex('transactionId', 'transactionId');\n                }\n                if (!db.objectStoreNames.contains('monitor_events')) {\n                    // monitor_events object store\n                    const monitorEventsStore = db.createObjectStore('monitor_events', {\n                        keyPath: 'id',\n                        autoIncrement: true\n                    });\n                }\n                if (!db.objectStoreNames.contains('sync_states')) {\n                    // sync_states object store\n                    const syncStatesStore = db.createObjectStore('sync_states', {\n                        keyPath: 'syncStateId',\n                        autoIncrement: true\n                    });\n                    syncStatesStore.createIndex('userId', 'userId');\n                    syncStatesStore.createIndex('refNum', 'refNum', { unique: true });\n                    syncStatesStore.createIndex('status', 'status');\n                }\n                if (!db.objectStoreNames.contains('settings')) {\n                    if (!storageName || !storageIdentityKey) {\n                        throw new sdk.WERR_INVALID_OPERATION('migrate must be called before first access');\n                    }\n                    const settings = db.createObjectStore('settings', {\n                        keyPath: 'storageIdentityKey'\n                    });\n                    const s = {\n                        created_at: new Date(),\n                        updated_at: new Date(),\n                        storageIdentityKey,\n                        storageName,\n                        chain,\n                        dbtype: 'IndexedDB',\n                        maxOutputScript\n                    };\n                    settings.put(s);\n                }\n            }\n        });\n        return db;\n    }\n    //\n    // StorageProvider abstract methods\n    //\n    async reviewStatus(args) {\n        return await (0, reviewStatusIdb_1.reviewStatusIdb)(this, args);\n    }\n    async purgeData(params, trx) {\n        return await (0, purgeDataIdb_1.purgeDataIdb)(this, params, trx);\n    }\n    /**\n     * Proceeds in three stages:\n     * 1. Find an output that exactly funds the transaction (if exactSatoshis is not undefined).\n     * 2. Find an output that overfunds by the least amount (targetSatoshis).\n     * 3. Find an output that comes as close to funding as possible (targetSatoshis).\n     * 4. Return undefined if no output is found.\n     *\n     * Outputs must belong to userId and basketId and have spendable true.\n     * Their corresponding transaction must have status of 'completed', 'unproven', or 'sending' (if excludeSending is false).\n     *\n     * @param userId\n     * @param basketId\n     * @param targetSatoshis\n     * @param exactSatoshis\n     * @param excludeSending\n     * @param transactionId\n     * @returns next funding output to add to transaction or undefined if there are none.\n     */\n    async allocateChangeInput(userId, basketId, targetSatoshis, exactSatoshis, excludeSending, transactionId) {\n        const dbTrx = this.toDbTrx(['outputs', 'transactions'], 'readwrite');\n        try {\n            const txStatus = ['completed', 'unproven'];\n            if (!excludeSending)\n                txStatus.push('sending');\n            const args = {\n                partial: { userId, basketId, spendable: true },\n                txStatus,\n                trx: dbTrx\n            };\n            const outputs = await this.findOutputs(args);\n            let output;\n            let scores = [];\n            for (const o of outputs) {\n                if (exactSatoshis && o.satoshis === exactSatoshis) {\n                    output = o;\n                    break;\n                }\n                const score = o.satoshis - targetSatoshis;\n                scores.push({ output: o, score });\n            }\n            if (!output) {\n                // sort scores increasing by score property\n                scores = scores.sort((a, b) => a.score - b.score);\n                // find the first score that is greater than or equal to 0\n                const o = scores.find(s => s.score >= 0);\n                if (o) {\n                    // stage 2 satisfied (minimally funded)\n                    output = o.output;\n                }\n                else if (scores.length > 0) {\n                    // stage 3 satisfied (minimally under-funded)\n                    output = scores.slice(-1)[0].output;\n                }\n                else {\n                    // no available funding outputs\n                    output = undefined;\n                }\n            }\n            if (output) {\n                // mark output as spent by transactionId\n                await this.updateOutput(output.outputId, { spendable: false, spentBy: transactionId }, dbTrx);\n            }\n            return output;\n        }\n        finally {\n            await dbTrx.done;\n        }\n    }\n    async getProvenOrRawTx(txid, trx) {\n        const r = {\n            proven: undefined,\n            rawTx: undefined,\n            inputBEEF: undefined\n        };\n        r.proven = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { txid: txid }, trx }));\n        if (!r.proven) {\n            const req = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { txid: txid }, trx }));\n            if (req && ['unsent', 'unmined', 'unconfirmed', 'sending', 'nosend', 'completed'].includes(req.status)) {\n                r.rawTx = req.rawTx;\n                r.inputBEEF = req.inputBEEF;\n            }\n        }\n        return r;\n    }\n    async getRawTxOfKnownValidTransaction(txid, offset, length, trx) {\n        if (!txid)\n            return undefined;\n        if (!this.isAvailable())\n            await this.makeAvailable();\n        let rawTx = undefined;\n        const r = await this.getProvenOrRawTx(txid, trx);\n        if (r.proven)\n            rawTx = r.proven.rawTx;\n        else\n            rawTx = r.rawTx;\n        if (rawTx && offset !== undefined && length !== undefined && Number.isInteger(offset) && Number.isInteger(length)) {\n            rawTx = rawTx.slice(offset, offset + length);\n        }\n        return rawTx;\n    }\n    async getLabelsForTransactionId(transactionId, trx) {\n        const maps = await this.findTxLabelMaps({ partial: { transactionId, isDeleted: false }, trx });\n        const labelIds = maps.map(m => m.txLabelId);\n        const labels = [];\n        for (const txLabelId of labelIds) {\n            const label = (0, utilityHelpers_1.verifyOne)(await this.findTxLabels({ partial: { txLabelId, isDeleted: false }, trx }));\n            labels.push(label);\n        }\n        return labels;\n    }\n    async getTagsForOutputId(outputId, trx) {\n        const maps = await this.findOutputTagMaps({ partial: { outputId, isDeleted: false }, trx });\n        const tagIds = maps.map(m => m.outputTagId);\n        const tags = [];\n        for (const outputTagId of tagIds) {\n            const tag = (0, utilityHelpers_1.verifyOne)(await this.findOutputTags({ partial: { outputTagId, isDeleted: false }, trx }));\n            tags.push(tag);\n        }\n        return tags;\n    }\n    async listActions(auth, vargs) {\n        if (!auth.userId)\n            throw new sdk.WERR_UNAUTHORIZED();\n        return await (0, listActionsIdb_1.listActionsIdb)(this, auth, vargs);\n    }\n    async listOutputs(auth, vargs) {\n        if (!auth.userId)\n            throw new sdk.WERR_UNAUTHORIZED();\n        return await (0, listOutputsIdb_1.listOutputsIdb)(this, auth, vargs);\n    }\n    async countChangeInputs(userId, basketId, excludeSending) {\n        const txStatus = ['completed', 'unproven'];\n        if (!excludeSending)\n            txStatus.push('sending');\n        const args = { partial: { userId, basketId }, txStatus };\n        let count = 0;\n        await this.filterOutputs(args, r => {\n            count++;\n        });\n        return count;\n    }\n    async findCertificatesAuth(auth, args) {\n        if (!auth.userId || (args.partial.userId && args.partial.userId !== auth.userId))\n            throw new sdk.WERR_UNAUTHORIZED();\n        args.partial.userId = auth.userId;\n        return await this.findCertificates(args);\n    }\n    async findOutputBasketsAuth(auth, args) {\n        if (!auth.userId || (args.partial.userId && args.partial.userId !== auth.userId))\n            throw new sdk.WERR_UNAUTHORIZED();\n        args.partial.userId = auth.userId;\n        return await this.findOutputBaskets(args);\n    }\n    async findOutputsAuth(auth, args) {\n        if (!auth.userId || (args.partial.userId && args.partial.userId !== auth.userId))\n            throw new sdk.WERR_UNAUTHORIZED();\n        args.partial.userId = auth.userId;\n        return await this.findOutputs(args);\n    }\n    async insertCertificateAuth(auth, certificate) {\n        if (!auth.userId || (certificate.userId && certificate.userId !== auth.userId))\n            throw new sdk.WERR_UNAUTHORIZED();\n        certificate.userId = auth.userId;\n        return await this.insertCertificate(certificate);\n    }\n    //\n    // StorageReaderWriter abstract methods\n    //\n    async dropAllData() {\n        await (0, idb_1.deleteDB)(this.dbName);\n    }\n    async filterOutputTagMaps(args, filtered, userId) {\n        var _a, _b, _c, _d;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['output_tags_map'], 'readonly', args.trx);\n        let cursor;\n        if (((_b = args.partial) === null || _b === void 0 ? void 0 : _b.outputTagId) !== undefined) {\n            cursor = await dbTrx.objectStore('output_tags_map').index('outputTagId').openCursor(args.partial.outputTagId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.outputId) !== undefined) {\n            cursor = await dbTrx.objectStore('output_tags_map').index('outputId').openCursor(args.partial.outputId);\n        }\n        else {\n            cursor = await dbTrx.objectStore('output_tags_map').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.tagIds && !args.tagIds.includes(r.outputTagId))\n                continue;\n            if (args.partial) {\n                if (args.partial.outputTagId && r.outputTagId !== args.partial.outputTagId)\n                    continue;\n                if (args.partial.outputId && r.outputId !== args.partial.outputId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.isDeleted !== undefined && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (userId !== undefined && r.txid) {\n                const count = await this.countOutputTags({ partial: { userId, outputTagId: r.outputTagId }, trx: args.trx });\n                if (count === 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_d = args.paged) === null || _d === void 0 ? void 0 : _d.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findOutputTagMaps(args) {\n        const results = [];\n        await this.filterOutputTagMaps(args, r => {\n            results.push(this.validateEntity(r));\n        });\n        return results;\n    }\n    async filterProvenTxReqs(args, filtered, userId) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (args.partial.rawTx)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.rawTx', `undefined. ProvenTxReqs may not be found by rawTx value.`);\n        if (args.partial.inputBEEF)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.inputBEEF', `undefined. ProvenTxReqs may not be found by inputBEEF value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['proven_tx_reqs'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.provenTxReqId) {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').openCursor(args.partial.provenTxReqId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.provenTxId) !== undefined) {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').index('provenTxId').openCursor(args.partial.provenTxId);\n        }\n        else if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.txid) !== undefined) {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').index('txid').openCursor(args.partial.txid);\n        }\n        else if (((_e = args.partial) === null || _e === void 0 ? void 0 : _e.status) !== undefined) {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').index('status').openCursor(args.partial.status);\n        }\n        else if (((_f = args.partial) === null || _f === void 0 ? void 0 : _f.batch) !== undefined) {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').index('batch').openCursor(args.partial.batch);\n        }\n        else {\n            cursor = await dbTrx.objectStore('proven_tx_reqs').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.provenTxReqId && r.provenTxReqId !== args.partial.provenTxReqId)\n                    continue;\n                if (args.partial.provenTxId && r.provenTxId !== args.partial.provenTxId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.status && r.status !== args.partial.status)\n                    continue;\n                if (args.partial.attempts !== undefined && r.attempts !== args.partial.attempts)\n                    continue;\n                if (args.partial.notified !== undefined && r.notified !== args.partial.notified)\n                    continue;\n                if (args.partial.txid && r.txid !== args.partial.txid)\n                    continue;\n                if (args.partial.batch && r.batch !== args.partial.batch)\n                    continue;\n                if (args.partial.history && r.history !== args.partial.history)\n                    continue;\n                if (args.partial.notify && r.notify !== args.partial.notify)\n                    continue;\n            }\n            if (userId !== undefined && r.txid) {\n                const count = await this.countTransactions({ partial: { userId, txid: r.txid }, trx: args.trx });\n                if (count === 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_g = args.paged) === null || _g === void 0 ? void 0 : _g.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findProvenTxReqs(args) {\n        const results = [];\n        await this.filterProvenTxReqs(args, r => {\n            results.push(this.validateEntity(r));\n        });\n        return results;\n    }\n    async filterProvenTxs(args, filtered, userId) {\n        var _a, _b, _c, _d;\n        if (args.partial.rawTx)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.rawTx', `undefined. ProvenTxs may not be found by rawTx value.`);\n        if (args.partial.merklePath)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.merklePath', `undefined. ProvenTxs may not be found by merklePath value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['proven_txs'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.provenTxId) {\n            cursor = await dbTrx.objectStore('proven_txs').openCursor(args.partial.provenTxId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.txid) !== undefined) {\n            cursor = await dbTrx.objectStore('proven_txs').index('txid').openCursor(args.partial.txid);\n        }\n        else {\n            cursor = await dbTrx.objectStore('proven_txs').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.provenTxId && r.provenTxId !== args.partial.provenTxId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.txid && r.txid !== args.partial.txid)\n                    continue;\n                if (args.partial.height !== undefined && r.height !== args.partial.height)\n                    continue;\n                if (args.partial.index !== undefined && r.index !== args.partial.index)\n                    continue;\n                if (args.partial.blockHash && r.blockHash !== args.partial.blockHash)\n                    continue;\n                if (args.partial.merkleRoot && r.merkleRoot !== args.partial.merkleRoot)\n                    continue;\n            }\n            if (userId !== undefined) {\n                const count = await this.countTransactions({ partial: { userId, provenTxId: r.provenTxId }, trx: args.trx });\n                if (count === 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_d = args.paged) === null || _d === void 0 ? void 0 : _d.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findProvenTxs(args) {\n        const results = [];\n        await this.filterProvenTxs(args, r => {\n            results.push(this.validateEntity(r));\n        });\n        return results;\n    }\n    async filterTxLabelMaps(args, filtered, userId) {\n        var _a, _b, _c, _d;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['tx_labels_map'], 'readonly', args.trx);\n        let cursor;\n        if (((_b = args.partial) === null || _b === void 0 ? void 0 : _b.transactionId) !== undefined) {\n            cursor = await dbTrx.objectStore('tx_labels_map').index('transactionId').openCursor(args.partial.transactionId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.txLabelId) !== undefined) {\n            cursor = await dbTrx.objectStore('tx_labels_map').index('txLabelId').openCursor(args.partial.txLabelId);\n        }\n        else {\n            cursor = await dbTrx.objectStore('tx_labels_map').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.txLabelId && r.txLabelId !== args.partial.txLabelId)\n                    continue;\n                if (args.partial.transactionId && r.transactionId !== args.partial.transactionId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.isDeleted !== undefined && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (userId !== undefined) {\n                const count = await this.countTxLabels({ partial: { userId, txLabelId: r.txLabelId }, trx: args.trx });\n                if (count === 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_d = args.paged) === null || _d === void 0 ? void 0 : _d.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findTxLabelMaps(args) {\n        const results = [];\n        await this.filterTxLabelMaps(args, r => {\n            results.push(this.validateEntity(r));\n        });\n        return results;\n    }\n    async countOutputTagMaps(args) {\n        let count = 0;\n        await this.filterOutputTagMaps(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countProvenTxReqs(args) {\n        let count = 0;\n        await this.filterProvenTxReqs(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countProvenTxs(args) {\n        let count = 0;\n        await this.filterProvenTxs(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countTxLabelMaps(args) {\n        let count = 0;\n        await this.filterTxLabelMaps(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async insertCertificate(certificate, trx) {\n        const e = await this.validateEntityForInsert(certificate, trx, undefined, ['isDeleted']);\n        const fields = e.fields;\n        if (e.fields)\n            delete e.fields;\n        if (e.certificateId === 0)\n            delete e.certificateId;\n        const dbTrx = this.toDbTrx(['certificates', 'certificate_fields'], 'readwrite', trx);\n        const store = dbTrx.objectStore('certificates');\n        try {\n            const id = Number(await store.add(e));\n            certificate.certificateId = id;\n            if (fields) {\n                for (const field of fields) {\n                    field.certificateId = certificate.certificateId;\n                    field.userId = certificate.userId;\n                    await this.insertCertificateField(field, dbTrx);\n                }\n            }\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return certificate.certificateId;\n    }\n    async insertCertificateField(certificateField, trx) {\n        const e = await this.validateEntityForInsert(certificateField, trx);\n        const dbTrx = this.toDbTrx(['certificate_fields'], 'readwrite', trx);\n        const store = dbTrx.objectStore('certificate_fields');\n        try {\n            await store.add(e);\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n    }\n    async insertCommission(commission, trx) {\n        const e = await this.validateEntityForInsert(commission, trx);\n        if (e.commissionId === 0)\n            delete e.commissionId;\n        const dbTrx = this.toDbTrx(['commissions'], 'readwrite', trx);\n        const store = dbTrx.objectStore('commissions');\n        try {\n            const id = Number(await store.add(e));\n            commission.commissionId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return commission.commissionId;\n    }\n    async insertMonitorEvent(event, trx) {\n        const e = await this.validateEntityForInsert(event, trx);\n        if (e.id === 0)\n            delete e.id;\n        const dbTrx = this.toDbTrx(['monitor_events'], 'readwrite', trx);\n        const store = dbTrx.objectStore('monitor_events');\n        try {\n            const id = Number(await store.add(e));\n            event.id = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return event.id;\n    }\n    async insertOutput(output, trx) {\n        const e = await this.validateEntityForInsert(output, trx);\n        if (e.outputId === 0)\n            delete e.outputId;\n        const dbTrx = this.toDbTrx(['outputs'], 'readwrite', trx);\n        const store = dbTrx.objectStore('outputs');\n        try {\n            const id = Number(await store.add(e));\n            output.outputId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return output.outputId;\n    }\n    async insertOutputBasket(basket, trx) {\n        const e = await this.validateEntityForInsert(basket, trx, undefined, ['isDeleted']);\n        if (e.basketId === 0)\n            delete e.basketId;\n        const dbTrx = this.toDbTrx(['output_baskets'], 'readwrite', trx);\n        const store = dbTrx.objectStore('output_baskets');\n        try {\n            const id = Number(await store.add(e));\n            basket.basketId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return basket.basketId;\n    }\n    async insertOutputTag(tag, trx) {\n        const e = await this.validateEntityForInsert(tag, trx, undefined, ['isDeleted']);\n        if (e.outputTagId === 0)\n            delete e.outputTagId;\n        const dbTrx = this.toDbTrx(['output_tags'], 'readwrite', trx);\n        const store = dbTrx.objectStore('output_tags');\n        try {\n            const id = Number(await store.add(e));\n            tag.outputTagId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return tag.outputTagId;\n    }\n    async insertOutputTagMap(tagMap, trx) {\n        const e = await this.validateEntityForInsert(tagMap, trx, undefined, ['isDeleted']);\n        const dbTrx = this.toDbTrx(['output_tags_map'], 'readwrite', trx);\n        const store = dbTrx.objectStore('output_tags_map');\n        try {\n            await store.add(e);\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n    }\n    async insertProvenTx(tx, trx) {\n        const e = await this.validateEntityForInsert(tx, trx);\n        if (e.provenTxId === 0)\n            delete e.provenTxId;\n        const dbTrx = this.toDbTrx(['proven_txs'], 'readwrite', trx);\n        const store = dbTrx.objectStore('proven_txs');\n        try {\n            const id = Number(await store.add(e));\n            tx.provenTxId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return tx.provenTxId;\n    }\n    async insertProvenTxReq(tx, trx) {\n        const e = await this.validateEntityForInsert(tx, trx);\n        if (e.provenTxReqId === 0)\n            delete e.provenTxReqId;\n        const dbTrx = this.toDbTrx(['proven_tx_reqs'], 'readwrite', trx);\n        const store = dbTrx.objectStore('proven_tx_reqs');\n        try {\n            const id = Number(await store.add(e));\n            tx.provenTxReqId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return tx.provenTxReqId;\n    }\n    async insertSyncState(syncState, trx) {\n        const e = await this.validateEntityForInsert(syncState, trx, ['when'], ['init']);\n        if (e.syncStateId === 0)\n            delete e.syncStateId;\n        const dbTrx = this.toDbTrx(['sync_states'], 'readwrite', trx);\n        const store = dbTrx.objectStore('sync_states');\n        try {\n            const id = Number(await store.add(e));\n            syncState.syncStateId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return syncState.syncStateId;\n    }\n    async insertTransaction(tx, trx) {\n        const e = await this.validateEntityForInsert(tx, trx);\n        if (e.transactionId === 0)\n            delete e.transactionId;\n        const dbTrx = this.toDbTrx(['transactions'], 'readwrite', trx);\n        const store = dbTrx.objectStore('transactions');\n        try {\n            const id = Number(await store.add(e));\n            tx.transactionId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return tx.transactionId;\n    }\n    async insertTxLabel(label, trx) {\n        const e = await this.validateEntityForInsert(label, trx, undefined, ['isDeleted']);\n        if (e.txLabelId === 0)\n            delete e.txLabelId;\n        const dbTrx = this.toDbTrx(['tx_labels'], 'readwrite', trx);\n        const store = dbTrx.objectStore('tx_labels');\n        try {\n            const id = Number(await store.add(e));\n            label.txLabelId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return label.txLabelId;\n    }\n    async insertTxLabelMap(labelMap, trx) {\n        const e = await this.validateEntityForInsert(labelMap, trx, undefined, ['isDeleted']);\n        const dbTrx = this.toDbTrx(['tx_labels_map'], 'readwrite', trx);\n        const store = dbTrx.objectStore('tx_labels_map');\n        try {\n            await store.add(e);\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n    }\n    async insertUser(user, trx) {\n        const e = await this.validateEntityForInsert(user, trx);\n        if (e.userId === 0)\n            delete e.userId;\n        const dbTrx = this.toDbTrx(['users'], 'readwrite', trx);\n        const store = dbTrx.objectStore('users');\n        try {\n            const id = Number(await store.add(e));\n            user.userId = id;\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return user.userId;\n    }\n    async updateIdb(id, update, keyProp, storeName, trx) {\n        if (update[keyProp] !== undefined && (Array.isArray(id) || update[keyProp] !== id)) {\n            throw new sdk.WERR_INVALID_PARAMETER(`update.${keyProp}`, `undefined`);\n        }\n        const u = this.validatePartialForUpdate(update);\n        const dbTrx = this.toDbTrx([storeName], 'readwrite', trx);\n        const store = dbTrx.objectStore(storeName);\n        const ids = Array.isArray(id) ? id : [id];\n        try {\n            for (const i of ids) {\n                const e = await store.get(i);\n                if (!e)\n                    throw new sdk.WERR_INVALID_PARAMETER('id', `an existing record to update ${keyProp} ${i} not found`);\n                const v = {\n                    ...e,\n                    ...u\n                };\n                const uid = await store.put(v);\n                if (uid !== i)\n                    throw new sdk.WERR_INTERNAL(`updated id ${uid} does not match original ${id}`);\n            }\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return 1;\n    }\n    async updateIdbKey(key, update, keyProps, storeName, trx) {\n        if (key.length !== keyProps.length)\n            throw new sdk.WERR_INTERNAL(`key.length ${key.length} !== keyProps.length ${keyProps.length}`);\n        for (let i = 0; i < key.length; i++) {\n            if (update[keyProps[i]] !== undefined && update[keyProps[i]] !== key[i]) {\n                throw new sdk.WERR_INVALID_PARAMETER(`update.${keyProps[i]}`, `undefined`);\n            }\n        }\n        const u = this.validatePartialForUpdate(update);\n        const dbTrx = this.toDbTrx([storeName], 'readwrite', trx);\n        const store = dbTrx.objectStore(storeName);\n        try {\n            const e = await store.get(key);\n            if (!e)\n                throw new sdk.WERR_INVALID_PARAMETER('key', `an existing record to update ${keyProps.join(',')} ${key.join(',')} not found`);\n            const v = {\n                ...e,\n                ...u\n            };\n            const uid = await store.put(v);\n            for (let i = 0; i < key.length; i++) {\n                if (uid[i] !== key[i])\n                    throw new sdk.WERR_INTERNAL(`updated key ${uid[i]} does not match original ${key[i]}`);\n            }\n        }\n        finally {\n            if (!trx)\n                await dbTrx.done;\n        }\n        return 1;\n    }\n    async updateCertificate(id, update, trx) {\n        return this.updateIdb(id, update, 'certificateId', 'certificates', trx);\n    }\n    async updateCertificateField(certificateId, fieldName, update, trx) {\n        return this.updateIdbKey([certificateId, fieldName], update, ['certificateId', 'fieldName'], 'certificate_fields', trx);\n    }\n    async updateCommission(id, update, trx) {\n        return this.updateIdb(id, update, 'commissionId', 'commissions', trx);\n    }\n    async updateMonitorEvent(id, update, trx) {\n        return this.updateIdb(id, update, 'id', 'monitor_events', trx);\n    }\n    async updateOutput(id, update, trx) {\n        return this.updateIdb(id, update, 'outputId', 'outputs', trx);\n    }\n    async updateOutputBasket(id, update, trx) {\n        return this.updateIdb(id, update, 'basketId', 'output_baskets', trx);\n    }\n    async updateOutputTag(id, update, trx) {\n        return this.updateIdb(id, update, 'outputTagId', 'output_tags', trx);\n    }\n    async updateProvenTx(id, update, trx) {\n        return this.updateIdb(id, update, 'provenTxId', 'proven_txs', trx);\n    }\n    async updateProvenTxReq(id, update, trx) {\n        return this.updateIdb(id, update, 'provenTxReqId', 'proven_tx_reqs', trx);\n    }\n    async updateSyncState(id, update, trx) {\n        return this.updateIdb(id, update, 'syncStateId', 'sync_states', trx);\n    }\n    async updateTransaction(id, update, trx) {\n        return this.updateIdb(id, update, 'transactionId', 'transactions', trx);\n    }\n    async updateTxLabel(id, update, trx) {\n        return this.updateIdb(id, update, 'txLabelId', 'tx_labels', trx);\n    }\n    async updateUser(id, update, trx) {\n        return this.updateIdb(id, update, 'userId', 'users', trx);\n    }\n    async updateOutputTagMap(outputId, tagId, update, trx) {\n        return this.updateIdbKey([tagId, outputId], update, ['outputTagId', 'outputId'], 'output_tags_map', trx);\n    }\n    async updateTxLabelMap(transactionId, txLabelId, update, trx) {\n        return this.updateIdbKey([txLabelId, transactionId], update, ['txLabelId', 'transactionId'], 'tx_labels_map', trx);\n    }\n    //\n    // StorageReader abstract methods\n    //\n    async destroy() {\n        if (this.db) {\n            this.db.close();\n        }\n        this.db = undefined;\n        this._settings = undefined;\n    }\n    /**\n     * @param scope\n     * @param trx\n     * @returns\n     */\n    async transaction(scope, trx) {\n        if (trx)\n            return await scope(trx);\n        const stores = this.allStores;\n        const db = await this.verifyDB();\n        const tx = db.transaction(stores, 'readwrite');\n        try {\n            const r = await scope(tx);\n            await tx.done;\n            return r;\n        }\n        catch (err) {\n            tx.abort();\n            await tx.done;\n            throw err;\n        }\n    }\n    async filterCertificateFields(args, filtered) {\n        var _a, _b, _c, _d;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['certificate_fields'], 'readonly', args.trx);\n        let cursor;\n        if (((_b = args.partial) === null || _b === void 0 ? void 0 : _b.certificateId) !== undefined) {\n            cursor = await dbTrx\n                .objectStore('certificate_fields')\n                .index('certificateId')\n                .openCursor(args.partial.certificateId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            cursor = await dbTrx.objectStore('certificate_fields').index('userId').openCursor(args.partial.userId);\n        }\n        else {\n            cursor = await dbTrx.objectStore('certificate_fields').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.certificateId && r.certificateId !== args.partial.certificateId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.fieldName && r.fieldName !== args.partial.fieldName)\n                    continue;\n                if (args.partial.fieldValue && r.fieldValue !== args.partial.fieldValue)\n                    continue;\n                if (args.partial.masterKey && r.masterKey !== args.partial.masterKey)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_d = args.paged) === null || _d === void 0 ? void 0 : _d.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findCertificateFields(args) {\n        const result = [];\n        await this.filterCertificateFields(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterCertificates(args, filtered) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['certificates'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.certificateId) {\n            cursor = await dbTrx.objectStore('certificates').openCursor(args.partial.certificateId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.type) && ((_e = args.partial) === null || _e === void 0 ? void 0 : _e.certifier) && ((_f = args.partial) === null || _f === void 0 ? void 0 : _f.serialNumber)) {\n                cursor = await dbTrx\n                    .objectStore('certificates')\n                    .index('userId_type_certifier_serialNumber')\n                    .openCursor([args.partial.userId, args.partial.type, args.partial.certifier, args.partial.serialNumber]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('certificates').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else {\n            cursor = await dbTrx.objectStore('certificates').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.certifiers && !args.certifiers.includes(r.certifier))\n                continue;\n            if (args.types && !args.types.includes(r.type))\n                continue;\n            if (args.partial) {\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.certificateId && r.certificateId !== args.partial.certificateId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.type && r.type !== args.partial.type)\n                    continue;\n                if (args.partial.serialNumber && r.serialNumber !== args.partial.serialNumber)\n                    continue;\n                if (args.partial.certifier && r.certifier !== args.partial.certifier)\n                    continue;\n                if (args.partial.subject && r.subject !== args.partial.subject)\n                    continue;\n                if (args.partial.verifier && r.verifier !== args.partial.verifier)\n                    continue;\n                if (args.partial.revocationOutpoint && r.revocationOutpoint !== args.partial.revocationOutpoint)\n                    continue;\n                if (args.partial.signature && r.signature !== args.partial.signature)\n                    continue;\n                if (args.partial.isDeleted && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_g = args.paged) === null || _g === void 0 ? void 0 : _g.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findCertificates(args) {\n        const result = [];\n        await this.filterCertificates(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        if (args.includeFields) {\n            for (const c of result) {\n                const fields = await this.findCertificateFields({ partial: { certificateId: c.certificateId }, trx: args.trx });\n                c.fields = fields;\n            }\n        }\n        return result;\n    }\n    async filterCommissions(args, filtered) {\n        var _a, _b, _c, _d, _e;\n        if (args.partial.lockingScript)\n            throw new sdk.WERR_INVALID_PARAMETER('partial.lockingScript', `undefined. Commissions may not be found by lockingScript value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['commissions'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.commissionId) {\n            cursor = await dbTrx.objectStore('commissions').openCursor(args.partial.commissionId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            cursor = await dbTrx.objectStore('commissions').index('userId').openCursor(args.partial.userId);\n        }\n        else if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.transactionId) !== undefined) {\n            cursor = await dbTrx.objectStore('commissions').index('transactionId').openCursor(args.partial.transactionId);\n        }\n        else {\n            cursor = await dbTrx.objectStore('commissions').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.commissionId && r.commissionId !== args.partial.commissionId)\n                    continue;\n                if (args.partial.transactionId && r.transactionId !== args.partial.transactionId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.satoshis !== undefined && r.satoshis !== args.partial.satoshis)\n                    continue;\n                if (args.partial.keyOffset && r.keyOffset !== args.partial.keyOffset)\n                    continue;\n                if (args.partial.isRedeemed !== undefined && r.isRedeemed !== args.partial.isRedeemed)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_e = args.paged) === null || _e === void 0 ? void 0 : _e.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findCommissions(args) {\n        const result = [];\n        await this.filterCommissions(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterMonitorEvents(args, filtered) {\n        var _a, _b, _c;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['monitor_events'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.id) {\n            cursor = await dbTrx.objectStore('monitor_events').openCursor(args.partial.id);\n        }\n        else {\n            cursor = await dbTrx.objectStore('monitor_events').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.id && r.id !== args.partial.id)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.event && r.event !== args.partial.event)\n                    continue;\n                if (args.partial.details && r.details !== args.partial.details)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_c = args.paged) === null || _c === void 0 ? void 0 : _c.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findMonitorEvents(args) {\n        const result = [];\n        await this.filterMonitorEvents(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterOutputBaskets(args, filtered) {\n        var _a, _b, _c, _d, _e;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['output_baskets'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.basketId) {\n            cursor = await dbTrx.objectStore('output_baskets').openCursor(args.partial.basketId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.name) !== undefined) {\n                cursor = await dbTrx\n                    .objectStore('output_baskets')\n                    .index('name_userId')\n                    .openCursor([args.partial.name, args.partial.userId]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('output_baskets').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else {\n            cursor = await dbTrx.objectStore('output_baskets').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.basketId && r.basketId !== args.partial.basketId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.name && r.name !== args.partial.name)\n                    continue;\n                if (args.partial.numberOfDesiredUTXOs !== undefined &&\n                    r.numberOfDesiredUTXOs !== args.partial.numberOfDesiredUTXOs)\n                    continue;\n                if (args.partial.minimumDesiredUTXOValue !== undefined &&\n                    r.numberOfDesiredSatoshis !== args.partial.minimumDesiredUTXOValue)\n                    continue;\n                if (args.partial.isDeleted !== undefined && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_e = args.paged) === null || _e === void 0 ? void 0 : _e.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findOutputBaskets(args) {\n        const result = [];\n        await this.filterOutputBaskets(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterOutputs(args, filtered, tagIds, isQueryModeAll) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        // args.txStatus\n        // args.noScript\n        if (args.partial.lockingScript)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.lockingScript', `undefined. Outputs may not be found by lockingScript value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const stores = ['outputs'];\n        if (tagIds && tagIds.length > 0) {\n            stores.push('output_tags_map');\n        }\n        if (args.txStatus) {\n            stores.push('transactions');\n        }\n        const dbTrx = this.toDbTrx(stores, 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.outputId) {\n            cursor = await dbTrx.objectStore('outputs').openCursor(args.partial.outputId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.transactionId) && ((_e = args.partial) === null || _e === void 0 ? void 0 : _e.vout) !== undefined) {\n                cursor = await dbTrx\n                    .objectStore('outputs')\n                    .index('transactionId_vout_userId')\n                    .openCursor([args.partial.transactionId, args.partial.vout, args.partial.userId]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('outputs').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else if (((_f = args.partial) === null || _f === void 0 ? void 0 : _f.transactionId) !== undefined) {\n            cursor = await dbTrx.objectStore('outputs').index('transactionId').openCursor(args.partial.transactionId);\n        }\n        else if (((_g = args.partial) === null || _g === void 0 ? void 0 : _g.basketId) !== undefined) {\n            cursor = await dbTrx.objectStore('outputs').index('basketId').openCursor(args.partial.basketId);\n        }\n        else if (((_h = args.partial) === null || _h === void 0 ? void 0 : _h.spentBy) !== undefined) {\n            cursor = await dbTrx.objectStore('outputs').index('spentBy').openCursor(args.partial.spentBy);\n        }\n        else {\n            cursor = await dbTrx.objectStore('outputs').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.outputId && r.outputId !== args.partial.outputId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.transactionId && r.transactionId !== args.partial.transactionId)\n                    continue;\n                if (args.partial.basketId && r.basketId !== args.partial.basketId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.spendable !== undefined && r.spendable !== args.partial.spendable)\n                    continue;\n                if (args.partial.change !== undefined && r.change !== args.partial.change)\n                    continue;\n                if (args.partial.outputDescription && r.outputDescription !== args.partial.outputDescription)\n                    continue;\n                if (args.partial.vout !== undefined && r.vout !== args.partial.vout)\n                    continue;\n                if (args.partial.satoshis !== undefined && r.satoshis !== args.partial.satoshis)\n                    continue;\n                if (args.partial.providedBy && r.providedBy !== args.partial.providedBy)\n                    continue;\n                if (args.partial.purpose && r.purpose !== args.partial.purpose)\n                    continue;\n                if (args.partial.type && r.type !== args.partial.type)\n                    continue;\n                if (args.partial.txid && r.txid !== args.partial.txid)\n                    continue;\n                if (args.partial.senderIdentityKey && r.senderIdentityKey !== args.partial.senderIdentityKey)\n                    continue;\n                if (args.partial.derivationPrefix && r.derivationPrefix !== args.partial.derivationPrefix)\n                    continue;\n                if (args.partial.derivationSuffix && r.derivationSuffix !== args.partial.derivationSuffix)\n                    continue;\n                if (args.partial.customInstructions && r.customInstructions !== args.partial.customInstructions)\n                    continue;\n                if (args.partial.spentBy && r.spentBy !== args.partial.spentBy)\n                    continue;\n                if (args.partial.sequenceNumber !== undefined && r.sequenceNumber !== args.partial.sequenceNumber)\n                    continue;\n                if (args.partial.scriptLength !== undefined && r.scriptLength !== args.partial.scriptLength)\n                    continue;\n                if (args.partial.scriptOffset !== undefined && r.scriptOffset !== args.partial.scriptOffset)\n                    continue;\n            }\n            if (args.txStatus !== undefined) {\n                const count = await this.countTransactions({\n                    partial: { transactionId: r.transactionId },\n                    status: args.txStatus,\n                    trx: dbTrx\n                });\n                if (count === 0)\n                    continue;\n            }\n            if (tagIds && tagIds.length > 0) {\n                let ids = [...tagIds];\n                await this.filterOutputTagMaps({ partial: { outputId: r.outputId }, trx: dbTrx }, tm => {\n                    if (ids.length > 0) {\n                        const i = ids.indexOf(tm.outputTagId);\n                        if (i >= 0) {\n                            if (isQueryModeAll) {\n                                ids.splice(i, 1);\n                            }\n                            else {\n                                ids = [];\n                            }\n                        }\n                    }\n                });\n                if (ids.length > 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            if (args.noScript === true) {\n                r.script = undefined;\n            }\n            filtered(r);\n            count++;\n            if (((_j = args.paged) === null || _j === void 0 ? void 0 : _j.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findOutputs(args, tagIds, isQueryModeAll) {\n        const results = [];\n        await this.filterOutputs(args, r => {\n            results.push(this.validateEntity(r));\n        }, tagIds, isQueryModeAll);\n        for (const o of results) {\n            if (!args.noScript) {\n                await this.validateOutputScript(o);\n            }\n            else {\n                o.lockingScript = undefined;\n            }\n        }\n        return results;\n    }\n    async filterOutputTags(args, filtered) {\n        var _a, _b, _c, _d, _e;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['output_tags'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.outputTagId) {\n            cursor = await dbTrx.objectStore('output_tags').openCursor(args.partial.outputTagId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.tag) !== undefined) {\n                cursor = await dbTrx\n                    .objectStore('output_tags')\n                    .index('tag_userId')\n                    .openCursor([args.partial.tag, args.partial.userId]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('output_tags').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else {\n            cursor = await dbTrx.objectStore('output_tags').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.outputTagId && r.outputTagId !== args.partial.outputTagId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.tag && r.tag !== args.partial.tag)\n                    continue;\n                if (args.partial.isDeleted !== undefined && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_e = args.paged) === null || _e === void 0 ? void 0 : _e.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findOutputTags(args) {\n        const result = [];\n        await this.filterOutputTags(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterSyncStates(args, filtered) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (args.partial.syncMap)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.syncMap', `undefined. SyncStates may not be found by syncMap value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['sync_states'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.syncStateId) {\n            cursor = await dbTrx.objectStore('sync_states').openCursor(args.partial.syncStateId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            cursor = await dbTrx.objectStore('sync_states').index('userId').openCursor(args.partial.userId);\n        }\n        else if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.refNum) !== undefined) {\n            cursor = await dbTrx.objectStore('sync_states').index('refNum').openCursor(args.partial.refNum);\n        }\n        else if (((_e = args.partial) === null || _e === void 0 ? void 0 : _e.status) !== undefined) {\n            cursor = await dbTrx.objectStore('sync_states').index('status').openCursor(args.partial.status);\n        }\n        else {\n            cursor = await dbTrx.objectStore('sync_states').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.syncStateId && r.syncStateId !== args.partial.syncStateId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.storageIdentityKey && r.storageIdentityKey !== args.partial.storageIdentityKey)\n                    continue;\n                if (args.partial.storageName && r.storageName !== args.partial.storageName)\n                    continue;\n                if (args.partial.status && r.status !== args.partial.status)\n                    continue;\n                if (args.partial.init !== undefined && r.init !== args.partial.init)\n                    continue;\n                if (args.partial.refNum !== undefined && r.refNum !== args.partial.refNum)\n                    continue;\n                if (args.partial.when && ((_f = r.when) === null || _f === void 0 ? void 0 : _f.getTime()) !== args.partial.when.getTime())\n                    continue;\n                if (args.partial.satoshis !== undefined && r.satoshis !== args.partial.satoshis)\n                    continue;\n                if (args.partial.errorLocal && r.errorLocale !== args.partial.errorLocal)\n                    continue;\n                if (args.partial.errorOther && r.errorOther !== args.partial.errorOther)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_g = args.paged) === null || _g === void 0 ? void 0 : _g.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findSyncStates(args) {\n        const result = [];\n        await this.filterSyncStates(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterTransactions(args, filtered, labelIds, isQueryModeAll) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (args.partial.rawTx)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.rawTx', `undefined. Transactions may not be found by rawTx value.`);\n        if (args.partial.inputBEEF)\n            throw new sdk.WERR_INVALID_PARAMETER('args.partial.inputBEEF', `undefined. Transactions may not be found by inputBEEF value.`);\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const stores = ['transactions'];\n        if (labelIds && labelIds.length > 0) {\n            stores.push('tx_labels_map');\n        }\n        const dbTrx = this.toDbTrx(stores, 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.transactionId) {\n            cursor = await dbTrx.objectStore('transactions').openCursor(args.partial.transactionId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.status) !== undefined) {\n                cursor = await dbTrx\n                    .objectStore('transactions')\n                    .index('status_userId')\n                    .openCursor([args.partial.status, args.partial.userId]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('transactions').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else if (((_e = args.partial) === null || _e === void 0 ? void 0 : _e.status) !== undefined) {\n            cursor = await dbTrx.objectStore('transactions').index('status').openCursor(args.partial.status);\n        }\n        else if (((_f = args.partial) === null || _f === void 0 ? void 0 : _f.provenTxId) !== undefined) {\n            cursor = await dbTrx.objectStore('transactions').index('provenTxId').openCursor(args.partial.provenTxId);\n        }\n        else if (((_g = args.partial) === null || _g === void 0 ? void 0 : _g.reference) !== undefined) {\n            cursor = await dbTrx.objectStore('transactions').index('reference').openCursor(args.partial.reference);\n        }\n        else {\n            cursor = await dbTrx.objectStore('transactions').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.status && !args.status.includes(r.status))\n                continue;\n            if (args.partial) {\n                if (args.partial.transactionId && r.transactionId !== args.partial.transactionId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.provenTxId && r.provenTxId !== args.partial.provenTxId)\n                    continue;\n                if (args.partial.status && r.status !== args.partial.status)\n                    continue;\n                if (args.partial.reference && r.reference !== args.partial.reference)\n                    continue;\n                if (args.partial.isOutgoing !== undefined && r.isOutgoing !== args.partial.isOutgoing)\n                    continue;\n                if (args.partial.satoshis !== undefined && r.satoshis !== args.partial.satoshis)\n                    continue;\n                if (args.partial.description && r.description !== args.partial.description)\n                    continue;\n                if (args.partial.version !== undefined && r.version !== args.partial.version)\n                    continue;\n                if (args.partial.lockTime !== undefined && r.lockTime !== args.partial.lockTime)\n                    continue;\n                if (args.partial.txid && r.txid !== args.partial.txid)\n                    continue;\n            }\n            if (labelIds && labelIds.length > 0) {\n                let ids = [...labelIds];\n                await this.filterTxLabelMaps({ partial: { transactionId: r.transactionId }, trx: dbTrx }, lm => {\n                    if (ids.length > 0) {\n                        const i = ids.indexOf(lm.txLabelId);\n                        if (i >= 0) {\n                            if (isQueryModeAll) {\n                                ids.splice(i, 1);\n                            }\n                            else {\n                                ids = [];\n                            }\n                        }\n                    }\n                });\n                if (ids.length > 0)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_h = args.paged) === null || _h === void 0 ? void 0 : _h.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findTransactions(args, labelIds, isQueryModeAll) {\n        const results = [];\n        await this.filterTransactions(args, r => {\n            results.push(this.validateEntity(r));\n        }, labelIds, isQueryModeAll);\n        for (const t of results) {\n            if (!args.noRawTx) {\n                await this.validateRawTransaction(t, args.trx);\n            }\n            else {\n                t.rawTx = undefined;\n                t.inputBEEF = undefined;\n            }\n        }\n        return results;\n    }\n    async filterTxLabels(args, filtered) {\n        var _a, _b, _c, _d, _e;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['tx_labels'], 'readonly', args.trx);\n        let cursor;\n        if ((_b = args.partial) === null || _b === void 0 ? void 0 : _b.txLabelId) {\n            cursor = await dbTrx.objectStore('tx_labels').openCursor(args.partial.txLabelId);\n        }\n        else if (((_c = args.partial) === null || _c === void 0 ? void 0 : _c.userId) !== undefined) {\n            if (((_d = args.partial) === null || _d === void 0 ? void 0 : _d.label) !== undefined) {\n                cursor = await dbTrx\n                    .objectStore('tx_labels')\n                    .index('label_userId')\n                    .openCursor([args.partial.label, args.partial.userId]);\n            }\n            else {\n                cursor = await dbTrx.objectStore('tx_labels').index('userId').openCursor(args.partial.userId);\n            }\n        }\n        else {\n            cursor = await dbTrx.objectStore('tx_labels').openCursor();\n        }\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.txLabelId && r.txLabelId !== args.partial.txLabelId)\n                    continue;\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.label && r.label !== args.partial.label)\n                    continue;\n                if (args.partial.isDeleted !== undefined && r.isDeleted !== args.partial.isDeleted)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_e = args.paged) === null || _e === void 0 ? void 0 : _e.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findTxLabels(args) {\n        const result = [];\n        await this.filterTxLabels(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async filterUsers(args, filtered) {\n        var _a, _b;\n        const offset = ((_a = args.paged) === null || _a === void 0 ? void 0 : _a.offset) || 0;\n        let skipped = 0;\n        let count = 0;\n        const dbTrx = this.toDbTrx(['users'], 'readonly', args.trx);\n        let cursor = await dbTrx.objectStore('users').openCursor();\n        let firstTime = true;\n        while (cursor) {\n            if (!firstTime)\n                cursor = await cursor.continue();\n            if (!cursor)\n                break;\n            firstTime = false;\n            const r = cursor.value;\n            if (args.since && args.since > r.updated_at)\n                continue;\n            if (args.partial) {\n                if (args.partial.userId && r.userId !== args.partial.userId)\n                    continue;\n                if (args.partial.created_at && r.created_at.getTime() !== args.partial.created_at.getTime())\n                    continue;\n                if (args.partial.updated_at && r.updated_at.getTime() !== args.partial.updated_at.getTime())\n                    continue;\n                if (args.partial.identityKey && r.identityKey !== args.partial.identityKey)\n                    continue;\n                if (args.partial.activeStorage && r.activeStorage !== args.partial.activeStorage)\n                    continue;\n            }\n            if (skipped < offset) {\n                skipped++;\n                continue;\n            }\n            filtered(r);\n            count++;\n            if (((_b = args.paged) === null || _b === void 0 ? void 0 : _b.limit) && count >= args.paged.limit)\n                break;\n        }\n        if (!args.trx)\n            await dbTrx.done;\n    }\n    async findUsers(args) {\n        const result = [];\n        await this.filterUsers(args, r => {\n            result.push(this.validateEntity(r));\n        });\n        return result;\n    }\n    async countCertificateFields(args) {\n        let count = 0;\n        await this.filterCertificateFields(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countCertificates(args) {\n        let count = 0;\n        await this.filterCertificates(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countCommissions(args) {\n        let count = 0;\n        await this.filterCommissions(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countMonitorEvents(args) {\n        let count = 0;\n        await this.filterMonitorEvents(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countOutputBaskets(args) {\n        let count = 0;\n        await this.filterOutputBaskets(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countOutputs(args, tagIds, isQueryModeAll) {\n        let count = 0;\n        await this.filterOutputs({ ...args, noScript: true }, () => {\n            count++;\n        }, tagIds, isQueryModeAll);\n        return count;\n    }\n    async countOutputTags(args) {\n        let count = 0;\n        await this.filterOutputTags(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countSyncStates(args) {\n        let count = 0;\n        await this.filterSyncStates(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countTransactions(args, labelIds, isQueryModeAll) {\n        let count = 0;\n        await this.filterTransactions({ ...args, noRawTx: true }, () => {\n            count++;\n        }, labelIds, isQueryModeAll);\n        return count;\n    }\n    async countTxLabels(args) {\n        let count = 0;\n        await this.filterTxLabels(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async countUsers(args) {\n        let count = 0;\n        await this.filterUsers(args, () => {\n            count++;\n        });\n        return count;\n    }\n    async getProvenTxsForUser(args) {\n        const results = [];\n        const fargs = {\n            partial: {},\n            since: args.since,\n            paged: args.paged,\n            trx: args.trx\n        };\n        await this.filterProvenTxs(fargs, r => {\n            results.push(this.validateEntity(r));\n        }, args.userId);\n        return results;\n    }\n    async getProvenTxReqsForUser(args) {\n        const results = [];\n        const fargs = {\n            partial: {},\n            since: args.since,\n            paged: args.paged,\n            trx: args.trx\n        };\n        await this.filterProvenTxReqs(fargs, r => {\n            results.push(this.validateEntity(r));\n        }, args.userId);\n        return results;\n    }\n    async getTxLabelMapsForUser(args) {\n        const results = [];\n        const fargs = {\n            partial: {},\n            since: args.since,\n            paged: args.paged,\n            trx: args.trx\n        };\n        await this.filterTxLabelMaps(fargs, r => {\n            results.push(this.validateEntity(r));\n        }, args.userId);\n        return results;\n    }\n    async getOutputTagMapsForUser(args) {\n        const results = [];\n        const fargs = {\n            partial: {},\n            since: args.since,\n            paged: args.paged,\n            trx: args.trx\n        };\n        await this.filterOutputTagMaps(fargs, r => {\n            results.push(this.validateEntity(r));\n        }, args.userId);\n        return results;\n    }\n    async verifyReadyForDatabaseAccess(trx) {\n        if (!this._settings) {\n            this._settings = await this.readSettings();\n        }\n        return this._settings.dbtype;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all individual records with time stamps or number[] retreived from database.\n     */\n    validateEntity(entity, dateFields, booleanFields) {\n        entity.created_at = this.validateDate(entity.created_at);\n        entity.updated_at = this.validateDate(entity.updated_at);\n        if (dateFields) {\n            for (const df of dateFields) {\n                if (entity[df])\n                    entity[df] = this.validateDate(entity[df]);\n            }\n        }\n        if (booleanFields) {\n            for (const df of booleanFields) {\n                if (entity[df] !== undefined)\n                    entity[df] = !!entity[df];\n            }\n        }\n        for (const key of Object.keys(entity)) {\n            const val = entity[key];\n            if (val === null) {\n                entity[key] = undefined;\n            }\n            else if (val instanceof Uint8Array) {\n                entity[key] = Array.from(val);\n            }\n        }\n        return entity;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all arrays of records with time stamps retreived from database.\n     * @returns input `entities` array with contained values validated.\n     */\n    validateEntities(entities, dateFields, booleanFields) {\n        for (let i = 0; i < entities.length; i++) {\n            entities[i] = this.validateEntity(entities[i], dateFields, booleanFields);\n        }\n        return entities;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process the update template for entities being updated.\n     */\n    validatePartialForUpdate(update, dateFields, booleanFields) {\n        if (!this.dbtype)\n            throw new sdk.WERR_INTERNAL('must call verifyReadyForDatabaseAccess first');\n        const v = { ...update };\n        if (v.created_at)\n            v.created_at = this.validateEntityDate(v.created_at);\n        if (v.updated_at)\n            v.updated_at = this.validateEntityDate(v.updated_at);\n        if (!v.created_at)\n            delete v.created_at;\n        if (!v.updated_at)\n            v.updated_at = this.validateEntityDate(new Date());\n        if (dateFields) {\n            for (const df of dateFields) {\n                if (v[df])\n                    v[df] = this.validateOptionalEntityDate(v[df]);\n            }\n        }\n        if (booleanFields) {\n            for (const df of booleanFields) {\n                if (update[df] !== undefined)\n                    update[df] = !!update[df] ? 1 : 0;\n            }\n        }\n        for (const key of Object.keys(v)) {\n            const val = v[key];\n            if (Array.isArray(val) && (val.length === 0 || Number.isInteger(val[0]))) {\n                v[key] = Uint8Array.from(val);\n            }\n            else if (val === null) {\n                v[key] = undefined;\n            }\n        }\n        this.isDirty = true;\n        return v;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process new entities being inserted into the database.\n     */\n    async validateEntityForInsert(entity, trx, dateFields, booleanFields) {\n        await this.verifyReadyForDatabaseAccess(trx);\n        const v = { ...entity };\n        v.created_at = this.validateOptionalEntityDate(v.created_at, true);\n        v.updated_at = this.validateOptionalEntityDate(v.updated_at, true);\n        if (!v.created_at)\n            delete v.created_at;\n        if (!v.updated_at)\n            delete v.updated_at;\n        if (dateFields) {\n            for (const df of dateFields) {\n                if (v[df])\n                    v[df] = this.validateOptionalEntityDate(v[df]);\n            }\n        }\n        if (booleanFields) {\n            for (const df of booleanFields) {\n                if (entity[df] !== undefined)\n                    entity[df] = !!entity[df] ? 1 : 0;\n            }\n        }\n        for (const key of Object.keys(v)) {\n            const val = v[key];\n            if (Array.isArray(val) && (val.length === 0 || Number.isInteger(val[0]))) {\n                v[key] = Uint8Array.from(val);\n            }\n            else if (val === null) {\n                v[key] = undefined;\n            }\n        }\n        this.isDirty = true;\n        return v;\n    }\n    async validateRawTransaction(t, trx) {\n        // if there is no txid or there is a rawTransaction return what we have.\n        if (t.rawTx || !t.txid)\n            return;\n        // rawTransaction is missing, see if we moved it ...\n        const rawTx = await this.getRawTxOfKnownValidTransaction(t.txid, undefined, undefined, trx);\n        if (!rawTx)\n            return;\n        t.rawTx = rawTx;\n    }\n    async adminStats(adminIdentityKey) {\n        throw new Error('Method intentionally not implemented for personal storage.');\n    }\n}\nexports.StorageIdb = StorageIdb;\n//# sourceMappingURL=StorageIdb.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageIdb.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageProvider = void 0;\nexports.validateStorageFeeModel = validateStorageFeeModel;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst getBeefForTransaction_1 = __webpack_require__(/*! ./methods/getBeefForTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getBeefForTransaction.js\");\nconst processAction_1 = __webpack_require__(/*! ./methods/processAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/processAction.js\");\nconst attemptToPostReqsToNetwork_1 = __webpack_require__(/*! ./methods/attemptToPostReqsToNetwork */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/attemptToPostReqsToNetwork.js\");\nconst listCertificates_1 = __webpack_require__(/*! ./methods/listCertificates */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listCertificates.js\");\nconst createAction_1 = __webpack_require__(/*! ./methods/createAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/createAction.js\");\nconst internalizeAction_1 = __webpack_require__(/*! ./methods/internalizeAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/internalizeAction.js\");\nconst StorageReaderWriter_1 = __webpack_require__(/*! ./StorageReaderWriter */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReaderWriter.js\");\nconst entities_1 = __webpack_require__(/*! ./schema/entities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass StorageProvider extends StorageReaderWriter_1.StorageReaderWriter {\n    static defaultOptions() {\n        return {\n            feeModel: { model: 'sat/kb', value: 1 },\n            commissionSatoshis: 0,\n            commissionPubKeyHex: undefined\n        };\n    }\n    static createStorageBaseOptions(chain) {\n        const options = {\n            ...StorageProvider.defaultOptions(),\n            chain\n        };\n        return options;\n    }\n    constructor(options) {\n        super(options);\n        this.isDirty = false;\n        this.feeModel = options.feeModel;\n        this.commissionPubKeyHex = options.commissionPubKeyHex;\n        this.commissionSatoshis = options.commissionSatoshis;\n    }\n    isStorageProvider() {\n        return true;\n    }\n    setServices(v) {\n        this._services = v;\n    }\n    getServices() {\n        if (!this._services)\n            throw new index_client_1.sdk.WERR_INVALID_OPERATION('Must setServices first.');\n        return this._services;\n    }\n    async abortAction(auth, args) {\n        if (!auth.userId)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('auth.userId', 'valid');\n        const userId = auth.userId;\n        let reference = args.reference;\n        let txid = undefined;\n        const r = await this.transaction(async (trx) => {\n            let tx = (0, index_client_1.verifyOneOrNone)(await this.findTransactions({\n                partial: { reference, userId },\n                noRawTx: true,\n                trx\n            }));\n            if (!tx && args.reference.length === 64) {\n                // reference may also be a txid\n                txid = reference;\n                reference = undefined;\n                tx = (0, index_client_1.verifyOneOrNone)(await this.findTransactions({\n                    partial: { txid, userId },\n                    noRawTx: true,\n                    trx\n                }));\n            }\n            const unAbortableStatus = ['completed', 'failed', 'sending', 'unproven'];\n            if (!tx || !tx.isOutgoing || -1 < unAbortableStatus.findIndex(s => s === tx.status))\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('reference', 'an inprocess, outgoing action that has not been signed and shared to the network.');\n            await this.updateTransactionStatus('failed', tx.transactionId, userId, reference, trx);\n            if (tx.txid) {\n                const req = await entities_1.EntityProvenTxReq.fromStorageTxid(this, tx.txid, trx);\n                if (req) {\n                    req.addHistoryNote({ what: 'abortAction', reference: args.reference });\n                    req.status = 'invalid';\n                    await req.updateStorageDynamicProperties(this, trx);\n                }\n            }\n            const r = {\n                aborted: true\n            };\n            return r;\n        });\n        return r;\n    }\n    async internalizeAction(auth, args) {\n        return await (0, internalizeAction_1.internalizeAction)(this, auth, args);\n    }\n    /**\n     * Given an array of transaction txids with current ProvenTxReq ready-to-share status,\n     * lookup their ProvenTxReqApi req records.\n     * For the txids with reqs and status still ready to send construct a single merged beef.\n     *\n     * @param txids\n     * @param knownTxids\n     * @param trx\n     */\n    async getReqsAndBeefToShareWithWorld(txids, knownTxids, trx) {\n        const r = {\n            beef: new sdk_1.Beef(),\n            details: []\n        };\n        for (const txid of txids) {\n            const d = {\n                txid,\n                status: 'unknown'\n            };\n            r.details.push(d);\n            try {\n                d.proven = (0, index_client_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { txid }, trx }));\n                if (d.proven)\n                    d.status = 'alreadySent';\n                else {\n                    const alreadySentStatus = ['unmined', 'callback', 'unconfirmed', 'completed'];\n                    const readyToSendStatus = ['sending', 'unsent', 'nosend', 'unprocessed'];\n                    const errorStatus = ['unknown', 'nonfinal', 'invalid', 'doubleSpend'];\n                    d.req = (0, index_client_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { txid }, trx }));\n                    if (!d.req) {\n                        d.status = 'error';\n                        d.error = `ERR_UNKNOWN_TXID: ${txid} was not found.`;\n                    }\n                    else if (errorStatus.indexOf(d.req.status) > -1) {\n                        d.status = 'error';\n                        d.error = `ERR_INVALID_PARAMETER: ${txid} is not ready to send.`;\n                    }\n                    else if (alreadySentStatus.indexOf(d.req.status) > -1) {\n                        d.status = 'alreadySent';\n                    }\n                    else if (readyToSendStatus.indexOf(d.req.status) > -1) {\n                        if (!d.req.rawTx || !d.req.inputBEEF) {\n                            d.status = 'error';\n                            d.error = `ERR_INTERNAL: ${txid} req is missing rawTx or beef.`;\n                        }\n                        else\n                            d.status = 'readyToSend';\n                    }\n                    else {\n                        d.status = 'error';\n                        d.error = `ERR_INTERNAL: ${txid} has unexpected req status ${d.req.status}`;\n                    }\n                    if (d.status === 'readyToSend') {\n                        await this.mergeReqToBeefToShareExternally(d.req, r.beef, knownTxids, trx);\n                    }\n                }\n            }\n            catch (eu) {\n                const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n                d.error = `${e.name}: ${e.message}`;\n            }\n        }\n        return r;\n    }\n    async mergeReqToBeefToShareExternally(req, mergeToBeef, knownTxids, trx) {\n        const { rawTx, inputBEEF: beef } = req;\n        if (!rawTx || !beef)\n            throw new index_client_1.sdk.WERR_INTERNAL(`req rawTx and beef must be valid.`);\n        mergeToBeef.mergeRawTx((0, index_client_1.asArray)(rawTx));\n        mergeToBeef.mergeBeef((0, index_client_1.asArray)(beef));\n        const tx = sdk_1.Transaction.fromBinary((0, index_client_1.asArray)(rawTx));\n        for (const input of tx.inputs) {\n            if (!input.sourceTXID)\n                throw new index_client_1.sdk.WERR_INTERNAL(`req all transaction inputs must have valid sourceTXID`);\n            const txid = input.sourceTXID;\n            const btx = mergeToBeef.findTxid(txid);\n            if (!btx) {\n                if (knownTxids && knownTxids.indexOf(txid) > -1)\n                    mergeToBeef.mergeTxidOnly(txid);\n                else\n                    await this.getValidBeefForKnownTxid(txid, mergeToBeef, undefined, knownTxids, trx);\n            }\n        }\n    }\n    /**\n     * Checks if txid is a known valid ProvenTx and returns it if found.\n     * Next checks if txid is a current ProvenTxReq and returns that if found.\n     * If `newReq` is provided and an existing ProvenTxReq isn't found,\n     * use `newReq` to create a new ProvenTxReq.\n     *\n     * This is safe \"findOrInsert\" operation using retry if unique index constraint\n     * is violated by a race condition insert.\n     *\n     * @param txid\n     * @param newReq\n     * @param trx\n     * @returns\n     */\n    async getProvenOrReq(txid, newReq, trx) {\n        if (newReq && txid !== newReq.txid)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('newReq', `same txid`);\n        const r = { proven: undefined, req: undefined };\n        r.proven = (0, index_client_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { txid }, trx }));\n        if (r.proven)\n            return r;\n        for (let retry = 0;; retry++) {\n            try {\n                r.req = (0, index_client_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { txid }, trx }));\n                if (!r.req && !newReq)\n                    break;\n                if (!r.req && newReq) {\n                    await this.insertProvenTxReq(newReq, trx);\n                }\n                if (r.req && newReq) {\n                    // Merge history and notify into existing\n                    const req1 = new entities_1.EntityProvenTxReq(r.req);\n                    req1.mergeHistory(newReq, undefined, true);\n                    req1.mergeNotifyTransactionIds(newReq);\n                    await req1.updateStorageDynamicProperties(this, trx);\n                }\n                break;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n        return r;\n    }\n    async updateTransactionsStatus(transactionIds, status, trx) {\n        await this.transaction(async (trx) => {\n            for (const id of transactionIds) {\n                await this.updateTransactionStatus(status, id, undefined, undefined, trx);\n            }\n        }, trx);\n    }\n    /**\n     * For all `status` values besides 'failed', just updates the transaction records status property.\n     *\n     * For 'status' of 'failed', attempts to make outputs previously allocated as inputs to this transaction usable again.\n     *\n     * @param status\n     * @param transactionId\n     * @param userId\n     * @param reference\n     * @param trx\n     */\n    async updateTransactionStatus(status, transactionId, userId, reference, trx) {\n        if (!transactionId && !(userId && reference))\n            throw new index_client_1.sdk.WERR_MISSING_PARAMETER('either transactionId or userId and reference');\n        await this.transaction(async (trx) => {\n            const where = {};\n            if (transactionId)\n                where.transactionId = transactionId;\n            if (userId)\n                where.userId = userId;\n            if (reference)\n                where.reference = reference;\n            const tx = (0, index_client_1.verifyOne)(await this.findTransactions({ partial: where, noRawTx: true, trx }));\n            //if (tx.status === status)\n            // no change required. Assume inputs and outputs spendable and spentBy are valid for status.\n            //return\n            // Once completed, this method cannot be used to \"uncomplete\" transaction.\n            if ((status !== 'completed' && tx.status === 'completed') || tx.provenTxId)\n                throw new index_client_1.sdk.WERR_INVALID_OPERATION('The status of a \"completed\" transaction cannot be changed.');\n            // It is not possible to un-fail a transaction. Information is lost and not recoverable.\n            if (status !== 'failed' && tx.status === 'failed')\n                throw new index_client_1.sdk.WERR_INVALID_OPERATION(`A \"failed\" transaction may not be un-failed by this method.`);\n            switch (status) {\n                case 'failed':\n                    {\n                        // Attempt to make outputs previously allocated as inputs to this transaction usable again.\n                        // Only clear input's spentBy and reset spendable = true if it references this transaction\n                        const t = new entities_1.EntityTransaction(tx);\n                        const inputs = await t.getInputs(this, trx);\n                        for (const input of inputs) {\n                            // input is a prior output belonging to userId that reference this transaction either by `spentBy`\n                            // or by txid and vout.\n                            await this.updateOutput((0, index_client_1.verifyId)(input.outputId), { spendable: true, spentBy: undefined }, trx);\n                        }\n                    }\n                    break;\n                case 'nosend':\n                case 'unsigned':\n                case 'unprocessed':\n                case 'sending':\n                case 'unproven':\n                case 'completed':\n                    break;\n                default:\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('status', `not be ${status}`);\n            }\n            await this.updateTransaction(tx.transactionId, { status }, trx);\n        }, trx);\n    }\n    async createAction(auth, args) {\n        if (!auth.userId)\n            throw new index_client_1.sdk.WERR_UNAUTHORIZED();\n        return await (0, createAction_1.createAction)(this, auth, args);\n    }\n    async processAction(auth, args) {\n        if (!auth.userId)\n            throw new index_client_1.sdk.WERR_UNAUTHORIZED();\n        return await (0, processAction_1.processAction)(this, auth, args);\n    }\n    async attemptToPostReqsToNetwork(reqs, trx) {\n        return await (0, attemptToPostReqsToNetwork_1.attemptToPostReqsToNetwork)(this, reqs, trx);\n    }\n    async listCertificates(auth, args) {\n        return await (0, listCertificates_1.listCertificates)(this, auth, args);\n    }\n    async verifyKnownValidTransaction(txid, trx) {\n        const { proven, rawTx } = await this.getProvenOrRawTx(txid, trx);\n        return proven != undefined || rawTx != undefined;\n    }\n    async getValidBeefForKnownTxid(txid, mergeToBeef, trustSelf, knownTxids, trx, requiredLevels) {\n        const beef = await this.getValidBeefForTxid(txid, mergeToBeef, trustSelf, knownTxids, trx, requiredLevels);\n        if (!beef)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('txid', `known to storage. ${txid} is not known.`);\n        return beef;\n    }\n    async getValidBeefForTxid(txid, mergeToBeef, trustSelf, knownTxids, trx, requiredLevels) {\n        const beef = mergeToBeef || new sdk_1.Beef();\n        const r = await this.getProvenOrRawTx(txid, trx);\n        if (r.proven) {\n            if (requiredLevels) {\n                r.rawTx = r.proven.rawTx;\n            }\n            else {\n                if (trustSelf === 'known')\n                    beef.mergeTxidOnly(txid);\n                else {\n                    beef.mergeRawTx(r.proven.rawTx);\n                    const mp = new entities_1.EntityProvenTx(r.proven).getMerklePath();\n                    beef.mergeBump(mp);\n                    return beef;\n                }\n            }\n        }\n        if (!r.rawTx)\n            return undefined;\n        if (trustSelf === 'known') {\n            beef.mergeTxidOnly(txid);\n        }\n        else {\n            beef.mergeRawTx(r.rawTx);\n            if (r.inputBEEF)\n                beef.mergeBeef(r.inputBEEF);\n            const tx = sdk_1.Transaction.fromBinary(r.rawTx);\n            if (requiredLevels)\n                requiredLevels--;\n            for (const input of tx.inputs) {\n                const btx = beef.findTxid(input.sourceTXID);\n                if (!btx) {\n                    if (!requiredLevels && knownTxids && knownTxids.indexOf(input.sourceTXID) > -1)\n                        beef.mergeTxidOnly(input.sourceTXID);\n                    else\n                        await this.getValidBeefForKnownTxid(input.sourceTXID, beef, trustSelf, knownTxids, trx, requiredLevels);\n                }\n            }\n        }\n        return beef;\n    }\n    async getBeefForTransaction(txid, options) {\n        const beef = await (0, getBeefForTransaction_1.getBeefForTransaction)(this, txid, options);\n        return beef;\n    }\n    async findMonitorEventById(id, trx) {\n        return (0, index_client_1.verifyOneOrNone)(await this.findMonitorEvents({ partial: { id }, trx }));\n    }\n    async relinquishCertificate(auth, args) {\n        const vargs = index_client_1.sdk.validateRelinquishCertificateArgs(args);\n        const cert = (0, index_client_1.verifyOne)(await this.findCertificates({\n            partial: {\n                certifier: vargs.certifier,\n                serialNumber: vargs.serialNumber,\n                type: vargs.type\n            }\n        }));\n        return await this.updateCertificate(cert.certificateId, {\n            isDeleted: true\n        });\n    }\n    async relinquishOutput(auth, args) {\n        const vargs = index_client_1.sdk.validateRelinquishOutputArgs(args);\n        const { txid, vout } = index_client_1.sdk.parseWalletOutpoint(vargs.output);\n        const output = (0, index_client_1.verifyOne)(await this.findOutputs({ partial: { txid, vout } }));\n        return await this.updateOutput(output.outputId, { basketId: undefined });\n    }\n    async processSyncChunk(args, chunk) {\n        const user = (0, index_client_1.verifyTruthy)(await this.findUserByIdentityKey(args.identityKey));\n        const ss = new entities_1.EntitySyncState((0, index_client_1.verifyOne)(await this.findSyncStates({\n            partial: {\n                storageIdentityKey: args.fromStorageIdentityKey,\n                userId: user.userId\n            }\n        })));\n        const r = await ss.processSyncChunk(this, args, chunk);\n        return r;\n    }\n    /**\n     * Handles storage changes when a valid MerklePath and mined block header are found for a ProvenTxReq txid.\n     *\n     * Performs the following storage updates (typically):\n     * 1. Lookup the exising `ProvenTxReq` record for its rawTx\n     * 2. Insert a new ProvenTx record using properties from `args` and rawTx, yielding a new provenTxId\n     * 3. Update ProvenTxReq record with status 'completed' and new provenTxId value (and history of status changed)\n     * 4. Unpack notify transactionIds from req and update each transaction's status to 'completed', provenTxId value.\n     * 5. Update ProvenTxReq history again to record that transactions have been notified.\n     * 6. Return results...\n     *\n     * Alterations of \"typically\" to handle:\n     */\n    async updateProvenTxReqWithNewProvenTx(args) {\n        const req = await entities_1.EntityProvenTxReq.fromStorageId(this, args.provenTxReqId);\n        let proven;\n        if (req.provenTxId) {\n            // Someone beat us to it, grab what we need for results...\n            proven = new entities_1.EntityProvenTx((0, index_client_1.verifyOne)(await this.findProvenTxs({ partial: { txid: args.txid } })));\n        }\n        else {\n            let isNew;\n            ({ proven, isNew } = await this.transaction(async (trx) => {\n                const { proven: api, isNew } = await this.findOrInsertProvenTx({\n                    created_at: new Date(),\n                    updated_at: new Date(),\n                    provenTxId: 0,\n                    txid: args.txid,\n                    height: args.height,\n                    index: args.index,\n                    merklePath: args.merklePath,\n                    rawTx: req.rawTx,\n                    blockHash: args.blockHash,\n                    merkleRoot: args.merkleRoot\n                }, trx);\n                proven = new entities_1.EntityProvenTx(api);\n                if (isNew) {\n                    req.status = 'completed';\n                    req.provenTxId = proven.provenTxId;\n                    await req.updateStorageDynamicProperties(this, trx);\n                    // upate the transaction notifications outside of storage transaction....\n                }\n                return { proven, isNew };\n            }));\n            if (isNew) {\n                const ids = req.notify.transactionIds || [];\n                if (ids.length > 0) {\n                    for (const id of ids) {\n                        try {\n                            await this.updateTransaction(id, {\n                                provenTxId: proven.provenTxId,\n                                status: 'completed'\n                            });\n                            req.addHistoryNote({ what: 'notifyTxOfProof', transactionId: id });\n                        }\n                        catch (eu) {\n                            const { code, description } = index_client_1.sdk.WalletError.fromUnknown(eu);\n                            const { provenTxId } = proven;\n                            req.addHistoryNote({ what: 'notifyTxOfProofError', id, provenTxId, code, description });\n                        }\n                    }\n                    await req.updateStorageDynamicProperties(this);\n                }\n            }\n        }\n        const r = {\n            status: req.status,\n            history: req.apiHistory,\n            provenTxId: proven.provenTxId\n        };\n        return r;\n    }\n    /**\n     * For each spendable output in the 'default' basket of the authenticated user,\n     * verify that the output script, satoshis, vout and txid match that of an output\n     * still in the mempool of at least one service provider.\n     *\n     * @returns object with invalidSpendableOutputs array. A good result is an empty array.\n     */\n    async confirmSpendableOutputs() {\n        const invalidSpendableOutputs = [];\n        const users = await this.findUsers({ partial: {} });\n        for (const { userId } of users) {\n            const defaultBasket = (0, index_client_1.verifyOne)(await this.findOutputBaskets({ partial: { userId, name: 'default' } }));\n            const where = {\n                userId,\n                basketId: defaultBasket.basketId,\n                spendable: true\n            };\n            const outputs = await this.findOutputs({ partial: where });\n            const services = this.getServices();\n            for (let i = outputs.length - 1; i >= 0; i--) {\n                const o = outputs[i];\n                const oid = (0, index_client_1.verifyId)(o.outputId);\n                if (o.spendable) {\n                    let ok = false;\n                    if (o.lockingScript && o.lockingScript.length > 0) {\n                        const hash = services.hashOutputScript((0, index_client_1.asString)(o.lockingScript));\n                        const r = await services.getUtxoStatus(hash, undefined, `${o.txid}.${o.vout}`);\n                        if (r.isUtxo === true)\n                            ok = true;\n                    }\n                    if (!ok)\n                        invalidSpendableOutputs.push(o);\n                }\n            }\n        }\n        return { invalidSpendableOutputs };\n    }\n    async updateProvenTxReqDynamics(id, update, trx) {\n        const partial = {};\n        if (update['updated_at'])\n            partial['updated_at'] = update['updated_at'];\n        if (update['provenTxId'])\n            partial['provenTxId'] = update['provenTxId'];\n        if (update['status'])\n            partial['status'] = update['status'];\n        if (Number.isInteger(update['attempts']))\n            partial['attempts'] = update['attempts'];\n        if (update['notified'] !== undefined)\n            partial['notified'] = update['notified'];\n        if (update['batch'])\n            partial['batch'] = update['batch'];\n        if (update['history'])\n            partial['history'] = update['history'];\n        if (update['notify'])\n            partial['notify'] = update['notify'];\n        return await this.updateProvenTxReq(id, partial, trx);\n    }\n    async extendOutput(o, includeBasket = false, includeTags = false, trx) {\n        const ox = o;\n        if (includeBasket && ox.basketId)\n            ox.basket = await this.findOutputBasketById(o.basketId, trx);\n        if (includeTags) {\n            ox.tags = await this.getTagsForOutputId(o.outputId);\n        }\n        return o;\n    }\n    async validateOutputScript(o, trx) {\n        // without offset and length values return what we have (make no changes)\n        if (!o.scriptLength || !o.scriptOffset || !o.txid)\n            return;\n        // if there is an outputScript and its length is the expected length return what we have.\n        if (o.lockingScript && o.lockingScript.length === o.scriptLength)\n            return;\n        // outputScript is missing or has incorrect length...\n        const script = await this.getRawTxOfKnownValidTransaction(o.txid, o.scriptOffset, o.scriptLength, trx);\n        if (!script)\n            return;\n        o.lockingScript = script;\n    }\n}\nexports.StorageProvider = StorageProvider;\nfunction validateStorageFeeModel(v) {\n    const r = {\n        model: 'sat/kb',\n        value: 1\n    };\n    if (typeof v === 'object') {\n        if (v.model !== 'sat/kb')\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('StorageFeeModel.model', `\"sat/kb\"`);\n        if (typeof v.value === 'number') {\n            r.value = v.value;\n        }\n    }\n    return r;\n}\n//# sourceMappingURL=StorageProvider.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReader.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReader.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageReader = void 0;\nconst sdk = __importStar(__webpack_require__(/*! ../sdk/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nconst utilityHelpers_1 = __webpack_require__(/*! ../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst getSyncChunk_1 = __webpack_require__(/*! ./methods/getSyncChunk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getSyncChunk.js\");\n/**\n * The `StorageReader` abstract class is the base of the concrete wallet storage provider classes.\n *\n * It is the minimal interface required to read all wallet state records and is the base class for sync readers.\n *\n * The next class in the heirarchy is the `StorageReaderWriter` which supports sync readers and writers.\n *\n * The last class in the heirarchy is the `Storage` class which supports all active wallet operations.\n *\n * The ability to construct a properly configured instance of this class implies authentication.\n * As such there are no user specific authenticated access checks implied in the implementation of any of these methods.\n */\nclass StorageReader {\n    get dbtype() {\n        var _a;\n        return (_a = this._settings) === null || _a === void 0 ? void 0 : _a.dbtype;\n    }\n    constructor(options) {\n        this.chain = options.chain;\n    }\n    isAvailable() {\n        return !!this._settings;\n    }\n    async makeAvailable() {\n        if (this._settings)\n            return this._settings;\n        return (this._settings = await this.readSettings());\n    }\n    getSettings() {\n        if (!this._settings)\n            throw new sdk.WERR_INVALID_OPERATION('must call \"makeAvailable\" before accessing \"settings\"');\n        return this._settings;\n    }\n    isStorageProvider() {\n        return false;\n    }\n    async findUserByIdentityKey(key) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findUsers({ partial: { identityKey: key } }));\n    }\n    async getSyncChunk(args) {\n        return (0, getSyncChunk_1.getSyncChunk)(this, args);\n    }\n    /**\n     * Force dates to strings on SQLite and Date objects on MySQL\n     * @param date\n     * @returns\n     */\n    validateEntityDate(date) {\n        if (!this.dbtype)\n            throw new sdk.WERR_INTERNAL('must call verifyReadyForDatabaseAccess first');\n        let r = this.validateDate(date);\n        switch (this.dbtype) {\n            case 'IndexedDB':\n            case 'MySQL':\n                break;\n            case 'SQLite':\n                r = r.toISOString();\n                break;\n            default:\n                throw new sdk.WERR_INTERNAL(`Invalid dateScheme ${this.dbtype}`);\n        }\n        return r;\n    }\n    /**\n     *\n     * @param date\n     * @param useNowAsDefault if true and date is null or undefiend, set to current time.\n     * @returns\n     */\n    validateOptionalEntityDate(date, useNowAsDefault) {\n        if (!this.dbtype)\n            throw new sdk.WERR_INTERNAL('must call verifyReadyForDatabaseAccess first');\n        let r = this.validateOptionalDate(date);\n        if (!r && useNowAsDefault)\n            r = new Date();\n        switch (this.dbtype) {\n            case 'IndexedDB':\n            case 'MySQL':\n                break;\n            case 'SQLite':\n                if (r)\n                    r = r.toISOString();\n                break;\n            default:\n                throw new sdk.WERR_INTERNAL(`Invalid dateScheme ${this.dbtype}`);\n        }\n        return r;\n    }\n    validateDate(date) {\n        let r;\n        if (date instanceof Date)\n            r = date;\n        else\n            r = new Date(date);\n        return r;\n    }\n    validateOptionalDate(date) {\n        if (date === null || date === undefined)\n            return undefined;\n        return this.validateDate(date);\n    }\n    validateDateForWhere(date) {\n        if (!this.dbtype)\n            throw new sdk.WERR_INTERNAL('must call verifyReadyForDatabaseAccess first');\n        if (typeof date === 'number')\n            date = (0, utilityHelpers_1.validateSecondsSinceEpoch)(date);\n        const vdate = (0, utilityHelpers_1.verifyTruthy)(this.validateDate(date));\n        let r;\n        switch (this.dbtype) {\n            case 'IndexedDB':\n            case 'MySQL':\n                r = vdate;\n                break;\n            case 'SQLite':\n                r = vdate.toISOString();\n                break;\n            default:\n                throw new sdk.WERR_INTERNAL(`Invalid dateScheme ${this.dbtype}`);\n        }\n        return r;\n    }\n}\nexports.StorageReader = StorageReader;\n//# sourceMappingURL=StorageReader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReaderWriter.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReaderWriter.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageReaderWriter = void 0;\nconst utilityHelpers_1 = __webpack_require__(/*! ../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\nconst entities_1 = __webpack_require__(/*! ./schema/entities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nconst StorageReader_1 = __webpack_require__(/*! ./StorageReader */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReader.js\");\nclass StorageReaderWriter extends StorageReader_1.StorageReader {\n    constructor(options) {\n        super(options);\n    }\n    async setActive(auth, newActiveStorageIdentityKey) {\n        return await this.updateUser((0, utilityHelpers_1.verifyId)(auth.userId), {\n            activeStorage: newActiveStorageIdentityKey\n        });\n    }\n    async findCertificateById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findCertificates({ partial: { certificateId: id }, trx }));\n    }\n    async findCommissionById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findCommissions({ partial: { commissionId: id }, trx }));\n    }\n    async findOutputById(id, trx, noScript) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputs({ partial: { outputId: id }, noScript, trx }));\n    }\n    async findOutputBasketById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputBaskets({ partial: { basketId: id }, trx }));\n    }\n    async findProvenTxById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { provenTxId: id }, trx }));\n    }\n    async findProvenTxReqById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { provenTxReqId: id }, trx }));\n    }\n    async findSyncStateById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findSyncStates({ partial: { syncStateId: id }, trx }));\n    }\n    async findTransactionById(id, trx, noRawTx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findTransactions({\n            partial: { transactionId: id },\n            noRawTx,\n            trx\n        }));\n    }\n    async findTxLabelById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabels({ partial: { txLabelId: id }, trx }));\n    }\n    async findOutputTagById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTags({ partial: { outputTagId: id }, trx }));\n    }\n    async findUserById(id, trx) {\n        return (0, utilityHelpers_1.verifyOneOrNone)(await this.findUsers({ partial: { userId: id }, trx }));\n    }\n    async findOrInsertUser(identityKey, trx) {\n        let user;\n        let isNew = false;\n        for (let retry = 0;; retry++) {\n            try {\n                user = (0, utilityHelpers_1.verifyOneOrNone)(await this.findUsers({ partial: { identityKey }, trx }));\n                //console.log(`findOrInsertUser oneOrNone: ${JSON.stringify(user || 'none').slice(0,512)}`)\n                if (user)\n                    break;\n                const now = new Date();\n                user = {\n                    created_at: now,\n                    updated_at: new Date('1971-01-01'), // Default constructed user, sync will override with any updated user.\n                    userId: 0,\n                    identityKey,\n                    activeStorage: this.getSettings().storageIdentityKey\n                };\n                user.userId = await this.insertUser(user, trx);\n                isNew = true;\n                // Add default change basket for new user.\n                await this.insertOutputBasket({\n                    created_at: now,\n                    updated_at: new Date('1971-01-01'), // Default constructed basket, sync will override with any updated basket.\n                    basketId: 0,\n                    userId: user.userId,\n                    name: 'default',\n                    numberOfDesiredUTXOs: 144,\n                    minimumDesiredUTXOValue: 32,\n                    isDeleted: false\n                });\n                break;\n            }\n            catch (eu) {\n                console.log(`findOrInsertUser catch: ${JSON.stringify(eu).slice(0, 512)}`);\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n        return { user, isNew };\n    }\n    async findOrInsertTransaction(newTx, trx) {\n        let tx;\n        let isNew = false;\n        for (let retry = 0;; retry++) {\n            try {\n                tx = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTransactions({\n                    partial: { userId: newTx.userId, txid: newTx.txid },\n                    trx\n                }));\n                if (tx)\n                    break;\n                newTx.transactionId = await this.insertTransaction(newTx, trx);\n                isNew = true;\n                tx = newTx;\n                break;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n        return { tx, isNew };\n    }\n    async findOrInsertOutputBasket(userId, name, trx) {\n        const partial = { name, userId };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let basket = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputBaskets({ partial, trx }));\n                if (!basket) {\n                    basket = {\n                        ...partial,\n                        minimumDesiredUTXOValue: 0,\n                        numberOfDesiredUTXOs: 0,\n                        basketId: 0,\n                        created_at: now,\n                        updated_at: now,\n                        isDeleted: false\n                    };\n                    basket.basketId = await this.insertOutputBasket(basket, trx);\n                }\n                if (basket.isDeleted) {\n                    await this.updateOutputBasket((0, utilityHelpers_1.verifyId)(basket.basketId), {\n                        isDeleted: false\n                    });\n                }\n                return basket;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertTxLabel(userId, label, trx) {\n        const partial = { label, userId };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let txLabel = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabels({ partial, trx }));\n                if (!txLabel) {\n                    txLabel = {\n                        ...partial,\n                        txLabelId: 0,\n                        created_at: now,\n                        updated_at: now,\n                        isDeleted: false\n                    };\n                    txLabel.txLabelId = await this.insertTxLabel(txLabel, trx);\n                }\n                if (txLabel.isDeleted) {\n                    await this.updateTxLabel((0, utilityHelpers_1.verifyId)(txLabel.txLabelId), {\n                        isDeleted: false\n                    });\n                }\n                return txLabel;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertTxLabelMap(transactionId, txLabelId, trx) {\n        const partial = { transactionId, txLabelId };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let txLabelMap = (0, utilityHelpers_1.verifyOneOrNone)(await this.findTxLabelMaps({ partial, trx }));\n                if (!txLabelMap) {\n                    txLabelMap = {\n                        ...partial,\n                        created_at: now,\n                        updated_at: now,\n                        isDeleted: false\n                    };\n                    await this.insertTxLabelMap(txLabelMap, trx);\n                }\n                if (txLabelMap.isDeleted) {\n                    await this.updateTxLabelMap(transactionId, txLabelId, {\n                        isDeleted: false\n                    });\n                }\n                return txLabelMap;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertOutputTag(userId, tag, trx) {\n        const partial = { tag, userId };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let outputTag = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTags({ partial, trx }));\n                if (!outputTag) {\n                    outputTag = {\n                        ...partial,\n                        outputTagId: 0,\n                        created_at: now,\n                        updated_at: now,\n                        isDeleted: false\n                    };\n                    outputTag.outputTagId = await this.insertOutputTag(outputTag, trx);\n                }\n                if (outputTag.isDeleted) {\n                    await this.updateOutputTag((0, utilityHelpers_1.verifyId)(outputTag.outputTagId), {\n                        isDeleted: false\n                    });\n                }\n                return outputTag;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertOutputTagMap(outputId, outputTagId, trx) {\n        const partial = { outputId, outputTagId };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let outputTagMap = (0, utilityHelpers_1.verifyOneOrNone)(await this.findOutputTagMaps({ partial, trx }));\n                if (!outputTagMap) {\n                    outputTagMap = {\n                        ...partial,\n                        created_at: now,\n                        updated_at: now,\n                        isDeleted: false\n                    };\n                    await this.insertOutputTagMap(outputTagMap, trx);\n                }\n                if (outputTagMap.isDeleted) {\n                    await this.updateOutputTagMap(outputId, outputTagId, {\n                        isDeleted: false\n                    });\n                }\n                return outputTagMap;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertSyncStateAuth(auth, storageIdentityKey, storageName) {\n        const partial = { userId: auth.userId, storageIdentityKey, storageName };\n        for (let retry = 0;; retry++) {\n            try {\n                const now = new Date();\n                let syncState = (0, utilityHelpers_1.verifyOneOrNone)(await this.findSyncStates({ partial }));\n                if (!syncState) {\n                    syncState = {\n                        ...partial,\n                        created_at: now,\n                        updated_at: now,\n                        syncStateId: 0,\n                        status: 'unknown',\n                        init: false,\n                        refNum: (0, utilityHelpers_1.randomBytesBase64)(12),\n                        syncMap: JSON.stringify((0, entities_1.createSyncMap)())\n                    };\n                    await this.insertSyncState(syncState);\n                    return { syncState, isNew: true };\n                }\n                return { syncState, isNew: false };\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n    }\n    async findOrInsertProvenTxReq(newReq, trx) {\n        let req;\n        let isNew = false;\n        for (let retry = 0;; retry++) {\n            try {\n                req = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxReqs({ partial: { txid: newReq.txid }, trx }));\n                if (req)\n                    break;\n                newReq.provenTxReqId = await this.insertProvenTxReq(newReq, trx);\n                isNew = true;\n                req = newReq;\n                break;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n        return { req, isNew };\n    }\n    async findOrInsertProvenTx(newProven, trx) {\n        let proven;\n        let isNew = false;\n        for (let retry = 0;; retry++) {\n            try {\n                proven = (0, utilityHelpers_1.verifyOneOrNone)(await this.findProvenTxs({ partial: { txid: newProven.txid }, trx }));\n                if (proven)\n                    break;\n                newProven.provenTxId = await this.insertProvenTx(newProven, trx);\n                isNew = true;\n                proven = newProven;\n                break;\n            }\n            catch (eu) {\n                if (retry > 0)\n                    throw eu;\n            }\n        }\n        return { proven, isNew };\n    }\n    async tagOutput(partial, tag, trx) {\n        await this.transaction(async (trx) => {\n            const o = (0, utilityHelpers_1.verifyOne)(await this.findOutputs({ partial, noScript: true, trx }));\n            const outputTag = await this.findOrInsertOutputTag(o.userId, tag, trx);\n            await this.findOrInsertOutputTagMap((0, utilityHelpers_1.verifyId)(o.outputId), (0, utilityHelpers_1.verifyId)(outputTag.outputTagId), trx);\n        }, trx);\n    }\n}\nexports.StorageReaderWriter = StorageReaderWriter;\n//# sourceMappingURL=StorageReaderWriter.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageReaderWriter.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageSyncReader.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageSyncReader.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageSyncReader = void 0;\nconst sdk = __importStar(__webpack_require__(/*! ../sdk/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\n/**\n * The `StorageSyncReader` non-abstract class must be used when authentication checking access to the methods of a `StorageBaseReader` is required.\n *\n * Constructed from an `auth` object that must minimally include the authenticated user's identityKey,\n * and the `StorageBaseReader` to be protected.\n */\nclass StorageSyncReader {\n    constructor(auth, storage) {\n        this.auth = auth;\n        this.storage = storage;\n    }\n    async makeAvailable() {\n        await this.storage.makeAvailable();\n        if (this.auth.userId === undefined) {\n            const user = await this.storage.findUserByIdentityKey(this.auth.identityKey);\n            if (!user)\n                throw new sdk.WERR_UNAUTHORIZED();\n            this.auth.userId = user.userId;\n        }\n        return this.storage.getSettings();\n    }\n    destroy() {\n        return this.storage.destroy();\n    }\n    async getSyncChunk(args) {\n        if (!this.auth.userId)\n            await this.makeAvailable();\n        if (args.identityKey !== this.auth.identityKey)\n            throw new sdk.WERR_UNAUTHORIZED();\n        return await this.storage.getSyncChunk(args);\n    }\n}\nexports.StorageSyncReader = StorageSyncReader;\n//# sourceMappingURL=StorageSyncReader.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageSyncReader.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/WalletStorageManager.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/WalletStorageManager.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WalletStorageManager = void 0;\nconst entities_1 = __webpack_require__(/*! ../storage/schema/entities */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nconst sdk = __importStar(__webpack_require__(/*! ../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nclass ManagedStorage {\n    constructor(storage) {\n        this.storage = storage;\n        this.isStorageProvider = storage.isStorageProvider();\n        this.isAvailable = false;\n    }\n}\n/**\n * The `WalletStorageManager` class delivers authentication checking storage access to the wallet.\n *\n * If manages multiple `StorageBase` derived storage services: one actice, the rest as backups.\n *\n * Of the storage services, one is 'active' at any one time.\n * On startup, and whenever triggered by the wallet, `WalletStorageManager` runs a syncrhonization sequence:\n *\n * 1. While synchronizing, all other access to storage is blocked waiting.\n * 2. The active service is confirmed, potentially triggering a resolution process if there is disagreement.\n * 3. Changes are pushed from the active storage service to each inactive, backup service.\n *\n * Some storage services do not support multiple writers. `WalletStorageManager` manages wait-blocking write requests\n * for these services.\n */\nclass WalletStorageManager {\n    /**\n     * Creates a new WalletStorageManager with the given identityKey and optional active and backup storage providers.\n     *\n     * @param identityKey The identity key of the user for whom this wallet is being managed.\n     * @param active An optional active storage provider. If not provided, no active storage will be set.\n     * @param backups An optional array of backup storage providers. If not provided, no backups will be set.\n     */\n    constructor(identityKey, active, backups) {\n        /**\n         * All configured stores including current active, backups, and conflicting actives.\n         */\n        this._stores = [];\n        /**\n         * True if makeAvailable has been run and access to managed stores (active) is allowed\n         */\n        this._isAvailable = false;\n        this.readerLocks = [];\n        this.writerLocks = [];\n        this.syncLocks = [];\n        this.spLocks = [];\n        const stores = [...(backups || [])];\n        if (active)\n            stores.unshift(active);\n        this._stores = stores.map(s => new ManagedStorage(s));\n        this._authId = { identityKey };\n    }\n    isStorageProvider() {\n        return false;\n    }\n    isAvailable() {\n        return this._isAvailable;\n    }\n    /**\n     * The active storage is \"enabled\" only if its `storageIdentityKey` matches the user's currently selected `activeStorage`,\n     * and only if there are no stores with conflicting `activeStorage` selections.\n     *\n     * A wallet may be created without including the user's currently selected active storage. This allows readonly access to their wallet data.\n     *\n     * In addition, if there are conflicting `activeStorage` selections among backup storage providers then the active remains disabled.\n     */\n    get isActiveEnabled() {\n        return (this._active !== undefined &&\n            this._active.settings.storageIdentityKey === this._active.user.activeStorage &&\n            this._conflictingActives !== undefined &&\n            this._conflictingActives.length === 0);\n    }\n    /**\n     * @returns true if at least one WalletStorageProvider has been added.\n     */\n    canMakeAvailable() {\n        return this._stores.length > 0;\n    }\n    /**\n     * This async function must be called after construction and before\n     * any other async function can proceed.\n     *\n     * Runs through `_stores` validating all properties and partitioning across `_active`, `_backups`, `_conflictingActives`.\n     *\n     * @throws WERR_INVALID_PARAMETER if canMakeAvailable returns false.\n     *\n     * @returns {TableSettings} from the active storage.\n     */\n    async makeAvailable() {\n        var _a;\n        if (this._isAvailable)\n            return this._active.settings;\n        this._active = undefined;\n        this._backups = [];\n        this._conflictingActives = [];\n        if (this._stores.length < 1)\n            throw new sdk.WERR_INVALID_PARAMETER('active', 'valid. Must add active storage provider to wallet.');\n        // Initial backups. conflictingActives will be removed.\n        const backups = [];\n        let i = -1;\n        for (const store of this._stores) {\n            i++;\n            if (!store.isAvailable || !store.settings || !store.user) {\n                // Validate all ManagedStorage properties.\n                store.settings = await store.storage.makeAvailable();\n                const r = await store.storage.findOrInsertUser(this._authId.identityKey);\n                store.user = r.user;\n                store.isAvailable = true;\n            }\n            if (!this._active)\n                // _stores[0] becomes the default active store. It may be replaced if it is not the user's \"enabled\" activeStorage and that store is found among the remainder (backups).\n                this._active = store;\n            else {\n                const ua = store.user.activeStorage;\n                const si = store.settings.storageIdentityKey;\n                if (ua === si && !this.isActiveEnabled) {\n                    // This store's user record selects it as an enabled active storage...\n                    // swap the current not-enabled active for this storeage.\n                    backups.push(this._active);\n                    this._active = store;\n                }\n                else {\n                    // This store is a backup: Its user record selects some other storage as active.\n                    backups.push(store);\n                }\n            }\n        }\n        // Review backups, partition out conflicting actives.\n        const si = (_a = this._active.settings) === null || _a === void 0 ? void 0 : _a.storageIdentityKey;\n        for (const store of backups) {\n            if (store.user.activeStorage !== si)\n                this._conflictingActives.push(store);\n            else\n                this._backups.push(store);\n        }\n        this._isAvailable = true;\n        this._authId.userId = this._active.user.userId;\n        this._authId.isActive = this.isActiveEnabled;\n        return this._active.settings;\n    }\n    verifyActive() {\n        if (!this._active || !this._isAvailable)\n            throw new sdk.WERR_INVALID_OPERATION('An active WalletStorageProvider must be added to this WalletStorageManager and makeAvailable must be called.');\n        return this._active;\n    }\n    async getAuth(mustBeActive) {\n        if (!this.isAvailable())\n            await this.makeAvailable();\n        if (mustBeActive && !this._authId.isActive)\n            throw new sdk.WERR_NOT_ACTIVE();\n        return this._authId;\n    }\n    async getUserId() {\n        return (await this.getAuth()).userId;\n    }\n    getActive() {\n        return this.verifyActive().storage;\n    }\n    getActiveSettings() {\n        return this.verifyActive().settings;\n    }\n    getActiveUser() {\n        return this.verifyActive().user;\n    }\n    getActiveStore() {\n        return this.verifyActive().settings.storageIdentityKey;\n    }\n    getActiveStoreName() {\n        return this.verifyActive().settings.storageName;\n    }\n    getBackupStores() {\n        this.verifyActive();\n        return this._backups.map(b => b.settings.storageIdentityKey);\n    }\n    getConflictingStores() {\n        this.verifyActive();\n        return this._conflictingActives.map(b => b.settings.storageIdentityKey);\n    }\n    getAllStores() {\n        this.verifyActive();\n        return this._stores.map(b => b.settings.storageIdentityKey);\n    }\n    async getActiveLock(lockQueue) {\n        if (!this.isAvailable())\n            await this.makeAvailable();\n        let resolveNewLock = () => { };\n        const newLock = new Promise(resolve => {\n            resolveNewLock = resolve;\n            lockQueue.push(resolve);\n        });\n        if (lockQueue.length === 1) {\n            resolveNewLock();\n        }\n        await newLock;\n    }\n    releaseActiveLock(queue) {\n        queue.shift(); // Remove the current lock from the queue\n        if (queue.length > 0) {\n            queue[0]();\n        }\n    }\n    async getActiveForReader() {\n        await this.getActiveLock(this.readerLocks);\n        return this.getActive();\n    }\n    releaseActiveForReader() {\n        this.releaseActiveLock(this.readerLocks);\n    }\n    async getActiveForWriter() {\n        await this.getActiveLock(this.readerLocks);\n        await this.getActiveLock(this.writerLocks);\n        return this.getActive();\n    }\n    releaseActiveForWriter() {\n        this.releaseActiveLock(this.writerLocks);\n        this.releaseActiveLock(this.readerLocks);\n    }\n    async getActiveForSync() {\n        await this.getActiveLock(this.readerLocks);\n        await this.getActiveLock(this.writerLocks);\n        await this.getActiveLock(this.syncLocks);\n        return this.getActive();\n    }\n    releaseActiveForSync() {\n        this.releaseActiveLock(this.syncLocks);\n        this.releaseActiveLock(this.writerLocks);\n        this.releaseActiveLock(this.readerLocks);\n    }\n    async getActiveForStorageProvider() {\n        await this.getActiveLock(this.readerLocks);\n        await this.getActiveLock(this.writerLocks);\n        await this.getActiveLock(this.syncLocks);\n        await this.getActiveLock(this.spLocks);\n        const active = this.getActive();\n        // We can finally confirm that active storage is still able to support `StorageProvider`\n        if (!active.isStorageProvider())\n            throw new sdk.WERR_INVALID_OPERATION('Active \"WalletStorageProvider\" does not support \"StorageProvider\" interface.');\n        // Allow the sync to proceed on the active store.\n        return active;\n    }\n    releaseActiveForStorageProvider() {\n        this.releaseActiveLock(this.spLocks);\n        this.releaseActiveLock(this.syncLocks);\n        this.releaseActiveLock(this.writerLocks);\n        this.releaseActiveLock(this.readerLocks);\n    }\n    async runAsWriter(writer) {\n        try {\n            const active = await this.getActiveForWriter();\n            const r = await writer(active);\n            return r;\n        }\n        finally {\n            this.releaseActiveForWriter();\n        }\n    }\n    async runAsReader(reader) {\n        try {\n            const active = await this.getActiveForReader();\n            const r = await reader(active);\n            return r;\n        }\n        finally {\n            this.releaseActiveForReader();\n        }\n    }\n    /**\n     *\n     * @param sync the function to run with sync access lock\n     * @param activeSync from chained sync functions, active storage already held under sync access lock.\n     * @returns\n     */\n    async runAsSync(sync, activeSync) {\n        try {\n            const active = activeSync || (await this.getActiveForSync());\n            const r = await sync(active);\n            return r;\n        }\n        finally {\n            if (!activeSync)\n                this.releaseActiveForSync();\n        }\n    }\n    async runAsStorageProvider(sync) {\n        try {\n            const active = await this.getActiveForStorageProvider();\n            const r = await sync(active);\n            return r;\n        }\n        finally {\n            this.releaseActiveForStorageProvider();\n        }\n    }\n    /**\n     *\n     * @returns true if the active `WalletStorageProvider` also implements `StorageProvider`\n     */\n    isActiveStorageProvider() {\n        return this.getActive().isStorageProvider();\n    }\n    async addWalletStorageProvider(provider) {\n        await provider.makeAvailable();\n        if (this._services)\n            provider.setServices(this._services);\n        this._stores.push(new ManagedStorage(provider));\n        this._isAvailable = false;\n        await this.makeAvailable();\n    }\n    setServices(v) {\n        this._services = v;\n        for (const store of this._stores)\n            store.storage.setServices(v);\n    }\n    getServices() {\n        if (!this._services)\n            throw new sdk.WERR_INVALID_OPERATION('Must setServices first.');\n        return this._services;\n    }\n    getSettings() {\n        return this.getActive().getSettings();\n    }\n    async migrate(storageName, storageIdentityKey) {\n        return await this.runAsWriter(async (writer) => {\n            return writer.migrate(storageName, storageIdentityKey);\n        });\n    }\n    async destroy() {\n        if (this._stores.length < 1)\n            return;\n        return await this.runAsWriter(async (writer) => {\n            for (const store of this._stores)\n                await store.storage.destroy();\n        });\n    }\n    async findOrInsertUser(identityKey) {\n        const auth = await this.getAuth();\n        if (identityKey != auth.identityKey)\n            throw new sdk.WERR_UNAUTHORIZED();\n        return await this.runAsWriter(async (writer) => {\n            const r = await writer.findOrInsertUser(identityKey);\n            if (auth.userId && auth.userId !== r.user.userId)\n                throw new sdk.WERR_INTERNAL('userId may not change for given identityKey');\n            this._authId.userId = r.user.userId;\n            return r;\n        });\n    }\n    async abortAction(args) {\n        sdk.validateAbortActionArgs(args);\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.abortAction(auth, args);\n        });\n    }\n    async createAction(vargs) {\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.createAction(auth, vargs);\n        });\n    }\n    async internalizeAction(args) {\n        sdk.validateInternalizeActionArgs(args);\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.internalizeAction(auth, args);\n        });\n    }\n    async relinquishCertificate(args) {\n        sdk.validateRelinquishCertificateArgs(args);\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.relinquishCertificate(auth, args);\n        });\n    }\n    async relinquishOutput(args) {\n        sdk.validateRelinquishOutputArgs(args);\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.relinquishOutput(auth, args);\n        });\n    }\n    async processAction(args) {\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.processAction(auth, args);\n        });\n    }\n    async insertCertificate(certificate) {\n        return await this.runAsWriter(async (writer) => {\n            const auth = await this.getAuth(true);\n            return await writer.insertCertificateAuth(auth, certificate);\n        });\n    }\n    async listActions(vargs) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.listActions(auth, vargs);\n        });\n    }\n    async listCertificates(args) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.listCertificates(auth, args);\n        });\n    }\n    async listOutputs(vargs) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.listOutputs(auth, vargs);\n        });\n    }\n    async findCertificates(args) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.findCertificatesAuth(auth, args);\n        });\n    }\n    async findOutputBaskets(args) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.findOutputBasketsAuth(auth, args);\n        });\n    }\n    async findOutputs(args) {\n        const auth = await this.getAuth();\n        return await this.runAsReader(async (reader) => {\n            return await reader.findOutputsAuth(auth, args);\n        });\n    }\n    async findProvenTxReqs(args) {\n        return await this.runAsReader(async (reader) => {\n            return await reader.findProvenTxReqs(args);\n        });\n    }\n    async syncFromReader(identityKey, reader, activeSync, log = '') {\n        const auth = await this.getAuth();\n        if (identityKey !== auth.identityKey)\n            throw new sdk.WERR_UNAUTHORIZED();\n        const readerSettings = await reader.makeAvailable();\n        let inserts = 0, updates = 0;\n        log = await this.runAsSync(async (sync) => {\n            const writer = sync;\n            const writerSettings = this.getSettings();\n            log += `syncFromReader from ${readerSettings.storageName} to ${writerSettings.storageName}\\n`;\n            let i = -1;\n            for (;;) {\n                i++;\n                const ss = await entities_1.EntitySyncState.fromStorage(writer, identityKey, readerSettings);\n                const args = ss.makeRequestSyncChunkArgs(identityKey, writerSettings.storageIdentityKey);\n                const chunk = await reader.getSyncChunk(args);\n                if (chunk.user) {\n                    // Merging state from a reader cannot update activeStorage\n                    chunk.user.activeStorage = this._active.user.activeStorage;\n                }\n                const r = await writer.processSyncChunk(args, chunk);\n                inserts += r.inserts;\n                updates += r.updates;\n                log += `chunk ${i} inserted ${r.inserts} updated ${r.updates} ${r.maxUpdated_at}\\n`;\n                if (r.done)\n                    break;\n            }\n            log += `syncFromReader complete: ${inserts} inserts, ${updates} updates\\n`;\n            return log;\n        }, activeSync);\n        return { inserts, updates, log };\n    }\n    async syncToWriter(auth, writer, activeSync, log = '', progLog) {\n        progLog || (progLog = s => s);\n        const identityKey = auth.identityKey;\n        const writerSettings = await writer.makeAvailable();\n        let inserts = 0, updates = 0;\n        log = await this.runAsSync(async (sync) => {\n            const reader = sync;\n            const readerSettings = reader.getSettings();\n            log += progLog(`syncToWriter from ${readerSettings.storageName} to ${writerSettings.storageName}\\n`);\n            let i = -1;\n            for (;;) {\n                i++;\n                const ss = await entities_1.EntitySyncState.fromStorage(writer, identityKey, readerSettings);\n                const args = ss.makeRequestSyncChunkArgs(identityKey, writerSettings.storageIdentityKey);\n                const chunk = await reader.getSyncChunk(args);\n                log += entities_1.EntitySyncState.syncChunkSummary(chunk);\n                const r = await writer.processSyncChunk(args, chunk);\n                inserts += r.inserts;\n                updates += r.updates;\n                log += progLog(`chunk ${i} inserted ${r.inserts} updated ${r.updates} ${r.maxUpdated_at}\\n`);\n                if (r.done)\n                    break;\n            }\n            log += progLog(`syncToWriter complete: ${inserts} inserts, ${updates} updates\\n`);\n            return log;\n        }, activeSync);\n        return { inserts, updates, log };\n    }\n    async updateBackups(activeSync, progLog) {\n        progLog || (progLog = s => s);\n        const auth = await this.getAuth(true);\n        return await this.runAsSync(async (sync) => {\n            let log = progLog(`BACKUP CURRENT ACTIVE TO ${this._backups.length} STORES\\n`);\n            for (const backup of this._backups) {\n                const stwr = await this.syncToWriter(auth, backup.storage, sync, undefined, progLog);\n                log += stwr.log;\n            }\n            return log;\n        }, activeSync);\n    }\n    /**\n     * Updates backups and switches to new active storage provider from among current backup providers.\n     *\n     * Also resolves conflicting actives.\n     *\n     * @param storageIdentityKey of current backup storage provider that is to become the new active provider.\n     */\n    async setActive(storageIdentityKey, progLog) {\n        progLog || (progLog = s => s);\n        if (!this.isAvailable())\n            await this.makeAvailable();\n        // Confirm a valid storageIdentityKey: must match one of the _stores.\n        const newActiveIndex = this._stores.findIndex(s => s.settings.storageIdentityKey === storageIdentityKey);\n        if (newActiveIndex < 0)\n            throw new sdk.WERR_INVALID_PARAMETER('storageIdentityKey', `registered with this \"WalletStorageManager\". ${storageIdentityKey} does not match any managed store.`);\n        const identityKey = (await this.getAuth()).identityKey;\n        const newActive = this._stores[newActiveIndex];\n        let log = progLog(`setActive to ${newActive.settings.storageName}`);\n        if (storageIdentityKey === this.getActiveStore() && this.isActiveEnabled)\n            /** Setting the current active as the new active is a permitted no-op. */\n            return log + progLog(` unchanged\\n`);\n        log += progLog('\\n');\n        log += await this.runAsSync(async (sync) => {\n            let log = '';\n            if (this._conflictingActives.length > 0) {\n                // Merge state from conflicting actives into `newActive`.\n                // Handle case where new active is current active to resolve conflicts.\n                // And where new active is one of the current conflict actives.\n                this._conflictingActives.push(this._active);\n                // Remove the new active from conflicting actives and\n                // set new active as the conflicting active that matches the target `storageIdentityKey`\n                this._conflictingActives = this._conflictingActives.filter(ca => {\n                    const isNewActive = ca.settings.storageIdentityKey === storageIdentityKey;\n                    return !isNewActive;\n                });\n                // Merge state from conflicting actives into `newActive`.\n                for (const conflict of this._conflictingActives) {\n                    log += progLog('MERGING STATE FROM CONFLICTING ACTIVES:\\n');\n                    const sfr = await this.syncToWriter({ identityKey, userId: newActive.user.userId, isActive: false }, newActive.storage, conflict.storage, undefined, progLog);\n                    log += sfr.log;\n                }\n                log += progLog('PROPAGATE MERGED ACTIVE STATE TO NON-ACTIVES\\n');\n            }\n            else {\n                log += progLog('BACKUP CURRENT ACTIVE STATE THEN SET NEW ACTIVE\\n');\n            }\n            // If there were conflicting actives,\n            // Push state merged from all merged actives into newActive to all stores other than the now single active.\n            // Otherwise,\n            // Push state from current active to all other stores.\n            const backupSource = this._conflictingActives.length > 0 ? newActive : this._active;\n            // Update the backupSource's user record with the new activeStorage\n            // which will propagate to all other stores in the following backup loop.\n            await backupSource.storage.setActive({ identityKey, userId: backupSource.user.userId }, storageIdentityKey);\n            for (const store of this._stores) {\n                // Update cached user.activeStorage of all stores\n                store.user.activeStorage = storageIdentityKey;\n                if (store.settings.storageIdentityKey !== backupSource.settings.storageIdentityKey) {\n                    // If this store is not the backupSource store push state from backupSource to this store.\n                    const stwr = await this.syncToWriter({ identityKey, userId: store.user.userId, isActive: false }, store.storage, backupSource.storage, undefined, progLog);\n                    log += stwr.log;\n                }\n            }\n            this._isAvailable = false;\n            await this.makeAvailable();\n            return log;\n        });\n        return log;\n    }\n    getStoreEndpointURL(store) {\n        if (store.storage.constructor.name === 'StorageClient')\n            return store.storage.endpointUrl;\n        return undefined;\n    }\n    getStores() {\n        const stores = [];\n        if (this._active) {\n            stores.push({\n                isActive: true,\n                isEnabled: this.isActiveEnabled,\n                isBackup: false,\n                isConflicting: false,\n                userId: this._active.user.userId,\n                storageIdentityKey: this._active.settings.storageIdentityKey,\n                storageName: this._active.settings.storageName,\n                storageClass: this._active.storage.constructor.name,\n                endpointURL: this.getStoreEndpointURL(this._active)\n            });\n        }\n        for (const store of this._conflictingActives || []) {\n            stores.push({\n                isActive: true,\n                isEnabled: false,\n                isBackup: false,\n                isConflicting: true,\n                userId: store.user.userId,\n                storageIdentityKey: store.settings.storageIdentityKey,\n                storageName: store.settings.storageName,\n                storageClass: store.storage.constructor.name,\n                endpointURL: this.getStoreEndpointURL(store)\n            });\n        }\n        for (const store of this._backups || []) {\n            stores.push({\n                isActive: false,\n                isEnabled: false,\n                isBackup: true,\n                isConflicting: false,\n                userId: store.user.userId,\n                storageIdentityKey: store.settings.storageIdentityKey,\n                storageName: store.settings.storageName,\n                storageClass: store.storage.constructor.name,\n                endpointURL: this.getStoreEndpointURL(store)\n            });\n        }\n        return stores;\n    }\n}\nexports.WalletStorageManager = WalletStorageManager;\n//# sourceMappingURL=WalletStorageManager.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/WalletStorageManager.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.client.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./WalletStorageManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/WalletStorageManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageIdb */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageIdb.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageProvider */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageSyncReader */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageSyncReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schema/tables/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schema/entities/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./remoting/StorageClient */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageClient.js\"), exports);\n//# sourceMappingURL=index.client.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.client.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.mobile.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.mobile.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./WalletStorageManager */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/WalletStorageManager.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageProvider */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageProvider.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageSyncReader */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/StorageSyncReader.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schema/tables/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./schema/entities/index */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\"), exports);\n__exportStar(__webpack_require__(/*! ./remoting/StorageMobile */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageMobile.js\"), exports);\n//# sourceMappingURL=index.mobile.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/index.mobile.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListActionsSpecOp.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListActionsSpecOp.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getLabelToSpecOp = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst getLabelToSpecOp = () => {\n    return {\n        [index_client_1.sdk.specOpNoSendActions]: {\n            name: 'noSendActions',\n            labelsToIntercept: ['abort'],\n            setStatusFilter: () => ['nosend'],\n            postProcess: async (s, auth, vargs, specOpLabels, txs) => {\n                if (specOpLabels.indexOf('abort') >= 0) {\n                    for (const tx of txs) {\n                        if (tx.status === 'nosend') {\n                            await s.abortAction(auth, { reference: tx.reference });\n                            tx.status = 'failed';\n                        }\n                    }\n                }\n            }\n        },\n        [index_client_1.sdk.specOpFailedActions]: {\n            name: 'failedActions',\n            labelsToIntercept: ['unfail'],\n            setStatusFilter: () => ['failed'],\n            postProcess: async (s, auth, vargs, specOpLabels, txs) => {\n                if (specOpLabels.indexOf('unfail') >= 0) {\n                    for (const tx of txs) {\n                        if (tx.status === 'failed') {\n                            await s.updateTransaction(tx.transactionId, { status: 'unfail' });\n                            // wallet wire does not support 'unfail' status, return as 'failed'.\n                        }\n                    }\n                }\n            }\n        }\n    };\n};\nexports.getLabelToSpecOp = getLabelToSpecOp;\n//# sourceMappingURL=ListActionsSpecOp.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListActionsSpecOp.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListOutputsSpecOp.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListOutputsSpecOp.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBasketToSpecOp = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst getBasketToSpecOp = () => {\n    return {\n        [index_client_1.sdk.specOpWalletBalance]: {\n            name: 'totalOutputsIsWalletBalance',\n            useBasket: 'default',\n            ignoreLimit: true,\n            resultFromOutputs: async (s, auth, vargs, specOpTags, outputs) => {\n                let totalOutputs = 0;\n                for (const o of outputs)\n                    totalOutputs += o.satoshis;\n                return { totalOutputs, outputs: [] };\n            }\n        },\n        [index_client_1.sdk.specOpInvalidChange]: {\n            name: 'invalidChangeOutputs',\n            useBasket: 'default',\n            ignoreLimit: true,\n            includeOutputScripts: true,\n            includeSpent: false,\n            tagsToIntercept: ['release', 'all'],\n            filterOutputs: async (s, auth, vargs, specOpTags, outputs) => {\n                const filteredOutputs = [];\n                const services = s.getServices();\n                for (const o of outputs) {\n                    await s.validateOutputScript(o);\n                    let ok = false;\n                    if (o.lockingScript && o.lockingScript.length > 0) {\n                        ok = await services.isUtxo(o);\n                    }\n                    else {\n                        ok = undefined;\n                    }\n                    if (ok === false) {\n                        filteredOutputs.push(o);\n                    }\n                }\n                if (specOpTags.indexOf('release') >= 0) {\n                    for (const o of filteredOutputs) {\n                        await s.updateOutput(o.outputId, { spendable: false });\n                        o.spendable = false;\n                    }\n                }\n                return filteredOutputs;\n            }\n        },\n        [index_client_1.sdk.specOpSetWalletChangeParams]: {\n            name: 'setWalletChangeParams',\n            tagsParamsCount: 2,\n            resultFromTags: async (s, auth, vargs, specOpTags) => {\n                if (specOpTags.length !== 2)\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('numberOfDesiredUTXOs and minimumDesiredUTXOValue', 'valid');\n                const numberOfDesiredUTXOs = (0, index_client_1.verifyInteger)(Number(specOpTags[0]));\n                const minimumDesiredUTXOValue = (0, index_client_1.verifyInteger)(Number(specOpTags[1]));\n                const basket = (0, index_client_1.verifyOne)(await s.findOutputBaskets({\n                    partial: { userId: (0, index_client_1.verifyId)(auth.userId), name: 'default' }\n                }));\n                await s.updateOutputBasket(basket.basketId, {\n                    numberOfDesiredUTXOs,\n                    minimumDesiredUTXOValue\n                });\n                return { totalOutputs: 0, outputs: [] };\n            }\n        }\n    };\n};\nexports.getBasketToSpecOp = getBasketToSpecOp;\n//# sourceMappingURL=ListOutputsSpecOp.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListOutputsSpecOp.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/attemptToPostReqsToNetwork.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/attemptToPostReqsToNetwork.js ***!
  \*******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.attemptToPostReqsToNetwork = attemptToPostReqsToNetwork;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst sdk = __importStar(__webpack_require__(/*! ../../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\"));\nconst utilityHelpers_1 = __webpack_require__(/*! ../../utility/utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\");\n/**\n * Attempt to post one or more `ProvenTxReq` with status 'unsent'\n * to the bitcoin network.\n *\n * @param reqs\n */\nasync function attemptToPostReqsToNetwork(storage, reqs, trx) {\n    // initialize results, validate reqs ready to post, txids are of the transactions in the beef that we care about.\n    const { r, vreqs, txids } = await validateReqsAndMergeBeefs(storage, reqs, trx);\n    const services = storage.getServices();\n    const pbrs = await services.postBeef(r.beef, txids);\n    // post beef results (pbrs) is an array by service provider\n    // for each service provider, there's an aggregate result and individual results by txid.\n    await transferNotesToReqHistories(txids, vreqs, pbrs, storage, trx);\n    const apbrs = aggregatePostBeefResultsByTxid(txids, vreqs, pbrs);\n    await updateReqsFromAggregateResults(txids, r, apbrs, storage, services, trx);\n    return r;\n}\nasync function validateReqsAndMergeBeefs(storage, reqs, trx) {\n    const r = {\n        status: 'success',\n        beef: new sdk_1.Beef(),\n        details: [],\n        log: ''\n    };\n    const vreqs = [];\n    for (const req of reqs) {\n        try {\n            const noRawTx = !req.rawTx;\n            const noTxIds = !req.notify.transactionIds || req.notify.transactionIds.length < 1;\n            const noInputBEEF = !req.inputBEEF;\n            if (noRawTx || noTxIds || noInputBEEF) {\n                // This should have happened earlier...\n                req.addHistoryNote({ when: new Date().toISOString(), what: 'validateReqFailed', noRawTx, noTxIds, noInputBEEF });\n                req.status = 'invalid';\n                await req.updateStorageDynamicProperties(storage, trx);\n                r.details.push({ txid: req.txid, req, status: 'invalid' });\n            }\n            else {\n                const vreq = { txid: req.txid, req, status: 'unknown' };\n                await storage.mergeReqToBeefToShareExternally(req.api, r.beef, [], trx);\n                vreqs.push(vreq);\n                r.details.push(vreq);\n            }\n        }\n        catch (eu) {\n            const { code, message } = sdk.WalletError.fromUnknown(eu);\n            req.addHistoryNote({ when: new Date().toISOString(), what: 'validateReqError', txid: req.txid, code, message });\n            req.attempts++;\n            if (req.attempts > 6) {\n                req.status = 'invalid';\n                r.details.push({ txid: req.txid, req, status: 'invalid' });\n            }\n            await req.updateStorageDynamicProperties(storage, trx);\n        }\n    }\n    return { r, vreqs, txids: vreqs.map(r => r.txid) };\n}\nasync function transferNotesToReqHistories(txids, vreqs, pbrs, storage, trx) {\n    for (const txid of txids) {\n        const vreq = vreqs.find(r => r.txid === txid);\n        if (!vreq)\n            throw new sdk.WERR_INTERNAL();\n        const notes = [];\n        for (const pbr of pbrs) {\n            notes.push(...(pbr.notes || []));\n            const r = pbr.txidResults.find(tr => tr.txid === txid);\n            if (r)\n                notes.push(...(r.notes || []));\n        }\n        for (const n of notes) {\n            vreq.req.addHistoryNote(n);\n        }\n        await vreq.req.updateStorageDynamicProperties(storage, trx);\n    }\n}\n/**\n * For each txid, decide on the aggregate success or failure of attempting to broadcast it to the bitcoin processing network.\n *\n * Possible results:\n * 1. Success: At least one success, no double spends.\n * 2. DoubleSpend: One or more double spends.\n * 3. InvalidTransaction: No success, no double spend, one or more non-exception errors.\n * 4. Service Failure: No results or all results are exception errors.\n *\n * @param txids\n * @param reqs\n * @param pbrs\n * @param storage\n * @returns\n */\nfunction aggregatePostBeefResultsByTxid(txids, vreqs, pbrs) {\n    const r = {};\n    for (const txid of txids) {\n        const vreq = vreqs.find(r => r.txid === txid);\n        const ar = {\n            txid,\n            vreq,\n            txidResults: [],\n            status: 'success',\n            successCount: 0,\n            doubleSpendCount: 0,\n            statusErrorCount: 0,\n            serviceErrorCount: 0,\n            competingTxs: []\n        };\n        r[txid] = ar;\n        for (const pbr of pbrs) {\n            const tr = pbr.txidResults.find(tr => tr.txid === txid);\n            if (tr) {\n                ar.txidResults.push(tr);\n                if (tr.status === 'success')\n                    ar.successCount++;\n                else if (tr.doubleSpend) {\n                    ar.doubleSpendCount++;\n                    if (tr.competingTxs) {\n                        ar.competingTxs = [...tr.competingTxs];\n                    }\n                }\n                else if (tr.serviceError)\n                    ar.serviceErrorCount++;\n                else\n                    ar.statusErrorCount++;\n            }\n            if (ar.competingTxs.length > 1)\n                ar.competingTxs = [...new Set(ar.competingTxs)]; // Remove duplicates\n        }\n        if (ar.successCount > 0 && ar.doubleSpendCount === 0)\n            ar.status = 'success';\n        else if (ar.doubleSpendCount > 0)\n            ar.status = 'doubleSpend';\n        else if (ar.statusErrorCount > 0)\n            ar.status = 'invalidTx';\n        else\n            ar.status = 'serviceError';\n    }\n    return r;\n}\n/**\n * For each txid in submitted `txids`:\n *\n *   Based on its aggregate status, and whether broadcast happening in background (isDelayed) or immediately (!isDelayed),\n *   and iff current req.status is not 'unproven' or 'completed':\n *\n *     'success':\n *       req.status => 'unmined', tx.status => 'unproven'\n *     'doubleSpend':\n *       req.status => 'doubleSpend', tx.status => 'failed'\n *     'invalidTx':\n *       req.status => 'invalid', tx.status => 'failed'\n *     'serviceError':\n *       increment req.attempts\n *\n * @param txids\n * @param apbrs\n * @param storage\n * @param services if valid, doubleSpend results will be verified (but only if not within a trx. e.g. trx must be undefined)\n * @param trx\n */\nasync function updateReqsFromAggregateResults(txids, r, apbrs, storage, services, trx) {\n    for (const txid of txids) {\n        const ar = apbrs[txid];\n        const req = ar.vreq.req;\n        await req.refreshFromStorage(storage, trx);\n        const { successCount, doubleSpendCount, statusErrorCount, serviceErrorCount } = ar;\n        const note = {\n            when: new Date().toISOString(),\n            what: 'aggregateResults',\n            reqStatus: req.status,\n            aggStatus: ar.status,\n            attempts: req.attempts,\n            successCount,\n            doubleSpendCount,\n            statusErrorCount,\n            serviceErrorCount\n        };\n        if (['completed', 'unmined'].indexOf(req.status) >= 0)\n            // However it happened, don't degrade status if it is somehow already beyond broadcast stage\n            continue;\n        if (ar.status === 'doubleSpend' && services && !trx)\n            await confirmDoubleSpend(ar, r.beef, storage, services);\n        let newReqStatus = undefined;\n        let newTxStatus = undefined;\n        switch (ar.status) {\n            case 'success':\n                newReqStatus = 'unmined';\n                newTxStatus = 'unproven';\n                break;\n            case 'doubleSpend':\n                newReqStatus = 'doubleSpend';\n                newTxStatus = 'failed';\n                break;\n            case 'invalidTx':\n                newReqStatus = 'invalid';\n                newTxStatus = 'failed';\n                break;\n            case 'serviceError':\n                newReqStatus = 'sending';\n                newTxStatus = 'sending';\n                req.attempts++;\n                break;\n            default:\n                throw new sdk.WERR_INTERNAL(`unimplemented AggregateStatus ${ar.status}`);\n        }\n        note.newReqStatus = newReqStatus;\n        note.newTxStatus = newTxStatus;\n        note.newAttempts = req.attempts;\n        if (newReqStatus)\n            req.status = newReqStatus;\n        req.addHistoryNote(note);\n        await req.updateStorageDynamicProperties(storage, trx);\n        if (newTxStatus) {\n            const ids = req.notify.transactionIds;\n            if (ids) {\n                // Also set generated outputs to spendable false and consumed input outputs to spendable true (and clears their spentBy).\n                await storage.updateTransactionsStatus(ids, newTxStatus, trx);\n            }\n        }\n        // Transfer critical results to details going back to the user\n        const details = r.details.find(d => d.txid === txid);\n        details.status = ar.status;\n        details.competingTxs = ar.competingTxs;\n    }\n}\n/**\n * Requires ar.status === 'doubleSpend'\n *\n * Parse the rawTx and review each input as a possible double spend.\n *\n * If all inputs appear to be unspent, update aggregate status to 'success' if successCount > 0, otherwise 'serviceError'.\n *\n * @param ar\n * @param storage\n * @param services\n */\nasync function confirmDoubleSpend(ar, beef, storage, services) {\n    var _a, _b;\n    const req = ar.vreq.req;\n    const note = { when: new Date().toISOString(), what: 'confirmDoubleSpend' };\n    let known = false;\n    for (let retry = 0; retry < 3; retry++) {\n        const gsr = await services.getStatusForTxids([req.txid]);\n        note[`getStatus${retry}`] = `${gsr.status}${gsr.error ? `${gsr.error.code}` : ''},${(_a = gsr.results[0]) === null || _a === void 0 ? void 0 : _a.status}`;\n        if (gsr.status === 'success' && gsr.results[0].status !== 'unknown') {\n            known = true;\n            break;\n        }\n        else {\n            await (0, utilityHelpers_1.wait)(1000);\n        }\n    }\n    if (known) {\n        // doubleSpend -> success\n        ar.status = 'success';\n        note.newStatus = ar.status;\n    }\n    else {\n        // Confirmed double spend, get txids of possible competing transactions.\n        const tx = sdk_1.Transaction.fromBinary(req.rawTx);\n        const competingTxids = new Set(ar.competingTxs);\n        for (const input of tx.inputs) {\n            const sourceTx = (_b = beef.findTxid(input.sourceTXID)) === null || _b === void 0 ? void 0 : _b.tx;\n            if (!sourceTx)\n                throw new sdk.WERR_INTERNAL(`beef lacks tx for ${input.sourceTXID}`);\n            const lockingScript = sourceTx.outputs[input.sourceOutputIndex].lockingScript.toHex();\n            const hash = services.hashOutputScript(lockingScript);\n            const shhrs = await services.getScriptHashHistory(hash);\n            if (shhrs.status === 'success') {\n                for (const h of shhrs.history) {\n                    // Neither the source of the input nor the current transaction are competition.\n                    if (h.txid !== input.sourceTXID && h.txid !== ar.txid)\n                        competingTxids.add(h.txid);\n                }\n            }\n        }\n        ar.competingTxs = [...competingTxids].slice(-24); // keep at most 24, if they were sorted by time, keep newest\n        note.competingTxs = ar.competingTxs.join(',');\n    }\n    req.addHistoryNote(note);\n}\n//# sourceMappingURL=attemptToPostReqsToNetwork.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/attemptToPostReqsToNetwork.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/createAction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/createAction.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.setDisableDoubleSpendCheckForTest = setDisableDoubleSpendCheckForTest;\nexports.createAction = createAction;\nexports.offsetPubKey = offsetPubKey;\nexports.lockScriptWithKeyOffsetFromPubKey = lockScriptWithKeyOffsetFromPubKey;\nexports.createStorageServiceChargeScript = createStorageServiceChargeScript;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst generateChange_1 = __webpack_require__(/*! ./generateChange */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/generateChange.js\");\nlet disableDoubleSpendCheckForTest = true;\nfunction setDisableDoubleSpendCheckForTest(v) {\n    disableDoubleSpendCheckForTest = v;\n}\nasync function createAction(storage, auth, vargs, originator) {\n    //stampLog(vargs, `start storage createTransactionSdk`)\n    if (!vargs.isNewTx)\n        // The purpose of this function is to create the initial storage records associated\n        // with a new transaction. It's an error if we have no new inputs or outputs...\n        throw new index_client_1.sdk.WERR_INTERNAL();\n    /**\n     * Steps to create a transaction:\n     * - Verify that all inputs either have proof in vargs.inputBEEF or that options.trustSelf === 'known' and input txid.vout are known valid to storage.\n     * - Create a new transaction record with status 'unsigned' as the anchor for construction work and to new outputs.\n     * - Create all transaction labels.\n     * - Add new commission output\n     * - Attempt to fund the transaction by allocating change outputs:\n     *    - As each change output is selected it is simultaneously locked.\n     * - Create all new output, basket, tag records\n     * - If requested, create result Beef with complete proofs for all inputs used\n     * - Create result inputs with source locking scripts\n     * - Create result outputs with new locking scripts.\n     * - Create and return result.\n     */\n    const userId = auth.userId;\n    const { storageBeef, beef, xinputs } = await validateRequiredInputs(storage, userId, vargs);\n    const xoutputs = validateRequiredOutputs(storage, userId, vargs);\n    const changeBasketName = 'default';\n    const changeBasket = (0, index_client_1.verifyOne)(await storage.findOutputBaskets({\n        partial: { userId, name: changeBasketName }\n    }), `Invalid outputGeneration basket \"${changeBasketName}\"`);\n    const noSendChangeIn = await validateNoSendChange(storage, userId, vargs, changeBasket);\n    const availableChangeCount = await storage.countChangeInputs(userId, changeBasket.basketId, !vargs.isDelayed);\n    const feeModel = (0, index_client_1.validateStorageFeeModel)(storage.feeModel);\n    const newTx = await createNewTxRecord(storage, userId, vargs, storageBeef);\n    const ctx = {\n        xinputs,\n        xoutputs,\n        changeBasket,\n        noSendChangeIn,\n        availableChangeCount,\n        feeModel,\n        transactionId: newTx.transactionId\n    };\n    const { allocatedChange, changeOutputs, derivationPrefix, maxPossibleSatoshisAdjustment } = await fundNewTransactionSdk(storage, userId, vargs, ctx);\n    if (maxPossibleSatoshisAdjustment) {\n        const a = maxPossibleSatoshisAdjustment;\n        if (ctx.xoutputs[a.fixedOutputIndex].satoshis !== generateChange_1.maxPossibleSatoshis)\n            throw new index_client_1.sdk.WERR_INTERNAL();\n        ctx.xoutputs[a.fixedOutputIndex].satoshis = a.satoshis;\n    }\n    // The satoshis of the transaction is the satoshis we get back in change minus the satoshis we spend.\n    const satoshis = changeOutputs.reduce((a, e) => a + e.satoshis, 0) - allocatedChange.reduce((a, e) => a + e.satoshis, 0);\n    await storage.updateTransaction(newTx.transactionId, { satoshis });\n    const { outputs, changeVouts } = await createNewOutputs(storage, userId, vargs, ctx, changeOutputs);\n    const inputBeef = await mergeAllocatedChangeBeefs(storage, userId, vargs, allocatedChange, beef);\n    const inputs = await createNewInputs(storage, userId, vargs, ctx, allocatedChange);\n    const r = {\n        reference: newTx.reference,\n        version: newTx.version,\n        lockTime: newTx.lockTime,\n        inputs,\n        outputs,\n        derivationPrefix,\n        inputBeef,\n        noSendChangeOutputVouts: vargs.isNoSend ? changeVouts : undefined\n    };\n    //stampLog(vargs, `end storage createTransactionSdk`)\n    return r;\n}\nfunction makeDefaultOutput(userId, transactionId, satoshis, vout) {\n    const now = new Date();\n    const output = {\n        created_at: now,\n        updated_at: now,\n        outputId: 0,\n        userId,\n        transactionId,\n        satoshis: satoshis,\n        vout,\n        basketId: undefined,\n        change: false,\n        customInstructions: undefined,\n        derivationPrefix: undefined,\n        derivationSuffix: undefined,\n        outputDescription: '',\n        lockingScript: undefined,\n        providedBy: 'you',\n        purpose: '',\n        senderIdentityKey: undefined,\n        spendable: true,\n        spendingDescription: undefined,\n        spentBy: undefined,\n        txid: undefined,\n        type: ''\n    };\n    return output;\n}\nasync function createNewInputs(storage, userId, vargs, ctx, allocatedChange) {\n    const r = [];\n    const newInputs = [];\n    for (const i of ctx.xinputs) {\n        const o = i.output;\n        newInputs.push({ i, o });\n        if (o) {\n            await storage.transaction(async (trx) => {\n                const o2 = (0, index_client_1.verifyOne)(await storage.findOutputs({ partial: { outputId: o.outputId }, trx }));\n                if (o2.spendable != true || o2.spentBy !== undefined)\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`inputs[${i.vin}]`, `spendable output. output ${o.txid}:${o.vout} appears to have been spent.`);\n                await storage.updateOutput(o.outputId, {\n                    spendable: false,\n                    spentBy: ctx.transactionId,\n                    spendingDescription: i.inputDescription\n                }, trx);\n            });\n        }\n    }\n    for (const o of allocatedChange) {\n        newInputs.push({ o, unlockLen: 107 });\n    }\n    let vin = -1;\n    for (const { i, o, unlockLen } of newInputs) {\n        vin++;\n        if (o) {\n            if (!i && !unlockLen)\n                throw new index_client_1.sdk.WERR_INTERNAL(`vin ${vin} non-fixedInput without unlockLen`);\n            const sourceTransaction = vargs.includeAllSourceTransactions && vargs.isSignAction\n                ? await storage.getRawTxOfKnownValidTransaction(o.txid)\n                : undefined;\n            const ri = {\n                vin,\n                sourceTxid: o.txid,\n                sourceVout: o.vout,\n                sourceSatoshis: o.satoshis,\n                sourceLockingScript: (0, index_client_1.asString)(o.lockingScript),\n                sourceTransaction,\n                unlockingScriptLength: unlockLen ? unlockLen : i.unlockingScriptLength,\n                providedBy: i && o.providedBy === 'storage' ? 'you-and-storage' : o.providedBy,\n                type: o.type,\n                spendingDescription: o.spendingDescription || undefined,\n                derivationPrefix: o.derivationPrefix || undefined,\n                derivationSuffix: o.derivationSuffix || undefined,\n                senderIdentityKey: o.senderIdentityKey || undefined\n            };\n            r.push(ri);\n        }\n        else {\n            if (!i)\n                throw new index_client_1.sdk.WERR_INTERNAL(`vin ${vin} without output or xinput`);\n            // user specified input with no corresponding output being spent.\n            const ri = {\n                vin,\n                sourceTxid: i.outpoint.txid,\n                sourceVout: i.outpoint.vout,\n                sourceSatoshis: i.satoshis,\n                sourceLockingScript: i.lockingScript.toHex(),\n                unlockingScriptLength: i.unlockingScriptLength,\n                providedBy: 'you',\n                type: 'custom',\n                spendingDescription: undefined,\n                derivationPrefix: undefined,\n                derivationSuffix: undefined,\n                senderIdentityKey: undefined\n            };\n            r.push(ri);\n        }\n    }\n    return r;\n}\nasync function createNewOutputs(storage, userId, vargs, ctx, changeOutputs) {\n    var _a;\n    const outputs = [];\n    // Lookup output baskets\n    const txBaskets = {};\n    for (const xo of ctx.xoutputs) {\n        if (xo.basket !== undefined && !txBaskets[xo.basket])\n            txBaskets[xo.basket] = await storage.findOrInsertOutputBasket(userId, xo.basket);\n    }\n    // Lookup output tags\n    const txTags = {};\n    for (const xo of ctx.xoutputs) {\n        for (const tag of xo.tags) {\n            txTags[tag] = await storage.findOrInsertOutputTag(userId, tag);\n        }\n    }\n    const newOutputs = [];\n    for (const xo of ctx.xoutputs) {\n        const lockingScript = (0, index_client_1.asArray)(xo.lockingScript);\n        if (xo.purpose === 'service-charge') {\n            const now = new Date();\n            await storage.insertCommission({\n                userId,\n                transactionId: ctx.transactionId,\n                lockingScript,\n                satoshis: xo.satoshis,\n                isRedeemed: false,\n                keyOffset: (0, index_client_1.verifyTruthy)(xo.keyOffset),\n                created_at: now,\n                updated_at: now,\n                commissionId: 0\n            });\n            const o = makeDefaultOutput(userId, ctx.transactionId, xo.satoshis, xo.vout);\n            o.lockingScript = lockingScript;\n            o.providedBy = 'storage';\n            o.purpose = 'storage-commission';\n            o.type = 'custom';\n            o.spendable = false;\n            newOutputs.push({ o, tags: [] });\n        }\n        else {\n            // The user wants tracking if they put their output in a basket\n            const basketId = !xo.basket ? undefined : txBaskets[xo.basket].basketId;\n            const o = makeDefaultOutput(userId, ctx.transactionId, xo.satoshis, xo.vout);\n            o.lockingScript = lockingScript;\n            o.basketId = basketId;\n            o.customInstructions = xo.customInstructions;\n            o.outputDescription = xo.outputDescription;\n            o.providedBy = xo.providedBy;\n            o.purpose = xo.purpose || '';\n            o.type = 'custom';\n            newOutputs.push({ o, tags: xo.tags });\n        }\n    }\n    for (const o of changeOutputs) {\n        o.spendable = true;\n        newOutputs.push({ o, tags: [] });\n    }\n    if (vargs.options.randomizeOutputs) {\n        const randomVals = [];\n        const nextRandomVal = () => {\n            let val = 0;\n            if (!randomVals || randomVals.length === 0) {\n                val = Math.random();\n            }\n            else {\n                val = randomVals.shift() || 0;\n                randomVals.push(val);\n            }\n            return val;\n        };\n        /** In-place array shuffle */\n        const shuffleArray = (array) => {\n            let currentIndex = array.length;\n            let temporaryValue;\n            let randomIndex;\n            while (currentIndex !== 0) {\n                randomIndex = Math.floor(nextRandomVal() * currentIndex);\n                currentIndex -= 1;\n                temporaryValue = array[currentIndex];\n                array[currentIndex] = array[randomIndex];\n                array[randomIndex] = temporaryValue;\n            }\n            return array;\n        };\n        let vout = -1;\n        const newVouts = Array(newOutputs.length);\n        for (let i = 0; i < newVouts.length; i++)\n            newVouts[i] = i;\n        shuffleArray(newVouts);\n        for (const no of newOutputs) {\n            vout++;\n            if (no.o.vout !== vout)\n                throw new index_client_1.sdk.WERR_INTERNAL(`new output ${vout} has out of order vout ${no.o.vout}`);\n            no.o.vout = newVouts[vout];\n        }\n    }\n    const changeVouts = [];\n    for (const { o, tags } of newOutputs) {\n        o.outputId = await storage.insertOutput(o);\n        if (o.change && o.purpose === 'change' && o.providedBy === 'storage')\n            changeVouts.push(o.vout);\n        // Add tags to the output\n        for (const tagName of tags) {\n            const tag = txTags[tagName];\n            await storage.findOrInsertOutputTagMap((0, index_client_1.verifyId)(o.outputId), (0, index_client_1.verifyId)(tag.outputTagId));\n        }\n        const ro = {\n            vout: (0, index_client_1.verifyInteger)(o.vout),\n            satoshis: (0, index_client_1.verifyTruthy)(o.satoshis),\n            lockingScript: !o.lockingScript ? '' : (0, index_client_1.asString)(o.lockingScript),\n            providedBy: (0, index_client_1.verifyTruthy)(o.providedBy),\n            purpose: o.purpose || undefined,\n            basket: (_a = Object.values(txBaskets).find(b => b.basketId === o.basketId)) === null || _a === void 0 ? void 0 : _a.name,\n            tags: tags,\n            outputDescription: o.outputDescription,\n            derivationSuffix: o.derivationSuffix,\n            customInstructions: o.customInstructions\n        };\n        outputs.push(ro);\n    }\n    return { outputs, changeVouts };\n}\nasync function createNewTxRecord(storage, userId, vargs, storageBeef) {\n    const now = new Date();\n    const newTx = {\n        created_at: now,\n        updated_at: now,\n        transactionId: 0,\n        version: vargs.version,\n        lockTime: vargs.lockTime,\n        status: 'unsigned',\n        reference: (0, index_client_1.randomBytesBase64)(12),\n        satoshis: 0, // updated after fundingTransaction\n        userId,\n        isOutgoing: true,\n        inputBEEF: storageBeef.toBinary(),\n        description: vargs.description,\n        txid: undefined,\n        rawTx: undefined\n    };\n    newTx.transactionId = await storage.insertTransaction(newTx);\n    for (const label of vargs.labels) {\n        const txLabel = await storage.findOrInsertTxLabel(userId, label);\n        await storage.findOrInsertTxLabelMap((0, index_client_1.verifyId)(newTx.transactionId), (0, index_client_1.verifyId)(txLabel.txLabelId));\n    }\n    return newTx;\n}\n/**\n * Convert vargs.outputs:\n *\n * lockingScript: HexString\n * satoshis: SatoshiValue\n * outputDescription: DescriptionString5to50Bytes\n * basket?: BasketStringUnder300Bytes\n * customInstructions?: string\n * tags: BasketStringUnderBytes[]\n *\n * to XValidCreateActionOutput (which aims for sdk.StorageCreateTransactionSdkOutput)\n *\n * adds:\n *   vout: number\n *   providedBy: sdk.StorageProvidedBy\n *   purpose?: string\n *   derivationSuffix?: string\n *   keyOffset?: string\n *\n * @param vargs\n * @returns xoutputs\n */\nfunction validateRequiredOutputs(storage, userId, vargs) {\n    const xoutputs = [];\n    let vout = -1;\n    for (const output of vargs.outputs) {\n        vout++;\n        const xo = {\n            ...output,\n            vout,\n            providedBy: 'you',\n            purpose: undefined,\n            derivationSuffix: undefined,\n            keyOffset: undefined\n        };\n        xoutputs.push(xo);\n    }\n    if (storage.commissionSatoshis > 0 && storage.commissionPubKeyHex) {\n        vout++;\n        const { script, keyOffset } = createStorageServiceChargeScript(storage.commissionPubKeyHex);\n        xoutputs.push({\n            lockingScript: script,\n            satoshis: storage.commissionSatoshis,\n            outputDescription: 'Storage Service Charge',\n            basket: undefined,\n            tags: [],\n            vout,\n            providedBy: 'storage',\n            purpose: 'service-charge',\n            keyOffset\n        });\n    }\n    return xoutputs;\n}\n/**\n * Verify that we are in posession of validity proof data for any inputs being proposed for a new transaction.\n *\n * `vargs.inputs` is the source of inputs.\n * `vargs.inputBEEF` may include new user supplied validity data.\n * 'vargs.options.trustSelf === 'known'` indicates whether we can rely on the storage database records.\n *\n * If there are no inputs, returns an empty `Beef`.\n *\n * Always pulls rawTx data into first level of validity chains so that parsed transaction data is available\n * and checks input sourceSatoshis as well as filling in input sourceLockingScript.\n *\n * This data may be pruned again before being returned to the user based on `vargs.options.knownTxids`.\n *\n * @param storage\n * @param userId\n * @param vargs\n * @returns {storageBeef} containing only validity proof data for only unknown required inputs.\n * @returns {beef} containing verified validity proof data for all required inputs.\n * @returns {xinputs} extended validated required inputs.\n */\nasync function validateRequiredInputs(storage, userId, vargs) {\n    //stampLog(vargs, `start storage verifyInputBeef`)\n    const beef = new sdk_1.Beef();\n    if (vargs.inputs.length === 0)\n        return { storageBeef: beef, beef, xinputs: [] };\n    if (vargs.inputBEEF)\n        beef.mergeBeef(vargs.inputBEEF);\n    const xinputs = vargs.inputs.map((input, vin) => ({\n        ...input,\n        vin,\n        satoshis: -1,\n        lockingScript: new sdk_1.Script(),\n        output: undefined\n    }));\n    const trustSelf = vargs.options.trustSelf === 'known';\n    const inputTxids = {};\n    for (const input of xinputs)\n        inputTxids[input.outpoint.txid] = true;\n    // Check beef from user that either there are no txidOnly entries,\n    // or that we can trust storage data and it does indeed vouch\n    // for any txidOnly entries\n    for (const btx of beef.txs) {\n        if (btx.isTxidOnly) {\n            if (!trustSelf)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('inputBEEF', `valid and contain complete proof data for ${btx.txid}`);\n            if (!inputTxids[btx.txid]) {\n                // inputTxids are checked next\n                const isKnown = await storage.verifyKnownValidTransaction(btx.txid);\n                if (!isKnown)\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('inputBEEF', `valid and contain complete proof data for unknown ${btx.txid}`);\n            }\n        }\n    }\n    // Make sure that there's an entry for all inputs txid values:\n    for (const txid of Object.keys(inputTxids)) {\n        let btx = beef.findTxid(txid);\n        if (!btx && trustSelf) {\n            if (await storage.verifyKnownValidTransaction(txid))\n                btx = beef.mergeTxidOnly(txid);\n        }\n        if (!btx)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('inputBEEF', `valid and contain proof data for possibly known ${txid}`);\n    }\n    if (!(await beef.verify(await storage.getServices().getChainTracker(), true))) {\n        console.log(`verifyInputBeef failed, inputBEEF failed to verify.\\n${beef.toLogString()}\\n`);\n        //console.log(`verifyInputBeef failed, inputBEEF failed to verify.\\n${stampLogFormat(vargs.log)}\\n${beef.toLogString()}\\n`)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('inputBEEF', 'valid Beef when factoring options.trustSelf');\n    }\n    // beef may now be trusted and has a BeefTx for every input txid.\n    const storageBeef = beef.clone();\n    for (const input of xinputs) {\n        const { txid, vout } = input.outpoint;\n        const output = (0, index_client_1.verifyOneOrNone)(await storage.findOutputs({ partial: { userId, txid, vout } }));\n        if (output) {\n            if (output.change) {\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`inputs[${input.vin}]`, 'an unmanaged input. Change outputs are managed by your wallet.');\n            }\n            input.output = output;\n            if (!Array.isArray(output.lockingScript) || !Number.isInteger(output.satoshis))\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`${txid}.${vout}`, 'output with valid lockingScript and satoshis');\n            if (!disableDoubleSpendCheckForTest && !output.spendable && !vargs.isNoSend)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`${txid}.${vout}`, 'spendable output unless noSend is true');\n            // input is spending an existing user output which has an lockingScript\n            input.satoshis = (0, index_client_1.verifyNumber)(output.satoshis);\n            input.lockingScript = sdk_1.Script.fromBinary((0, index_client_1.asArray)(output.lockingScript));\n        }\n        else {\n            let btx = beef.findTxid(txid);\n            if (btx.isTxidOnly) {\n                const { rawTx, proven } = await storage.getProvenOrRawTx(txid);\n                //stampLog(vargs, `... storage verifyInputBeef getProvenOrRawTx ${txid} ${proven ? 'proven' : rawTx ? 'rawTx' : 'unknown'}`)\n                if (!rawTx)\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('inputBEEF', `valid and contain proof data for ${txid}`);\n                btx = beef.mergeRawTx((0, index_client_1.asArray)(rawTx));\n                if (proven)\n                    beef.mergeBump(new index_client_1.EntityProvenTx(proven).getMerklePath());\n            }\n            // btx is valid has parsed transaction data.\n            if (vout >= btx.tx.outputs.length)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`${txid}.${vout}`, 'valid outpoint');\n            const so = btx.tx.outputs[vout];\n            input.satoshis = (0, index_client_1.verifyTruthy)(so.satoshis);\n            input.lockingScript = so.lockingScript;\n        }\n    }\n    return { beef, storageBeef, xinputs };\n}\nasync function validateNoSendChange(storage, userId, vargs, changeBasket) {\n    const r = [];\n    if (!vargs.isNoSend)\n        return [];\n    const noSendChange = vargs.options.noSendChange;\n    if (noSendChange && noSendChange.length > 0) {\n        for (const op of noSendChange) {\n            const output = (0, index_client_1.verifyOneOrNone)(await storage.findOutputs({\n                partial: { userId, txid: op.txid, vout: op.vout }\n            }));\n            // noSendChange is not marked spendable until sent, may not already be spent, and must have a valid greater than zero satoshis\n            if (!output ||\n                output.providedBy !== 'storage' ||\n                output.purpose !== 'change' ||\n                output.spendable === false ||\n                Number.isInteger(output.spentBy) ||\n                !(0, index_client_1.verifyNumber)(output.satoshis) ||\n                output.basketId !== changeBasket.basketId)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('noSendChange outpoint', 'valid');\n            if (-1 < r.findIndex(o => o.outputId === output.outputId))\n                // noSendChange duplicate OutPoints are not allowed.\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('noSendChange outpoint', 'unique. Duplicates are not allowed.');\n            r.push(output);\n        }\n    }\n    return r;\n}\nasync function fundNewTransactionSdk(storage, userId, vargs, ctx) {\n    const params = {\n        fixedInputs: ctx.xinputs.map(xi => ({\n            satoshis: xi.satoshis,\n            unlockingScriptLength: xi.unlockingScriptLength\n        })),\n        fixedOutputs: ctx.xoutputs.map(xo => ({\n            satoshis: xo.satoshis,\n            lockingScriptLength: xo.lockingScript.length / 2\n        })),\n        feeModel: ctx.feeModel,\n        changeInitialSatoshis: ctx.changeBasket.minimumDesiredUTXOValue,\n        changeFirstSatoshis: Math.max(1, Math.round(ctx.changeBasket.minimumDesiredUTXOValue / 4)),\n        changeLockingScriptLength: 25,\n        changeUnlockingScriptLength: 107,\n        targetNetCount: ctx.changeBasket.numberOfDesiredUTXOs - ctx.availableChangeCount,\n        randomVals: vargs.randomVals\n    };\n    const noSendChange = [...ctx.noSendChangeIn];\n    const outputs = {};\n    const allocateChangeInput = async (targetSatoshis, exactSatoshis) => {\n        // noSendChange gets allocated first...typically only one input...just allocate in order...\n        if (noSendChange.length > 0) {\n            const o = noSendChange.pop();\n            outputs[o.outputId] = o;\n            // allocate the output in storage, noSendChange is by definition spendable false and part of noSpend transaction batch.\n            await storage.updateOutput(o.outputId, {\n                spendable: false,\n                spentBy: ctx.transactionId\n            });\n            o.spendable = false;\n            o.spentBy = ctx.transactionId;\n            const r = {\n                outputId: o.outputId,\n                satoshis: o.satoshis\n            };\n            return r;\n        }\n        const basketId = ctx.changeBasket.basketId;\n        const o = await storage.allocateChangeInput(userId, basketId, targetSatoshis, exactSatoshis, !vargs.isDelayed, ctx.transactionId);\n        if (!o)\n            return undefined;\n        outputs[o.outputId] = o;\n        const r = {\n            outputId: o.outputId,\n            satoshis: o.satoshis\n        };\n        return r;\n    };\n    const releaseChangeInput = async (outputId) => {\n        const nsco = ctx.noSendChangeIn.find(o => o.outputId === outputId);\n        if (nsco) {\n            noSendChange.push(nsco);\n            return;\n        }\n        await storage.updateOutput(outputId, {\n            spendable: true,\n            spentBy: undefined\n        });\n    };\n    const gcr = await (0, generateChange_1.generateChangeSdk)(params, allocateChangeInput, releaseChangeInput);\n    const nextRandomVal = () => {\n        let val = 0;\n        if (!vargs.randomVals || vargs.randomVals.length === 0) {\n            val = Math.random();\n        }\n        else {\n            val = vargs.randomVals.shift() || 0;\n            vargs.randomVals.push(val);\n        }\n        return val;\n    };\n    /**\n     * @returns a random integer betweenn min and max, inclussive.\n     */\n    const rand = (min, max) => {\n        if (max < min)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('max', `less than min (${min}). max is (${max})`);\n        return Math.floor(nextRandomVal() * (max - min + 1) + min);\n    };\n    const randomDerivation = (count) => {\n        let val = [];\n        if (!vargs.randomVals || vargs.randomVals.length === 0) {\n            val = (0, sdk_1.Random)(count);\n        }\n        else {\n            for (let i = 0; i < count; i++)\n                val.push(rand(0, 255));\n        }\n        return sdk_1.Utils.toBase64(val);\n    };\n    // Generate a derivation prefix for the payment\n    const derivationPrefix = randomDerivation(16);\n    const r = {\n        maxPossibleSatoshisAdjustment: gcr.maxPossibleSatoshisAdjustment,\n        allocatedChange: gcr.allocatedChangeInputs.map(i => outputs[i.outputId]),\n        changeOutputs: gcr.changeOutputs.map((o, i) => ({\n            // what we knnow now and can insert into the database for this new transaction's change output\n            created_at: new Date(),\n            updated_at: new Date(),\n            outputId: 0,\n            userId,\n            transactionId: ctx.transactionId,\n            vout: params.fixedOutputs.length + i,\n            satoshis: o.satoshis,\n            basketId: ctx.changeBasket.basketId,\n            spendable: false,\n            change: true,\n            type: 'P2PKH',\n            derivationPrefix,\n            derivationSuffix: randomDerivation(16),\n            providedBy: 'storage',\n            purpose: 'change',\n            customInstructions: undefined,\n            senderIdentityKey: undefined,\n            outputDescription: '',\n            // what will be known when transaction is signed\n            txid: undefined,\n            lockingScript: undefined,\n            // when this output gets spent\n            spentBy: undefined,\n            spendingDescription: undefined\n        })),\n        derivationPrefix\n    };\n    return r;\n}\n/**\n * Avoid returning any known raw transaction data by converting any known transaction\n * in the `beef` to txidOnly.\n * @returns undefined if `vargs.options.returnTXIDOnly` or trimmed `Beef`\n */\nfunction trimInputBeef(beef, vargs) {\n    if (vargs.options.returnTXIDOnly)\n        return undefined;\n    const knownTxids = {};\n    for (const txid of vargs.options.knownTxids)\n        knownTxids[txid] = true;\n    for (const txid of beef.txs.map(btx => btx.txid))\n        if (knownTxids[txid])\n            beef.makeTxidOnly(txid);\n    return beef.toBinary();\n}\nasync function mergeAllocatedChangeBeefs(storage, userId, vargs, allocatedChange, beef) {\n    const options = {\n        trustSelf: undefined,\n        knownTxids: vargs.options.knownTxids,\n        mergeToBeef: beef,\n        ignoreStorage: false,\n        ignoreServices: true,\n        ignoreNewProven: false,\n        minProofLevel: undefined\n    };\n    if (vargs.options.returnTXIDOnly)\n        return undefined;\n    for (const o of allocatedChange) {\n        if (!beef.findTxid(o.txid) && !vargs.options.knownTxids.find(txid => txid === o.txid)) {\n            await storage.getBeefForTransaction(o.txid, options);\n        }\n    }\n    return trimInputBeef(beef, vargs);\n}\nfunction keyOffsetToHashedSecret(pub, keyOffset) {\n    let offset;\n    if (keyOffset !== undefined && typeof keyOffset === 'string') {\n        if (keyOffset.length === 64)\n            offset = sdk_1.PrivateKey.fromString(keyOffset, 'hex');\n        else\n            offset = sdk_1.PrivateKey.fromWif(keyOffset);\n    }\n    else {\n        offset = sdk_1.PrivateKey.fromRandom();\n        keyOffset = offset.toWif();\n    }\n    const sharedSecret = pub.mul(offset).encode(true, undefined);\n    const hashedSecret = (0, index_client_1.sha256Hash)(sharedSecret);\n    return { hashedSecret: new sdk_1.BigNumber(hashedSecret), keyOffset };\n}\nfunction offsetPubKey(pubKey, keyOffset) {\n    const pub = sdk_1.PublicKey.fromString(pubKey);\n    const r = keyOffsetToHashedSecret(pub, keyOffset);\n    // The hashed secret is multiplied by the generator point.\n    const point = new sdk_1.Curve().g.mul(r.hashedSecret);\n    // The resulting point is added to the recipient public key.\n    const offsetPubKey = new sdk_1.PublicKey(pub.add(point));\n    return { offsetPubKey: offsetPubKey.toString(), keyOffset: r.keyOffset };\n}\nfunction lockScriptWithKeyOffsetFromPubKey(pubKey, keyOffset) {\n    const r = offsetPubKey(pubKey, keyOffset);\n    const offsetPub = sdk_1.PublicKey.fromString(r.offsetPubKey);\n    const hash = offsetPub.toHash();\n    const script = new sdk_1.P2PKH().lock(hash).toHex();\n    return { script, keyOffset: r.keyOffset };\n}\nfunction createStorageServiceChargeScript(pubKeyHex) {\n    return lockScriptWithKeyOffsetFromPubKey(pubKeyHex);\n}\n//# sourceMappingURL=createAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/createAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/generateChange.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/generateChange.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.maxPossibleSatoshis = void 0;\nexports.generateChangeSdk = generateChangeSdk;\nexports.validateGenerateChangeSdkResult = validateGenerateChangeSdkResult;\nexports.validateGenerateChangeSdkParams = validateGenerateChangeSdkParams;\nexports.generateChangeSdkMakeStorage = generateChangeSdkMakeStorage;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/utils.js\");\n/**\n * An output of this satoshis amount will be adjusted to the largest fundable amount.\n */\nexports.maxPossibleSatoshis = 2099999999999999;\n/**\n * Simplifications:\n *  - only support one change type with fixed length scripts.\n *  - only support satsPerKb fee model.\n *\n * Confirms for each availbleChange output that it remains available as they are allocated and selects alternate if not.\n *\n * @param params\n * @returns\n */\nasync function generateChangeSdk(params, allocateChangeInput, releaseChangeInput) {\n    if (params.noLogging === false)\n        logGenerateChangeSdkParams(params);\n    const r = {\n        allocatedChangeInputs: [],\n        changeOutputs: [],\n        size: 0,\n        fee: 0,\n        satsPerKb: 0\n    };\n    // eslint-disable-next-line no-useless-catch\n    try {\n        const vgcpr = validateGenerateChangeSdkParams(params);\n        const satsPerKb = params.feeModel.value || 0;\n        const randomVals = [...(params.randomVals || [])];\n        const randomValsUsed = [];\n        const nextRandomVal = () => {\n            let val = 0;\n            if (!randomVals || randomVals.length === 0) {\n                val = Math.random();\n            }\n            else {\n                val = randomVals.shift() || 0;\n                randomVals.push(val);\n            }\n            // Capture random sequence used if not supplied\n            randomValsUsed.push(val);\n            return val;\n        };\n        /**\n         * @returns a random integer betweenn min and max, inclussive.\n         */\n        const rand = (min, max) => {\n            if (max < min)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('max', `less than min (${min}). max is (${max})`);\n            return Math.floor(nextRandomVal() * (max - min + 1) + min);\n        };\n        const fixedInputs = params.fixedInputs;\n        const fixedOutputs = params.fixedOutputs;\n        /**\n         * @returns sum of transaction fixedInputs satoshis and fundingInputs satoshis\n         */\n        const funding = () => {\n            return (fixedInputs.reduce((a, e) => a + e.satoshis, 0) + r.allocatedChangeInputs.reduce((a, e) => a + e.satoshis, 0));\n        };\n        /**\n         * @returns sum of transaction fixedOutputs satoshis\n         */\n        const spending = () => {\n            return fixedOutputs.reduce((a, e) => a + e.satoshis, 0);\n        };\n        /**\n         * @returns sum of transaction changeOutputs satoshis\n         */\n        const change = () => {\n            return r.changeOutputs.reduce((a, e) => a + e.satoshis, 0);\n        };\n        const fee = () => funding() - spending() - change();\n        const size = (addedChangeInputs, addedChangeOutputs) => {\n            const inputScriptLengths = [\n                ...fixedInputs.map(x => x.unlockingScriptLength),\n                ...Array(r.allocatedChangeInputs.length + (addedChangeInputs || 0)).fill(params.changeUnlockingScriptLength)\n            ];\n            const outputScriptLengths = [\n                ...fixedOutputs.map(x => x.lockingScriptLength),\n                ...Array(r.changeOutputs.length + (addedChangeOutputs || 0)).fill(params.changeLockingScriptLength)\n            ];\n            const size = (0, utils_1.transactionSize)(inputScriptLengths, outputScriptLengths);\n            return size;\n        };\n        /**\n         * @returns the target fee required for the transaction as currently configured under feeModel.\n         */\n        const feeTarget = (addedChangeInputs, addedChangeOutputs) => {\n            const fee = Math.ceil((size(addedChangeInputs, addedChangeOutputs) / 1000) * satsPerKb);\n            return fee;\n        };\n        /**\n         * @returns the current excess fee for the transaction as currently configured.\n         *\n         * This is funding() - spending() - change() - feeTarget()\n         *\n         * The goal is an excess fee of zero.\n         *\n         * A positive value is okay if the cost of an additional change output is greater.\n         *\n         * A negative value means the transaction is under funded, or over spends, and may be rejected.\n         */\n        const feeExcess = (addedChangeInputs, addedChangeOutputs) => {\n            const fe = funding() - spending() - change() - feeTarget(addedChangeInputs, addedChangeOutputs);\n            if (!addedChangeInputs && !addedChangeOutputs)\n                feeExcessNow = fe;\n            return fe;\n        };\n        // The most recent feeExcess()\n        let feeExcessNow = 0;\n        feeExcess();\n        const hasTargetNetCount = params.targetNetCount !== undefined;\n        const targetNetCount = params.targetNetCount || 0;\n        // current net change in count of change outputs\n        const netChangeCount = () => {\n            return r.changeOutputs.length - r.allocatedChangeInputs.length;\n        };\n        const addOutputToBalanceNewInput = () => {\n            if (!hasTargetNetCount)\n                return false;\n            return netChangeCount() - 1 < targetNetCount;\n        };\n        const releaseAllocatedChangeInputs = async () => {\n            while (r.allocatedChangeInputs.length > 0) {\n                const i = r.allocatedChangeInputs.pop();\n                if (i) {\n                    await releaseChangeInput(i.outputId);\n                }\n            }\n            feeExcessNow = feeExcess();\n        };\n        // If we'd like to have more change outputs create them now.\n        // They may be removed if it turns out we can't fund them.\n        while ((hasTargetNetCount && targetNetCount > netChangeCount()) ||\n            (r.changeOutputs.length === 0 && feeExcess() > 0)) {\n            r.changeOutputs.push({\n                satoshis: r.changeOutputs.length === 0 ? params.changeFirstSatoshis : params.changeInitialSatoshis,\n                lockingScriptLength: params.changeLockingScriptLength\n            });\n        }\n        const fundTransaction = async () => {\n            let removingOutputs = false;\n            const attemptToFundTransaction = async () => {\n                if (feeExcess() > 0)\n                    return true;\n                let exactSatoshis = undefined;\n                if (!hasTargetNetCount && r.changeOutputs.length === 0) {\n                    exactSatoshis = -feeExcess(1);\n                }\n                const ao = addOutputToBalanceNewInput() ? 1 : 0;\n                const targetSatoshis = -feeExcess(1, ao) + (ao === 1 ? 2 * params.changeInitialSatoshis : 0);\n                const allocatedChangeInput = await allocateChangeInput(targetSatoshis, exactSatoshis);\n                if (!allocatedChangeInput) {\n                    // Unable to add another funding change input\n                    return false;\n                }\n                r.allocatedChangeInputs.push(allocatedChangeInput);\n                if (!removingOutputs && feeExcess() > 0) {\n                    if (ao == 1 || r.changeOutputs.length === 0) {\n                        r.changeOutputs.push({\n                            satoshis: Math.min(feeExcess(), r.changeOutputs.length === 0 ? params.changeFirstSatoshis : params.changeInitialSatoshis),\n                            lockingScriptLength: params.changeLockingScriptLength\n                        });\n                    }\n                }\n                return true;\n            };\n            for (;;) {\n                // This is the starvation loop, drops change outputs one at a time if unable to fund them...\n                await releaseAllocatedChangeInputs();\n                while (feeExcess() < 0) {\n                    // This is the funding loop, add one change input at a time...\n                    const ok = await attemptToFundTransaction();\n                    if (!ok)\n                        break;\n                }\n                // Done if blanced overbalanced or impossible (all funding applied, all change outputs removed).\n                if (feeExcess() >= 0 || r.changeOutputs.length === 0)\n                    break;\n                removingOutputs = true;\n                while (r.changeOutputs.length > 0 && feeExcess() < 0) {\n                    r.changeOutputs.pop();\n                }\n                if (feeExcess() < 0)\n                    // Not enough available funding even if no change outputs\n                    break;\n                // At this point we have a funded transaction, but there may be change outputs that are each costing as change input,\n                // resulting in pointless churn of change outputs.\n                // And remove change inputs that funded only a single change output (along with that output)...\n                const changeInputs = [...r.allocatedChangeInputs];\n                while (changeInputs.length > 1 && r.changeOutputs.length > 1) {\n                    const lastOutput = r.changeOutputs.slice(-1)[0];\n                    const i = changeInputs.findIndex(ci => ci.satoshis <= lastOutput.satoshis);\n                    if (i < 0)\n                        break;\n                    r.changeOutputs.pop();\n                    changeInputs.splice(i, 1);\n                }\n                // and try again...\n            }\n        };\n        /**\n         * Add funding to achieve a non-negative feeExcess value, if necessary.\n         */\n        await fundTransaction();\n        if (feeExcess() < 0 && vgcpr.hasMaxPossibleOutput !== undefined) {\n            // Reduce the fixed output with satoshis of maxPossibleSatoshis to what will just fund the transaction...\n            if (fixedOutputs[vgcpr.hasMaxPossibleOutput].satoshis !== exports.maxPossibleSatoshis)\n                throw new index_client_1.sdk.WERR_INTERNAL();\n            fixedOutputs[vgcpr.hasMaxPossibleOutput].satoshis += feeExcess();\n            r.maxPossibleSatoshisAdjustment = {\n                fixedOutputIndex: vgcpr.hasMaxPossibleOutput,\n                satoshis: fixedOutputs[vgcpr.hasMaxPossibleOutput].satoshis\n            };\n        }\n        /**\n         * Trigger an account funding event if we don't have enough to cover this transaction.\n         */\n        if (feeExcess() < 0) {\n            await releaseAllocatedChangeInputs();\n            throw new index_client_1.sdk.WERR_INSUFFICIENT_FUNDS(spending() + feeTarget(), -feeExcessNow);\n        }\n        /**\n         * If needed, seek funding to avoid overspending on fees without a change output to recapture it.\n         */\n        if (r.changeOutputs.length === 0 && feeExcessNow > 0) {\n            await releaseAllocatedChangeInputs();\n            throw new index_client_1.sdk.WERR_INSUFFICIENT_FUNDS(spending() + feeTarget(), params.changeFirstSatoshis);\n        }\n        /**\n         * Distribute the excess fees across the changeOutputs added.\n         */\n        while (r.changeOutputs.length > 0 && feeExcessNow > 0) {\n            if (r.changeOutputs.length === 1) {\n                r.changeOutputs[0].satoshis += feeExcessNow;\n                feeExcessNow = 0;\n            }\n            else if (r.changeOutputs[0].satoshis < params.changeInitialSatoshis) {\n                const sats = Math.min(feeExcessNow, params.changeInitialSatoshis - r.changeOutputs[0].satoshis);\n                feeExcessNow -= sats;\n                r.changeOutputs[0].satoshis += sats;\n            }\n            else {\n                // Distribute a random percentage between 25% and 50% but at least one satoshi\n                const sats = Math.max(1, Math.floor((rand(2500, 5000) / 10000) * feeExcessNow));\n                feeExcessNow -= sats;\n                const index = rand(0, r.changeOutputs.length - 1);\n                r.changeOutputs[index].satoshis += sats;\n            }\n        }\n        r.size = size();\n        (r.fee = fee()), (r.satsPerKb = satsPerKb);\n        const { ok, log } = validateGenerateChangeSdkResult(params, r);\n        if (!ok) {\n            throw new index_client_1.sdk.WERR_INTERNAL(`generateChangeSdk error: ${log}`);\n        }\n        if (r.allocatedChangeInputs.length > 4 && r.changeOutputs.length > 4) {\n            console.log('generateChangeSdk_Capture_too_many_ins_and_outs');\n            logGenerateChangeSdkParams(params);\n        }\n        return r;\n    }\n    catch (eu) {\n        const e = index_client_1.sdk.WalletError.fromUnknown(eu);\n        if (e.code === 'WERR_INSUFFICIENT_FUNDS')\n            throw eu;\n        // Capture the params in cloud run log which has a 100k text length limit per line.\n        // logGenerateChangeSdkParams(params, eu)\n        throw eu;\n    }\n}\nfunction validateGenerateChangeSdkResult(params, r) {\n    let ok = true;\n    let log = '';\n    const sumIn = params.fixedInputs.reduce((a, e) => a + e.satoshis, 0) + r.allocatedChangeInputs.reduce((a, e) => a + e.satoshis, 0);\n    const sumOut = params.fixedOutputs.reduce((a, e) => a + e.satoshis, 0) + r.changeOutputs.reduce((a, e) => a + e.satoshis, 0);\n    if (r.fee && Number.isInteger(r.fee) && r.fee < 0) {\n        log += `basic fee error ${r.fee};`;\n        ok = false;\n    }\n    const feePaid = sumIn - sumOut;\n    if (feePaid !== r.fee) {\n        log += `exact fee error ${feePaid} !== ${r.fee};`;\n        ok = false;\n    }\n    const feeRequired = Math.ceil(((r.size || 0) / 1000) * (r.satsPerKb || 0));\n    if (feeRequired !== r.fee) {\n        log += `required fee error ${feeRequired} !== ${r.fee};`;\n        ok = false;\n    }\n    return { ok, log };\n}\nfunction logGenerateChangeSdkParams(params, eu) {\n    let s = JSON.stringify(params);\n    console.log(`generateChangeSdk params length ${s.length}${eu ? ` error: ${eu}` : ''}`);\n    let i = -1;\n    const maxlen = 99900;\n    for (;;) {\n        i++;\n        console.log(`generateChangeSdk params ${i} XXX${s.slice(0, maxlen)}XXX`);\n        s = s.slice(maxlen);\n        if (!s || i > 100)\n            break;\n    }\n}\nfunction validateGenerateChangeSdkParams(params) {\n    if (!Array.isArray(params.fixedInputs))\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('fixedInputs', 'an array of objects');\n    const r = {};\n    params.fixedInputs.forEach((x, i) => {\n        index_client_1.sdk.validateSatoshis(x.satoshis, `fixedInputs[${i}].satoshis`);\n        index_client_1.sdk.validateInteger(x.unlockingScriptLength, `fixedInputs[${i}].unlockingScriptLength`, undefined, 0);\n    });\n    if (!Array.isArray(params.fixedOutputs))\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('fixedOutputs', 'an array of objects');\n    params.fixedOutputs.forEach((x, i) => {\n        index_client_1.sdk.validateSatoshis(x.satoshis, `fixedOutputs[${i}].satoshis`);\n        index_client_1.sdk.validateInteger(x.lockingScriptLength, `fixedOutputs[${i}].lockingScriptLength`, undefined, 0);\n        if (x.satoshis === exports.maxPossibleSatoshis) {\n            if (r.hasMaxPossibleOutput !== undefined)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`fixedOutputs[${i}].satoshis`, `valid satoshis amount. Only one 'maxPossibleSatoshis' output allowed.`);\n            r.hasMaxPossibleOutput = i;\n        }\n    });\n    params.feeModel = (0, index_client_1.validateStorageFeeModel)(params.feeModel);\n    if (params.feeModel.model !== 'sat/kb')\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('feeModel.model', `'sat/kb'`);\n    index_client_1.sdk.validateOptionalInteger(params.targetNetCount, `targetNetCount`);\n    index_client_1.sdk.validateSatoshis(params.changeFirstSatoshis, 'changeFirstSatoshis', 1);\n    index_client_1.sdk.validateSatoshis(params.changeInitialSatoshis, 'changeInitialSatoshis', 1);\n    index_client_1.sdk.validateInteger(params.changeLockingScriptLength, `changeLockingScriptLength`);\n    index_client_1.sdk.validateInteger(params.changeUnlockingScriptLength, `changeUnlockingScriptLength`);\n    return r;\n}\nfunction generateChangeSdkMakeStorage(availableChange) {\n    const change = availableChange.map(c => ({\n        ...c,\n        spendable: true\n    }));\n    change.sort((a, b) => a.satoshis < b.satoshis\n        ? -1\n        : a.satoshis > b.satoshis\n            ? 1\n            : a.outputId < b.outputId\n                ? -1\n                : a.outputId > b.outputId\n                    ? 1\n                    : 0);\n    let log = '';\n    for (const c of change)\n        log += `change ${c.satoshis} ${c.outputId}\\n`;\n    const getLog = () => log;\n    const allocate = (c) => {\n        log += ` -> ${c.satoshis} sats, id ${c.outputId}\\n`;\n        c.spendable = false;\n        return c;\n    };\n    const allocateChangeInput = async (targetSatoshis, exactSatoshis) => {\n        log += `allocate target ${targetSatoshis} exact ${exactSatoshis}`;\n        if (exactSatoshis !== undefined) {\n            const exact = change.find(c => c.spendable && c.satoshis === exactSatoshis);\n            if (exact)\n                return allocate(exact);\n        }\n        const over = change.find(c => c.spendable && c.satoshis >= targetSatoshis);\n        if (over)\n            return allocate(over);\n        let under = undefined;\n        for (let i = change.length - 1; i >= 0; i--) {\n            if (change[i].spendable) {\n                under = change[i];\n                break;\n            }\n        }\n        if (under)\n            return allocate(under);\n        log += `\\n`;\n        return undefined;\n    };\n    const releaseChangeInput = async (outputId) => {\n        log += `release id ${outputId}\\n`;\n        const c = change.find(x => x.outputId === outputId);\n        if (!c)\n            throw new index_client_1.sdk.WERR_INTERNAL(`unknown outputId ${outputId}`);\n        if (c.spendable)\n            throw new index_client_1.sdk.WERR_INTERNAL(`release of spendable outputId ${outputId}`);\n        c.spendable = true;\n    };\n    return { allocateChangeInput, releaseChangeInput, getLog };\n}\n//# sourceMappingURL=generateChange.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/generateChange.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getBeefForTransaction.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getBeefForTransaction.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getBeefForTransaction = getBeefForTransaction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * Creates a `Beef` to support the validity of a transaction identified by its `txid`.\n *\n * `storage` is used to retrieve proven transactions and their merkle paths,\n * or proven_tx_req record with beef of external inputs (internal inputs meged by recursion).\n * Otherwise external services are used.\n *\n * `options.maxRecursionDepth` can be set to prevent overly deep chained dependencies. Will throw ERR_EXTSVS_ENVELOPE_DEPTH if exceeded.\n *\n * If `trustSelf` is true, a partial `Beef` will be returned where transactions known by `storage` to\n * be valid by verified proof are represented solely by 'txid'.\n *\n * If `knownTxids` is defined, any 'txid' required by the `Beef` that appears in the array is represented solely as a 'known' txid.\n *\n * @param storage the chain on which txid exists.\n * @param txid the transaction hash for which an envelope is requested.\n * @param options\n */\nasync function getBeefForTransaction(storage, txid, options) {\n    const beef = \n    // deserialize mergeToBeef if it is an array\n    Array.isArray(options.mergeToBeef)\n        ? sdk_1.Beef.fromBinary(options.mergeToBeef)\n        : // otherwise if undefined create a new Beef\n            options.mergeToBeef || new sdk_1.Beef();\n    await mergeBeefForTransactionRecurse(beef, storage, txid, options, 0);\n    return beef;\n}\n/**\n * @returns rawTx if txid known to network, if merkle proof available then also proven result is valid.\n */\nasync function getProvenOrRawTxFromServices(storage, txid, options) {\n    var _a;\n    const services = storage.getServices();\n    const por = await index_client_1.EntityProvenTx.fromTxid(txid, await storage.getServices());\n    if (por.proven && !options.ignoreStorage && !options.ignoreNewProven) {\n        por.proven.provenTxId = await storage.insertProvenTx(por.proven.toApi());\n    }\n    return { proven: (_a = por.proven) === null || _a === void 0 ? void 0 : _a.toApi(), rawTx: por.rawTx };\n}\nasync function mergeBeefForTransactionRecurse(beef, storage, txid, options, recursionDepth) {\n    const maxDepth = storage.maxRecursionDepth;\n    if (maxDepth && maxDepth <= recursionDepth)\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION(`Maximum BEEF depth exceeded. Limit is ${storage.maxRecursionDepth}`);\n    if (options.knownTxids && options.knownTxids.indexOf(txid) > -1) {\n        // This txid is one of the txids the caller claims to already know are valid...\n        beef.mergeTxidOnly(txid);\n        return beef;\n    }\n    if (!options.ignoreStorage) {\n        // if we can use storage, ask storage if it has the txid\n        const requiredLevels = options.minProofLevel === undefined ? undefined : options.minProofLevel + recursionDepth;\n        const knownBeef = await storage.getValidBeefForTxid(txid, beef, options.trustSelf, options.knownTxids, undefined, requiredLevels);\n        if (knownBeef)\n            return knownBeef;\n    }\n    if (options.ignoreServices)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`txid ${txid}`, `valid transaction on chain ${storage.chain}`);\n    // if storage doesn't know about txid, use services\n    // to find it and if it has a proof, remember it.\n    const r = await getProvenOrRawTxFromServices(storage, txid, options);\n    if (r.proven && options.minProofLevel !== undefined && options.minProofLevel > recursionDepth) {\n        // ignore proof at this recursion depth\n        r.proven = undefined;\n    }\n    if (r.proven) {\n        // storage has proven this txid,\n        // merge both the raw transaction and its merkle path\n        beef.mergeRawTx(r.proven.rawTx);\n        beef.mergeBump(new index_client_1.EntityProvenTx(r.proven).getMerklePath());\n        return beef;\n    }\n    if (!r.rawTx)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER(`txid ${txid}`, `valid transaction on chain ${storage.chain}`);\n    // merge the raw transaction and recurse over its inputs.\n    beef.mergeRawTx(r.rawTx);\n    // recurse inputs\n    const tx = (0, index_client_1.asBsvSdkTx)(r.rawTx);\n    for (const input of tx.inputs) {\n        const inputTxid = (0, index_client_1.verifyTruthy)(input.sourceTXID);\n        if (!beef.findTxid(inputTxid)) {\n            // Only if the txid is not already in the list of beef transactions.\n            await mergeBeefForTransactionRecurse(beef, storage, inputTxid, options, recursionDepth + 1);\n        }\n    }\n    return beef;\n}\n//# sourceMappingURL=getBeefForTransaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getBeefForTransaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getSyncChunk.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getSyncChunk.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getSyncChunk = getSyncChunk;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * Gets the next sync chunk of updated data from un-remoted storage (could be using a remote DB connection).\n * @param storage\n * @param args\n * @returns\n */\nasync function getSyncChunk(storage, args) {\n    const r = {\n        fromStorageIdentityKey: args.fromStorageIdentityKey,\n        toStorageIdentityKey: args.toStorageIdentityKey,\n        userIdentityKey: args.identityKey\n    };\n    let itemCount = args.maxItems;\n    let roughSize = args.maxRoughSize;\n    let i = 0;\n    let done = false;\n    const user = (0, index_client_1.verifyTruthy)(await storage.findUserByIdentityKey(args.identityKey));\n    if (!args.since || user.updated_at > new Date(args.since))\n        r.user = user;\n    const chunkers = [\n        {\n            name: 'provenTx',\n            maxDivider: 100,\n            preAdd: () => {\n                r.provenTxs = [];\n            },\n            addItem: (i) => {\n                r.provenTxs.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.getProvenTxsForUser(args);\n            }\n        },\n        {\n            name: 'outputBasket',\n            maxDivider: 1,\n            preAdd: () => {\n                r.outputBaskets = [];\n            },\n            addItem: (i) => {\n                r.outputBaskets.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findOutputBaskets({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'outputTag',\n            maxDivider: 1,\n            preAdd: () => {\n                r.outputTags = [];\n            },\n            addItem: (i) => {\n                r.outputTags.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findOutputTags({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'txLabel',\n            maxDivider: 1,\n            preAdd: () => {\n                r.txLabels = [];\n            },\n            addItem: (i) => {\n                r.txLabels.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findTxLabels({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'transaction',\n            maxDivider: 25,\n            preAdd: () => {\n                r.transactions = [];\n            },\n            addItem: (i) => {\n                r.transactions.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findTransactions({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'output',\n            maxDivider: 25,\n            preAdd: () => {\n                r.outputs = [];\n            },\n            addItem: (i) => {\n                r.outputs.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findOutputs({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'txLabelMap',\n            maxDivider: 1,\n            preAdd: () => {\n                r.txLabelMaps = [];\n            },\n            addItem: (i) => {\n                r.txLabelMaps.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.getTxLabelMapsForUser(args);\n            }\n        },\n        {\n            name: 'outputTagMap',\n            maxDivider: 1,\n            preAdd: () => {\n                r.outputTagMaps = [];\n            },\n            addItem: (i) => {\n                r.outputTagMaps.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.getOutputTagMapsForUser(args);\n            }\n        },\n        {\n            name: 'certificate',\n            maxDivider: 25,\n            preAdd: () => {\n                r.certificates = [];\n            },\n            addItem: (i) => {\n                r.certificates.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findCertificates({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'certificateField',\n            maxDivider: 25,\n            preAdd: () => {\n                r.certificateFields = [];\n            },\n            addItem: (i) => {\n                r.certificateFields.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findCertificateFields({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'commission',\n            maxDivider: 25,\n            preAdd: () => {\n                r.commissions = [];\n            },\n            addItem: (i) => {\n                r.commissions.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.findCommissions({\n                    partial: { userId: args.userId },\n                    since: args.since,\n                    paged: args.paged\n                });\n            }\n        },\n        {\n            name: 'provenTxReq',\n            maxDivider: 100,\n            preAdd: () => {\n                r.provenTxReqs = [];\n            },\n            addItem: (i) => {\n                r.provenTxReqs.push(i);\n            },\n            findItems: async (storage, args) => {\n                return await storage.getProvenTxReqsForUser(args);\n            }\n        }\n    ];\n    const addItems = async (a) => {\n        if (i >= args.offsets.length) {\n            done = true;\n            return;\n        }\n        let { offset, name: oname } = args.offsets[i++];\n        if (a.name !== oname)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('offsets', `in dependency order. '${a.name}' expected, found ${oname}.`);\n        let preAddCalled = false;\n        for (; !done;) {\n            const limit = Math.min(itemCount, Math.max(10, args.maxItems / a.maxDivider));\n            if (limit <= 0)\n                break;\n            const items = await a.findItems(storage, {\n                userId: user.userId,\n                since: args.since,\n                paged: { limit, offset }\n            });\n            checkEntityValues(items);\n            if (!preAddCalled) {\n                a.preAdd();\n                preAddCalled = true;\n            }\n            if (items.length === 0)\n                break;\n            for (const item of items) {\n                offset++;\n                a.addItem(item);\n                itemCount--;\n                roughSize -= JSON.stringify(item).length;\n                if (itemCount <= 0 || roughSize < 0) {\n                    done = true;\n                    break;\n                }\n            }\n        }\n    };\n    for (; !done;) {\n        for (const c of chunkers) {\n            await addItems(c);\n        }\n    }\n    return r;\n}\nfunction checkIsDate(v) {\n    if (!(v instanceof Date))\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('bad date');\n}\nfunction checkEntityValues(es) {\n    for (const e of es) {\n        checkIsDate(e['created_at']);\n        checkIsDate(e['updated_at']);\n        for (const key of Object.keys(e))\n            if (e[key] === null)\n                throw new index_client_1.sdk.WERR_INVALID_OPERATION();\n    }\n}\n//# sourceMappingURL=getSyncChunk.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/getSyncChunk.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/internalizeAction.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/internalizeAction.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\n/* eslint-disable @typescript-eslint/no-unused-vars */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.internalizeAction = internalizeAction;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst processAction_1 = __webpack_require__(/*! ./processAction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/processAction.js\");\n/**\n * Internalize Action allows a wallet to take ownership of outputs in a pre-existing transaction.\n * The transaction may, or may not already be known to both the storage and user.\n *\n * Two types of outputs are handled: \"wallet payments\" and \"basket insertions\".\n *\n * A \"basket insertion\" output is considered a custom output and has no effect on the wallet's \"balance\".\n *\n * A \"wallet payment\" adds an outputs value to the wallet's change \"balance\". These outputs are assigned to the \"default\" basket.\n *\n * Processing starts with simple validation and then checks for a pre-existing transaction.\n * If the transaction is already known to the user, then the outputs are reviewed against the existing outputs treatment,\n * and merge rules are added to the arguments passed to the storage layer.\n * The existing transaction must be in the 'unproven' or 'completed' status. Any other status is an error.\n *\n * When the transaction already exists, the description is updated. The isOutgoing sense is not changed.\n *\n * \"basket insertion\" Merge Rules:\n * 1. The \"default\" basket may not be specified as the insertion basket.\n * 2. A change output in the \"default\" basket may not be target of an insertion into a different basket.\n * 3. These baskets do not affect the wallet's balance and are typed \"custom\".\n *\n * \"wallet payment\" Merge Rules:\n * 1. Targetting an existing change \"default\" basket output results in a no-op. No error. No alterations made.\n * 2. Targetting a previously \"custom\" non-change output converts it into a change output. This alters the transaction's `satoshis`, and the wallet balance.\n */\nasync function internalizeAction(storage, auth, args) {\n    const ctx = new InternalizeActionContext(storage, auth, args);\n    await ctx.asyncSetup();\n    if (ctx.isMerge)\n        await ctx.mergedInternalize();\n    else\n        await ctx.newInternalize();\n    return ctx.r;\n}\nclass InternalizeActionContext {\n    constructor(storage, auth, args) {\n        this.storage = storage;\n        this.auth = auth;\n        this.args = args;\n        this.vargs = index_client_1.sdk.validateInternalizeActionArgs(args);\n        this.userId = auth.userId;\n        this.r = {\n            accepted: true,\n            isMerge: false,\n            txid: '',\n            satoshis: 0\n        };\n        this.ab = new sdk_1.Beef();\n        this.tx = new sdk_1.Transaction();\n        this.changeBasket = {};\n        this.baskets = {};\n        this.basketInsertions = [];\n        this.walletPayments = [];\n        this.eos = [];\n    }\n    get isMerge() {\n        return this.r.isMerge;\n    }\n    set isMerge(v) {\n        this.r.isMerge = v;\n    }\n    get txid() {\n        return this.r.txid;\n    }\n    set txid(v) {\n        this.r.txid = v;\n    }\n    get satoshis() {\n        return this.r.satoshis;\n    }\n    set satoshis(v) {\n        this.r.satoshis = v;\n    }\n    async getBasket(basketName) {\n        let b = this.baskets[basketName];\n        if (b)\n            return b;\n        b = await this.storage.findOrInsertOutputBasket(this.userId, basketName);\n        this.baskets[basketName] = b;\n        return b;\n    }\n    async asyncSetup() {\n        ;\n        ({ ab: this.ab, tx: this.tx, txid: this.txid } = await this.validateAtomicBeef(this.args.tx));\n        for (const o of this.args.outputs) {\n            if (o.outputIndex < 0 || o.outputIndex >= this.tx.outputs.length)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputIndex', `a valid output index in range 0 to ${this.tx.outputs.length - 1}`);\n            const txo = this.tx.outputs[o.outputIndex];\n            switch (o.protocol) {\n                case 'basket insertion':\n                    {\n                        if (!o.insertionRemittance || o.paymentRemittance)\n                            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('basket insertion', 'valid insertionRemittance and no paymentRemittance');\n                        this.basketInsertions.push({\n                            ...o.insertionRemittance,\n                            txo,\n                            vout: o.outputIndex\n                        });\n                    }\n                    break;\n                case 'wallet payment':\n                    {\n                        if (o.insertionRemittance || !o.paymentRemittance)\n                            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('wallet payment', 'valid paymentRemittance and no insertionRemittance');\n                        this.walletPayments.push({\n                            ...o.paymentRemittance,\n                            txo,\n                            vout: o.outputIndex,\n                            ignore: false\n                        });\n                    }\n                    break;\n                default:\n                    throw new index_client_1.sdk.WERR_INTERNAL(`unexpected protocol ${o.protocol}`);\n            }\n        }\n        this.changeBasket = (0, index_client_1.verifyOne)(await this.storage.findOutputBaskets({\n            partial: { userId: this.userId, name: 'default' }\n        }));\n        this.baskets = {};\n        this.etx = (0, index_client_1.verifyOneOrNone)(await this.storage.findTransactions({\n            partial: { userId: this.userId, txid: this.txid }\n        }));\n        if (this.etx && !(this.etx.status == 'completed' || this.etx.status === 'unproven' || this.etx.status === 'nosend'))\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `target transaction of internalizeAction has invalid status ${this.etx.status}.`);\n        this.isMerge = !!this.etx;\n        if (this.isMerge) {\n            this.eos = await this.storage.findOutputs({\n                partial: { userId: this.userId, txid: this.txid }\n            }); // It is possible for a transaction to have no outputs, or less outputs in storage than in the transaction itself.\n            for (const eo of this.eos) {\n                const bi = this.basketInsertions.find(b => b.vout === eo.vout);\n                const wp = this.walletPayments.find(b => b.vout === eo.vout);\n                if (bi && wp)\n                    throw new index_client_1.sdk.WERR_INVALID_PARAMETER('outputs', `unique outputIndex values`);\n                if (bi)\n                    bi.eo = eo;\n                if (wp)\n                    wp.eo = eo;\n            }\n        }\n        for (const basket of this.basketInsertions) {\n            if (this.isMerge && basket.eo) {\n                // merging with an existing user output\n                if (basket.eo.basketId === this.changeBasket.basketId) {\n                    // converting a change output to a user basket custom output\n                    this.satoshis -= basket.txo.satoshis;\n                }\n            }\n        }\n        for (const payment of this.walletPayments) {\n            if (this.isMerge) {\n                if (payment.eo) {\n                    // merging with an existing user output\n                    if (payment.eo.basketId === this.changeBasket.basketId) {\n                        // ignore attempts to internalize an existing change output.\n                        payment.ignore = true;\n                    }\n                    else {\n                        // converting an existing non-change output to change... increases net satoshis\n                        this.satoshis += payment.txo.satoshis;\n                    }\n                }\n                else {\n                    // adding a previously untracked output of an existing transaction as change... increase net satoshis\n                    this.satoshis += payment.txo.satoshis;\n                }\n            }\n            else {\n                // If there are no existing outputs, all incoming wallet payment outputs add to net satoshis\n                this.satoshis += payment.txo.satoshis;\n            }\n        }\n    }\n    async validateAtomicBeef(atomicBeef) {\n        const ab = sdk_1.Beef.fromBinary(atomicBeef);\n        const txValid = await ab.verify(await this.storage.getServices().getChainTracker(), false);\n        if (!txValid || !ab.atomicTxid)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', 'valid AtomicBEEF');\n        const txid = ab.atomicTxid;\n        const btx = ab.findTxid(txid);\n        if (!btx)\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `valid AtomicBEEF with newest txid of ${txid}`);\n        const tx = btx.tx;\n        /*\n        for (const i of tx.inputs) {\n          if (!i.sourceTXID)\n            throw new sdk.WERR_INTERNAL('beef Transactions must have sourceTXIDs')\n          if (!i.sourceTransaction) {\n            const btx = ab.findTxid(i.sourceTXID)\n            if (!btx)\n              throw new sdk.WERR_INVALID_PARAMETER('tx', `valid AtomicBEEF and contain input transaction with txid ${i.sourceTXID}`);\n            i.sourceTransaction = btx.tx\n          }\n        }\n        */\n        return { ab, tx, txid };\n    }\n    async findOrInsertTargetTransaction(satoshis, status) {\n        const now = new Date();\n        const newTx = {\n            created_at: now,\n            updated_at: now,\n            transactionId: 0,\n            status,\n            satoshis,\n            version: this.tx.version,\n            lockTime: this.tx.lockTime,\n            reference: (0, index_client_1.randomBytesBase64)(7),\n            userId: this.userId,\n            isOutgoing: false,\n            description: this.args.description,\n            inputBEEF: undefined,\n            txid: this.txid,\n            rawTx: undefined\n        };\n        const tr = await this.storage.findOrInsertTransaction(newTx);\n        if (!tr.isNew) {\n            if (!this.isMerge)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('tx', `target transaction of internalizeAction is undergoing active changes.`);\n            await this.storage.updateTransaction(tr.tx.transactionId, {\n                satoshis: tr.tx.satoshis + satoshis\n            });\n        }\n        return tr.tx;\n    }\n    async mergedInternalize() {\n        const transactionId = this.etx.transactionId;\n        await this.addLabels(transactionId);\n        for (const payment of this.walletPayments) {\n            if (payment.eo && !payment.ignore)\n                await this.mergeWalletPaymentForOutput(transactionId, payment);\n            else if (!payment.ignore)\n                await this.storeNewWalletPaymentForOutput(transactionId, payment);\n        }\n        for (const basket of this.basketInsertions) {\n            if (basket.eo)\n                await this.mergeBasketInsertionForOutput(transactionId, basket);\n            else\n                await this.storeNewBasketInsertionForOutput(transactionId, basket);\n        }\n    }\n    async newInternalize() {\n        this.etx = await this.findOrInsertTargetTransaction(this.satoshis, 'unproven');\n        const transactionId = this.etx.transactionId;\n        // transaction record for user is new, but the txid may not be new to storage\n        // make sure storage pursues getting a proof for it.\n        const newReq = index_client_1.EntityProvenTxReq.fromTxid(this.txid, this.tx.toBinary(), this.args.tx);\n        // this status is only relevant if the transaction is new to storage.\n        newReq.status = 'unsent';\n        // this history and notify will be merged into an existing req if it exists.\n        newReq.addHistoryNote({ what: 'internalizeAction', userId: this.userId });\n        newReq.addNotifyTransactionId(transactionId);\n        const pr = await this.storage.getProvenOrReq(this.txid, newReq.toApi());\n        if (pr.isNew) {\n            // This storage doesn't know about this txid yet.\n            // TODO Can we immediately prove this txid?\n            // TODO Do full validation on the transaction?\n            // Attempt to broadcast it to the network, throwing an error if it fails.\n            const { swr, ndr } = await (0, processAction_1.shareReqsWithWorld)(this.storage, this.userId, [this.txid], false);\n            if (ndr[0].status !== 'success') {\n                this.r.sendWithResults = swr;\n                this.r.notDelayedResults = ndr;\n                // abort the internalize action, WERR_REVIEW_ACTIONS exception will be thrown\n                return;\n            }\n        }\n        await this.addLabels(transactionId);\n        for (const payment of this.walletPayments) {\n            await this.storeNewWalletPaymentForOutput(transactionId, payment);\n        }\n        for (const basket of this.basketInsertions) {\n            await this.storeNewBasketInsertionForOutput(transactionId, basket);\n        }\n    }\n    async addLabels(transactionId) {\n        for (const label of this.vargs.labels) {\n            const txLabel = await this.storage.findOrInsertTxLabel(this.userId, label);\n            await this.storage.findOrInsertTxLabelMap((0, index_client_1.verifyId)(transactionId), (0, index_client_1.verifyId)(txLabel.txLabelId));\n        }\n    }\n    async addBasketTags(basket, outputId) {\n        for (const tag of basket.tags || []) {\n            await this.storage.tagOutput({ outputId, userId: this.userId }, tag);\n        }\n    }\n    async storeNewWalletPaymentForOutput(transactionId, payment) {\n        const now = new Date();\n        const txOut = {\n            created_at: now,\n            updated_at: now,\n            outputId: 0,\n            transactionId,\n            userId: this.userId,\n            spendable: true,\n            lockingScript: payment.txo.lockingScript.toBinary(),\n            vout: payment.vout,\n            basketId: this.changeBasket.basketId,\n            satoshis: payment.txo.satoshis,\n            txid: this.txid,\n            senderIdentityKey: payment.senderIdentityKey,\n            type: 'P2PKH',\n            providedBy: 'storage',\n            purpose: 'change',\n            derivationPrefix: payment.derivationPrefix,\n            derivationSuffix: payment.derivationSuffix,\n            change: true,\n            spentBy: undefined,\n            customInstructions: undefined,\n            outputDescription: '',\n            spendingDescription: undefined\n        };\n        txOut.outputId = await this.storage.insertOutput(txOut);\n        payment.eo = txOut;\n    }\n    async mergeWalletPaymentForOutput(transactionId, payment) {\n        const outputId = payment.eo.outputId;\n        const update = {\n            basketId: this.changeBasket.basketId,\n            type: 'P2PKH',\n            customInstructions: undefined,\n            change: true,\n            providedBy: 'storage',\n            purpose: 'change',\n            senderIdentityKey: payment.senderIdentityKey,\n            derivationPrefix: payment.derivationPrefix,\n            derivationSuffix: payment.derivationSuffix\n        };\n        await this.storage.updateOutput(outputId, update);\n        payment.eo = { ...payment.eo, ...update };\n    }\n    async mergeBasketInsertionForOutput(transactionId, basket) {\n        const outputId = basket.eo.outputId;\n        const update = {\n            basketId: (await this.getBasket(basket.basket)).basketId,\n            type: 'custom',\n            customInstructions: basket.customInstructions,\n            change: false,\n            providedBy: 'you',\n            purpose: '',\n            senderIdentityKey: undefined,\n            derivationPrefix: undefined,\n            derivationSuffix: undefined\n        };\n        await this.storage.updateOutput(outputId, update);\n        basket.eo = { ...basket.eo, ...update };\n    }\n    async storeNewBasketInsertionForOutput(transactionId, basket) {\n        const now = new Date();\n        const txOut = {\n            created_at: now,\n            updated_at: now,\n            outputId: 0,\n            transactionId,\n            userId: this.userId,\n            spendable: true,\n            lockingScript: basket.txo.lockingScript.toBinary(),\n            vout: basket.vout,\n            basketId: (await this.getBasket(basket.basket)).basketId,\n            satoshis: basket.txo.satoshis,\n            txid: this.txid,\n            type: 'custom',\n            customInstructions: basket.customInstructions,\n            change: false,\n            spentBy: undefined,\n            outputDescription: '',\n            spendingDescription: undefined,\n            providedBy: 'you',\n            purpose: '',\n            senderIdentityKey: undefined,\n            derivationPrefix: undefined,\n            derivationSuffix: undefined\n        };\n        txOut.outputId = await this.storage.insertOutput(txOut);\n        await this.addBasketTags(basket, txOut.outputId);\n        basket.eo = txOut;\n    }\n}\n//# sourceMappingURL=internalizeAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/internalizeAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listActionsIdb.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listActionsIdb.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.listActionsIdb = listActionsIdb;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst sdk_2 = __webpack_require__(/*! ../../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\nconst ListActionsSpecOp_1 = __webpack_require__(/*! ./ListActionsSpecOp */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListActionsSpecOp.js\");\nasync function listActionsIdb(storage, auth, vargs) {\n    const limit = vargs.limit;\n    const offset = vargs.offset;\n    const r = {\n        totalActions: 0,\n        actions: []\n    };\n    let specOp = undefined;\n    let specOpLabels = [];\n    let labels = [];\n    for (const label of vargs.labels) {\n        if ((0, sdk_2.isListActionsSpecOp)(label)) {\n            specOp = (0, ListActionsSpecOp_1.getLabelToSpecOp)()[label];\n        }\n        else {\n            labels.push(label);\n        }\n    }\n    if ((specOp === null || specOp === void 0 ? void 0 : specOp.labelsToIntercept) !== undefined) {\n        const intercept = specOp.labelsToIntercept;\n        const labels2 = labels;\n        labels = [];\n        if (intercept.length === 0) {\n            specOpLabels = labels2;\n        }\n        for (const label of labels2) {\n            if (intercept.indexOf(label) >= 0) {\n                specOpLabels.push(label);\n            }\n            else {\n                labels.push(label);\n            }\n        }\n    }\n    let labelIds = [];\n    if (labels.length > 0) {\n        await storage.filterTxLabels({ partial: { userId: auth.userId, isDeleted: false } }, tl => {\n            if (labels.includes(tl.label)) {\n                labelIds.push(tl.txLabelId);\n            }\n        });\n    }\n    const isQueryModeAll = vargs.labelQueryMode === 'all';\n    if (isQueryModeAll && labelIds.length < labels.length)\n        // all the required labels don't exist, impossible to satisfy.\n        return r;\n    if (!isQueryModeAll && labelIds.length === 0 && labels.length > 0)\n        // any and only non-existing labels, impossible to satisfy.\n        return r;\n    const stati = (specOp === null || specOp === void 0 ? void 0 : specOp.setStatusFilter)\n        ? specOp.setStatusFilter()\n        : ['completed', 'unprocessed', 'sending', 'unproven', 'unsigned', 'nosend', 'nonfinal'];\n    const noLabels = labelIds.length === 0;\n    const txs = await storage.findTransactions({\n        partial: { userId: auth.userId },\n        status: stati,\n        paged: { limit: vargs.limit, offset: vargs.offset },\n        noRawTx: true\n    }, labelIds, isQueryModeAll);\n    if (txs.length === vargs.limit) {\n        r.totalActions = await storage.countTransactions({ partial: { userId: auth.userId }, status: stati }, labelIds, isQueryModeAll);\n    }\n    else {\n        r.totalActions = txs.length;\n    }\n    if (specOp === null || specOp === void 0 ? void 0 : specOp.postProcess) {\n        await specOp.postProcess(storage, auth, vargs, specOpLabels, txs);\n    }\n    for (const tx of txs) {\n        const wtx = {\n            txid: tx.txid || '',\n            satoshis: tx.satoshis || 0,\n            status: tx.status,\n            isOutgoing: !!tx.isOutgoing,\n            description: tx.description || '',\n            version: tx.version || 0,\n            lockTime: tx.lockTime || 0\n        };\n        r.actions.push(wtx);\n    }\n    if (vargs.includeLabels || vargs.includeInputs || vargs.includeOutputs) {\n        await Promise.all(txs.map(async (tx, i) => {\n            var _a, _b, _c;\n            //let i = -1\n            //for (const tx of txs) {\n            //    i++\n            const action = r.actions[i];\n            if (vargs.includeLabels) {\n                action.labels = (await storage.getLabelsForTransactionId(tx.transactionId)).map(l => l.label);\n            }\n            if (vargs.includeOutputs) {\n                const outputs = await storage.findOutputs({\n                    partial: { transactionId: tx.transactionId },\n                    noScript: !vargs.includeOutputLockingScripts\n                });\n                action.outputs = [];\n                for (const o of outputs) {\n                    await storage.extendOutput(o, true, true);\n                    const wo = {\n                        satoshis: o.satoshis || 0,\n                        spendable: !!o.spendable,\n                        tags: ((_a = o.tags) === null || _a === void 0 ? void 0 : _a.map(t => t.tag)) || [],\n                        outputIndex: Number(o.vout),\n                        outputDescription: o.outputDescription || '',\n                        basket: ((_b = o.basket) === null || _b === void 0 ? void 0 : _b.name) || ''\n                    };\n                    if (vargs.includeOutputLockingScripts)\n                        wo.lockingScript = (0, index_client_1.asString)(o.lockingScript || []);\n                    action.outputs.push(wo);\n                }\n            }\n            if (vargs.includeInputs) {\n                const inputs = await storage.findOutputs({\n                    partial: { spentBy: tx.transactionId },\n                    noScript: !vargs.includeInputSourceLockingScripts\n                });\n                action.inputs = [];\n                if (inputs.length > 0) {\n                    const rawTx = await storage.getRawTxOfKnownValidTransaction(tx.txid);\n                    let bsvTx = undefined;\n                    if (rawTx) {\n                        bsvTx = sdk_1.Transaction.fromBinary(rawTx);\n                    }\n                    for (const o of inputs) {\n                        await storage.extendOutput(o, true, true);\n                        const input = bsvTx === null || bsvTx === void 0 ? void 0 : bsvTx.inputs.find(v => v.sourceTXID === o.txid && v.sourceOutputIndex === o.vout);\n                        const wo = {\n                            sourceOutpoint: `${o.txid}.${o.vout}`,\n                            sourceSatoshis: o.satoshis || 0,\n                            inputDescription: o.outputDescription || '',\n                            sequenceNumber: (input === null || input === void 0 ? void 0 : input.sequence) || 0\n                        };\n                        action.inputs.push(wo);\n                        if (vargs.includeInputSourceLockingScripts) {\n                            wo.sourceLockingScript = (0, index_client_1.asString)(o.lockingScript || []);\n                        }\n                        if (vargs.includeInputUnlockingScripts) {\n                            wo.unlockingScript = (_c = input === null || input === void 0 ? void 0 : input.unlockingScript) === null || _c === void 0 ? void 0 : _c.toHex();\n                        }\n                    }\n                }\n            }\n            //}\n        }));\n    }\n    return r;\n}\n//# sourceMappingURL=listActionsIdb.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listActionsIdb.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listCertificates.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listCertificates.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.listCertificates = listCertificates;\nasync function listCertificates(storage, auth, vargs, originator) {\n    const paged = { limit: vargs.limit, offset: vargs.offset };\n    const partial = {\n        userId: auth.userId,\n        isDeleted: false\n    };\n    if (vargs.partial) {\n        const vp = vargs.partial;\n        if (vp.type)\n            partial['type'] = vp.type;\n        if (vp.subject)\n            partial['subject'] = vp.subject;\n        if (vp.serialNumber)\n            partial['serialNumber'] = vp.serialNumber;\n        if (vp.certifier)\n            partial['certifier'] = vp.certifier;\n        if (vp.revocationOutpoint)\n            partial['revocationOutpoint'] = vp.revocationOutpoint;\n        if (vp.signature)\n            partial['signature'] = vp.signature;\n    }\n    const r = await storage.transaction(async (trx) => {\n        const findCertsArgs = {\n            partial,\n            certifiers: vargs.certifiers,\n            types: vargs.types,\n            paged,\n            trx\n        };\n        const certs = await storage.findCertificates(findCertsArgs);\n        const certsWithFields = await Promise.all(certs.map(async (cert) => {\n            const fields = await storage.findCertificateFields({\n                partial: { certificateId: cert.certificateId, userId: auth.userId },\n                trx\n            });\n            return {\n                ...cert,\n                fields: Object.fromEntries(fields.map(f => [f.fieldName, f.fieldValue])),\n                masterKeyring: Object.fromEntries(fields.map(f => [f.fieldName, f.masterKey]))\n            };\n        }));\n        const r = {\n            totalCertificates: 0,\n            certificates: certsWithFields.map(cwf => ({\n                type: cwf.type,\n                subject: cwf.subject,\n                serialNumber: cwf.serialNumber,\n                certifier: cwf.certifier,\n                revocationOutpoint: cwf.revocationOutpoint,\n                signature: cwf.signature,\n                fields: cwf.fields,\n                verifier: cwf.verifier,\n                keyring: cwf.masterKeyring\n            }))\n        };\n        if (r.certificates.length < paged.limit)\n            r.totalCertificates = r.certificates.length;\n        else {\n            r.totalCertificates = await storage.countCertificates(findCertsArgs);\n        }\n        return r;\n    });\n    return r;\n}\n//# sourceMappingURL=listCertificates.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listCertificates.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listOutputsIdb.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listOutputsIdb.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.listOutputsIdb = listOutputsIdb;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst ListOutputsSpecOp_1 = __webpack_require__(/*! ./ListOutputsSpecOp */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/ListOutputsSpecOp.js\");\nasync function listOutputsIdb(storage, auth, vargs, originator) {\n    const userId = (0, index_client_1.verifyId)(auth.userId);\n    const limit = vargs.limit;\n    const offset = vargs.offset;\n    const r = {\n        totalOutputs: 0,\n        outputs: []\n    };\n    /*\n          ListOutputsArgs {\n              basket: BasketStringUnder300Bytes\n  \n              tags?: OutputTagStringUnder300Bytes[]\n              tagQueryMode?: 'all' | 'any' // default any\n  \n              limit?: PositiveIntegerDefault10Max10000\n              offset?: PositiveIntegerOrZero\n          }\n      */\n    let specOp = undefined;\n    let basketId = undefined;\n    const basketsById = {};\n    if (vargs.basket) {\n        let b = vargs.basket;\n        specOp = (0, ListOutputsSpecOp_1.getBasketToSpecOp)()[b];\n        b = specOp ? (specOp.useBasket ? specOp.useBasket : '') : b;\n        if (b) {\n            const baskets = await storage.findOutputBaskets({\n                partial: { userId, name: b }\n            });\n            if (baskets.length !== 1) {\n                // If basket does not exist, result is no outputs.\n                return r;\n            }\n            const basket = baskets[0];\n            basketId = basket.basketId;\n            basketsById[basketId] = basket;\n        }\n    }\n    let tags = [...vargs.tags];\n    const specOpTags = [];\n    if (specOp && specOp.tagsParamsCount) {\n        specOpTags.push(...tags.splice(0, Math.min(tags.length, specOp.tagsParamsCount)));\n    }\n    if (specOp && specOp.tagsToIntercept) {\n        // Pull out tags used by current specOp\n        const ts = tags;\n        tags = [];\n        for (const t of ts) {\n            if (specOp.tagsToIntercept.length === 0 || specOp.tagsToIntercept.indexOf(t) >= 0) {\n                specOpTags.push(t);\n                if (t === 'all') {\n                    basketId = undefined;\n                }\n            }\n            else {\n                tags.push(t);\n            }\n        }\n    }\n    if (specOp && specOp.resultFromTags) {\n        const r = await specOp.resultFromTags(storage, auth, vargs, specOpTags);\n        return r;\n    }\n    let tagIds = [];\n    if (tags && tags.length > 0) {\n        await storage.filterOutputTags({ partial: { userId, isDeleted: false } }, ot => {\n            if (tags.includes(ot.tag)) {\n                tagIds.push(ot.outputTagId);\n            }\n        });\n    }\n    const isQueryModeAll = vargs.tagQueryMode === 'all';\n    if (isQueryModeAll && tagIds.length < tags.length)\n        // all the required tags don't exist, impossible to satisfy.\n        return r;\n    if (!isQueryModeAll && tagIds.length === 0 && tags.length > 0)\n        // any and only non-existing labels, impossible to satisfy.\n        return r;\n    const noTags = tagIds.length === 0;\n    const includeSpent = false;\n    const stati = ['completed', 'unproven', 'nosend'];\n    const args = {\n        partial: {\n            userId,\n            basketId,\n            spendable: !includeSpent ? true : undefined\n        },\n        txStatus: stati,\n        noScript: true\n    };\n    if (!specOp || !specOp.ignoreLimit)\n        args.paged = { limit, offset };\n    let outputs = await storage.findOutputs(args, tagIds, isQueryModeAll);\n    if (outputs.length === vargs.limit) {\n        args.paged = undefined;\n        r.totalOutputs = await storage.countOutputs(args, tagIds, isQueryModeAll);\n    }\n    else {\n        r.totalOutputs = outputs.length;\n    }\n    if (specOp) {\n        if (specOp.filterOutputs)\n            outputs = await specOp.filterOutputs(storage, auth, vargs, specOpTags, outputs);\n        if (specOp.resultFromOutputs) {\n            const r = await specOp.resultFromOutputs(storage, auth, vargs, specOpTags, outputs);\n            return r;\n        }\n    }\n    /*\n          ListOutputsArgs {\n              include?: 'locking scripts' | 'entire transactions'\n              includeCustomInstructions?: BooleanDefaultFalse\n              includeTags?: BooleanDefaultFalse\n              includeLabels?: BooleanDefaultFalse\n          }\n  \n          ListOutputsResult {\n              totalOutputs: PositiveIntegerOrZero\n              BEEF?: BEEF\n              outputs: Array<WalletOutput>\n          }\n  \n          WalletOutput {\n              satoshis: SatoshiValue\n              spendable: boolean\n              outpoint: OutpointString\n  \n              customInstructions?: string\n              lockingScript?: HexString\n              tags?: OutputTagStringUnder300Bytes[]\n              labels?: LabelStringUnder300Bytes[]\n          }\n      */\n    const labelsByTxid = {};\n    const beef = new sdk_1.Beef();\n    for (const o of outputs) {\n        const wo = {\n            satoshis: Number(o.satoshis),\n            spendable: !!o.spendable,\n            outpoint: `${o.txid}.${o.vout}`\n        };\n        r.outputs.push(wo);\n        //if (vargs.includeBasket && o.basketId) {\n        //    if (!basketsById[o.basketId]) {\n        //        basketsById[o.basketId] = verifyTruthy(await dsk.findOutputBasketId(o.basketId!, trx))\n        //    }\n        //    wo.basket = basketsById[o.basketId].name\n        //}\n        if (vargs.includeCustomInstructions && o.customInstructions)\n            wo.customInstructions = o.customInstructions;\n        if (vargs.includeLabels && o.txid) {\n            if (labelsByTxid[o.txid] === undefined) {\n                labelsByTxid[o.txid] = (await storage.getLabelsForTransactionId(o.transactionId)).map(l => l.label);\n            }\n            wo.labels = labelsByTxid[o.txid];\n        }\n        if (vargs.includeTags) {\n            wo.tags = (await storage.getTagsForOutputId(o.outputId)).map(t => t.tag);\n        }\n        if (vargs.includeLockingScripts) {\n            await storage.validateOutputScript(o);\n            if (o.lockingScript)\n                wo.lockingScript = (0, index_client_1.asString)(o.lockingScript);\n        }\n        if (vargs.includeTransactions && !beef.findTxid(o.txid)) {\n            await storage.getValidBeefForKnownTxid(o.txid, beef, undefined, vargs.knownTxids);\n        }\n    }\n    if (vargs.includeTransactions) {\n        r.BEEF = beef.toBinary();\n    }\n    return r;\n}\n//# sourceMappingURL=listOutputsIdb.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/listOutputsIdb.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/processAction.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/processAction.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.processAction = processAction;\nexports.shareReqsWithWorld = shareReqsWithWorld;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst aggregateResults_1 = __webpack_require__(/*! ../../utility/aggregateResults */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/aggregateResults.js\");\nasync function processAction(storage, auth, args) {\n    (0, index_client_1.stampLog)(args.log, `start storage processActionSdk`);\n    const userId = (0, index_client_1.verifyId)(auth.userId);\n    const r = {\n        sendWithResults: undefined\n    };\n    let req;\n    const txidsOfReqsToShareWithWorld = [...args.sendWith];\n    if (args.isNewTx) {\n        const vargs = await validateCommitNewTxToStorageArgs(storage, userId, args);\n        ({ req, log: args.log } = await commitNewTxToStorage(storage, userId, vargs));\n        if (!req)\n            throw new index_client_1.sdk.WERR_INTERNAL();\n        // Add the new txid to sendWith unless there are no others to send and the noSend option is set.\n        if (args.isNoSend && !args.isSendWith)\n            (0, index_client_1.stampLog)(args.log, `... storage processActionSdk newTx committed noSend`);\n        else {\n            txidsOfReqsToShareWithWorld.push(req.txid);\n            (0, index_client_1.stampLog)(args.log, `... storage processActionSdk newTx committed sendWith ${req.txid}`);\n        }\n    }\n    const { swr, ndr } = await shareReqsWithWorld(storage, userId, txidsOfReqsToShareWithWorld, args.isDelayed);\n    r.sendWithResults = swr;\n    r.notDelayedResults = ndr;\n    (0, index_client_1.stampLog)(args.log, `end storage processActionSdk`);\n    return r;\n}\n/**\n * Verifies that all the txids are known reqs with ready-to-share status.\n * Assigns a batch identifier and updates all the provenTxReqs.\n * If not isDelayed, triggers an initial attempt to broadcast the batch and returns the results.\n *\n * @param storage\n * @param userId\n * @param txids\n * @param isDelayed\n */\nasync function shareReqsWithWorld(storage, userId, txids, isDelayed) {\n    let swr = [];\n    let ndr = undefined;\n    if (txids.length < 1)\n        return { swr, ndr };\n    // Collect what we know about these sendWith transaction txids from storage.\n    const r = await storage.getReqsAndBeefToShareWithWorld(txids, []);\n    const readyToSendReqs = [];\n    for (const getReq of r.details) {\n        let status = 'failed';\n        if (getReq.status === 'alreadySent')\n            status = 'unproven';\n        else if (getReq.status === 'readyToSend') {\n            status = 'sending';\n            readyToSendReqs.push(new index_client_1.EntityProvenTxReq(getReq.req));\n        }\n        swr.push({\n            txid: getReq.txid,\n            status\n        });\n    }\n    // Filter original txids down to reqIds that are available and need sending\n    const readyToSendReqIds = readyToSendReqs.map(r => r.id);\n    const transactionIds = readyToSendReqs.map(r => r.notify.transactionIds || []).flat();\n    // If there are reqs to send, verify that we have a valid aggregate beef for them.\n    // If isDelayed, this (or a different beef) will have to be rebuilt at the time of sending.\n    if (readyToSendReqs.length > 0) {\n        const beefIsValid = await r.beef.verify(await storage.getServices().getChainTracker());\n        if (!beefIsValid) {\n            console.log(`VERIFY FALSE BEEF: ${r.beef.toLogString()}`);\n            throw new index_client_1.sdk.WERR_INTERNAL(`merged Beef failed validation.`);\n        }\n    }\n    // Set req batch property for the reqs being sent\n    // If delayed, also bump status to 'unsent' and we're done here\n    const batch = txids.length > 1 ? (0, index_client_1.randomBytesBase64)(16) : undefined;\n    if (isDelayed) {\n        // Just bump the req status to 'unsent' to enable background sending...\n        if (readyToSendReqIds.length > 0) {\n            await storage.transaction(async (trx) => {\n                await storage.updateProvenTxReq(readyToSendReqIds, { status: 'unsent', batch }, trx);\n                await storage.updateTransaction(transactionIds, { status: 'sending' }, trx);\n            });\n        }\n        return { swr, ndr };\n    }\n    if (readyToSendReqIds.length < 1) {\n        return { swr, ndr };\n    }\n    if (batch) {\n        // Keep batch values in sync...\n        for (const req of readyToSendReqs)\n            req.batch = batch;\n        await storage.updateProvenTxReq(readyToSendReqIds, { batch });\n    }\n    //\n    // Handle the NON-DELAYED-SEND-NOW case\n    //\n    const prtn = await storage.attemptToPostReqsToNetwork(readyToSendReqs);\n    const { swr: swrRes, rar } = await (0, aggregateResults_1.aggregateActionResults)(storage, swr, prtn);\n    return { swr: swrRes, ndr: rar };\n}\nasync function validateCommitNewTxToStorageArgs(storage, userId, params) {\n    if (!params.reference || !params.txid || !params.rawTx)\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('One or more expected params are undefined.');\n    let tx;\n    try {\n        tx = sdk_1.Transaction.fromBinary(params.rawTx);\n    }\n    catch (e) {\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('Parsing serialized transaction failed.');\n    }\n    if (params.txid !== tx.id('hex'))\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION(`Hash of serialized transaction doesn't match expected txid`);\n    if (!(await storage.getServices()).nLockTimeIsFinal(tx)) {\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION(`This transaction is not final.\n         Ensure that the transaction meets the rules for being a finalized\n         which can be found at https://wiki.bitcoinsv.io/index.php/NLocktime_and_nSequence`);\n    }\n    const txScriptOffsets = (0, index_client_1.parseTxScriptOffsets)(params.rawTx);\n    const transaction = (0, index_client_1.verifyOne)(await storage.findTransactions({\n        partial: { userId, reference: params.reference }\n    }));\n    if (!transaction.isOutgoing)\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('isOutgoing is not true');\n    if (!transaction.inputBEEF)\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION();\n    const beef = sdk_1.Beef.fromBinary((0, index_client_1.asArray)(transaction.inputBEEF));\n    // TODO: Could check beef validates transaction inputs...\n    // Transaction must have unsigned or unprocessed status\n    if (transaction.status !== 'unsigned' && transaction.status !== 'unprocessed')\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION(`invalid transaction status ${transaction.status}`);\n    const transactionId = (0, index_client_1.verifyId)(transaction.transactionId);\n    const outputOutputs = await storage.findOutputs({\n        partial: { userId, transactionId }\n    });\n    const inputOutputs = await storage.findOutputs({\n        partial: { userId, spentBy: transactionId }\n    });\n    const commission = (0, index_client_1.verifyOneOrNone)(await storage.findCommissions({ partial: { transactionId, userId } }));\n    if (storage.commissionSatoshis > 0) {\n        // A commission is required...\n        if (!commission)\n            throw new index_client_1.sdk.WERR_INTERNAL();\n        const commissionValid = tx.outputs.some(x => x.satoshis === commission.satoshis && x.lockingScript.toHex() === (0, index_client_1.asString)(commission.lockingScript));\n        if (!commissionValid)\n            throw new index_client_1.sdk.WERR_INVALID_OPERATION('Transaction did not include an output to cover service fee.');\n    }\n    const req = index_client_1.EntityProvenTxReq.fromTxid(params.txid, params.rawTx, transaction.inputBEEF);\n    req.addNotifyTransactionId(transactionId);\n    // \"Processing\" a transaction is the final step of creating a new one.\n    // If it is to be sent to the network directly (prior to return from processAction),\n    // then there is status pre-send and post-send.\n    // Otherwise there is no post-send status.\n    // Note that isSendWith trumps isNoSend, e.g. isNoSend && !isSendWith\n    //\n    // Determine what status the req and transaction should have pre- at the end of processing.\n    //                           Pre-Status (to newReq/newTx)     Post-Status (to all sent reqs/txs)\n    //                           req         tx                   req                 tx\n    // isNoSend                  noSend      noSend\n    // !isNoSend && isDelayed    unsent      unprocessed\n    // !isNoSend && !isDelayed   unprocessed unprocessed          sending/unmined     sending/unproven      This is the only case that sends immediately.\n    let postStatus = undefined;\n    let status;\n    if (params.isNoSend && !params.isSendWith)\n        status = { req: 'nosend', tx: 'nosend' };\n    else if (!params.isNoSend && params.isDelayed)\n        status = { req: 'unsent', tx: 'unprocessed' };\n    else if (!params.isNoSend && !params.isDelayed) {\n        status = { req: 'unprocessed', tx: 'unprocessed' };\n        postStatus = { req: 'unmined', tx: 'unproven' };\n    }\n    else\n        throw new index_client_1.sdk.WERR_INTERNAL('logic error');\n    req.status = status.req;\n    const vargs = {\n        reference: params.reference,\n        txid: params.txid,\n        rawTx: params.rawTx,\n        isSendWith: !!params.sendWith && params.sendWith.length > 0,\n        isDelayed: params.isDelayed,\n        isNoSend: params.isNoSend,\n        // Properties with values added during validation.\n        tx,\n        txScriptOffsets,\n        transactionId,\n        transaction,\n        inputOutputs,\n        outputOutputs,\n        commission,\n        beef,\n        req,\n        outputUpdates: [],\n        // update txid, status in transactions table and drop rawTransaction value\n        transactionUpdate: {\n            txid: params.txid,\n            rawTx: undefined,\n            inputBEEF: undefined,\n            status: status.tx\n        },\n        postStatus\n    };\n    // update outputs with txid, script offsets and lengths, drop long output scripts from outputs table\n    // outputs spendable will be updated for change to true and all others to !!o.tracked when tx has been broadcast\n    // MAX_OUTPUTSCRIPT_LENGTH is limit for scripts left in outputs table\n    for (const o of vargs.outputOutputs) {\n        const vout = (0, index_client_1.verifyInteger)(o.vout);\n        const offset = vargs.txScriptOffsets.outputs[vout];\n        const rawTxScript = (0, index_client_1.asString)(vargs.rawTx.slice(offset.offset, offset.offset + offset.length));\n        if (o.lockingScript && rawTxScript !== (0, index_client_1.asString)(o.lockingScript))\n            throw new index_client_1.sdk.WERR_INVALID_OPERATION(`rawTx output locking script for vout ${vout} not equal to expected output script.`);\n        if (tx.outputs[vout].lockingScript.toHex() !== rawTxScript)\n            throw new index_client_1.sdk.WERR_INVALID_OPERATION(`parsed transaction output locking script for vout ${vout} not equal to expected output script.`);\n        const update = {\n            txid: vargs.txid,\n            spendable: true, // spendability is gated by transaction status. Remains true until the output is spent.\n            scriptLength: offset.length,\n            scriptOffset: offset.offset\n        };\n        if (offset.length > (await storage.getSettings()).maxOutputScript)\n            // Remove long lockingScript data from outputs table, will be read from rawTx in proven_tx or proven_tx_reqs tables.\n            update.lockingScript = undefined;\n        vargs.outputUpdates.push({ id: o.outputId, update });\n    }\n    return vargs;\n}\nasync function commitNewTxToStorage(storage, userId, vargs) {\n    let log = vargs.log;\n    log = (0, index_client_1.stampLog)(log, `start storage commitNewTxToStorage`);\n    let req;\n    await storage.transaction(async (trx) => {\n        log = (0, index_client_1.stampLog)(log, `... storage commitNewTxToStorage storage transaction start`);\n        // Create initial 'nosend' proven_tx_req record to store signed, valid rawTx and input beef\n        req = await vargs.req.insertOrMerge(storage, trx);\n        log = (0, index_client_1.stampLog)(log, `... storage commitNewTxToStorage req inserted`);\n        for (const ou of vargs.outputUpdates) {\n            await storage.updateOutput(ou.id, ou.update, trx);\n        }\n        log = (0, index_client_1.stampLog)(log, `... storage commitNewTxToStorage outputs updated`);\n        await storage.updateTransaction(vargs.transactionId, vargs.transactionUpdate, trx);\n        log = (0, index_client_1.stampLog)(log, `... storage commitNewTxToStorage storage transaction end`);\n    });\n    log = (0, index_client_1.stampLog)(log, `... storage commitNewTxToStorage storage transaction await done`);\n    const r = {\n        req: (0, index_client_1.verifyTruthy)(req),\n        log\n    };\n    log = (0, index_client_1.stampLog)(log, `end storage commitNewTxToStorage`);\n    return r;\n}\n//# sourceMappingURL=processAction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/processAction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/purgeDataIdb.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/purgeDataIdb.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.purgeDataIdb = purgeDataIdb;\nasync function purgeDataIdb(storage, params, trx) {\n    const r = { count: 0, log: '' };\n    // TODO: implement purgeDataIdb\n    return r;\n}\n//# sourceMappingURL=purgeDataIdb.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/purgeDataIdb.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/reviewStatusIdb.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/reviewStatusIdb.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.reviewStatusIdb = reviewStatusIdb;\n/**\n * Looks for unpropagated state:\n *\n * 1. set transactions to 'failed' if not already failed and provenTxReq with matching txid has status of 'invalid'.\n * 2. sets transactions to 'completed' if provenTx with matching txid exists and current provenTxId is null.\n * 3. sets outputs to spendable true, spentBy undefined if spentBy is a transaction with status 'failed'.\n *\n * @param storage\n * @param args\n * @returns\n */\nasync function reviewStatusIdb(storage, args) {\n    const r = { log: '' };\n    // 1. set transactions to 'failed' if not already failed and provenTxReq with matching txid has status of 'invalid'.\n    const invalidTxids = [];\n    await storage.filterProvenTxReqs({ partial: { status: 'invalid' } }, txReq => {\n        invalidTxids.push(txReq.txid);\n    });\n    for (const txid of invalidTxids) {\n        const txs = await storage.findTransactions({ partial: { txid } });\n        for (const tx of txs) {\n            if (tx.status !== 'failed') {\n                r.log += `transaction ${tx.transactionId} updated to status of 'failed' was ${tx.status}\\n`;\n                await storage.updateTransactionStatus('failed', tx.transactionId);\n            }\n        }\n    }\n    // 2. sets transactions to 'completed' if provenTx with matching txid exists and current provenTxId is null.\n    // 3. sets outputs to spendable true, spentBy undefined if spentBy is a transaction with status 'failed'.\n    return r;\n}\n//# sourceMappingURL=reviewStatusIdb.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/reviewStatusIdb.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/utils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/utils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.varUintSize = varUintSize;\nexports.transactionInputSize = transactionInputSize;\nexports.transactionOutputSize = transactionOutputSize;\nexports.transactionSize = transactionSize;\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * Returns the byte size required to encode number as Bitcoin VarUint\n * @publicbody\n */\nfunction varUintSize(val) {\n    if (val < 0)\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('varUint', 'non-negative');\n    return val <= 0xfc ? 1 : val <= 0xffff ? 3 : val <= 0xffffffff ? 5 : 9;\n}\n/**\n * @param scriptSize byte length of input script\n * @returns serialized byte length a transaction input\n */\nfunction transactionInputSize(scriptSize) {\n    return (32 + // txid\n        4 + // vout\n        varUintSize(scriptSize) + // script length, this is already in bytes\n        scriptSize + // script\n        4); // sequence number\n}\n/**\n * @param scriptSize byte length of output script\n * @returns serialized byte length a transaction output\n */\nfunction transactionOutputSize(scriptSize) {\n    return (varUintSize(scriptSize) + // output script length, from script encoded as hex string\n        scriptSize + // output script\n        8); // output amount (satoshis)\n}\n/**\n * Compute the serialized binary transaction size in bytes\n * given the number of inputs and outputs,\n * and the size of each script.\n * @param inputs array of input script lengths, in bytes\n * @param outputs array of output script lengths, in bytes\n * @returns total transaction size in bytes\n */\nfunction transactionSize(inputs, outputs) {\n    return (4 + // Version\n        varUintSize(inputs.length) + // Number of inputs\n        inputs.reduce((a, e) => a + transactionInputSize(e), 0) + // all inputs\n        varUintSize(outputs.length) + // Number of outputs\n        outputs.reduce((a, e) => a + transactionOutputSize(e), 0) + // all outputs\n        4); // lock time\n}\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/methods/utils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageClient.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageClient.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageClient = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * `StorageClient` implements the `WalletStorageProvider` interface which allows it to\n * serve as a BRC-100 wallet's active storage.\n *\n * Internally, it uses JSON-RPC over HTTPS to make requests of a remote server.\n * Typically this server uses the `StorageServer` class to implement the service.\n *\n * The `AuthFetch` component is used to secure and authenticate the requests to the remote server.\n *\n * `AuthFetch` is initialized with a BRC-100 wallet which establishes the identity of\n * the party making requests of the remote service.\n *\n * For details of the API implemented, follow the \"See also\" link for the `WalletStorageProvider` interface.\n */\nclass StorageClient {\n    constructor(wallet, endpointUrl) {\n        this.nextId = 1;\n        this.authClient = new sdk_1.AuthFetch(wallet);\n        this.endpointUrl = endpointUrl;\n    }\n    /**\n     * The `StorageClient` implements the `WalletStorageProvider` interface.\n     * It does not implement the lower level `StorageProvider` interface.\n     *\n     * @returns false\n     */\n    isStorageProvider() {\n        return false;\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    // JSON-RPC helper\n    //////////////////////////////////////////////////////////////////////////////\n    /**\n     * Make a JSON-RPC call to the remote server.\n     * @param method The WalletStorage method name to call.\n     * @param params The array of parameters to pass to the method in order.\n     */\n    async rpcCall(method, params) {\n        try {\n            const id = this.nextId++;\n            const body = {\n                jsonrpc: '2.0',\n                method,\n                params,\n                id\n            };\n            let response;\n            try {\n                response = await this.authClient.fetch(this.endpointUrl, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify(body)\n                });\n            }\n            catch (eu) {\n                throw eu;\n            }\n            if (!response.ok) {\n                throw new Error(`WalletStorageClient rpcCall: network error ${response.status} ${response.statusText}`);\n            }\n            const json = await response.json();\n            if (json.error) {\n                const { code, message, data } = json.error;\n                const err = new Error(`RPC Error: ${message}`);\n                err.code = code;\n                err.data = data;\n                throw err;\n            }\n            return json.result;\n        }\n        catch (eu) {\n            throw eu;\n        }\n    }\n    /**\n     * @returns true once storage `TableSettings` have been retreived from remote storage.\n     */\n    isAvailable() {\n        // We'll just say \"yes\" if we have settings\n        return !!this.settings;\n    }\n    /**\n     * @returns remote storage `TableSettings` if they have been retreived by `makeAvailable`.\n     * @throws WERR_INVALID_OPERATION if `makeAvailable` has not yet been called.\n     */\n    getSettings() {\n        if (!this.settings) {\n            throw new index_client_1.sdk.WERR_INVALID_OPERATION('call makeAvailable at least once before getSettings');\n        }\n        return this.settings;\n    }\n    /**\n     * Must be called prior to making use of storage.\n     * Retreives `TableSettings` from remote storage provider.\n     * @returns remote storage `TableSettings`\n     */\n    async makeAvailable() {\n        if (!this.settings) {\n            this.settings = await this.rpcCall('makeAvailable', []);\n        }\n        return this.settings;\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    //\n    // Implementation of all WalletStorage interface methods\n    // They are simple pass-thrus to rpcCall\n    //\n    // IMPORTANT: The parameter ordering must match exactly as in your interface.\n    //////////////////////////////////////////////////////////////////////////////\n    /**\n     * Called to cleanup resources when no further use of this object will occur.\n     */\n    async destroy() {\n        return this.rpcCall('destroy', []);\n    }\n    /**\n     * Requests schema migration to latest.\n     * Typically remote storage will ignore this request.\n     * @param storageName Unique human readable name for remote storage if it does not yet exist.\n     * @param storageIdentityKey Unique identity key for remote storage if it does not yet exist.\n     * @returns current schema migration identifier\n     */\n    async migrate(storageName, storageIdentityKey) {\n        return this.rpcCall('migrate', [storageName]);\n    }\n    /**\n     * Remote storage does not offer `Services` to remote clients.\n     * @throws WERR_INVALID_OPERATION\n     */\n    getServices() {\n        // Typically, the client would not store or retrieve \"Services\" from a remote server.\n        // The \"services\" in local in-memory usage is a no-op or your own approach:\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('getServices() not implemented in remote client. This method typically is not used remotely.');\n    }\n    /**\n     * Ignored. Remote storage cannot share `Services` with remote clients.\n     */\n    setServices(v) {\n        // Typically no-op for remote client\n        // Because \"services\" are usually local definitions to the Storage.\n    }\n    /**\n     * Storage level processing for wallet `internalizeAction`.\n     * Updates internalized outputs in remote storage.\n     * Triggers proof validation of containing transaction.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Original wallet `internalizeAction` arguments.\n     * @returns `internalizeAction` results\n     */\n    async internalizeAction(auth, args) {\n        return this.rpcCall('internalizeAction', [auth, args]);\n    }\n    /**\n     * Storage level processing for wallet `createAction`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `createAction` arguments.\n     * @returns `StorageCreateActionResults` supporting additional wallet processing to yield `createAction` results.\n     */\n    async createAction(auth, args) {\n        return this.rpcCall('createAction', [auth, args]);\n    }\n    /**\n     * Storage level processing for wallet `createAction` and `signAction`.\n     *\n     * Handles remaining storage tasks once a fully signed transaction has been completed. This is common to both `createAction` and `signAction`.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `StorageProcessActionArgs` convey completed signed transaction to storage.\n     * @returns `StorageProcessActionResults` supporting final wallet processing to yield `createAction` or `signAction` results.\n     */\n    async processAction(auth, args) {\n        return this.rpcCall('processAction', [auth, args]);\n    }\n    /**\n     * Aborts an action by `reference` string.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `abortAction` args.\n     * @returns `abortAction` result.\n     */\n    async abortAction(auth, args) {\n        return this.rpcCall('abortAction', [auth, args]);\n    }\n    /**\n     * Used to both find and initialize a new user by identity key.\n     * It is up to the remote storage whether to allow creation of new users by this method.\n     * @param identityKey of the user.\n     * @returns `TableUser` for the user and whether a new user was created.\n     */\n    async findOrInsertUser(identityKey) {\n        return this.rpcCall('findOrInsertUser', [identityKey]);\n    }\n    /**\n     * Used to both find and insert a `TableSyncState` record for the user to track wallet data replication across storage providers.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param storageName the name of the remote storage being sync'd\n     * @param storageIdentityKey the identity key of the remote storage being sync'd\n     * @returns `TableSyncState` and whether a new record was created.\n     */\n    async findOrInsertSyncStateAuth(auth, storageIdentityKey, storageName) {\n        const r = await this.rpcCall('findOrInsertSyncStateAuth', [\n            auth,\n            storageIdentityKey,\n            storageName\n        ]);\n        r.syncState = this.validateEntity(r.syncState, ['when']);\n        return r;\n    }\n    /**\n     * Inserts a new certificate with fields and keyring into remote storage.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param certificate the certificate to insert.\n     * @returns record Id of the inserted `TableCertificate` record.\n     */\n    async insertCertificateAuth(auth, certificate) {\n        const r = await this.rpcCall('insertCertificateAuth', [auth, certificate]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listActions`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listActions` arguments.\n     * @returns `listActions` results.\n     */\n    async listActions(auth, vargs) {\n        const r = await this.rpcCall('listActions', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listOutputs`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listOutputs` arguments.\n     * @returns `listOutputs` results.\n     */\n    async listOutputs(auth, vargs) {\n        const r = await this.rpcCall('listOutputs', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listCertificates`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listCertificates` arguments.\n     * @returns `listCertificates` results.\n     */\n    async listCertificates(auth, vargs) {\n        const r = await this.rpcCall('listCertificates', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Find user certificates, optionally with fields.\n     *\n     * This certificate retrieval method supports internal wallet operations.\n     * Field values are stored and retrieved encrypted.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindCertificatesArgs` determines which certificates to retrieve and whether to include fields.\n     * @returns array of certificates matching args.\n     */\n    async findCertificatesAuth(auth, args) {\n        const r = await this.rpcCall('findCertificatesAuth', [auth, args]);\n        this.validateEntities(r);\n        if (args.includeFields) {\n            for (const c of r) {\n                if (c.fields)\n                    this.validateEntities(c.fields);\n            }\n        }\n        return r;\n    }\n    /**\n     * Find output baskets.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindOutputBasketsArgs` determines which baskets to retrieve.\n     * @returns array of output baskets matching args.\n     */\n    async findOutputBasketsAuth(auth, args) {\n        const r = await this.rpcCall('findOutputBaskets', [auth, args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Find outputs.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindOutputsArgs` determines which outputs to retrieve.\n     * @returns array of outputs matching args.\n     */\n    async findOutputsAuth(auth, args) {\n        const r = await this.rpcCall('findOutputsAuth', [auth, args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Find requests for transaction proofs.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindProvenTxReqsArgs` determines which proof requests to retrieve.\n     * @returns array of proof requests matching args.\n     */\n    async findProvenTxReqs(args) {\n        const r = await this.rpcCall('findProvenTxReqs', [args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Relinquish a certificate.\n     *\n     * For storage supporting replication records must be kept of deletions. Therefore certificates are marked as deleted\n     * when relinquished, and no longer returned by `listCertificates`, but are still retained by storage.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `relinquishCertificate` args.\n     */\n    async relinquishCertificate(auth, args) {\n        return this.rpcCall('relinquishCertificate', [auth, args]);\n    }\n    /**\n     * Relinquish an output.\n     *\n     * Relinquishing an output removes the output from whatever basket was tracking it.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `relinquishOutput` args.\n     */\n    async relinquishOutput(auth, args) {\n        return this.rpcCall('relinquishOutput', [auth, args]);\n    }\n    /**\n     * Process a \"chunk\" of replication data for the user.\n     *\n     * The normal data flow is for the active storage to push backups as a sequence of data chunks to backup storage providers.\n     *\n     * @param args a copy of the replication request args that initiated the sequence of data chunks.\n     * @param chunk the current data chunk to process.\n     * @returns whether processing is done, counts of inserts and udpates, and related progress tracking properties.\n     */\n    async processSyncChunk(args, chunk) {\n        const r = await this.rpcCall('processSyncChunk', [args, chunk]);\n        return r;\n    }\n    /**\n     * Request a \"chunk\" of replication data for a specific user and storage provider.\n     *\n     * The normal data flow is for the active storage to push backups as a sequence of data chunks to backup storage providers.\n     * Also supports recovery where non-active storage can attempt to merge available data prior to becoming active.\n     *\n     * @param args that identify the non-active storage which will receive replication data and constrains the replication process.\n     * @returns the next \"chunk\" of replication data\n     */\n    async getSyncChunk(args) {\n        const r = await this.rpcCall('getSyncChunk', [args]);\n        if (r.certificateFields)\n            r.certificateFields = this.validateEntities(r.certificateFields);\n        if (r.certificates)\n            r.certificates = this.validateEntities(r.certificates);\n        if (r.commissions)\n            r.commissions = this.validateEntities(r.commissions);\n        if (r.outputBaskets)\n            r.outputBaskets = this.validateEntities(r.outputBaskets);\n        if (r.outputTagMaps)\n            r.outputTagMaps = this.validateEntities(r.outputTagMaps);\n        if (r.outputTags)\n            r.outputTags = this.validateEntities(r.outputTags);\n        if (r.outputs)\n            r.outputs = this.validateEntities(r.outputs);\n        if (r.provenTxReqs)\n            r.provenTxReqs = this.validateEntities(r.provenTxReqs);\n        if (r.provenTxs)\n            r.provenTxs = this.validateEntities(r.provenTxs);\n        if (r.transactions)\n            r.transactions = this.validateEntities(r.transactions);\n        if (r.txLabelMaps)\n            r.txLabelMaps = this.validateEntities(r.txLabelMaps);\n        if (r.txLabels)\n            r.txLabels = this.validateEntities(r.txLabels);\n        if (r.user)\n            r.user = this.validateEntity(r.user);\n        return r;\n    }\n    /**\n     * Handles the data received when a new transaction proof is found in response to an outstanding request for proof data:\n     *\n     *   - Creates a new `TableProvenTx` record.\n     *   - Notifies all user transaction records of the new status.\n     *   - Updates the proof request record to 'completed' status which enables delayed deletion.\n     *\n     * @param args proof request and new transaction proof data\n     * @returns results of updates\n     */\n    async updateProvenTxReqWithNewProvenTx(args) {\n        const r = await this.rpcCall('updateProvenTxReqWithNewProvenTx', [args]);\n        return r;\n    }\n    /**\n     * Ensures up-to-date wallet data replication to all configured backup storage providers,\n     * then promotes one of the configured backups to active,\n     * demoting the current active to new backup.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param newActiveStorageIdentityKey which must be a currently configured backup storage provider.\n     */\n    async setActive(auth, newActiveStorageIdentityKey) {\n        return this.rpcCall('setActive', [auth, newActiveStorageIdentityKey]);\n    }\n    validateDate(date) {\n        let r;\n        if (date instanceof Date)\n            r = date;\n        else\n            r = new Date(date);\n        return r;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all individual records with time stamps retreived from database.\n     */\n    validateEntity(entity, dateFields) {\n        entity.created_at = this.validateDate(entity.created_at);\n        entity.updated_at = this.validateDate(entity.updated_at);\n        if (dateFields) {\n            for (const df of dateFields) {\n                if (entity[df])\n                    entity[df] = this.validateDate(entity[df]);\n            }\n        }\n        for (const key of Object.keys(entity)) {\n            const val = entity[key];\n            if (val === null) {\n                entity[key] = undefined;\n            }\n            else if (val instanceof Uint8Array) {\n                entity[key] = Array.from(val);\n            }\n        }\n        return entity;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all arrays of records with time stamps retreived from database.\n     * @returns input `entities` array with contained values validated.\n     */\n    validateEntities(entities, dateFields) {\n        for (let i = 0; i < entities.length; i++) {\n            entities[i] = this.validateEntity(entities[i], dateFields);\n        }\n        return entities;\n    }\n}\nexports.StorageClient = StorageClient;\n//# sourceMappingURL=StorageClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageMobile.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageMobile.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StorageClient = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_mobile_1 = __webpack_require__(/*! ../../index.mobile */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.mobile.js\");\n/**\n * `StorageClient` implements the `WalletStorageProvider` interface which allows it to\n * serve as a BRC-100 wallet's active storage.\n *\n * Internally, it uses JSON-RPC over HTTPS to make requests of a remote server.\n * Typically this server uses the `StorageServer` class to implement the service.\n *\n * The `AuthFetch` component is used to secure and authenticate the requests to the remote server.\n *\n * `AuthFetch` is initialized with a BRC-100 wallet which establishes the identity of\n * the party making requests of the remote service.\n *\n * For details of the API implemented, follow the \"See also\" link for the `WalletStorageProvider` interface.\n */\nclass StorageClient {\n    constructor(wallet, endpointUrl) {\n        this.nextId = 1;\n        this.authClient = new sdk_1.AuthFetch(wallet);\n        this.endpointUrl = endpointUrl;\n    }\n    /**\n     * The `StorageClient` implements the `WalletStorageProvider` interface.\n     * It does not implement the lower level `StorageProvider` interface.\n     *\n     * @returns false\n     */\n    isStorageProvider() {\n        return false;\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    // JSON-RPC helper\n    //////////////////////////////////////////////////////////////////////////////\n    /**\n     * Make a JSON-RPC call to the remote server.\n     * @param method The WalletStorage method name to call.\n     * @param params The array of parameters to pass to the method in order.\n     */\n    async rpcCall(method, params) {\n        try {\n            const id = this.nextId++;\n            const body = {\n                jsonrpc: '2.0',\n                method,\n                params,\n                id\n            };\n            let response;\n            try {\n                response = await this.authClient.fetch(this.endpointUrl, {\n                    method: 'POST',\n                    headers: { 'Content-Type': 'application/json' },\n                    body: JSON.stringify(body)\n                });\n            }\n            catch (eu) {\n                throw eu;\n            }\n            if (!response.ok) {\n                throw new Error(`WalletStorageClient rpcCall: network error ${response.status} ${response.statusText}`);\n            }\n            const json = await response.json();\n            if (json.error) {\n                const { code, message, data } = json.error;\n                const err = new Error(`RPC Error: ${message}`);\n                err.code = code;\n                err.data = data;\n                throw err;\n            }\n            return json.result;\n        }\n        catch (eu) {\n            throw eu;\n        }\n    }\n    /**\n     * @returns true once storage `TableSettings` have been retreived from remote storage.\n     */\n    isAvailable() {\n        // We'll just say \"yes\" if we have settings\n        return !!this.settings;\n    }\n    /**\n     * @returns remote storage `TableSettings` if they have been retreived by `makeAvailable`.\n     * @throws WERR_INVALID_OPERATION if `makeAvailable` has not yet been called.\n     */\n    getSettings() {\n        if (!this.settings) {\n            throw new index_mobile_1.sdk.WERR_INVALID_OPERATION('call makeAvailable at least once before getSettings');\n        }\n        return this.settings;\n    }\n    /**\n     * Must be called prior to making use of storage.\n     * Retreives `TableSettings` from remote storage provider.\n     * @returns remote storage `TableSettings`\n     */\n    async makeAvailable() {\n        if (!this.settings) {\n            this.settings = await this.rpcCall('makeAvailable', []);\n        }\n        return this.settings;\n    }\n    //////////////////////////////////////////////////////////////////////////////\n    //\n    // Implementation of all WalletStorage interface methods\n    // They are simple pass-thrus to rpcCall\n    //\n    // IMPORTANT: The parameter ordering must match exactly as in your interface.\n    //////////////////////////////////////////////////////////////////////////////\n    /**\n     * Called to cleanup resources when no further use of this object will occur.\n     */\n    async destroy() {\n        return this.rpcCall('destroy', []);\n    }\n    /**\n     * Requests schema migration to latest.\n     * Typically remote storage will ignore this request.\n     * @param storageName Unique human readable name for remote storage if it does not yet exist.\n     * @param storageIdentityKey Unique identity key for remote storage if it does not yet exist.\n     * @returns current schema migration identifier\n     */\n    async migrate(storageName, storageIdentityKey) {\n        return this.rpcCall('migrate', [storageName]);\n    }\n    /**\n     * Remote storage does not offer `Services` to remote clients.\n     * @throws WERR_INVALID_OPERATION\n     */\n    getServices() {\n        // Typically, the client would not store or retrieve \"Services\" from a remote server.\n        // The \"services\" in local in-memory usage is a no-op or your own approach:\n        throw new index_mobile_1.sdk.WERR_INVALID_OPERATION('getServices() not implemented in remote client. This method typically is not used remotely.');\n    }\n    /**\n     * Ignored. Remote storage cannot share `Services` with remote clients.\n     */\n    setServices(v) {\n        // Typically no-op for remote client\n        // Because \"services\" are usually local definitions to the Storage.\n    }\n    /**\n     * Storage level processing for wallet `internalizeAction`.\n     * Updates internalized outputs in remote storage.\n     * Triggers proof validation of containing transaction.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Original wallet `internalizeAction` arguments.\n     * @returns `internalizeAction` results\n     */\n    async internalizeAction(auth, args) {\n        return this.rpcCall('internalizeAction', [auth, args]);\n    }\n    /**\n     * Storage level processing for wallet `createAction`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `createAction` arguments.\n     * @returns `StorageCreateActionResults` supporting additional wallet processing to yield `createAction` results.\n     */\n    async createAction(auth, args) {\n        return this.rpcCall('createAction', [auth, args]);\n    }\n    /**\n     * Storage level processing for wallet `createAction` and `signAction`.\n     *\n     * Handles remaining storage tasks once a fully signed transaction has been completed. This is common to both `createAction` and `signAction`.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `StorageProcessActionArgs` convey completed signed transaction to storage.\n     * @returns `StorageProcessActionResults` supporting final wallet processing to yield `createAction` or `signAction` results.\n     */\n    async processAction(auth, args) {\n        return this.rpcCall('processAction', [auth, args]);\n    }\n    /**\n     * Aborts an action by `reference` string.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `abortAction` args.\n     * @returns `abortAction` result.\n     */\n    async abortAction(auth, args) {\n        return this.rpcCall('abortAction', [auth, args]);\n    }\n    /**\n     * Used to both find and initialize a new user by identity key.\n     * It is up to the remote storage whether to allow creation of new users by this method.\n     * @param identityKey of the user.\n     * @returns `TableUser` for the user and whether a new user was created.\n     */\n    async findOrInsertUser(identityKey) {\n        return this.rpcCall('findOrInsertUser', [identityKey]);\n    }\n    /**\n     * Used to both find and insert a `TableSyncState` record for the user to track wallet data replication across storage providers.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param storageName the name of the remote storage being sync'd\n     * @param storageIdentityKey the identity key of the remote storage being sync'd\n     * @returns `TableSyncState` and whether a new record was created.\n     */\n    async findOrInsertSyncStateAuth(auth, storageIdentityKey, storageName) {\n        const r = await this.rpcCall('findOrInsertSyncStateAuth', [\n            auth,\n            storageIdentityKey,\n            storageName\n        ]);\n        r.syncState = this.validateEntity(r.syncState, ['when']);\n        return r;\n    }\n    /**\n     * Inserts a new certificate with fields and keyring into remote storage.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param certificate the certificate to insert.\n     * @returns record Id of the inserted `TableCertificate` record.\n     */\n    async insertCertificateAuth(auth, certificate) {\n        const r = await this.rpcCall('insertCertificateAuth', [auth, certificate]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listActions`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listActions` arguments.\n     * @returns `listActions` results.\n     */\n    async listActions(auth, vargs) {\n        const r = await this.rpcCall('listActions', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listOutputs`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listOutputs` arguments.\n     * @returns `listOutputs` results.\n     */\n    async listOutputs(auth, vargs) {\n        const r = await this.rpcCall('listOutputs', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Storage level processing for wallet `listCertificates`.\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args Validated extension of original wallet `listCertificates` arguments.\n     * @returns `listCertificates` results.\n     */\n    async listCertificates(auth, vargs) {\n        const r = await this.rpcCall('listCertificates', [auth, vargs]);\n        return r;\n    }\n    /**\n     * Find user certificates, optionally with fields.\n     *\n     * This certificate retrieval method supports internal wallet operations.\n     * Field values are stored and retrieved encrypted.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindCertificatesArgs` determines which certificates to retrieve and whether to include fields.\n     * @returns array of certificates matching args.\n     */\n    async findCertificatesAuth(auth, args) {\n        const r = await this.rpcCall('findCertificatesAuth', [auth, args]);\n        this.validateEntities(r);\n        if (args.includeFields) {\n            for (const c of r) {\n                if (c.fields)\n                    this.validateEntities(c.fields);\n            }\n        }\n        return r;\n    }\n    /**\n     * Find output baskets.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindOutputBasketsArgs` determines which baskets to retrieve.\n     * @returns array of output baskets matching args.\n     */\n    async findOutputBasketsAuth(auth, args) {\n        const r = await this.rpcCall('findOutputBaskets', [auth, args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Find outputs.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindOutputsArgs` determines which outputs to retrieve.\n     * @returns array of outputs matching args.\n     */\n    async findOutputsAuth(auth, args) {\n        const r = await this.rpcCall('findOutputsAuth', [auth, args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Find requests for transaction proofs.\n     *\n     * This retrieval method supports internal wallet operations.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args `FindProvenTxReqsArgs` determines which proof requests to retrieve.\n     * @returns array of proof requests matching args.\n     */\n    async findProvenTxReqs(args) {\n        const r = await this.rpcCall('findProvenTxReqs', [args]);\n        this.validateEntities(r);\n        return r;\n    }\n    /**\n     * Relinquish a certificate.\n     *\n     * For storage supporting replication records must be kept of deletions. Therefore certificates are marked as deleted\n     * when relinquished, and no longer returned by `listCertificates`, but are still retained by storage.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `relinquishCertificate` args.\n     */\n    async relinquishCertificate(auth, args) {\n        return this.rpcCall('relinquishCertificate', [auth, args]);\n    }\n    /**\n     * Relinquish an output.\n     *\n     * Relinquishing an output removes the output from whatever basket was tracking it.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param args original wallet `relinquishOutput` args.\n     */\n    async relinquishOutput(auth, args) {\n        return this.rpcCall('relinquishOutput', [auth, args]);\n    }\n    /**\n     * Process a \"chunk\" of replication data for the user.\n     *\n     * The normal data flow is for the active storage to push backups as a sequence of data chunks to backup storage providers.\n     *\n     * @param args a copy of the replication request args that initiated the sequence of data chunks.\n     * @param chunk the current data chunk to process.\n     * @returns whether processing is done, counts of inserts and udpates, and related progress tracking properties.\n     */\n    async processSyncChunk(args, chunk) {\n        const r = await this.rpcCall('processSyncChunk', [args, chunk]);\n        return r;\n    }\n    /**\n     * Request a \"chunk\" of replication data for a specific user and storage provider.\n     *\n     * The normal data flow is for the active storage to push backups as a sequence of data chunks to backup storage providers.\n     * Also supports recovery where non-active storage can attempt to merge available data prior to becoming active.\n     *\n     * @param args that identify the non-active storage which will receive replication data and constrains the replication process.\n     * @returns the next \"chunk\" of replication data\n     */\n    async getSyncChunk(args) {\n        const r = await this.rpcCall('getSyncChunk', [args]);\n        if (r.certificateFields)\n            r.certificateFields = this.validateEntities(r.certificateFields);\n        if (r.certificates)\n            r.certificates = this.validateEntities(r.certificates);\n        if (r.commissions)\n            r.commissions = this.validateEntities(r.commissions);\n        if (r.outputBaskets)\n            r.outputBaskets = this.validateEntities(r.outputBaskets);\n        if (r.outputTagMaps)\n            r.outputTagMaps = this.validateEntities(r.outputTagMaps);\n        if (r.outputTags)\n            r.outputTags = this.validateEntities(r.outputTags);\n        if (r.outputs)\n            r.outputs = this.validateEntities(r.outputs);\n        if (r.provenTxReqs)\n            r.provenTxReqs = this.validateEntities(r.provenTxReqs);\n        if (r.provenTxs)\n            r.provenTxs = this.validateEntities(r.provenTxs);\n        if (r.transactions)\n            r.transactions = this.validateEntities(r.transactions);\n        if (r.txLabelMaps)\n            r.txLabelMaps = this.validateEntities(r.txLabelMaps);\n        if (r.txLabels)\n            r.txLabels = this.validateEntities(r.txLabels);\n        if (r.user)\n            r.user = this.validateEntity(r.user);\n        return r;\n    }\n    /**\n     * Handles the data received when a new transaction proof is found in response to an outstanding request for proof data:\n     *\n     *   - Creates a new `TableProvenTx` record.\n     *   - Notifies all user transaction records of the new status.\n     *   - Updates the proof request record to 'completed' status which enables delayed deletion.\n     *\n     * @param args proof request and new transaction proof data\n     * @returns results of updates\n     */\n    async updateProvenTxReqWithNewProvenTx(args) {\n        const r = await this.rpcCall('updateProvenTxReqWithNewProvenTx', [args]);\n        return r;\n    }\n    /**\n     * Ensures up-to-date wallet data replication to all configured backup storage providers,\n     * then promotes one of the configured backups to active,\n     * demoting the current active to new backup.\n     *\n     * @param auth Identifies client by identity key and the storage identity key of their currently active storage.\n     * This must match the `AuthFetch` identity securing the remote conneciton.\n     * @param newActiveStorageIdentityKey which must be a currently configured backup storage provider.\n     */\n    async setActive(auth, newActiveStorageIdentityKey) {\n        return this.rpcCall('setActive', [auth, newActiveStorageIdentityKey]);\n    }\n    validateDate(date) {\n        let r;\n        if (date instanceof Date)\n            r = date;\n        else\n            r = new Date(date);\n        return r;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all individual records with time stamps retreived from database.\n     */\n    validateEntity(entity, dateFields) {\n        entity.created_at = this.validateDate(entity.created_at);\n        entity.updated_at = this.validateDate(entity.updated_at);\n        if (dateFields) {\n            for (const df of dateFields) {\n                if (entity[df])\n                    entity[df] = this.validateDate(entity[df]);\n            }\n        }\n        for (const key of Object.keys(entity)) {\n            const val = entity[key];\n            if (val === null) {\n                entity[key] = undefined;\n            }\n            else if (val instanceof Uint8Array) {\n                entity[key] = Array.from(val);\n            }\n        }\n        return entity;\n    }\n    /**\n     * Helper to force uniform behavior across database engines.\n     * Use to process all arrays of records with time stamps retreived from database.\n     * @returns input `entities` array with contained values validated.\n     */\n    validateEntities(entities, dateFields) {\n        for (let i = 0; i < entities.length; i++) {\n            entities[i] = this.validateEntity(entities[i], dateFields);\n        }\n        return entities;\n    }\n}\nexports.StorageClient = StorageClient;\n//# sourceMappingURL=StorageMobile.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/remoting/StorageMobile.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityBase.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityBase.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityBase = void 0;\nexports.createSyncMap = createSyncMap;\nclass EntityBase {\n    constructor(api) {\n        this.api = api;\n    }\n    /**\n     * An entity may decode properties of the underlying Api object on construction.\n     *\n     * The `toApi` method forces an `updateApi` before returning the underlying,\n     * now updated, Api object.\n     *\n     * @returns The underlying Api object with any entity decoded properties updated.\n     */\n    toApi() {\n        this.updateApi();\n        return this.api;\n    }\n}\nexports.EntityBase = EntityBase;\nfunction createSyncMap() {\n    const r = {\n        provenTx: {\n            entityName: 'provenTx',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        outputBasket: {\n            entityName: 'outputBasket',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        transaction: {\n            entityName: 'transaction',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        provenTxReq: {\n            entityName: 'provenTxReq',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        txLabel: {\n            entityName: 'txLabel',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        txLabelMap: {\n            entityName: 'txLabelMap',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        output: {\n            entityName: 'output',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        outputTag: {\n            entityName: 'outputTag',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        outputTagMap: {\n            entityName: 'outputTagMap',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        certificate: {\n            entityName: 'certificate',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        certificateField: {\n            entityName: 'certificateField',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        },\n        commission: {\n            entityName: 'commission',\n            idMap: {},\n            maxUpdated_at: undefined,\n            count: 0\n        }\n    };\n    return r;\n}\n//# sourceMappingURL=EntityBase.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityBase.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificate.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificate.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityCertificate = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityCertificate extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            certificateId: 0,\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            type: '',\n            subject: '',\n            verifier: undefined,\n            serialNumber: '',\n            certifier: '',\n            revocationOutpoint: '',\n            signature: '',\n            isDeleted: false\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get certificateId() {\n        return this.api.certificateId;\n    }\n    set certificateId(v) {\n        this.api.certificateId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get type() {\n        return this.api.type;\n    }\n    set type(v) {\n        this.api.type = v;\n    }\n    get subject() {\n        return this.api.subject;\n    }\n    set subject(v) {\n        this.api.subject = v;\n    }\n    get verifier() {\n        return this.api.verifier;\n    }\n    set verifier(v) {\n        this.api.verifier = v;\n    }\n    get serialNumber() {\n        return this.api.serialNumber;\n    }\n    set serialNumber(v) {\n        this.api.serialNumber = v;\n    }\n    get certifier() {\n        return this.api.certifier;\n    }\n    set certifier(v) {\n        this.api.certifier = v;\n    }\n    get revocationOutpoint() {\n        return this.api.revocationOutpoint;\n    }\n    set revocationOutpoint(v) {\n        this.api.revocationOutpoint = v;\n    }\n    get signature() {\n        return this.api.signature;\n    }\n    set signature(v) {\n        this.api.signature = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    //get fields() { return this.api.fields }\n    //set fields(v: Record<string, string> | undefined) { this.api.fields = v }\n    get id() {\n        return this.api.certificateId;\n    }\n    set id(v) {\n        this.api.certificateId = v;\n    }\n    get entityName() {\n        return 'certificate';\n    }\n    get entityTable() {\n        return 'certificates';\n    }\n    equals(ei, syncMap) {\n        if (this.type !== ei.type ||\n            this.subject !== ei.subject ||\n            this.serialNumber !== ei.serialNumber ||\n            this.revocationOutpoint !== ei.revocationOutpoint ||\n            this.signature !== ei.signature ||\n            this.verifier !== ei.verifier ||\n            this.isDeleted !== ei.isDeleted)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findCertificates({\n            partial: {\n                serialNumber: ei.serialNumber,\n                certifier: ei.certifier,\n                userId\n            },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityCertificate(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.certificateId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.userId = userId;\n        this.certificateId = 0;\n        this.certificateId = await storage.insertCertificate(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.type = ei.type;\n            this.subject = ei.subject;\n            this.serialNumber = ei.serialNumber;\n            this.revocationOutpoint = ei.revocationOutpoint;\n            this.signature = ei.signature;\n            this.verifier = ei.verifier;\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateCertificate(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityCertificate = EntityCertificate;\n//# sourceMappingURL=EntityCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificateField.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificateField.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityCertificateField = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityCertificateField extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            certificateId: 0,\n            fieldName: '',\n            fieldValue: '',\n            masterKey: ''\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get certificateId() {\n        return this.api.certificateId;\n    }\n    set certificateId(v) {\n        this.api.certificateId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get fieldName() {\n        return this.api.fieldName;\n    }\n    set fieldName(v) {\n        this.api.fieldName = v;\n    }\n    get fieldValue() {\n        return this.api.fieldValue;\n    }\n    set fieldValue(v) {\n        this.api.fieldValue = v;\n    }\n    get masterKey() {\n        return this.api.masterKey;\n    }\n    set masterKey(v) {\n        this.api.masterKey = v;\n    }\n    get id() {\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('entity has no \"id\" value');\n    }\n    get entityName() {\n        return 'certificateField';\n    }\n    get entityTable() {\n        return 'certificate_fields';\n    }\n    equals(ei, syncMap) {\n        if (this.certificateId !== (syncMap ? syncMap.certificate.idMap[ei.certificateId] : ei.certificateId) ||\n            this.fieldName !== ei.fieldName ||\n            this.fieldValue !== ei.fieldValue ||\n            this.masterKey !== ei.masterKey)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const certificateId = syncMap.certificate.idMap[ei.certificateId];\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findCertificateFields({\n            partial: { certificateId, userId, fieldName: ei.fieldName },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityCertificateField(ef || { ...ei }),\n            eiId: -1\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.certificateId = syncMap.certificate.idMap[this.certificateId];\n        this.userId = userId;\n        await storage.insertCertificateField(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.fieldValue = ei.fieldValue;\n            this.masterKey = ei.masterKey;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateCertificateField(this.certificateId, this.fieldName, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityCertificateField = EntityCertificateField;\n//# sourceMappingURL=EntityCertificateField.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificateField.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCommission.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCommission.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityCommission = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityCommission extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            commissionId: 0,\n            created_at: now,\n            updated_at: now,\n            transactionId: 0,\n            userId: 0,\n            isRedeemed: false,\n            keyOffset: '',\n            lockingScript: [],\n            satoshis: 0\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get commissionId() {\n        return this.api.commissionId;\n    }\n    set commissionId(v) {\n        this.api.commissionId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get transactionId() {\n        return this.api.transactionId;\n    }\n    set transactionId(v) {\n        this.api.transactionId = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get isRedeemed() {\n        return this.api.isRedeemed;\n    }\n    set isRedeemed(v) {\n        this.api.isRedeemed = v;\n    }\n    get keyOffset() {\n        return this.api.keyOffset;\n    }\n    set keyOffset(v) {\n        this.api.keyOffset = v;\n    }\n    get lockingScript() {\n        return this.api.lockingScript;\n    }\n    set lockingScript(v) {\n        this.api.lockingScript = v;\n    }\n    get satoshis() {\n        return this.api.satoshis;\n    }\n    set satoshis(v) {\n        this.api.satoshis = v;\n    }\n    get id() {\n        return this.api.commissionId;\n    }\n    set id(v) {\n        this.api.commissionId = v;\n    }\n    get entityName() {\n        return 'commission';\n    }\n    get entityTable() {\n        return 'commissions';\n    }\n    equals(ei, syncMap) {\n        if (this.isRedeemed !== ei.isRedeemed ||\n            this.transactionId !== (syncMap ? syncMap.transaction.idMap[ei.transactionId] : ei.transactionId) ||\n            this.keyOffset !== ei.keyOffset ||\n            !(0, index_client_1.arraysEqual)(this.lockingScript, ei.lockingScript) ||\n            this.satoshis !== ei.satoshis)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const transactionId = syncMap.transaction.idMap[ei.transactionId];\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findCommissions({ partial: { transactionId, userId }, trx }));\n        return {\n            found: !!ef,\n            eo: new EntityCommission(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.commissionId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        if (this.transactionId)\n            this.transactionId = syncMap.transaction.idMap[this.transactionId];\n        this.userId = userId;\n        this.commissionId = 0;\n        this.commissionId = await storage.insertCommission(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.isRedeemed = ei.isRedeemed;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateCommission(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityCommission = EntityCommission;\n//# sourceMappingURL=EntityCommission.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCommission.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutput.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutput.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityOutput = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityOutput extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            outputId: 0,\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            transactionId: 0,\n            spendable: false,\n            change: false,\n            satoshis: 0,\n            outputDescription: '',\n            vout: 0,\n            type: '',\n            providedBy: 'you',\n            purpose: '',\n            txid: undefined,\n            basketId: undefined,\n            spentBy: undefined,\n            derivationPrefix: undefined,\n            derivationSuffix: undefined,\n            senderIdentityKey: undefined,\n            customInstructions: undefined,\n            spendingDescription: undefined,\n            scriptLength: undefined,\n            scriptOffset: undefined,\n            lockingScript: undefined\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get outputId() {\n        return this.api.outputId;\n    }\n    set outputId(v) {\n        this.api.outputId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get transactionId() {\n        return this.api.transactionId;\n    }\n    set transactionId(v) {\n        this.api.transactionId = v;\n    }\n    get basketId() {\n        return this.api.basketId;\n    }\n    set basketId(v) {\n        this.api.basketId = v;\n    }\n    get spentBy() {\n        return this.api.spentBy;\n    }\n    set spentBy(v) {\n        this.api.spentBy = v;\n    }\n    get vout() {\n        return this.api.vout;\n    }\n    set vout(v) {\n        this.api.vout = v;\n    }\n    get satoshis() {\n        return this.api.satoshis;\n    }\n    set satoshis(v) {\n        this.api.satoshis = v;\n    }\n    get outputDescription() {\n        return this.api.outputDescription;\n    }\n    set outputDescription(v) {\n        this.api.outputDescription = v;\n    }\n    get spendable() {\n        return this.api.spendable;\n    }\n    set spendable(v) {\n        this.api.spendable = v;\n    }\n    get change() {\n        return this.api.change;\n    }\n    set change(v) {\n        this.api.change = v;\n    }\n    get txid() {\n        return this.api.txid;\n    }\n    set txid(v) {\n        this.api.txid = v;\n    }\n    get type() {\n        return this.api.type;\n    }\n    set type(v) {\n        this.api.type = v;\n    }\n    get providedBy() {\n        return this.api.providedBy;\n    }\n    set providedBy(v) {\n        this.api.providedBy = v;\n    }\n    get purpose() {\n        return this.api.purpose;\n    }\n    set purpose(v) {\n        this.api.purpose = v;\n    }\n    get spendingDescription() {\n        return this.api.spendingDescription;\n    }\n    set spendingDescription(v) {\n        this.api.spendingDescription = v;\n    }\n    get derivationPrefix() {\n        return this.api.derivationPrefix;\n    }\n    set derivationPrefix(v) {\n        this.api.derivationPrefix = v;\n    }\n    get derivationSuffix() {\n        return this.api.derivationSuffix;\n    }\n    set derivationSuffix(v) {\n        this.api.derivationSuffix = v;\n    }\n    get senderIdentityKey() {\n        return this.api.senderIdentityKey;\n    }\n    set senderIdentityKey(v) {\n        this.api.senderIdentityKey = v;\n    }\n    get customInstructions() {\n        return this.api.customInstructions;\n    }\n    set customInstructions(v) {\n        this.api.customInstructions = v;\n    }\n    get lockingScript() {\n        return this.api.lockingScript;\n    }\n    set lockingScript(v) {\n        this.api.lockingScript = v;\n    }\n    get scriptLength() {\n        return this.api.scriptLength;\n    }\n    set scriptLength(v) {\n        this.api.scriptLength = v;\n    }\n    get scriptOffset() {\n        return this.api.scriptOffset;\n    }\n    set scriptOffset(v) {\n        this.api.scriptOffset = v;\n    }\n    get id() {\n        return this.api.outputId;\n    }\n    set id(v) {\n        this.api.outputId = v;\n    }\n    get entityName() {\n        return 'output';\n    }\n    get entityTable() {\n        return 'outputs';\n    }\n    equals(ei, syncMap) {\n        if (this.transactionId !== (syncMap ? syncMap.transaction.idMap[ei.transactionId] : ei.transactionId) ||\n            this.basketId !== (syncMap && ei.basketId ? syncMap.outputBasket.idMap[ei.basketId] : ei.basketId) ||\n            this.spentBy !== (syncMap && ei.spentBy ? syncMap.transaction.idMap[ei.spentBy] : ei.spentBy) ||\n            this.vout !== ei.vout ||\n            this.satoshis !== ei.satoshis ||\n            this.spendable !== ei.spendable ||\n            this.change !== ei.change ||\n            this.txid !== ei.txid ||\n            this.type !== ei.type ||\n            this.providedBy !== ei.providedBy ||\n            this.purpose !== ei.purpose ||\n            this.outputDescription !== ei.outputDescription ||\n            this.spendingDescription !== ei.spendingDescription ||\n            this.derivationPrefix !== ei.derivationPrefix ||\n            this.derivationSuffix !== ei.derivationSuffix ||\n            this.senderIdentityKey !== ei.senderIdentityKey ||\n            this.customInstructions !== ei.customInstructions ||\n            !(0, index_client_1.optionalArraysEqual)(this.lockingScript, ei.lockingScript) ||\n            this.scriptLength !== ei.scriptLength ||\n            this.scriptOffset !== ei.scriptOffset)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const transactionId = syncMap.transaction.idMap[ei.transactionId];\n        const basketId = ei.basketId ? syncMap.outputBasket.idMap[ei.basketId] : null;\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findOutputs({\n            partial: { userId, transactionId, vout: ei.vout },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityOutput(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.outputId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.userId = userId;\n        this.basketId = this.basketId ? syncMap.outputBasket.idMap[this.basketId] : undefined;\n        this.transactionId = syncMap.transaction.idMap[this.transactionId];\n        this.spentBy = this.spentBy ? syncMap.transaction.idMap[this.spentBy] : undefined;\n        this.outputId = 0;\n        this.outputId = await storage.insertOutput(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.spentBy = ei.spentBy ? syncMap.transaction.idMap[ei.spentBy] : undefined;\n            this.spendable = ei.spendable;\n            this.change = ei.change;\n            this.type = ei.type;\n            this.providedBy = ei.providedBy;\n            this.purpose = ei.purpose;\n            this.outputDescription = ei.outputDescription;\n            this.spendingDescription = ei.spendingDescription;\n            this.senderIdentityKey = ei.senderIdentityKey;\n            this.customInstructions = ei.customInstructions;\n            this.scriptLength = ei.scriptLength;\n            this.scriptOffset = ei.scriptOffset;\n            this.lockingScript = ei.lockingScript;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateOutput(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityOutput = EntityOutput;\n//# sourceMappingURL=EntityOutput.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutput.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputBasket.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputBasket.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityOutputBasket = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityOutputBasket extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            basketId: 0,\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            name: '',\n            numberOfDesiredUTXOs: 0,\n            minimumDesiredUTXOValue: 0,\n            isDeleted: false\n        });\n    }\n    get basketId() {\n        return this.api.basketId;\n    }\n    set basketId(v) {\n        this.api.basketId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get name() {\n        return this.api.name;\n    }\n    set name(v) {\n        this.api.name = v;\n    }\n    get numberOfDesiredUTXOs() {\n        return this.api.numberOfDesiredUTXOs;\n    }\n    set numberOfDesiredUTXOs(v) {\n        this.api.numberOfDesiredUTXOs = v;\n    }\n    get minimumDesiredUTXOValue() {\n        return this.api.minimumDesiredUTXOValue;\n    }\n    set minimumDesiredUTXOValue(v) {\n        this.api.minimumDesiredUTXOValue = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    get id() {\n        return this.api.basketId;\n    }\n    set id(v) {\n        this.api.basketId = v;\n    }\n    get entityName() {\n        return 'outputBasket';\n    }\n    get entityTable() {\n        return 'output_baskets';\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    equals(ei, syncMap) {\n        const eo = this.api;\n        if (eo.name != ei.name ||\n            eo.numberOfDesiredUTXOs != ei.numberOfDesiredUTXOs ||\n            eo.minimumDesiredUTXOValue != ei.minimumDesiredUTXOValue)\n            return false;\n        if (syncMap) {\n            if (eo.basketId !== syncMap.outputBasket.idMap[(0, index_client_1.verifyId)(ei.basketId)])\n                return false;\n        }\n        else {\n            if (eo.basketId !== ei.basketId || eo.userId !== ei.userId)\n                return false;\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findOutputBaskets({\n            partial: { name: ei.name, userId },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityOutputBasket(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.basketId)\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.userId = userId;\n        this.name || (this.name = 'default');\n        this.basketId = 0;\n        this.basketId = await storage.insertOutputBasket(this.toApi(), trx);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            // basket name is its identity, should not change\n            this.minimumDesiredUTXOValue = ei.minimumDesiredUTXOValue;\n            this.numberOfDesiredUTXOs = ei.numberOfDesiredUTXOs;\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateOutputBasket(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityOutputBasket = EntityOutputBasket;\n//# sourceMappingURL=EntityOutputBasket.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputBasket.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTag.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTag.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityOutputTag = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityOutputTag extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            outputTagId: 0,\n            created_at: now,\n            updated_at: now,\n            tag: '',\n            userId: 0,\n            isDeleted: false\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get outputTagId() {\n        return this.api.outputTagId;\n    }\n    set outputTagId(v) {\n        this.api.outputTagId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get tag() {\n        return this.api.tag;\n    }\n    set tag(v) {\n        this.api.tag = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    get id() {\n        return this.api.outputTagId;\n    }\n    set id(v) {\n        this.api.outputTagId = v;\n    }\n    get entityName() {\n        return 'outputTag';\n    }\n    get entityTable() {\n        return 'output_tags';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.tag != ei.tag || eo.isDeleted != ei.isDeleted)\n            return false;\n        if (!syncMap) {\n            if (eo.userId !== ei.userId)\n                return false;\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findOutputTags({ partial: { tag: ei.tag, userId }, trx }));\n        return {\n            found: !!ef,\n            eo: new EntityOutputTag(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.outputTagId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.userId = userId;\n        this.outputTagId = 0;\n        this.outputTagId = await storage.insertOutputTag(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateOutputTag(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityOutputTag = EntityOutputTag;\n//# sourceMappingURL=EntityOutputTag.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTag.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTagMap.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTagMap.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityOutputTagMap = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityOutputTagMap extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            created_at: now,\n            updated_at: now,\n            outputId: 0,\n            outputTagId: 0,\n            isDeleted: false\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get outputTagId() {\n        return this.api.outputTagId;\n    }\n    set outputTagId(v) {\n        this.api.outputTagId = v;\n    }\n    get outputId() {\n        return this.api.outputId;\n    }\n    set outputId(v) {\n        this.api.outputId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    get id() {\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('entity has no \"id\" value');\n    }\n    get entityName() {\n        return 'outputTagMap';\n    }\n    get entityTable() {\n        return 'output_tags_map';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.outputId !== (syncMap ? syncMap.output.idMap[(0, index_client_1.verifyId)(ei.outputId)] : ei.outputId) ||\n            eo.outputTagId !== (syncMap ? syncMap.outputTag.idMap[(0, index_client_1.verifyId)(ei.outputTagId)] : ei.outputTagId) ||\n            eo.isDeleted !== ei.isDeleted)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const outputId = syncMap.output.idMap[ei.outputId];\n        const outputTagId = syncMap.outputTag.idMap[ei.outputTagId];\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findOutputTagMaps({\n            partial: { outputId, outputTagId },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityOutputTagMap(ef || { ...ei }),\n            eiId: -1\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.outputId = syncMap.output.idMap[this.outputId];\n        this.outputTagId = syncMap.outputTag.idMap[this.outputTagId];\n        await storage.insertOutputTagMap(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateOutputTagMap(this.outputId, this.outputTagId, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityOutputTagMap = EntityOutputTagMap;\n//# sourceMappingURL=EntityOutputTagMap.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTagMap.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTx.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTx.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityProvenTx = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityProvenTx extends _1.EntityBase {\n    /**\n     * Given a txid and optionally its rawTx, create a new ProvenTx object.\n     *\n     * rawTx is fetched if not provided.\n     *\n     * Only succeeds (proven is not undefined) if a proof is confirmed for rawTx,\n     * and hash of rawTx is confirmed to match txid\n     *\n     * The returned ProvenTx and ProvenTxReq objects have not been added to the storage database,\n     * this is optional and can be done by the caller if appropriate.\n     *\n     * @param txid\n     * @param services\n     * @param rawTx\n     * @returns\n     */\n    static async fromTxid(txid, services, rawTx) {\n        var _a;\n        const r = { proven: undefined, rawTx };\n        const chain = services.chain;\n        if (!r.rawTx) {\n            const gr = await services.getRawTx(txid);\n            if (!(gr === null || gr === void 0 ? void 0 : gr.rawTx))\n                // Failing to find anything...\n                return r;\n            r.rawTx = gr.rawTx;\n        }\n        const gmpr = await services.getMerklePath(txid);\n        if (gmpr.merklePath && gmpr.header) {\n            const index = (_a = gmpr.merklePath.path[0].find(l => l.hash === txid)) === null || _a === void 0 ? void 0 : _a.offset;\n            if (index !== undefined) {\n                const api = {\n                    created_at: new Date(),\n                    updated_at: new Date(),\n                    provenTxId: 0,\n                    txid,\n                    height: gmpr.header.height,\n                    index,\n                    merklePath: gmpr.merklePath.toBinary(),\n                    rawTx: r.rawTx,\n                    blockHash: gmpr.header.hash,\n                    merkleRoot: gmpr.header.merkleRoot\n                };\n                r.proven = new EntityProvenTx(api);\n            }\n        }\n        return r;\n    }\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            provenTxId: 0,\n            created_at: now,\n            updated_at: now,\n            txid: '',\n            height: 0,\n            index: 0,\n            merklePath: [],\n            rawTx: [],\n            blockHash: '',\n            merkleRoot: ''\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    /**\n     * @returns desirialized `MerklePath` object, value is cached.\n     */\n    getMerklePath() {\n        if (!this._mp)\n            this._mp = sdk_1.MerklePath.fromBinary(this.api.merklePath);\n        return this._mp;\n    }\n    get provenTxId() {\n        return this.api.provenTxId;\n    }\n    set provenTxId(v) {\n        this.api.provenTxId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get txid() {\n        return this.api.txid;\n    }\n    set txid(v) {\n        this.api.txid = v;\n    }\n    get height() {\n        return this.api.height;\n    }\n    set height(v) {\n        this.api.height = v;\n    }\n    get index() {\n        return this.api.index;\n    }\n    set index(v) {\n        this.api.index = v;\n    }\n    get merklePath() {\n        return this.api.merklePath;\n    }\n    set merklePath(v) {\n        this.api.merklePath = v;\n    }\n    get rawTx() {\n        return this.api.rawTx;\n    }\n    set rawTx(v) {\n        this.api.rawTx = v;\n    }\n    get blockHash() {\n        return this.api.blockHash;\n    }\n    set blockHash(v) {\n        this.api.blockHash = v;\n    }\n    get merkleRoot() {\n        return this.api.merkleRoot;\n    }\n    set merkleRoot(v) {\n        this.api.merkleRoot = v;\n    }\n    get id() {\n        return this.api.provenTxId;\n    }\n    set id(v) {\n        this.api.provenTxId = v;\n    }\n    get entityName() {\n        return 'provenTx';\n    }\n    get entityTable() {\n        return 'proven_txs';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.txid != ei.txid ||\n            eo.height != ei.height ||\n            eo.index != ei.index ||\n            !(0, index_client_1.arraysEqual)(eo.merklePath, ei.merklePath) ||\n            !(0, index_client_1.arraysEqual)(eo.rawTx, ei.rawTx) ||\n            eo.blockHash !== ei.blockHash ||\n            eo.merkleRoot !== ei.merkleRoot\n        // equality does not depend on timestamps.\n        // || eo.created_at !== ei.created_at\n        // || eo.updated_at !== ei.updated_at\n        )\n            return false;\n        if (syncMap) {\n            if (eo.provenTxId !== syncMap.provenTx.idMap[ei.provenTxId])\n                return false;\n        }\n        else {\n            if (eo.provenTxId !== ei.provenTxId)\n                return false;\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxs({ partial: { txid: ei.txid }, trx }));\n        return {\n            found: !!ef,\n            eo: new EntityProvenTx(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.provenTxId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.provenTxId = 0;\n        // TODO: Since these records are a shared resource, the record must be validated before accepting it...\n        this.provenTxId = await storage.insertProvenTx(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        // ProvenTxs are never updated.\n        return false;\n    }\n    /**\n     * Try to create a new ProvenTx from a ProvenTxReq and GetMerkleProofResultApi\n     *\n     * Otherwise it returns undefined and updates req.status to either 'unknown', 'invalid', or 'unconfirmed'\n     *\n     * @param req\n     * @param gmpResult\n     * @returns\n     */\n    static async fromReq(req, gmpResult, countsAsAttempt) {\n        if (!req.txid)\n            throw new index_client_1.sdk.WERR_MISSING_PARAMETER('req.txid');\n        if (!req.rawTx)\n            throw new index_client_1.sdk.WERR_MISSING_PARAMETER('req.rawTx');\n        if (!req.rawTx)\n            throw new index_client_1.sdk.WERR_INTERNAL('rawTx must be valid');\n        for (const note of gmpResult.notes || []) {\n            req.addHistoryNote(note, true);\n        }\n        if (!gmpResult.name && !gmpResult.merklePath && !gmpResult.error) {\n            // Most likely offline or now services configured.\n            // Does not count as a proof attempt.\n            return undefined;\n        }\n        if (!gmpResult.merklePath) {\n            if (req.created_at) {\n                const ageInMsecs = Date.now() - req.created_at.getTime();\n                const ageInMinutes = Math.ceil(ageInMsecs < 1 ? 0 : ageInMsecs / (1000 * 60));\n                if (req.attempts > EntityProvenTx.getProofAttemptsLimit && ageInMinutes > EntityProvenTx.getProofMinutes) {\n                    // Start the process of setting transactions to 'failed'\n                    const limit = EntityProvenTx.getProofAttemptsLimit;\n                    const { attempts } = req;\n                    req.addHistoryNote({ what: 'getMerklePathGiveUp', attempts, limit, ageInMinutes }, true);\n                    req.notified = false;\n                    req.status = 'invalid';\n                }\n            }\n            return undefined;\n        }\n        if (countsAsAttempt)\n            req.attempts++;\n        const merklePaths = Array.isArray(gmpResult.merklePath) ? gmpResult.merklePath : [gmpResult.merklePath];\n        for (const proof of merklePaths) {\n            try {\n                const now = new Date();\n                const leaf = proof.path[0].find(leaf => leaf.txid === true && leaf.hash === req.txid);\n                if (!leaf) {\n                    req.addHistoryNote({ what: 'getMerklePathTxidNotFound' }, true);\n                    throw new index_client_1.sdk.WERR_INTERNAL('merkle path does not contain leaf for txid');\n                }\n                const proven = new EntityProvenTx({\n                    created_at: now,\n                    updated_at: now,\n                    provenTxId: 0,\n                    txid: req.txid,\n                    height: proof.blockHeight,\n                    index: leaf.offset,\n                    merklePath: proof.toBinary(),\n                    rawTx: req.rawTx,\n                    merkleRoot: gmpResult.header.merkleRoot,\n                    blockHash: gmpResult.header.hash\n                });\n                return proven;\n            }\n            catch (eu) {\n                const { code, description } = index_client_1.sdk.WalletError.fromUnknown(eu);\n                const { attempts } = req;\n                req.addHistoryNote({ what: 'getMerklePathProvenError', attempts, code, description }, true);\n            }\n        }\n    }\n}\nexports.EntityProvenTx = EntityProvenTx;\n/**\n * How high attempts can go before status is forced to invalid\n */\nEntityProvenTx.getProofAttemptsLimit = 8;\n/**\n * How many hours we have to try for a poof\n */\nEntityProvenTx.getProofMinutes = 60;\n//# sourceMappingURL=EntityProvenTx.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTx.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTxReq.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTxReq.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityProvenTxReq = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityProvenTxReq extends _1.EntityBase {\n    static async fromStorageTxid(storage, txid, trx) {\n        const reqApi = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxReqs({ partial: { txid }, trx }));\n        if (!reqApi)\n            return undefined;\n        return new EntityProvenTxReq(reqApi);\n    }\n    static async fromStorageId(storage, id, trx) {\n        const reqApi = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxReqs({ partial: { provenTxReqId: id }, trx }));\n        if (!reqApi)\n            throw new index_client_1.sdk.WERR_INTERNAL(`proven_tx_reqs with id ${id} is missing.`);\n        return new EntityProvenTxReq(reqApi);\n    }\n    static fromTxid(txid, rawTx, inputBEEF) {\n        const now = new Date();\n        return new EntityProvenTxReq({\n            provenTxReqId: 0,\n            created_at: now,\n            updated_at: now,\n            txid,\n            inputBEEF,\n            rawTx,\n            status: 'unknown',\n            history: '{}',\n            notify: '{}',\n            attempts: 0,\n            notified: false\n        });\n    }\n    packApiHistory() {\n        this.api.history = JSON.stringify(this.history);\n    }\n    packApiNotify() {\n        this.api.notify = JSON.stringify(this.notify);\n    }\n    unpackApiHistory() {\n        this.history = JSON.parse(this.api.history);\n    }\n    unpackApiNotify() {\n        this.notify = JSON.parse(this.api.notify);\n    }\n    get apiHistory() {\n        this.packApiHistory();\n        return this.api.history;\n    }\n    get apiNotify() {\n        this.packApiNotify();\n        return this.api.notify;\n    }\n    set apiHistory(v) {\n        this.api.history = v;\n        this.unpackApiHistory();\n    }\n    set apiNotify(v) {\n        this.api.notify = v;\n        this.unpackApiNotify();\n    }\n    updateApi() {\n        this.packApiHistory();\n        this.packApiNotify();\n    }\n    unpackApi() {\n        this.unpackApiHistory();\n        this.unpackApiNotify();\n        if (this.notify.transactionIds) {\n            // Cleanup null values and duplicates.\n            const transactionIds = [];\n            for (const id of this.notify.transactionIds) {\n                if (Number.isInteger(id) && !transactionIds.some(txid => txid === id))\n                    transactionIds.push(id);\n            }\n            this.notify.transactionIds = transactionIds;\n        }\n    }\n    async refreshFromStorage(storage, trx) {\n        const newApi = (0, index_client_1.verifyOne)(await storage.findProvenTxReqs({ partial: { provenTxReqId: this.id }, trx }));\n        this.api = newApi;\n        this.unpackApi();\n    }\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            provenTxReqId: 0,\n            created_at: now,\n            updated_at: now,\n            txid: '',\n            rawTx: [],\n            history: '',\n            notify: '',\n            attempts: 0,\n            status: 'unknown',\n            notified: false\n        });\n        this.history = {};\n        this.notify = {};\n        this.unpackApi();\n    }\n    /**\n     * Returns history to only what followed since date.\n     */\n    historySince(since) {\n        const fh = { notes: [] };\n        const filter = since.toISOString();\n        const notes = this.history.notes;\n        if (notes && fh.notes) {\n            for (const note of notes)\n                if (note.when && note.when > filter)\n                    fh.notes.push(note);\n        }\n        return fh;\n    }\n    historyPretty(since, indent = 0) {\n        const h = since ? this.historySince(since) : { ...this.history };\n        if (!h.notes)\n            return '';\n        const whenLimit = since ? since.toISOString() : undefined;\n        let log = '';\n        for (const note of h.notes) {\n            if (whenLimit && note.when && note.when < whenLimit)\n                continue;\n            log += this.prettyNote(note) + '\\n';\n        }\n        return log;\n    }\n    prettyNote(note) {\n        let log = `${note.when}: ${note.what}`;\n        for (const [key, val] of Object.entries(note)) {\n            if (key !== 'when' && key !== 'what') {\n                if (typeof val === 'string')\n                    log += ' ' + key + ':`' + val + '`';\n                else\n                    log += ' ' + key + ':' + val;\n            }\n        }\n        return log;\n    }\n    getHistorySummary() {\n        const summary = {\n            setToCompleted: false,\n            setToUnmined: false,\n            setToCallback: false,\n            setToDoubleSpend: false,\n            setToSending: false,\n            setToUnconfirmed: false\n        };\n        const h = this.history;\n        if (h.notes) {\n            for (const note of h.notes) {\n                this.parseHistoryNote(note, summary);\n            }\n        }\n        return summary;\n    }\n    parseHistoryNote(note, summary) {\n        const c = summary || {\n            setToCompleted: false,\n            setToUnmined: false,\n            setToCallback: false,\n            setToDoubleSpend: false,\n            setToSending: false,\n            setToUnconfirmed: false\n        };\n        let n = this.prettyNote(note);\n        try {\n            switch (note.what) {\n                case 'status':\n                    {\n                        const status = note.status_now;\n                        switch (status) {\n                            case 'completed':\n                                c.setToCompleted = true;\n                                break;\n                            case 'unmined':\n                                c.setToUnmined = true;\n                                break;\n                            case 'callback':\n                                c.setToCallback = true;\n                                break;\n                            case 'doubleSpend':\n                                c.setToDoubleSpend = true;\n                                break;\n                            case 'sending':\n                                c.setToSending = true;\n                                break;\n                            case 'unconfirmed':\n                                c.setToUnconfirmed = true;\n                                break;\n                            default:\n                                break;\n                        }\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n        catch (_a) {\n            /** */\n        }\n        return n;\n    }\n    addNotifyTransactionId(id) {\n        if (!Number.isInteger(id))\n            throw new index_client_1.sdk.WERR_INVALID_PARAMETER('id', 'integer');\n        const s = new Set(this.notify.transactionIds || []);\n        s.add(id);\n        this.notify.transactionIds = [...s].sort((a, b) => (a > b ? 1 : a < b ? -1 : 0));\n        this.notified = false;\n    }\n    /**\n     * Adds a note to history.\n     * Notes with identical property values to an existing note are ignored.\n     * @param note Note to add\n     * @param noDupes if true, only newest note with same `what` value is retained.\n     */\n    addHistoryNote(note, noDupes) {\n        if (!this.history.notes)\n            this.history.notes = [];\n        if (!note.when)\n            note.when = new Date().toISOString();\n        if (noDupes) {\n            // Remove any existing notes with same 'what' value and either no 'when' or an earlier 'when'\n            this.history.notes = this.history.notes.filter(n => n.what !== note.what || (n.when && n.when > note.when));\n        }\n        let addNote = true;\n        for (const n of this.history.notes) {\n            let isEqual = true;\n            for (const [k, v] of Object.entries(n)) {\n                if (v !== note[k]) {\n                    isEqual = false;\n                    break;\n                }\n            }\n            if (isEqual)\n                addNote = false;\n            if (!addNote)\n                break;\n        }\n        if (addNote) {\n            this.history.notes.push(note);\n            const k = (n) => {\n                return `${n.when} ${n.what}`;\n            };\n            this.history.notes.sort((a, b) => (k(a) < k(b) ? -1 : k(a) > k(b) ? 1 : 0));\n        }\n    }\n    /**\n       * Updates database record with current state of this EntityUser\n  \n       * @param storage\n       * @param trx\n       */\n    async updateStorage(storage, trx) {\n        this.updated_at = new Date();\n        this.updateApi();\n        if (this.id === 0) {\n            await storage.insertProvenTxReq(this.api);\n        }\n        const update = { ...this.api };\n        await storage.updateProvenTxReq(this.id, update, trx);\n    }\n    /**\n     * Update storage with changes to non-static properties:\n     *   updated_at\n     *   provenTxId\n     *   status\n     *   history\n     *   notify\n     *   notified\n     *   attempts\n     *   batch\n     *\n     * @param storage\n     * @param trx\n     */\n    async updateStorageDynamicProperties(storage, trx) {\n        this.updated_at = new Date();\n        this.updateApi();\n        const update = {\n            updated_at: this.api.updated_at,\n            provenTxId: this.api.provenTxId,\n            status: this.api.status,\n            history: this.api.history,\n            notify: this.api.notify,\n            notified: this.api.notified,\n            attempts: this.api.attempts,\n            batch: this.api.batch\n        };\n        if (storage.isStorageProvider()) {\n            const sp = storage;\n            await sp.updateProvenTxReqDynamics(this.id, update, trx);\n        }\n        else {\n            const wsm = storage;\n            await wsm.runAsStorageProvider(async (sp) => {\n                await sp.updateProvenTxReqDynamics(this.id, update, trx);\n            });\n        }\n    }\n    async insertOrMerge(storage, trx) {\n        const req = await storage.transaction(async (trx) => {\n            let reqApi0 = this.toApi();\n            const { req: reqApi1, isNew } = await storage.findOrInsertProvenTxReq(reqApi0, trx);\n            if (isNew) {\n                return new EntityProvenTxReq(reqApi1);\n            }\n            else {\n                const req = new EntityProvenTxReq(reqApi1);\n                req.mergeNotifyTransactionIds(reqApi0);\n                req.mergeHistory(reqApi0, undefined, true);\n                await req.updateStorage(storage, trx);\n                return req;\n            }\n        }, trx);\n        return req;\n    }\n    /**\n     * See `ProvenTxReqStatusApi`\n     */\n    get status() {\n        return this.api.status;\n    }\n    set status(v) {\n        if (v !== this.api.status) {\n            this.addHistoryNote({ what: 'status', status_was: this.api.status, status_now: v });\n            this.api.status = v;\n        }\n    }\n    get provenTxReqId() {\n        return this.api.provenTxReqId;\n    }\n    set provenTxReqId(v) {\n        this.api.provenTxReqId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get txid() {\n        return this.api.txid;\n    }\n    set txid(v) {\n        this.api.txid = v;\n    }\n    get inputBEEF() {\n        return this.api.inputBEEF;\n    }\n    set inputBEEF(v) {\n        this.api.inputBEEF = v;\n    }\n    get rawTx() {\n        return this.api.rawTx;\n    }\n    set rawTx(v) {\n        this.api.rawTx = v;\n    }\n    get attempts() {\n        return this.api.attempts;\n    }\n    set attempts(v) {\n        this.api.attempts = v;\n    }\n    get provenTxId() {\n        return this.api.provenTxId;\n    }\n    set provenTxId(v) {\n        this.api.provenTxId = v;\n    }\n    get notified() {\n        return this.api.notified;\n    }\n    set notified(v) {\n        this.api.notified = v;\n    }\n    get batch() {\n        return this.api.batch;\n    }\n    set batch(v) {\n        this.api.batch = v;\n    }\n    get id() {\n        return this.api.provenTxReqId;\n    }\n    set id(v) {\n        this.api.provenTxReqId = v;\n    }\n    get entityName() {\n        return 'provenTxReq';\n    }\n    get entityTable() {\n        return 'proven_tx_reqs';\n    }\n    /**\n     * 'convergent' equality must satisfy (A sync B) equals (B sync A)\n     */\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.txid != ei.txid ||\n            !(0, index_client_1.arraysEqual)(eo.rawTx, ei.rawTx) ||\n            (!eo.inputBEEF && ei.inputBEEF) ||\n            (eo.inputBEEF && !ei.inputBEEF) ||\n            (eo.inputBEEF && ei.inputBEEF && !(0, index_client_1.arraysEqual)(eo.inputBEEF, ei.inputBEEF)) ||\n            eo.batch != ei.batch)\n            return false;\n        if (syncMap) {\n            if (\n            // attempts doesn't matter for convergent equality\n            // history doesn't matter for convergent equality\n            // only local transactionIds matter, that cared about this txid in sorted order\n            eo.provenTxReqId !== syncMap.provenTxReq.idMap[(0, index_client_1.verifyId)(ei.provenTxReqId)] ||\n                (!eo.provenTxId && ei.provenTxId) ||\n                (eo.provenTxId && !ei.provenTxId) ||\n                (ei.provenTxId && eo.provenTxId !== syncMap.provenTx.idMap[ei.provenTxId])\n            // || eo.created_at !== minDate(ei.created_at, eo.created_at)\n            // || eo.updated_at !== maxDate(ei.updated_at, eo.updated_at)\n            )\n                return false;\n        }\n        else {\n            if (eo.attempts != ei.attempts ||\n                eo.history != ei.history ||\n                eo.notify != ei.notify ||\n                eo.provenTxReqId !== ei.provenTxReqId ||\n                eo.provenTxId !== ei.provenTxId\n            // || eo.created_at !== ei.created_at\n            // || eo.updated_at !== ei.updated_at\n            )\n                return false;\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxReqs({ partial: { txid: ei.txid }, trx }));\n        return {\n            found: !!ef,\n            eo: new EntityProvenTxReq(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.provenTxReqId)\n        };\n    }\n    mapNotifyTransactionIds(syncMap) {\n        // Map external notification transaction ids to local ids\n        const externalIds = this.notify.transactionIds || [];\n        this.notify.transactionIds = [];\n        for (const transactionId of externalIds) {\n            const localTxId = syncMap.transaction.idMap[transactionId];\n            if (localTxId) {\n                this.addNotifyTransactionId(localTxId);\n            }\n        }\n    }\n    mergeNotifyTransactionIds(ei, syncMap) {\n        var _a;\n        // Map external notification transaction ids to local ids and merge them if they exist.\n        const eie = new EntityProvenTxReq(ei);\n        if (eie.notify.transactionIds) {\n            (_a = this.notify).transactionIds || (_a.transactionIds = []);\n            for (const transactionId of eie.notify.transactionIds) {\n                const localTxId = syncMap ? syncMap.transaction.idMap[transactionId] : transactionId;\n                if (localTxId) {\n                    this.addNotifyTransactionId(localTxId);\n                }\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    mergeHistory(ei, syncMap, noDupes) {\n        const eie = new EntityProvenTxReq(ei);\n        if (eie.history.notes) {\n            for (const note of eie.history.notes) {\n                this.addHistoryNote(note);\n            }\n        }\n    }\n    static isTerminalStatus(status) {\n        return index_client_1.sdk.ProvenTxReqTerminalStatus.some(s => s === status);\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        if (this.provenTxId)\n            this.provenTxId = syncMap.provenTx.idMap[this.provenTxId];\n        this.mapNotifyTransactionIds(syncMap);\n        this.provenTxReqId = 0;\n        this.provenTxReqId = await storage.insertProvenTxReq(this.toApi(), trx);\n    }\n    /**\n     * When merging `ProvenTxReq`, care is taken to avoid short-cirtuiting notification: `status` must not transition to `completed` without\n     * passing through `notifying`. Thus a full convergent merge passes through these sequence steps:\n     * 1. Remote storage completes before local storage.\n     * 2. The remotely completed req and ProvenTx sync to local storage.\n     * 3. The local storage transitions to `notifying`, after merging the remote attempts and history.\n     * 4. The local storage notifies, transitioning to `completed`.\n     * 5. Having been updated, the local req, but not ProvenTx sync to remote storage, but do not merge because the earlier `completed` wins.\n     * 6. Convergent equality is achieved (completing work - history and attempts are equal)\n     *\n     * On terminal failure: `doubleSpend` trumps `invalid` as it contains more data.\n     */\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        if (!this.batch && ei.batch)\n            this.batch = ei.batch;\n        else if (this.batch && ei.batch && this.batch !== ei.batch)\n            throw new index_client_1.sdk.WERR_INTERNAL('ProvenTxReq merge batch not equal.');\n        this.mergeHistory(ei, syncMap, true);\n        this.mergeNotifyTransactionIds(ei, syncMap);\n        this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n        await storage.updateProvenTxReq(this.id, this.toApi(), trx);\n        return false;\n    }\n}\nexports.EntityProvenTxReq = EntityProvenTxReq;\n//# sourceMappingURL=EntityProvenTxReq.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTxReq.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntitySyncState.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntitySyncState.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntitySyncState = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nclass EntitySyncState extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            syncStateId: 0,\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            storageIdentityKey: '',\n            storageName: '',\n            init: false,\n            refNum: '',\n            status: 'unknown',\n            when: undefined,\n            errorLocal: undefined,\n            errorOther: undefined,\n            satoshis: undefined,\n            syncMap: JSON.stringify((0, _1.createSyncMap)())\n        });\n        this.errorLocal = this.api.errorLocal ? JSON.parse(this.api.errorLocal) : undefined;\n        this.errorOther = this.api.errorOther ? JSON.parse(this.api.errorOther) : undefined;\n        this.syncMap = JSON.parse(this.api.syncMap);\n        this.validateSyncMap(this.syncMap);\n    }\n    validateSyncMap(sm) {\n        for (const key of Object.keys(sm)) {\n            const esm = sm[key];\n            if (typeof esm.maxUpdated_at === 'string')\n                esm.maxUpdated_at = new Date(esm.maxUpdated_at);\n        }\n    }\n    static async fromStorage(storage, userIdentityKey, remoteSettings) {\n        const { user } = (0, index_client_1.verifyTruthy)(await storage.findOrInsertUser(userIdentityKey));\n        let { syncState: api } = (0, index_client_1.verifyTruthy)(await storage.findOrInsertSyncStateAuth({ userId: user.userId, identityKey: userIdentityKey }, remoteSettings.storageIdentityKey, remoteSettings.storageName));\n        if (!api.syncMap || api.syncMap === '{}')\n            api.syncMap = JSON.stringify((0, _1.createSyncMap)());\n        const ss = new EntitySyncState(api);\n        return ss;\n    }\n    /**\n     * Handles both insert and update based on id value: zero indicates insert.\n     * @param storage\n     * @param notSyncMap if not new and true, excludes updating syncMap in storage.\n     * @param trx\n     */\n    async updateStorage(storage, notSyncMap, trx) {\n        this.updated_at = new Date();\n        this.updateApi(notSyncMap && this.id > 0);\n        if (this.id === 0) {\n            await storage.insertSyncState(this.api);\n        }\n        else {\n            const update = { ...this.api };\n            if (notSyncMap)\n                delete update.syncMap;\n            delete update.created_at;\n            await storage.updateSyncState((0, index_client_1.verifyId)(this.id), update, trx);\n        }\n    }\n    updateApi(notSyncMap) {\n        this.api.errorLocal = this.apiErrorLocal;\n        this.api.errorOther = this.apiErrorOther;\n        if (!notSyncMap)\n            this.api.syncMap = this.apiSyncMap;\n    }\n    // Pass through api properties\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set storageIdentityKey(v) {\n        this.api.storageIdentityKey = v;\n    }\n    get storageIdentityKey() {\n        return this.api.storageIdentityKey;\n    }\n    set storageName(v) {\n        this.api.storageName = v;\n    }\n    get storageName() {\n        return this.api.storageName;\n    }\n    set init(v) {\n        this.api.init = v;\n    }\n    get init() {\n        return this.api.init;\n    }\n    set refNum(v) {\n        this.api.refNum = v;\n    }\n    get refNum() {\n        return this.api.refNum;\n    }\n    set status(v) {\n        this.api.status = v;\n    }\n    get status() {\n        return this.api.status;\n    }\n    set when(v) {\n        this.api.when = v;\n    }\n    get when() {\n        return this.api.when;\n    }\n    set satoshis(v) {\n        this.api.satoshis = v;\n    }\n    get satoshis() {\n        return this.api.satoshis;\n    }\n    get apiErrorLocal() {\n        return this.errorToString(this.errorLocal);\n    }\n    get apiErrorOther() {\n        return this.errorToString(this.errorOther);\n    }\n    get apiSyncMap() {\n        return JSON.stringify(this.syncMap);\n    }\n    get id() {\n        return this.api.syncStateId;\n    }\n    set id(id) {\n        this.api.syncStateId = id;\n    }\n    get entityName() {\n        return 'syncState';\n    }\n    get entityTable() {\n        return 'sync_states';\n    }\n    static mergeIdMap(fromMap, toMap) {\n        for (const [key, value] of Object.entries(fromMap)) {\n            const fromValue = fromMap[key];\n            const toValue = toMap[key];\n            if (toValue !== undefined && toValue !== fromValue)\n                throw new index_client_1.sdk.WERR_INVALID_PARAMETER('syncMap', `an unmapped id or the same mapped id. ${key} maps to ${toValue} not equal to ${fromValue}`);\n            if (toValue === undefined)\n                toMap[key] = value;\n        }\n    }\n    /**\n     * Merge additions to the syncMap\n     * @param iSyncMap\n     */\n    mergeSyncMap(iSyncMap) {\n        EntitySyncState.mergeIdMap(iSyncMap.provenTx.idMap, this.syncMap.provenTx.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.outputBasket.idMap, this.syncMap.outputBasket.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.transaction.idMap, this.syncMap.transaction.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.provenTxReq.idMap, this.syncMap.provenTxReq.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.txLabel.idMap, this.syncMap.txLabel.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.output.idMap, this.syncMap.output.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.outputTag.idMap, this.syncMap.outputTag.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.certificate.idMap, this.syncMap.certificate.idMap);\n        EntitySyncState.mergeIdMap(iSyncMap.commission.idMap, this.syncMap.commission.idMap);\n    }\n    /**\n     * Eliminate any properties besides code and description\n     */\n    errorToString(e) {\n        if (!e)\n            return undefined;\n        const es = {\n            code: e.code,\n            description: e.description,\n            stack: e.stack\n        };\n        return JSON.stringify(es);\n    }\n    equals(ei, syncMap) {\n        return false;\n    }\n    async mergeNew(storage, userId, syncMap, trx) { }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        return false;\n    }\n    makeRequestSyncChunkArgs(forIdentityKey, forStorageIdentityKey, maxRoughSize, maxItems) {\n        const a = {\n            identityKey: forIdentityKey,\n            maxRoughSize: maxRoughSize || 10000000,\n            maxItems: maxItems || 1000,\n            offsets: [],\n            since: this.when,\n            fromStorageIdentityKey: this.storageIdentityKey,\n            toStorageIdentityKey: forStorageIdentityKey\n        };\n        for (const ess of [\n            this.syncMap.provenTx,\n            this.syncMap.outputBasket,\n            this.syncMap.outputTag,\n            this.syncMap.txLabel,\n            this.syncMap.transaction,\n            this.syncMap.output,\n            this.syncMap.txLabelMap,\n            this.syncMap.outputTagMap,\n            this.syncMap.certificate,\n            this.syncMap.certificateField,\n            this.syncMap.commission,\n            this.syncMap.provenTxReq\n        ]) {\n            if (!ess || !ess.entityName)\n                debugger;\n            a.offsets.push({ name: ess.entityName, offset: ess.count });\n        }\n        return a;\n    }\n    static syncChunkSummary(c) {\n        let log = '';\n        log += `SYNC CHUNK SUMMARY\n  from storage: ${c.fromStorageIdentityKey}\n  to storage: ${c.toStorageIdentityKey}\n  for user: ${c.userIdentityKey}\n`;\n        if (c.user)\n            log += `  USER activeStorage ${c.user.activeStorage}\\n`;\n        if (!!c.provenTxs) {\n            log += `  PROVEN_TXS\\n`;\n            for (const r of c.provenTxs) {\n                log += `    ${r.provenTxId} ${r.txid}\\n`;\n            }\n        }\n        if (!!c.provenTxReqs) {\n            log += `  PROVEN_TX_REQS\\n`;\n            for (const r of c.provenTxReqs) {\n                log += `    ${r.provenTxReqId} ${r.txid} ${r.status} ${r.provenTxId || ''}\\n`;\n            }\n        }\n        if (!!c.transactions) {\n            log += `  TRANSACTIONS\\n`;\n            for (const r of c.transactions) {\n                log += `    ${r.transactionId} ${r.txid} ${r.status} ${r.provenTxId || ''} sats:${r.satoshis}\\n`;\n            }\n        }\n        if (!!c.outputs) {\n            log += `  OUTPUTS\\n`;\n            for (const r of c.outputs) {\n                log += `    ${r.outputId} ${r.txid}.${r.vout} ${r.transactionId} ${r.spendable ? 'spendable' : ''} sats:${r.satoshis}\\n`;\n            }\n        }\n        return log;\n    }\n    async processSyncChunk(writer, args, chunk) {\n        var _a;\n        const mes = [\n            new _1.MergeEntity(chunk.provenTxs, _1.EntityProvenTx.mergeFind, this.syncMap.provenTx),\n            new _1.MergeEntity(chunk.outputBaskets, _1.EntityOutputBasket.mergeFind, this.syncMap.outputBasket),\n            new _1.MergeEntity(chunk.outputTags, _1.EntityOutputTag.mergeFind, this.syncMap.outputTag),\n            new _1.MergeEntity(chunk.txLabels, _1.EntityTxLabel.mergeFind, this.syncMap.txLabel),\n            new _1.MergeEntity(chunk.transactions, _1.EntityTransaction.mergeFind, this.syncMap.transaction),\n            new _1.MergeEntity(chunk.outputs, _1.EntityOutput.mergeFind, this.syncMap.output),\n            new _1.MergeEntity(chunk.txLabelMaps, _1.EntityTxLabelMap.mergeFind, this.syncMap.txLabelMap),\n            new _1.MergeEntity(chunk.outputTagMaps, _1.EntityOutputTagMap.mergeFind, this.syncMap.outputTagMap),\n            new _1.MergeEntity(chunk.certificates, _1.EntityCertificate.mergeFind, this.syncMap.certificate),\n            new _1.MergeEntity(chunk.certificateFields, _1.EntityCertificateField.mergeFind, this.syncMap.certificateField),\n            new _1.MergeEntity(chunk.commissions, _1.EntityCommission.mergeFind, this.syncMap.commission),\n            new _1.MergeEntity(chunk.provenTxReqs, _1.EntityProvenTxReq.mergeFind, this.syncMap.provenTxReq)\n        ];\n        let updates = 0;\n        let inserts = 0;\n        let maxUpdated_at = undefined;\n        let done = true;\n        // Merge User\n        if (chunk.user) {\n            const ei = chunk.user;\n            const { found, eo } = await _1.EntityUser.mergeFind(writer, this.userId, ei);\n            if (found) {\n                if (await eo.mergeExisting(writer, args.since, ei)) {\n                    maxUpdated_at = (0, index_client_1.maxDate)(maxUpdated_at, ei.updated_at);\n                    updates++;\n                }\n            }\n        }\n        // Merge everything else...\n        for (const me of mes) {\n            const r = await me.merge(args.since, writer, this.userId, this.syncMap);\n            // The counts become the offsets for the next chunk.\n            me.esm.count += ((_a = me.stateArray) === null || _a === void 0 ? void 0 : _a.length) || 0;\n            updates += r.updates;\n            inserts += r.inserts;\n            maxUpdated_at = (0, index_client_1.maxDate)(maxUpdated_at, me.esm.maxUpdated_at);\n            // If any entity type either did not report results or if there were at least one, then we aren't done.\n            if (me.stateArray === undefined || me.stateArray.length > 0)\n                done = false;\n            //if (me.stateArray !== undefined && me.stateArray.length > 0)\n            //    console.log(`merged ${me.stateArray?.length} ${me.esm.entityName} ${r.inserts} inserted, ${r.updates} updated`);\n        }\n        if (done) {\n            // Next batch starts further in the future with offsets of zero.\n            this.when = maxUpdated_at;\n            for (const me of mes)\n                me.esm.count = 0;\n        }\n        await this.updateStorage(writer, false);\n        return { done, maxUpdated_at, updates, inserts };\n    }\n}\nexports.EntitySyncState = EntitySyncState;\n//# sourceMappingURL=EntitySyncState.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntitySyncState.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTransaction.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTransaction.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityTransaction = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityTransaction extends _1.EntityBase {\n    /**\n     * @returns @bsv/sdk Transaction object from parsed rawTx.\n     * If rawTx is undefined, returns undefined.\n     */\n    getBsvTx() {\n        if (!this.rawTx)\n            return undefined;\n        return sdk_1.Transaction.fromBinary(this.rawTx);\n    }\n    /**\n     * @returns array of @bsv/sdk TransactionInput objects from parsed rawTx.\n     * If rawTx is undefined, an empty array is returned.\n     */\n    getBsvTxIns() {\n        const tx = this.getBsvTx();\n        if (!tx)\n            return [];\n        return tx.inputs;\n    }\n    /**\n     * Returns an array of \"known\" inputs to this transaction which belong to the same userId.\n     * Uses both spentBy and rawTx inputs (if available) to locate inputs from among user's outputs.\n     * Not all transaction inputs correspond to prior storage outputs.\n     */\n    async getInputs(storage, trx) {\n        const inputs = await storage.findOutputs({\n            partial: { userId: this.userId, spentBy: this.id },\n            trx\n        });\n        // Merge \"inputs\" by spentBy and userId\n        for (const input of this.getBsvTxIns()) {\n            //console.log(`getInputs of ${this.id}: ${input.txid()} ${input.txOutNum}`)\n            const pso = (0, index_client_1.verifyOneOrNone)(await storage.findOutputs({\n                partial: {\n                    userId: this.userId,\n                    txid: input.sourceTXID,\n                    vout: input.sourceOutputIndex\n                },\n                trx\n            }));\n            if (pso && !inputs.some(i => i.outputId === pso.outputId))\n                inputs.push(pso);\n        }\n        return inputs;\n    }\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            transactionId: 0,\n            created_at: now,\n            updated_at: now,\n            userId: 0,\n            txid: '',\n            status: 'unprocessed',\n            reference: '',\n            satoshis: 0,\n            description: '',\n            isOutgoing: false,\n            rawTx: undefined,\n            inputBEEF: undefined\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get transactionId() {\n        return this.api.transactionId;\n    }\n    set transactionId(v) {\n        this.api.transactionId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get version() {\n        return this.api.version;\n    }\n    set version(v) {\n        this.api.version = v;\n    }\n    get lockTime() {\n        return this.api.lockTime;\n    }\n    set lockTime(v) {\n        this.api.lockTime = v;\n    }\n    get isOutgoing() {\n        return this.api.isOutgoing;\n    }\n    set isOutgoing(v) {\n        this.api.isOutgoing = v;\n    }\n    get status() {\n        return this.api.status;\n    }\n    set status(v) {\n        this.api.status = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get provenTxId() {\n        return this.api.provenTxId;\n    }\n    set provenTxId(v) {\n        this.api.provenTxId = v;\n    }\n    get satoshis() {\n        return this.api.satoshis;\n    }\n    set satoshis(v) {\n        this.api.satoshis = v;\n    }\n    get txid() {\n        return this.api.txid;\n    }\n    set txid(v) {\n        this.api.txid = v;\n    }\n    get reference() {\n        return this.api.reference;\n    }\n    set reference(v) {\n        this.api.reference = v;\n    }\n    get inputBEEF() {\n        return this.api.inputBEEF;\n    }\n    set inputBEEF(v) {\n        this.api.inputBEEF = v;\n    }\n    get description() {\n        return this.api.description;\n    }\n    set description(v) {\n        this.api.description = v;\n    }\n    get rawTx() {\n        return this.api.rawTx;\n    }\n    set rawTx(v) {\n        this.api.rawTx = v;\n    }\n    // Extended (computed / dependent entity) Properties\n    //get labels() { return this.api.labels }\n    //set labels(v: string[] | undefined) { this.api.labels = v }\n    get id() {\n        return this.api.transactionId;\n    }\n    set id(v) {\n        this.api.transactionId = v;\n    }\n    get entityName() {\n        return 'transaction';\n    }\n    get entityTable() {\n        return 'transactions';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        // Properties that are never updated\n        if (eo.transactionId !== (syncMap ? syncMap.transaction.idMap[(0, index_client_1.verifyId)(ei.transactionId)] : ei.transactionId) ||\n            eo.reference !== ei.reference)\n            return false;\n        if (eo.version !== ei.version ||\n            eo.lockTime !== ei.lockTime ||\n            eo.isOutgoing !== ei.isOutgoing ||\n            eo.status !== ei.status ||\n            eo.satoshis !== ei.satoshis ||\n            eo.txid !== ei.txid ||\n            eo.description !== ei.description ||\n            !(0, index_client_1.optionalArraysEqual)(eo.rawTx, ei.rawTx) ||\n            !(0, index_client_1.optionalArraysEqual)(eo.inputBEEF, ei.inputBEEF))\n            return false;\n        if (!eo.provenTxId !== !ei.provenTxId ||\n            (ei.provenTxId && eo.provenTxId !== (syncMap ? syncMap.provenTx.idMap[(0, index_client_1.verifyId)(ei.provenTxId)] : ei.provenTxId)))\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findTransactions({\n            partial: { reference: ei.reference, userId },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityTransaction(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.transactionId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        if (this.provenTxId)\n            this.provenTxId = syncMap.provenTx.idMap[this.provenTxId];\n        this.userId = userId;\n        this.transactionId = 0;\n        this.transactionId = await storage.insertTransaction(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            // Properties that are never updated:\n            // transactionId\n            // userId\n            // reference\n            // Merged properties\n            this.version = ei.version;\n            this.lockTime = ei.lockTime;\n            this.isOutgoing = ei.isOutgoing;\n            this.status = ei.status;\n            this.provenTxId = ei.provenTxId ? syncMap.provenTx.idMap[ei.provenTxId] : undefined;\n            this.satoshis = ei.satoshis;\n            this.txid = ei.txid;\n            this.description = ei.description;\n            this.rawTx = ei.rawTx;\n            this.inputBEEF = ei.inputBEEF;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateTransaction(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n    async getProvenTx(storage, trx) {\n        if (!this.provenTxId)\n            return undefined;\n        const p = (0, index_client_1.verifyOneOrNone)(await storage.findProvenTxs({\n            partial: { provenTxId: this.provenTxId },\n            trx\n        }));\n        if (!p)\n            return undefined;\n        return new _1.EntityProvenTx(p);\n    }\n}\nexports.EntityTransaction = EntityTransaction;\n//# sourceMappingURL=EntityTransaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTransaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabel.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabel.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityTxLabel = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityTxLabel extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            txLabelId: 0,\n            created_at: now,\n            updated_at: now,\n            label: '',\n            userId: 0,\n            isDeleted: false\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get txLabelId() {\n        return this.api.txLabelId;\n    }\n    set txLabelId(v) {\n        this.api.txLabelId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get label() {\n        return this.api.label;\n    }\n    set label(v) {\n        this.api.label = v;\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    get id() {\n        return this.api.txLabelId;\n    }\n    set id(v) {\n        this.api.txLabelId = v;\n    }\n    get entityName() {\n        return 'txLabel';\n    }\n    get entityTable() {\n        return 'tx_labels';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.label != ei.label || eo.isDeleted != ei.isDeleted)\n            return false;\n        if (!syncMap) {\n            if (eo.userId !== ei.userId)\n                return false;\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findTxLabels({ partial: { label: ei.label, userId }, trx }));\n        return {\n            found: !!ef,\n            eo: new EntityTxLabel(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.txLabelId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.userId = userId;\n        this.txLabelId = 0;\n        this.txLabelId = await storage.insertTxLabel(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateTxLabel(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityTxLabel = EntityTxLabel;\n//# sourceMappingURL=EntityTxLabel.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabel.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabelMap.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabelMap.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityTxLabelMap = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityTxLabelMap extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            created_at: now,\n            updated_at: now,\n            transactionId: 0,\n            txLabelId: 0,\n            isDeleted: false\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get txLabelId() {\n        return this.api.txLabelId;\n    }\n    set txLabelId(v) {\n        this.api.txLabelId = v;\n    }\n    get transactionId() {\n        return this.api.transactionId;\n    }\n    set transactionId(v) {\n        this.api.transactionId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get isDeleted() {\n        return this.api.isDeleted;\n    }\n    set isDeleted(v) {\n        this.api.isDeleted = v;\n    }\n    get id() {\n        throw new index_client_1.sdk.WERR_INVALID_OPERATION('entity has no \"id\" value');\n    } // entity does not have its own id.\n    get entityName() {\n        return 'txLabelMap';\n    }\n    get entityTable() {\n        return 'tx_labels_map';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.transactionId !== (syncMap ? syncMap.transaction.idMap[(0, index_client_1.verifyId)(ei.transactionId)] : ei.transactionId) ||\n            eo.txLabelId !== (syncMap ? syncMap.txLabel.idMap[(0, index_client_1.verifyId)(ei.txLabelId)] : ei.txLabelId) ||\n            eo.isDeleted !== ei.isDeleted)\n            return false;\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, syncMap, trx) {\n        const transactionId = syncMap.transaction.idMap[ei.transactionId];\n        const txLabelId = syncMap.txLabel.idMap[ei.txLabelId];\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findTxLabelMaps({\n            partial: { transactionId, txLabelId },\n            trx\n        }));\n        return {\n            found: !!ef,\n            eo: new EntityTxLabelMap(ef || { ...ei }),\n            eiId: -1\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        this.transactionId = syncMap.transaction.idMap[this.transactionId];\n        this.txLabelId = syncMap.txLabel.idMap[this.txLabelId];\n        await storage.insertTxLabelMap(this.toApi(), trx);\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        if (ei.updated_at > this.updated_at) {\n            this.isDeleted = ei.isDeleted;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateTxLabelMap(this.transactionId, this.txLabelId, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityTxLabelMap = EntityTxLabelMap;\n//# sourceMappingURL=EntityTxLabelMap.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabelMap.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityUser.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityUser.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EntityUser = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nconst _1 = __webpack_require__(/*! . */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js\");\nclass EntityUser extends _1.EntityBase {\n    constructor(api) {\n        const now = new Date();\n        super(api || {\n            userId: 0,\n            created_at: now,\n            updated_at: now,\n            identityKey: '',\n            activeStorage: ''\n        });\n    }\n    updateApi() {\n        /* nothing needed yet... */\n    }\n    get userId() {\n        return this.api.userId;\n    }\n    set userId(v) {\n        this.api.userId = v;\n    }\n    get created_at() {\n        return this.api.created_at;\n    }\n    set created_at(v) {\n        this.api.created_at = v;\n    }\n    get updated_at() {\n        return this.api.updated_at;\n    }\n    set updated_at(v) {\n        this.api.updated_at = v;\n    }\n    get identityKey() {\n        return this.api.identityKey;\n    }\n    set identityKey(v) {\n        this.api.identityKey = v;\n    }\n    get activeStorage() {\n        return this.api.activeStorage;\n    }\n    set activeStorage(v) {\n        this.api.activeStorage = v;\n    }\n    get id() {\n        return this.api.userId;\n    }\n    set id(v) {\n        this.api.userId = v;\n    }\n    get entityName() {\n        return 'user';\n    }\n    get entityTable() {\n        return 'users';\n    }\n    equals(ei, syncMap) {\n        const eo = this.toApi();\n        if (eo.identityKey != ei.identityKey || eo.activeStorage != ei.activeStorage)\n            return false;\n        if (!syncMap) {\n            /** */\n        }\n        return true;\n    }\n    static async mergeFind(storage, userId, ei, trx) {\n        const ef = (0, index_client_1.verifyOneOrNone)(await storage.findUsers({ partial: { identityKey: ei.identityKey }, trx }));\n        if (ef && ef.userId != userId)\n            throw new index_client_1.sdk.WERR_INTERNAL('logic error, userIds don not match.');\n        return {\n            found: !!ef,\n            eo: new EntityUser(ef || { ...ei }),\n            eiId: (0, index_client_1.verifyId)(ei.userId)\n        };\n    }\n    async mergeNew(storage, userId, syncMap, trx) {\n        throw new index_client_1.sdk.WERR_INTERNAL('a sync chunk merge must never create a new user');\n    }\n    async mergeExisting(storage, since, ei, syncMap, trx) {\n        let wasMerged = false;\n        // The condition on activeStorage here is critical as a new user record may have just been created\n        // in a backup store to which a backup is being pushed.\n        if (ei.updated_at > this.updated_at || (this.activeStorage === undefined && ei.activeStorage !== undefined)) {\n            this.activeStorage = ei.activeStorage;\n            this.updated_at = new Date(Math.max(ei.updated_at.getTime(), this.updated_at.getTime()));\n            await storage.updateUser(this.id, this.toApi(), trx);\n            wasMerged = true;\n        }\n        return wasMerged;\n    }\n}\nexports.EntityUser = EntityUser;\n//# sourceMappingURL=EntityUser.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityUser.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/MergeEntity.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/MergeEntity.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MergeEntity = void 0;\nconst index_client_1 = __webpack_require__(/*! ../../../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\n/**\n * @param API one of the storage table interfaces.\n * @param DE the corresponding entity class\n */\nclass MergeEntity {\n    constructor(stateArray, find, \n    /** id map for primary id of API and DE object. */\n    esm) {\n        this.stateArray = stateArray;\n        this.find = find;\n        this.esm = esm;\n        this.idMap = esm.idMap;\n    }\n    updateSyncMap(map, inId, outId) {\n        const i = (0, index_client_1.verifyId)(inId);\n        const o = (0, index_client_1.verifyId)(outId);\n        if (map[i] === undefined) {\n            map[i] = o;\n        }\n        else if (map[i] !== o)\n            throw new index_client_1.sdk.WERR_INTERNAL(`updateSyncMap map[${inId}] can't override ${map[i]} with ${o}`);\n    }\n    /**\n     * @param since date of current sync chunk\n     */\n    async merge(since, storage, userId, syncMap, trx) {\n        let inserts = 0, updates = 0;\n        if (!this.stateArray)\n            return { inserts, updates };\n        for (const ei of this.stateArray) {\n            this.esm.maxUpdated_at = (0, index_client_1.maxDate)(this.esm.maxUpdated_at, ei.updated_at);\n            /**\n             * TODO:\n             * Switch to using syncMap. If the ei id is in the map its an existing merge, else its a new merge.\n             */\n            try {\n                const { found, eo, eiId } = await this.find(storage, userId, ei, syncMap, trx);\n                if (found) {\n                    if (await eo.mergeExisting(storage, since, ei, syncMap, trx)) {\n                        updates++;\n                    }\n                }\n                else {\n                    await eo.mergeNew(storage, userId, syncMap, trx);\n                    inserts++;\n                }\n                if (eiId > -1)\n                    this.updateSyncMap(this.idMap, eiId, eo.id);\n            }\n            catch (eu) {\n                throw eu;\n            }\n        }\n        return { inserts, updates };\n    }\n}\nexports.MergeEntity = MergeEntity;\n//# sourceMappingURL=MergeEntity.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/MergeEntity.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./EntityBase */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityBase.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntitySyncState */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntitySyncState.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityProvenTx */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTx.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityProvenTxReq */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityProvenTxReq.js\"), exports);\n__exportStar(__webpack_require__(/*! ./MergeEntity */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/MergeEntity.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityOutputBasket */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputBasket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityUser */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityUser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityTxLabelMap */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabelMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityTxLabel */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTxLabel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityOutputTag */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTag.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityOutputTagMap */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutputTagMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityCommission */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCommission.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityCertificate */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificate.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityCertificateField */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityCertificateField.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityTransaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./EntityOutput */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/EntityOutput.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/entities/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificate.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificate.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableCertificate.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificate.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificateField.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificateField.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableCertificateField.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificateField.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCommission.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCommission.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableCommission.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCommission.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableMonitorEvent.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableMonitorEvent.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableMonitorEvent.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableMonitorEvent.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutput.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutput.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.outputColumnsWithoutLockingScript = void 0;\nexports.outputColumnsWithoutLockingScript = [\n    'created_at',\n    'updated_at',\n    'outputId',\n    'userId',\n    'transactionId',\n    'basketId',\n    'spendable',\n    'change',\n    'vout',\n    'satoshis',\n    'providedBy',\n    'purpose',\n    'type',\n    'outputDescription',\n    'txid',\n    'senderIdentityKey',\n    'derivationPrefix',\n    'derivationSuffix',\n    'customInstructions',\n    'spentBy',\n    'sequenceNumber',\n    'spendingDescription',\n    'scriptLength',\n    'scriptOffset'\n    //'lockingScript',\n];\n//# sourceMappingURL=TableOutput.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutput.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputBasket.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputBasket.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableOutputBasket.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputBasket.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTag.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTag.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableOutputTag.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTag.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTagMap.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTagMap.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableOutputTagMap.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTagMap.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTx.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTx.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableProvenTx.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTx.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTxReq.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTxReq.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableProvenTxReq.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTxReq.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSettings.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSettings.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableSettings.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSettings.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSyncState.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSyncState.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableSyncState.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSyncState.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTransaction.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTransaction.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transactionColumnsWithoutRawTx = void 0;\nexports.transactionColumnsWithoutRawTx = [\n    'created_at',\n    'updated_at',\n    'transactionId',\n    'userId',\n    'provenTxId',\n    'status',\n    'reference',\n    'isOutgoing',\n    'satoshis',\n    'version',\n    'lockTime',\n    'description',\n    'txid'\n    //   'inputBEEF',\n    //   'rawTx',\n];\n//# sourceMappingURL=TableTransaction.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTransaction.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabel.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabel.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableTxLabel.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabel.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabelMap.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabelMap.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableTxLabelMap.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabelMap.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableUser.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableUser.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceMappingURL=TableUser.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableUser.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./TableSettings */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSettings.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableProvenTx */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTx.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableProvenTxReq */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableProvenTxReq.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableUser */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableUser.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableCertificate */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificate.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableCertificateField */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCertificateField.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableOutputBasket */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputBasket.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableTransaction */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTransaction.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableCommission */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableCommission.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableOutput */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutput.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableOutputTag */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTag.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableOutputTagMap */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableOutputTagMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableTxLabel */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabel.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableTxLabelMap */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableTxLabelMap.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableMonitorEvent */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableMonitorEvent.js\"), exports);\n__exportStar(__webpack_require__(/*! ./TableSyncState */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/TableSyncState.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/storage/schema/tables/index.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/ScriptTemplateBRC29.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/ScriptTemplateBRC29.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ScriptTemplateBRC29 = exports.brc29ProtocolID = void 0;\nconst index_client_1 = __webpack_require__(/*! ./index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js\");\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nexports.brc29ProtocolID = [2, '3241645161d8'];\n/**\n * Simple Authenticated BSV P2PKH Payment Protocol\n * https://brc.dev/29\n */\nclass ScriptTemplateBRC29 {\n    constructor(params) {\n        this.params = params;\n        /**\n         * P2PKH unlock estimateLength is a constant\n         */\n        this.unlockLength = 108;\n        this.p2pkh = new sdk_1.P2PKH();\n        (0, index_client_1.verifyTruthy)(params.derivationPrefix);\n        (0, index_client_1.verifyTruthy)(params.derivationSuffix);\n    }\n    getKeyID() {\n        return `${this.params.derivationPrefix} ${this.params.derivationSuffix}`;\n    }\n    getKeyDeriver(privKey) {\n        if (typeof privKey === 'string')\n            privKey = sdk_1.PrivateKey.fromHex(privKey);\n        if (!this.params.keyDeriver || this.params.keyDeriver.rootKey.toHex() !== privKey.toHex())\n            return new sdk_1.CachedKeyDeriver(privKey);\n        return this.params.keyDeriver;\n    }\n    lock(lockerPrivKey, unlockerPubKey) {\n        const address = this.getKeyDeriver(lockerPrivKey)\n            .derivePublicKey(exports.brc29ProtocolID, this.getKeyID(), unlockerPubKey, false)\n            .toAddress();\n        const r = this.p2pkh.lock(address);\n        return r;\n    }\n    unlock(unlockerPrivKey, lockerPubKey, sourceSatoshis, lockingScript) {\n        const derivedPrivateKey = this.getKeyDeriver(unlockerPrivKey)\n            .derivePrivateKey(exports.brc29ProtocolID, this.getKeyID(), lockerPubKey)\n            .toHex();\n        const r = this.p2pkh.unlock((0, index_client_1.asBsvSdkPrivateKey)(derivedPrivateKey), 'all', false, sourceSatoshis, lockingScript);\n        return r;\n    }\n}\nexports.ScriptTemplateBRC29 = ScriptTemplateBRC29;\n//# sourceMappingURL=ScriptTemplateBRC29.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/ScriptTemplateBRC29.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/aggregateResults.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/aggregateResults.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.aggregateActionResults = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst sdk_2 = __webpack_require__(/*! ../sdk */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/sdk/index.js\");\nconst aggregateActionResults = async (storage, sendWithResultReqs, postToNetworkResult) => {\n    const swr = [];\n    const rar = [];\n    for (const ar of sendWithResultReqs) {\n        const txid = ar.txid;\n        const d = postToNetworkResult.details.find(d => d.txid === txid);\n        if (!d)\n            throw new sdk_2.WERR_INTERNAL(`missing details for ${txid}`);\n        const arNdr = { txid: d.txid, status: 'success', competingTxs: d.competingTxs };\n        switch (d.status) {\n            case 'success':\n                // processing network has accepted this transaction\n                ar.status = 'unproven';\n                break;\n            case 'doubleSpend':\n                // confirmed double spend.\n                ar.status = 'failed';\n                arNdr.status = 'doubleSpend';\n                if (d.competingTxs)\n                    arNdr.competingBeef = await createMergedBeefOfTxids(d.competingTxs, storage);\n                break;\n            case 'serviceError':\n                // services might improve\n                ar.status = 'sending';\n                arNdr.status = 'serviceError';\n                break;\n            case 'invalidTx':\n                // nothing will fix this transaction\n                ar.status = 'failed';\n                arNdr.status = 'invalidTx';\n                break;\n            case 'unknown':\n            case 'invalid':\n            default:\n                throw new sdk_2.WERR_INTERNAL(`processAction with notDelayed status ${d.status} should not occur.`);\n        }\n        swr.push({ txid, status: ar.status });\n        rar.push(arNdr);\n    }\n    return { swr, rar };\n};\nexports.aggregateActionResults = aggregateActionResults;\nasync function createMergedBeefOfTxids(txids, storage) {\n    const beef = new sdk_1.Beef();\n    const options = {\n        mergeToBeef: beef,\n        ignoreNewProven: true\n    };\n    for (const txid of txids) {\n        await storage.getBeefForTransaction(txid, options);\n    }\n    return beef.toBinary();\n}\n//# sourceMappingURL=aggregateResults.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/aggregateResults.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/identityUtils.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/identityUtils.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseResults = exports.queryOverlay = exports.transformVerifiableCertificatesWithTrust = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst OUTPUT_INDEX = 0;\n/**\n * Transforms an array of VerifiableCertificate instances according to the trust settings.\n * Only certificates whose grouped total trust meets the threshold are returned,\n * and each certificate is augmented with a certifierInfo property.\n *\n * @param trustSettings - the user's trust settings including trustLevel and trusted certifiers.\n * @param certificates - an array of VerifiableCertificate objects.\n * @returns a DiscoverCertificatesResult with totalCertificates and ordered certificates.\n */\nconst transformVerifiableCertificatesWithTrust = (trustSettings, certificates) => {\n    // Group certificates by subject while accumulating trust.\n    const identityGroups = {};\n    // Cache certifier lookups.\n    const certifierCache = {};\n    certificates.forEach(cert => {\n        const { subject, certifier } = cert;\n        if (!subject || !certifier)\n            return;\n        // Lookup and cache certifier details from trustSettings.\n        if (!certifierCache[certifier]) {\n            const found = trustSettings.trustedCertifiers.find(x => x.identityKey === certifier);\n            if (!found)\n                return; // Skip this certificate if its certifier is not trusted.\n            certifierCache[certifier] = found;\n        }\n        // Create the IdentityCertifier object that we want to attach.\n        const certifierInfo = {\n            name: certifierCache[certifier].name,\n            iconUrl: certifierCache[certifier].iconUrl || '',\n            description: certifierCache[certifier].description,\n            trust: certifierCache[certifier].trust\n        };\n        // Create an extended certificate that includes certifierInfo.\n        // Note: We use object spread to copy over all properties from the original certificate.\n        const extendedCert = {\n            ...cert,\n            signature: cert.signature, // We know it exists at this point\n            decryptedFields: cert.decryptedFields,\n            publiclyRevealedKeyring: cert.keyring,\n            certifierInfo\n        };\n        // Group certificates by subject.\n        if (!identityGroups[subject]) {\n            identityGroups[subject] = { totalTrust: 0, members: [] };\n        }\n        identityGroups[subject].totalTrust += certifierInfo.trust;\n        identityGroups[subject].members.push(extendedCert);\n    });\n    // Filter out groups that do not meet the trust threshold and flatten the results.\n    const finalResults = [];\n    Object.values(identityGroups).forEach(group => {\n        if (group.totalTrust >= trustSettings.trustLevel) {\n            finalResults.push(...group.members);\n        }\n    });\n    // Sort the certificates by their certifier trust in descending order.\n    finalResults.sort((a, b) => b.certifierInfo.trust - a.certifierInfo.trust);\n    return {\n        totalCertificates: finalResults.length,\n        certificates: finalResults\n    };\n};\nexports.transformVerifiableCertificatesWithTrust = transformVerifiableCertificatesWithTrust;\n/**\n * Performs an identity overlay service lookup query and returns the parsed results\n *\n * @param query\n * @returns\n */\nconst queryOverlay = async (query, resolver) => {\n    const results = await resolver.query({\n        service: 'ls_identity',\n        query\n    });\n    return await (0, exports.parseResults)(results);\n};\nexports.queryOverlay = queryOverlay;\n/**\n * Internal func: Parse the returned UTXOs Decrypt and verify the certificates and signatures Return the set of identity keys, certificates and decrypted certificate fields\n *\n * @param {Output[]} outputs\n * @returns {Promise<VerifiableCertificate[]>}\n */\nconst parseResults = async (lookupResult) => {\n    if (lookupResult.type === 'output-list') {\n        const parsedResults = [];\n        for (const output of lookupResult.outputs) {\n            try {\n                const tx = sdk_1.Transaction.fromBEEF(output.beef);\n                // Decode the Identity token fields from the Bitcoin outputScript\n                const decodedOutput = sdk_1.PushDrop.decode(tx.outputs[output.outputIndex].lockingScript);\n                // Parse out the certificate and relevant data\n                const certificate = JSON.parse(sdk_1.Utils.toUTF8(decodedOutput.fields[0])); // TEST\n                const verifiableCert = new sdk_1.VerifiableCertificate(certificate.type, certificate.serialNumber, certificate.subject, certificate.certifier, certificate.revocationOutpoint, certificate.fields, certificate.keyring, certificate.signature);\n                const decryptedFields = await verifiableCert.decryptFields(new sdk_1.ProtoWallet('anyone'));\n                // Verify the certificate signature is correct\n                await verifiableCert.verify();\n                verifiableCert.decryptedFields = decryptedFields;\n                parsedResults.push(verifiableCert);\n            }\n            catch (error) {\n                console.error(error);\n                // do nothing\n            }\n        }\n        return parsedResults;\n    }\n    return [];\n};\nexports.parseResults = parseResults;\n//# sourceMappingURL=identityUtils.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/identityUtils.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n__exportStar(__webpack_require__(/*! ./stampLog */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/stampLog.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ScriptTemplateBRC29 */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/ScriptTemplateBRC29.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parseTxScriptOffsets */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/parseTxScriptOffsets.js\"), exports);\n__exportStar(__webpack_require__(/*! ./tscProofToMerklePath */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/tscProofToMerklePath.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utilityHelpers */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./utilityHelpers.noBuffer */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.noBuffer.js\"), exports);\n//# sourceMappingURL=index.client.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/index.client.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/parseTxScriptOffsets.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/parseTxScriptOffsets.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseTxScriptOffsets = parseTxScriptOffsets;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nfunction parseTxScriptOffsets(rawTx) {\n    const br = new sdk_1.Utils.Reader(rawTx);\n    const inputs = [];\n    const outputs = [];\n    br.pos += 4; // version\n    const inputsLength = br.readVarIntNum();\n    for (let i = 0; i < inputsLength; i++) {\n        br.pos += 36; // txid and vout\n        const scriptLength = br.readVarIntNum();\n        inputs.push({ vin: i, offset: br.pos, length: scriptLength });\n        br.pos += scriptLength + 4; // script and sequence\n    }\n    const outputsLength = br.readVarIntNum();\n    for (let i = 0; i < outputsLength; i++) {\n        br.pos += 8; // satoshis\n        const scriptLength = br.readVarIntNum();\n        outputs.push({ vout: i, offset: br.pos, length: scriptLength });\n        br.pos += scriptLength;\n    }\n    return { inputs, outputs };\n}\n//# sourceMappingURL=parseTxScriptOffsets.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/parseTxScriptOffsets.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/stampLog.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/stampLog.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.stampLog = stampLog;\nexports.stampLogFormat = stampLogFormat;\n/**\n * If a log is being kept, add a time stamped line.\n * @param log  Optional time stamped log to extend, or an object with a log property to update\n * @param lineToAdd Content to add to line.\n * @returns undefined or log extended by time stamped `lineToAdd` and new line.\n */\nfunction stampLog(log, lineToAdd) {\n    const add = `${new Date().toISOString()} ${lineToAdd}\\n`;\n    if (typeof log === 'object' && typeof log.log === 'string')\n        return (log.log = log.log + add);\n    if (typeof log === 'string')\n        return log + add;\n    return undefined;\n}\n/**\n * Replaces individual timestamps with delta msecs.\n * Looks for two network crossings and adjusts clock for clock skew if found.\n * Assumes log built by repeated calls to `stampLog`\n * @param log Each logged event starts with ISO time stamp, space, rest of line, terminated by `\\n`.\n * @returns reformated multi-line event log\n */\nfunction stampLogFormat(log) {\n    if (typeof log !== 'string')\n        return '';\n    const logLines = log.split('\\n');\n    const data = [];\n    let last = 0;\n    const newClocks = [];\n    for (const line of logLines) {\n        const spaceAt = line.indexOf(' ');\n        if (spaceAt > -1) {\n            const when = new Date(line.substring(0, spaceAt)).getTime();\n            const rest = line.substring(spaceAt + 1);\n            const delta = when - (last || when);\n            const newClock = rest.indexOf('**NETWORK**') > -1;\n            if (newClock)\n                newClocks.push(data.length);\n            data.push({ when, rest, delta, newClock });\n            last = when;\n        }\n    }\n    const total = data[data.length - 1].when - data[0].when;\n    if (newClocks.length % 2 === 0) {\n        // Adjust for paired network crossing times and clock skew between clocks.\n        let network = total;\n        let lastNewClock = 0;\n        for (const newClock of newClocks) {\n            network -= data[newClock - 1].when - data[lastNewClock].when;\n            lastNewClock = newClock;\n        }\n        network -= data[data.length - 1].when - data[lastNewClock].when;\n        let networks = newClocks.length;\n        for (const newClock of newClocks) {\n            const n = networks > 1 ? Math.floor(network / networks) : network;\n            data[newClock].delta = n;\n            network -= n;\n            networks--;\n        }\n    }\n    let log2 = `${new Date(data[0].when).toISOString()} Total = ${total} msecs\\n`;\n    for (const d of data) {\n        let df = d.delta.toString();\n        df = `${' '.repeat(8 - df.length)}${df}`;\n        log2 += `${df} ${d.rest}\\n`;\n    }\n    return log2;\n}\n//# sourceMappingURL=stampLog.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/stampLog.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/tscProofToMerklePath.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/tscProofToMerklePath.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.convertProofToMerklePath = convertProofToMerklePath;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nfunction convertProofToMerklePath(txid, proof) {\n    const blockHeight = proof.height;\n    const treeHeight = proof.nodes.length;\n    const path = Array(treeHeight)\n        .fill(0)\n        .map(() => []);\n    let index = proof.index;\n    for (let level = 0; level < treeHeight; level++) {\n        const node = proof.nodes[level];\n        const isOdd = index % 2 === 1;\n        const offset = isOdd ? index - 1 : index + 1;\n        const leaf = { offset };\n        if (node === '*' || (level === 0 && node === txid)) {\n            leaf.duplicate = true;\n        }\n        else {\n            leaf.hash = node;\n        }\n        path[level].push(leaf);\n        if (level === 0) {\n            const txidLeaf = {\n                offset: proof.index,\n                hash: txid,\n                txid: true\n            };\n            if (isOdd) {\n                path[0].push(txidLeaf);\n            }\n            else {\n                path[0].unshift(txidLeaf);\n            }\n        }\n        index = index >> 1;\n    }\n    return new sdk_1.MerklePath(blockHeight, path);\n}\n//# sourceMappingURL=tscProofToMerklePath.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/tscProofToMerklePath.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.buffer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.buffer.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asBuffer = asBuffer;\nexports.asString = asString;\nexports.asArray = asArray;\n/**\n * Coerce a value to Buffer if currently encoded as a string or\n * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.\n * @param encoding defaults to 'hex'. Only applies to val of type string\n * @returns input val if it is a Buffer or new Buffer from string val\n * @publicbody\n */\nfunction asBuffer(val, encoding) {\n    let b;\n    if (Buffer.isBuffer(val))\n        b = val;\n    else if (typeof val === 'string')\n        b = Buffer.from(val, encoding !== null && encoding !== void 0 ? encoding : 'hex');\n    else\n        b = Buffer.from(val);\n    return b;\n}\n/**\n * Coerce a value to an encoded string if currently a Buffer or number[]\n * @param val Buffer or string or number[]. If string, encoding param applies. If number[], Buffer.from constructor is used.\n * @param encoding defaults to 'hex'\n * @returns input val if it is a string; or if number[], first converted to Buffer then as Buffer; if Buffer encoded using `encoding`\n * @publicbody\n */\nfunction asString(val, encoding) {\n    if (Array.isArray(val))\n        val = Buffer.from(val);\n    return Buffer.isBuffer(val) ? val.toString(encoding !== null && encoding !== void 0 ? encoding : 'hex') : val;\n}\nfunction asArray(val, encoding) {\n    let a;\n    if (Array.isArray(val))\n        a = val;\n    else if (Buffer.isBuffer(val))\n        a = Array.from(val);\n    else\n        a = Array.from(Buffer.from(val, encoding || 'hex'));\n    return a;\n}\n//# sourceMappingURL=utilityHelpers.buffer.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.buffer.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getIdentityKey = getIdentityKey;\nexports.toWalletNetwork = toWalletNetwork;\nexports.makeAtomicBeef = makeAtomicBeef;\nexports.asBsvSdkTx = asBsvSdkTx;\nexports.asBsvSdkScript = asBsvSdkScript;\nexports.asBsvSdkPrivateKey = asBsvSdkPrivateKey;\nexports.asBsvSdkPublickKey = asBsvSdkPublickKey;\nexports.verifyTruthy = verifyTruthy;\nexports.verifyHexString = verifyHexString;\nexports.verifyOptionalHexString = verifyOptionalHexString;\nexports.verifyNumber = verifyNumber;\nexports.verifyInteger = verifyInteger;\nexports.verifyId = verifyId;\nexports.verifyOneOrNone = verifyOneOrNone;\nexports.verifyOne = verifyOne;\nexports.wait = wait;\nexports.randomBytes = randomBytes;\nexports.randomBytesHex = randomBytesHex;\nexports.randomBytesBase64 = randomBytesBase64;\nexports.validateSecondsSinceEpoch = validateSecondsSinceEpoch;\nexports.arraysEqual = arraysEqual;\nexports.optionalArraysEqual = optionalArraysEqual;\nexports.maxDate = maxDate;\nexports.sha256Hash = sha256Hash;\nexports.doubleSha256LE = doubleSha256LE;\nexports.doubleSha256BE = doubleSha256BE;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nconst index_client_1 = __webpack_require__(/*! ../index.client */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.client.js\");\nasync function getIdentityKey(wallet) {\n    return (await wallet.getPublicKey({ identityKey: true })).publicKey;\n}\nfunction toWalletNetwork(chain) {\n    return chain === 'main' ? 'mainnet' : 'testnet';\n}\nfunction makeAtomicBeef(tx, beef) {\n    if (Array.isArray(beef))\n        beef = sdk_1.Beef.fromBinary(beef);\n    beef.mergeTransaction(tx);\n    return beef.toBinaryAtomic(tx.id('hex'));\n}\n/**\n * Coerce a bsv transaction encoded as a hex string, serialized array, or Transaction to Transaction\n * If tx is already a Transaction, just return it.\n * @publicbody\n */\nfunction asBsvSdkTx(tx) {\n    if (Array.isArray(tx)) {\n        tx = sdk_1.Transaction.fromBinary(tx);\n    }\n    else if (typeof tx === 'string') {\n        tx = sdk_1.Transaction.fromHex(tx);\n    }\n    return tx;\n}\n/**\n * Coerce a bsv script encoded as a hex string, serialized array, or Script to Script\n * If script is already a Script, just return it.\n * @publicbody\n */\nfunction asBsvSdkScript(script) {\n    if (Array.isArray(script)) {\n        script = sdk_1.Script.fromBinary(script);\n    }\n    else if (typeof script === 'string') {\n        script = sdk_1.Script.fromHex(script);\n    }\n    return script;\n}\n/**\n * @param privKey bitcoin private key in 32 byte hex string form\n * @returns @bsv/sdk PrivateKey\n */\nfunction asBsvSdkPrivateKey(privKey) {\n    return sdk_1.PrivateKey.fromString(privKey, 'hex');\n}\n/**\n * @param pubKey bitcoin public key in standard compressed key hex string form\n * @returns @bsv/sdk PublicKey\n */\nfunction asBsvSdkPublickKey(pubKey) {\n    return sdk_1.PublicKey.fromString(pubKey);\n}\n/**\n * Helper function.\n *\n * Verifies that a possibly optional value has a value.\n */\nfunction verifyTruthy(v, description) {\n    if (!v)\n        throw new index_client_1.sdk.WERR_INTERNAL(description !== null && description !== void 0 ? description : 'A truthy value is required.');\n    return v;\n}\n/**\n * Helper function.\n *\n * Verifies that a hex string is trimmed and lower case.\n */\nfunction verifyHexString(v) {\n    if (typeof v !== 'string')\n        throw new index_client_1.sdk.WERR_INTERNAL('A string is required.');\n    v = v.trim().toLowerCase();\n    return v;\n}\n/**\n * Helper function.\n *\n * Verifies that an optional or null hex string is undefined or a trimmed lowercase string.\n */\nfunction verifyOptionalHexString(v) {\n    if (!v)\n        return undefined;\n    return verifyHexString(v);\n}\n/**\n * Helper function.\n *\n * Verifies that an optional or null number has a numeric value.\n */\nfunction verifyNumber(v) {\n    if (typeof v !== 'number')\n        throw new index_client_1.sdk.WERR_INTERNAL('A number is required.');\n    return v;\n}\n/**\n * Helper function.\n *\n * Verifies that an optional or null number has a numeric value.\n */\nfunction verifyInteger(v) {\n    if (typeof v !== 'number' || !Number.isInteger(v))\n        throw new index_client_1.sdk.WERR_INTERNAL('An integer is required.');\n    return v;\n}\n/**\n * Helper function.\n *\n * Verifies that a database record identifier is an integer greater than zero.\n */\nfunction verifyId(id) {\n    id = verifyInteger(id);\n    if (id < 1)\n        throw new index_client_1.sdk.WERR_INTERNAL(`id must be valid integer greater than zero.`);\n    return id;\n}\n/**\n * Helper function.\n *\n * @throws WERR_BAD_REQUEST if results has length greater than one.\n *\n * @returns results[0] or undefined if length is zero.\n */\nfunction verifyOneOrNone(results) {\n    if (results.length > 1)\n        throw new index_client_1.sdk.WERR_BAD_REQUEST('Result must be unique.');\n    return results[0];\n}\n/**\n * Helper function.\n *\n * @throws WERR_BAD_REQUEST if results has length other than one.\n *\n * @returns results[0].\n */\nfunction verifyOne(results, errorDescrition) {\n    if (results.length !== 1)\n        throw new index_client_1.sdk.WERR_BAD_REQUEST(errorDescrition !== null && errorDescrition !== void 0 ? errorDescrition : 'Result must exist and be unique.');\n    return results[0];\n}\n/**\n * Returns an await'able Promise that resolves in the given number of msecs.\n * @publicbody\n */\nfunction wait(msecs) {\n    return new Promise(resolve => setTimeout(resolve, msecs));\n}\n/**\n * @returns count cryptographically secure random bytes as array of bytes\n */\nfunction randomBytes(count) {\n    return (0, sdk_1.Random)(count);\n}\n/**\n * @returns count cryptographically secure random bytes as hex encoded string\n */\nfunction randomBytesHex(count) {\n    return sdk_1.Utils.toHex((0, sdk_1.Random)(count));\n}\n/**\n * @returns count cryptographically secure random bytes as base64 encoded string\n */\nfunction randomBytesBase64(count) {\n    return sdk_1.Utils.toBase64((0, sdk_1.Random)(count));\n}\nfunction validateSecondsSinceEpoch(time) {\n    const date = new Date(time * 1000);\n    if (date.getTime() / 1000 !== time || time < 1600000000 || time > 100000000000) {\n        throw new index_client_1.sdk.WERR_INVALID_PARAMETER('time', `valid \"since epoch\" unix time`);\n    }\n    return date;\n}\n/**\n * Compares lengths and direct equality of values.\n * @param arr1\n * @param arr2\n * @returns\n */\nfunction arraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length)\n        return false;\n    for (let i = 0; i < arr1.length; i++) {\n        if (arr1[i] !== arr2[i])\n            return false;\n    }\n    return true;\n}\nfunction optionalArraysEqual(arr1, arr2) {\n    if (!arr1 && !arr2)\n        return true;\n    if (!arr1 || !arr2)\n        return false;\n    return arraysEqual(arr1, arr2);\n}\nfunction maxDate(d1, d2) {\n    if (d1 && d2) {\n        if (d1 > d2)\n            return d1;\n        return d2;\n    }\n    if (d1)\n        return d1;\n    if (d2)\n        return d2;\n    return undefined;\n}\n/**\n * Calculate the SHA256 hash of an array of bytes\n * @returns sha256 hash of buffer contents.\n * @publicbody\n */\nfunction sha256Hash(data) {\n    const first = new sdk_1.Hash.SHA256().update(data).digest();\n    return first;\n}\n/**\n * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.\n * @param data an array of bytes\n * @returns double sha256 hash of data, byte 0 of hash first.\n * @publicbody\n */\nfunction doubleSha256LE(data) {\n    const first = new sdk_1.Hash.SHA256().update(data).digest();\n    const second = new sdk_1.Hash.SHA256().update(first).digest();\n    return second;\n}\n/**\n * Calculate the SHA256 hash of the SHA256 hash of an array of bytes.\n * @param data is an array of bytes.\n * @returns reversed (big-endian) double sha256 hash of data, byte 31 of hash first.\n * @publicbody\n */\nfunction doubleSha256BE(data) {\n    return doubleSha256LE(data).reverse();\n}\n//# sourceMappingURL=utilityHelpers.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.noBuffer.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.noBuffer.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.asString = asString;\nexports.asArray = asArray;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\n/**\n * Coerce a value to a hex encoded string if currently a hex encoded string or number[]\n * @param val string or number[]. If string, encoding must be hex. If number[], each value must be 0..255.\n * @returns input val if it is a string; or if number[], converts byte values to hex\n * @publicbody\n */\nfunction asString(val) {\n    if (typeof val === 'string')\n        return val;\n    return sdk_1.Utils.toHex(val);\n}\nfunction asArray(val) {\n    if (Array.isArray(val))\n        return val;\n    let a = sdk_1.Utils.toArray(val, 'hex');\n    return a;\n}\n//# sourceMappingURL=utilityHelpers.noBuffer.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/utility/utilityHelpers.noBuffer.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/WABClient.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/WABClient.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.WABClient = void 0;\nconst sdk_1 = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/cjs/mod.js\");\nclass WABClient {\n    constructor(serverUrl) {\n        this.serverUrl = serverUrl;\n    }\n    /**\n     * Return the WAB server info\n     */\n    async getInfo() {\n        const res = await fetch(`${this.serverUrl}/info`);\n        return res.json();\n    }\n    /**\n     * Generate a random 256-bit presentation key as a hex string (client side).\n     */\n    generateRandomPresentationKey() {\n        return sdk_1.PrivateKey.fromRandom().toHex();\n    }\n    /**\n     * Start an Auth Method flow\n     */\n    async startAuthMethod(authMethod, presentationKey, payload) {\n        return authMethod.startAuth(this.serverUrl, presentationKey, payload);\n    }\n    /**\n     * Complete an Auth Method flow\n     */\n    async completeAuthMethod(authMethod, presentationKey, payload) {\n        return authMethod.completeAuth(this.serverUrl, presentationKey, payload);\n    }\n    /**\n     * List user-linked methods\n     */\n    async listLinkedMethods(presentationKey) {\n        const res = await fetch(`${this.serverUrl}/user/linkedMethods`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ presentationKey })\n        });\n        return res.json();\n    }\n    /**\n     * Unlink a given Auth Method by ID\n     */\n    async unlinkMethod(presentationKey, authMethodId) {\n        const res = await fetch(`${this.serverUrl}/user/unlinkMethod`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ presentationKey, authMethodId })\n        });\n        return res.json();\n    }\n    /**\n     * Request faucet\n     */\n    async requestFaucet(presentationKey) {\n        const res = await fetch(`${this.serverUrl}/faucet/request`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ presentationKey })\n        });\n        return res.json();\n    }\n    /**\n     * Delete user\n     */\n    async deleteUser(presentationKey) {\n        const res = await fetch(`${this.serverUrl}/user/delete`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({ presentationKey })\n        });\n        return res.json();\n    }\n}\nexports.WABClient = WABClient;\n//# sourceMappingURL=WABClient.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/WABClient.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\n/**\n * AuthMethodInteractor\n *\n * A base interface/class for client-side logic to interact with a server\n * for a specific Auth Method's flow (start, complete).\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AuthMethodInteractor = void 0;\n/**\n * Abstract client-side interactor for an Auth Method\n */\nclass AuthMethodInteractor {\n}\nexports.AuthMethodInteractor = AuthMethodInteractor;\n//# sourceMappingURL=AuthMethodInteractor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/PersonaIDInteractor.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/PersonaIDInteractor.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PersonaIDInteractor = void 0;\nconst AuthMethodInteractor_1 = __webpack_require__(/*! ./AuthMethodInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js\");\nclass PersonaIDInteractor extends AuthMethodInteractor_1.AuthMethodInteractor {\n    constructor() {\n        super(...arguments);\n        this.methodType = 'PersonaID';\n    }\n    async startAuth(serverUrl, presentationKey, payload) {\n        const res = await fetch(`${serverUrl}/auth/start`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                methodType: this.methodType,\n                presentationKey,\n                payload\n            })\n        });\n        return res.json();\n    }\n    async completeAuth(serverUrl, presentationKey, payload) {\n        const res = await fetch(`${serverUrl}/auth/complete`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                methodType: this.methodType,\n                presentationKey,\n                payload\n            })\n        });\n        return res.json();\n    }\n}\nexports.PersonaIDInteractor = PersonaIDInteractor;\n//# sourceMappingURL=PersonaIDInteractor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/PersonaIDInteractor.js?\n}");

/***/ }),

/***/ "./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/TwilioPhoneInteractor.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/TwilioPhoneInteractor.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TwilioPhoneInteractor = void 0;\nconst AuthMethodInteractor_1 = __webpack_require__(/*! ./AuthMethodInteractor */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/AuthMethodInteractor.js\");\n/**\n * TwilioPhoneInteractor\n *\n * A client-side class that knows how to call the WAB server for Twilio-based phone verification.\n */\nclass TwilioPhoneInteractor extends AuthMethodInteractor_1.AuthMethodInteractor {\n    constructor() {\n        super(...arguments);\n        this.methodType = 'TwilioPhone';\n    }\n    /**\n     * Start the Twilio phone verification on the server.\n     * - The server will send an SMS code to the users phone, using Twilio Verify.\n     * @param serverUrl         - The base URL of the WAB server (e.g. http://localhost:3000)\n     * @param presentationKey   - The 256-bit key the client is attempting to authenticate with\n     * @param payload           - { phoneNumber: string } (the phone number to verify)\n     * @returns                 - { success, message, data }\n     */\n    async startAuth(serverUrl, presentationKey, payload) {\n        const res = await fetch(`${serverUrl}/auth/start`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                methodType: this.methodType,\n                presentationKey,\n                payload\n            })\n        });\n        if (!res.ok) {\n            return {\n                success: false,\n                message: `HTTP error ${res.status}`\n            };\n        }\n        return res.json();\n    }\n    /**\n     * Complete the Twilio phone verification on the server.\n     * - The server will verify the code with Twilio Verifys verificationChecks endpoint.\n     * @param serverUrl         - The base URL of the WAB server\n     * @param presentationKey   - The 256-bit key\n     * @param payload           - { phoneNumber: string, otp: string } (the code that was received via SMS)\n     * @returns                 - { success, message, presentationKey }\n     */\n    async completeAuth(serverUrl, presentationKey, payload) {\n        const res = await fetch(`${serverUrl}/auth/complete`, {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json' },\n            body: JSON.stringify({\n                methodType: this.methodType,\n                presentationKey,\n                payload\n            })\n        });\n        if (!res.ok) {\n            return {\n                success: false,\n                message: `HTTP error ${res.status}`\n            };\n        }\n        return res.json();\n    }\n}\nexports.TwilioPhoneInteractor = TwilioPhoneInteractor;\n//# sourceMappingURL=TwilioPhoneInteractor.js.map\n\n//# sourceURL=webpack://$/./node_modules/@bsv/wallet-toolbox-mobile/out/src/wab-client/auth-method-interactors/TwilioPhoneInteractor.js?\n}");

/***/ }),

/***/ "./src/authenticationManager.ts":
/*!**************************************!*\
  !*** ./src/authenticationManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AuthenticationManager: () => (/* binding */ AuthenticationManager)\n/* harmony export */ });\n/* harmony import */ var _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @bsv/sdk */ \"./node_modules/@bsv/sdk/dist/esm/mod.js\");\n/* harmony import */ var _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @bsv/wallet-toolbox-mobile */ \"./node_modules/@bsv/wallet-toolbox-mobile/out/src/index.mobile.js\");\n/* harmony import */ var _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./config */ \"./src/config.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = \"function\" == typeof Symbol ? Symbol : {}, n = r.iterator || \"@@iterator\", o = r.toStringTag || \"@@toStringTag\"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError(\"Generator is already running\"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = \"next\"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, \"toString\", function () { return \"[object Generator]\"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }\nfunction _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, \"\", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); } r ? i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n : (o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2)); }, _regeneratorDefine2(e, r, n, t); }\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }\nfunction _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n); } _next(void 0); }); }; }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\n\n\n\nvar AuthenticationManager = /*#__PURE__*/function () {\n  // Key promise resolver/rejecter\n\n  // Password retriver handlers\n\n  function AuthenticationManager(eventManager) {\n    _classCallCheck(this, AuthenticationManager);\n    // Authentication properties\n    _defineProperty(this, \"adminOriginator\", _config__WEBPACK_IMPORTED_MODULE_2__.ADMIN_ORIGINATOR);\n    _defineProperty(this, \"selectedStorageUrl\", _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_STORAGE_URL);\n    _defineProperty(this, \"selectedNetwork\", _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_CHAIN);\n    _defineProperty(this, \"selectedWabUrl\", _config__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_WAB_URL);\n    this.eventManager = eventManager;\n    // Register authmanager listeners\n    this.eventManager.listen('setAdminOriginator', this);\n    this.eventManager.listen('setSelectedStorageUrl', this);\n    this.eventManager.listen('setSelectedNetwork', this);\n    this.eventManager.listen('setSelectedWabUrl', this);\n    this.eventManager.listen('setRecoveryKeySaver', this);\n    this.eventManager.listen('setPasswordRetriver', this);\n    this.eventManager.listen('initialize', this);\n    this.eventManager.listen('loadSnapshot', this);\n    this.eventManager.listen('startAuth', this);\n    this.eventManager.listen('restartAuth', this);\n  }\n  return _createClass(AuthenticationManager, [{\n    key: \"setAdminOriginator\",\n    value: function setAdminOriginator(origin) {\n      this.adminOriginator = origin;\n      this.checkAndReadyEvent();\n      return this.adminOriginator;\n    }\n  }, {\n    key: \"setSelectedStorageUrl\",\n    value: function setSelectedStorageUrl(url) {\n      this.selectedStorageUrl = url;\n      this.checkAndReadyEvent();\n      return this.selectedStorageUrl;\n    }\n  }, {\n    key: \"setSelectedNetwork\",\n    value: function setSelectedNetwork(network) {\n      this.selectedNetwork = network;\n      this.checkAndReadyEvent();\n      return this.selectedNetwork;\n    }\n  }, {\n    key: \"setSelectedWabUrl\",\n    value: function setSelectedWabUrl(url) {\n      this.selectedWabUrl = url;\n      this.checkAndReadyEvent();\n      return this.selectedWabUrl;\n    }\n  }, {\n    key: \"setRecoveryKeySaver\",\n    value: function setRecoveryKeySaver() {\n      var _this = this;\n      this.recoveryKeySaver = function (key) {\n        return new Promise(function (resolve, reject) {\n          var keyAsStr = _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__.Utils.toBase64(key);\n\n          // When main thread saves key, resolve\n          _this.keySaverResolver = resolve;\n          // When main thread reject key, reject\n          _this.keySaverRejecter = reject;\n\n          // TODO:Send key as string to main thread\n          // setRecoveryKey(keyAsStr)\n          // setOpen(true)\n        });\n      };\n      this.checkAndReadyEvent();\n      return true;\n    }\n  }, {\n    key: \"setPasswordRetriver\",\n    value: function setPasswordRetriver() {\n      var _this2 = this;\n      this.passwordRetriever = function (reason, testFn) {\n        return new Promise(function (resolvePromise, rejectPromise) {\n          // TODO: Send password_reason event to main thread\n          // Actions to perform\n          // setReason(reason)\n\n          // When main thread test password, call this method\n          _this2.passwordTestFn = testFn;\n          // When main thread resolves password, call this resolve method\n          _this2.passwordResolver = resolvePromise;\n          // When main thread rejects password, call this reject method\n          _this2.passwordRejecter = rejectPromise;\n\n          // TODO: Send password_retriving event to main thread\n          // Actions to perform\n          // setOpen(true)\n          // manageFocus()\n        });\n      };\n      this.checkAndReadyEvent();\n      return true;\n    }\n  }, {\n    key: \"isReady\",\n    value: function isReady() {\n      // Check if all property are defined\n      console.log(this.adminOriginator, this.selectedStorageUrl, this.selectedNetwork, this.selectedWabUrl, this.recoveryKeySaver, this.passwordRetriever);\n      if (!this.adminOriginator || !this.selectedStorageUrl || !this.selectedNetwork || !this.selectedWabUrl || !this.recoveryKeySaver || !this.passwordRetriever) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"checkAndReadyEvent\",\n    value: function checkAndReadyEvent() {\n      if (this.isReady()) {\n        this.eventManager.send('authenticationReady');\n      }\n    }\n  }, {\n    key: \"initialize\",\n    value: function initialize() {\n      var _this3 = this;\n      if (this.isReady()) {\n        // Create network service based on selected network\n        var networkPreset = this.selectedNetwork === 'main' ? 'mainnet' : 'testnet';\n\n        // Create a LookupResolver instance\n        var resolver = new _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__.LookupResolver({\n          networkPreset: networkPreset\n        });\n\n        // Create a broadcaster with proper network settings\n        var broadcaster = new _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__.SHIPBroadcaster(['tm_users'], {\n          networkPreset: networkPreset\n        });\n\n        // Create a WAB Client with proper URL\n        var wabClient = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.WABClient(this.selectedWabUrl);\n\n        // Create a phone interactor\n        var phoneInteractor = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.TwilioPhoneInteractor();\n        this.authManager = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.WalletAuthenticationManager(this.adminOriginator, function (primaryKey, privilegedKeyManager) {\n          return _this3.buildWallet(primaryKey, privilegedKeyManager);\n        }, new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.OverlayUMPTokenInteractor(resolver, broadcaster), this.recoveryKeySaver, this.passwordRetriever,\n        // Type assertions needed due to interface mismatch between our WABClient and the expected SDK client\n        wabClient, phoneInteractor);\n        console.log(this.authManager);\n\n        // Load snapshot\n        return true;\n      } else {\n        _logger__WEBPACK_IMPORTED_MODULE_3__.Logger.log('Missing authentication properties');\n        return false;\n      }\n    }\n  }, {\n    key: \"buildWallet\",\n    value: function () {\n      var _buildWallet = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(primaryKey, privilegedKeyManager) {\n        var chain, keyDeriver, storageManager, signer, services, client, _t;\n        return _regenerator().w(function (_context) {\n          while (1) switch (_context.p = _context.n) {\n            case 0:\n              _context.p = 0;\n              // const newManagers = {} as any;\n              chain = this.selectedNetwork;\n              keyDeriver = new _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__.KeyDeriver(new _bsv_sdk__WEBPACK_IMPORTED_MODULE_0__.PrivateKey(primaryKey));\n              storageManager = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.WalletStorageManager(keyDeriver.identityKey);\n              signer = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.WalletSigner(chain, keyDeriver, storageManager);\n              services = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.Services(chain);\n              this.wallet = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.Wallet(signer, services, undefined, privilegedKeyManager);\n\n              // Use user-selected storage provider\n              client = new _bsv_wallet_toolbox_mobile__WEBPACK_IMPORTED_MODULE_1__.StorageClient(this.wallet, this.selectedStorageUrl);\n              _context.n = 1;\n              return client.makeAvailable();\n            case 1:\n              _context.n = 2;\n              return storageManager.addWalletStorageProvider(client);\n            case 2:\n              _context.n = 4;\n              break;\n            case 3:\n              _context.p = 3;\n              _t = _context.v;\n              _logger__WEBPACK_IMPORTED_MODULE_3__.Logger.log('Error building wallet:', _t);\n              return _context.a(2, null);\n            case 4:\n              return _context.a(2);\n          }\n        }, _callee, this, [[0, 3]]);\n      }));\n      function buildWallet(_x, _x2) {\n        return _buildWallet.apply(this, arguments);\n      }\n      return buildWallet;\n    }()\n  }, {\n    key: \"loadSnapshot\",\n    value: function () {\n      var _loadSnapshot = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(snap) {\n        var _t2;\n        return _regenerator().w(function (_context2) {\n          while (1) switch (_context2.p = _context2.n) {\n            case 0:\n              console.log('snap', snap, _typeof(snap));\n              _context2.p = 1;\n              _context2.n = 2;\n              return this.authManager.loadSnapshot(snap);\n            case 2:\n              _context2.n = 3;\n              return this.authManager.waitForAuthentication({});\n            case 3:\n              return _context2.a(2, true);\n            case 4:\n              _context2.p = 4;\n              _t2 = _context2.v;\n              _logger__WEBPACK_IMPORTED_MODULE_3__.Logger.log('Wallet snapshot load failed:', _t2);\n              return _context2.a(2, _t2);\n          }\n        }, _callee2, this, [[1, 4]]);\n      }));\n      function loadSnapshot(_x3) {\n        return _loadSnapshot.apply(this, arguments);\n      }\n      return loadSnapshot;\n    }()\n  }, {\n    key: \"startAuth\",\n    value: function () {\n      var _startAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(phoneNumber) {\n        var _t3;\n        return _regenerator().w(function (_context3) {\n          while (1) switch (_context3.p = _context3.n) {\n            case 0:\n              _context3.p = 0;\n              _context3.n = 1;\n              return this.authManager.startAuth({\n                phoneNumber: phoneNumber\n              });\n            case 1:\n              return _context3.a(2, _context3.v);\n            case 2:\n              _context3.p = 2;\n              _t3 = _context3.v;\n              return _context3.a(2, false);\n          }\n        }, _callee3, this, [[0, 2]]);\n      }));\n      function startAuth(_x4) {\n        return _startAuth.apply(this, arguments);\n      }\n      return startAuth;\n    }()\n  }, {\n    key: \"restartAuth\",\n    value: function () {\n      var _restartAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(phoneNumber) {\n        return _regenerator().w(function (_context4) {\n          while (1) switch (_context4.n) {\n            case 0:\n              return _context4.a(2, this.startAuth(phoneNumber));\n          }\n        }, _callee4, this);\n      }));\n      function restartAuth(_x5) {\n        return _restartAuth.apply(this, arguments);\n      }\n      return restartAuth;\n    }()\n  }, {\n    key: \"completeAuth\",\n    value: function () {\n      var _completeAuth = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee5(_ref) {\n        var phoneNumber, otp, _t4;\n        return _regenerator().w(function (_context5) {\n          while (1) switch (_context5.p = _context5.n) {\n            case 0:\n              phoneNumber = _ref.phoneNumber, otp = _ref.otp;\n              _context5.p = 1;\n              _context5.n = 2;\n              return this.authManager.completeAuth({\n                phoneNumber: phoneNumber,\n                otp: otp\n              });\n            case 2:\n              return _context5.a(2, _context5.v);\n            case 3:\n              _context5.p = 3;\n              _t4 = _context5.v;\n              return _context5.a(2, false);\n          }\n        }, _callee5, this, [[1, 3]]);\n      }));\n      function completeAuth(_x6) {\n        return _completeAuth.apply(this, arguments);\n      }\n      return completeAuth;\n    }()\n  }]);\n}();\n\n//# sourceURL=webpack://$/./src/authenticationManager.ts?\n}");

/***/ }),

/***/ "./src/config.ts":
/*!***********************!*\
  !*** ./src/config.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ADMIN_ORIGINATOR: () => (/* binding */ ADMIN_ORIGINATOR),\n/* harmony export */   DEFAULT_CHAIN: () => (/* binding */ DEFAULT_CHAIN),\n/* harmony export */   DEFAULT_STORAGE_URL: () => (/* binding */ DEFAULT_STORAGE_URL),\n/* harmony export */   DEFAULT_WAB_URL: () => (/* binding */ DEFAULT_WAB_URL)\n/* harmony export */ });\nvar DEFAULT_WAB_URL = 'https://wab.babbage.systems';\nvar DEFAULT_STORAGE_URL = 'https://storage.babbage.systems';\nvar DEFAULT_CHAIN = 'main';\nvar ADMIN_ORIGINATOR = 'admin.com';\n\n//# sourceURL=webpack://$/./src/config.ts?\n}");

/***/ }),

/***/ "./src/eventManager.ts":
/*!*****************************!*\
  !*** ./src/eventManager.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventManager: () => (/* binding */ EventManager)\n/* harmony export */ });\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\n\nvar EventManager = /*#__PURE__*/function () {\n  function EventManager() {\n    _classCallCheck(this, EventManager);\n    _defineProperty(this, \"listenners\", {});\n    // Listen to EventManager events\n    this.listen('clearLog', this);\n  }\n\n  /**\n   * Clears the log.\n   */\n  return _createClass(EventManager, [{\n    key: \"clearLog\",\n    value: function clearLog() {\n      _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.clear();\n    }\n\n    /**\n     * Process an event on all registered listeners.\n     * @param method Method name that must match the key on the listener object.\n     * @param params Optional parameters to be passed to the listener.\n     */\n  }, {\n    key: \"process\",\n    value: function process(method) {\n      var _this = this;\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (this.listenners[method]) {\n        this.listenners[method].forEach(function (listener) {\n          var fn = listener[method];\n          if (typeof fn === 'function') {\n            _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Start process', {\n              method: method,\n              params: params\n            });\n            var result = fn.call(listener, params);\n            _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Result process', {\n              result: result\n            });\n            _this.send(\"\".concat(method, \".callback\"), result);\n          } else {\n            _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Error process', {\n              method: method\n            });\n          }\n        });\n      } else {\n        _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Event not found', {\n          method: method\n        });\n      }\n    }\n\n    /**\n     * Process an event received by the EventManager.\n     * @param data event data from event source\n     */\n  }, {\n    key: \"receive\",\n    value: function receive(data) {\n      _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Receive event', data);\n      this.process(data.name, data.params);\n    }\n\n    /**\n     * Send an event to the main thread of the WebView.\n     * The event name is modified by appending \".callback\".\n     * The event is sent as a JSON string.\n     * @param event event name\n     * @param results event results\n     */\n  }, {\n    key: \"send\",\n    value: function send(event) {\n      var _window$ReactNativeWe;\n      var results = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var payload = {\n        name: \"\".concat(event),\n        results: results\n      };\n      _logger__WEBPACK_IMPORTED_MODULE_0__.Logger.log('Sending event', payload);\n      (_window$ReactNativeWe = window.ReactNativeWebView) === null || _window$ReactNativeWe === void 0 || _window$ReactNativeWe.postMessage(JSON.stringify(payload));\n    }\n\n    /**\n     * Registers a listener for the specified event.\n     * @param event event name\n     * @param object listener object\n     */\n  }, {\n    key: \"listen\",\n    value: function listen(event, object) {\n      if (!this.listenners[event]) {\n        this.listenners[event] = [];\n      }\n      this.listenners[event].push(object);\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://$/./src/eventManager.ts?\n}");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _eventManager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./eventManager */ \"./src/eventManager.ts\");\n/* harmony import */ var _authenticationManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./authenticationManager */ \"./src/authenticationManager.ts\");\n/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./logger */ \"./src/logger.ts\");\n\n\n\n_logger__WEBPACK_IMPORTED_MODULE_2__.Logger.log('Start Application');\nvar eventManager = new _eventManager__WEBPACK_IMPORTED_MODULE_0__.EventManager();\nnew _authenticationManager__WEBPACK_IMPORTED_MODULE_1__.AuthenticationManager(eventManager);\nwindow.eventManager = eventManager;\n\n//# sourceURL=webpack://$/./src/index.ts?\n}");

/***/ }),

/***/ "./src/logger.ts":
/*!***********************!*\
  !*** ./src/logger.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger)\n/* harmony export */ });\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Logger = /*#__PURE__*/function () {\n  function Logger() {\n    _classCallCheck(this, Logger);\n  }\n  return _createClass(Logger, null, [{\n    key: \"log\",\n    value:\n    /**\n     * Logs an event to the DOM by creating a new span element with the event name and parameters.\n     * The log entry includes a timestamp and is prepended to the element with the ID 'logger'.\n     *\n     * @param name - The name of the event to log.\n     * @param params - Optional parameters associated with the event, which will be serialized to JSON.\n     */\n    function log(name) {\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var span = document.createElement('span');\n      span.innerHTML = \"<strong>\".concat(new Date().toISOString(), \" \").concat(name, \"</strong>: \").concat(JSON.stringify(params), \"<br>\");\n      var logElmt = document.getElementById('logger');\n      logElmt === null || logElmt === void 0 || logElmt.prepend(span);\n    }\n\n    /**\n     * Resets the logger to the initial state.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      document.getElementById('logger').innerHTML = 'Application logger: ready';\n    }\n  }]);\n}();\n\n//# sourceURL=webpack://$/./src/logger.ts?\n}");

/***/ }),

/***/ "?0693":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://$/https_(ignored)?\n}");

/***/ }),

/***/ "?706f":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

eval("{/* (ignored) */\n\n//# sourceURL=webpack://$/crypto_(ignored)?\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/
/************************************************************************/
/******/
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/
/******/ 	return __webpack_exports__;
/******/ })()
;
});</script></head>

<body style="margin-top: 3rem;">
  <p id="logger">Application logger: ready</p>
</body>

</html>
